<!DOCTYPE html>
<html lang="en"  prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml" class="han-init">
<head>
    <title>A case in which tracing the execve system call with tracepoints does not accurately capture the system call parameters - mozillazg's Blog</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- share.css -->
    <link rel="stylesheet" href="/theme/cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">


    <link href="https://mozillazg.com/favicon.ico" rel="icon">

<link rel="canonical" href="https://mozillazg.com/2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case-en.html">

        <meta name="author" content="mozillazg" />
        <meta name="keywords" content="ebpf,tracepoint,libbpf,bpftrace,ELF,en-version" />
    <meta name="description" content="Background Some time ago, a netizen consulted a problem he encountered in the ebpf channel on slack : When writing an eBPF program that uses tracepoint/syscalls/sys_enter_execve to trace the execve system call, encountered a situation where there is a failure in reading the filename parameter of execve using bpf_probe_read_user_str in the recorded events, with an error code of -14/EFAULT. Especially when executing the tmux command, there will always be an event of a failed read: ret = bpf_probe_read_user_str(event-&gt;args, ARGSIZE, (const char*)ctx-&gt;args[0]); if (ret &lt; 0) { bpf_printk(&#34;comm=%s XXX cannot read file name&#34;, tgid, pid, event-&gt;comm); return 0; } utempter-4031732 [027] d...1 3878624.643948: bpf_trace_printk: comm=tmux: server XXX cannot read file name &lt;...&gt;-4035723 [077] d...1 3878668.047954: bpf_trace_printk: comm=tmux: server XXX cannot read file name This article will delve into the causes of this problem and propose a solution specifically designed for this situation. Reproduce the Problem Code Since the problem mentioned that the issue always occurs when executing the tmux command, and we can see in the output of bpf_printk that the process name for the corresponding event is utempter, we can try to write a simple program to reproduce the problem based on these two pieces of information. After searching online for the relationship between tmux and utempter, and reading the relevant tmux source code, I learned the following information: tmux uses the utempter_add_record function provided by utempter.h to create the required pseudo-terminal: xasprintf(&amp;cp, &#34;tmux(%lu).%%%u&#34;, (long)getpid(), new_wp-&gt;id); utempter_add_record(new_wp-&gt;fd, cp); In the utempter_add_record function, it will first construct an args from the passed parameters and then invoke the execute_helper function: #define UTEMPTER_DEFAULT_PATHNAME LIBEXECDIR &#34;/utempter/utempter&#34; static const char *utempter_pathname; int utempter_add_record(int master_fd, const char *hostname) { const char *const args[] = { utempter_pathname ? : UTEMPTER_DEFAULT_PATHNAME, &#34;add&#34;, hostname, 0 }; int status = execute_helper(master_fd, args); // ... } In the execute_helper function, the passed args will eventually be used to call the fork() and execv() functions to start a new process ( source code ): static int execute_helper(int master_fd, const char *const argv[]) { // ... child = fork(); if (!child) { do_child(master_fd, argv[0], (char *const *) argv); } else if (child &lt; 0) { // ... } static void __attribute__((__noreturn__)) do_child(int master_fd, const char *path, char *const *argv) { // ... execv(path, argv); print_dbg(&#34;execv: %s&#34;, strerror(errno)); //... } Based on the above information, we can write the following program to reproduce this issue reproduce.c: #define PATHNAME &#34;/usr/bin/echo&#34; int main(int argc, char **argv) { const char *hostname = argv[0]; const char *const args[] = { PATHNAME, &#34;add&#34;, hostname, 0 }; if (!fork()) { execv(args[0], (char *const *) args); } } Let&#39;s test the effectiveness of this program below: Compile using GCC: gcc -o reproduce reproduce.c Trace the tracepoint/syscalls/sys_enter_execve event using bpftrace in another terminal: sudo bpftrace -e &#39;tracepoint:syscalls:sys_enter_execve{printf(&#34;%s[%d]: %s\n&#34;, comm, pid, str(args-&gt;filename));}&#39; Run the example program: ./reproduce At this time, the terminal running bpftrace will output results similar to the following: bash[34882]: ./reproduce reproduce[34883]: In the previous results, we did not capture the value of the filename parameter used during the execution of the execve() system call by the reproducing program. From this, it can be seen that our program has reproduced the original issue. Reason Reminded by @ssfdust, someone in the bpftrace community has previously raised a similar issue: #2523 . In this issue, @fbs provided an explanation : Like I said earlier, the data you&#39;re using isn&#39;t in memory yet. These static strings are compiled in and are not actually faulted into memory until they&#39;re accessed. The access won&#39;t happen until its read, which is after your bpftrace probe ran. BPF won&#39;t pull the data in so you get an EFAULT/-14. By printing the values or just a random print of a constant string you pull the small amount of data into memory (as it goes by page, not by var) and then it works That is: In the sample program, when executing execve(), the file name string referred to by argv[0] is a static string. These static strings are stored in the .rodata section of the ELF (Executable and Linkable Format) file after compilation. They are loaded into memory only when the program accesses them, specifically when accessing the data stored in the .rodata section. Based on point 1, the static string referenced by argv[0] in the sample program is only loaded into memory during the execution of the execve() system call. However, since our eBPF program runs before the execve() system call, attempting to read argv[0] using bpf_probe_read_user_str will fail and result in an EFAULT/-14 error code. By actively loading strings into memory through printf and other methods, this problem can be resolved. Summary from @jschwinger233 : bpf_probe_read_user can only read data that has been loaded into memory (page-faulted into memory), and the above code has not read .rodata until the execve(2) time, thus not triggering a page fault. This can be verified using tracepoint:exceptions:page_fault*. Verification Add a printf statement From the above, it can be seen that actually we only need to modify the program to proactively load the data in .rodata into memory before executing execve(), for example, using the printf function. You can use the printf function to print argv[0], or you can directly print a static string: if (!fork()) { printf(&#34;test\n&#34;); // or // printf(&#34;argv[0]: %s\n&#34;, args[0]); execv(args[0], (char *const *) args); } After verification, the modified program reproduce_printf1.c does allow the ebpf program to correctly read the value of filename. Not using static strings Since the issue is caused by the fact that argv[0] is a static string, you can try changing argv[0] to use a non-static string to see if the problem still exists. The modified content is as follows: const char *const args[] = { argv[1], &#34;add&#34;, hostname, 0 }; After verification, the modified program reproduce_non_static.c can also allow the ebpf program to correctly read the value of filename. I wonder if anyone has noticed that the value of argv[2] in our program reproducing the issue is actually a non-static string, so it can also be verified by reading the content of this data in the eBPF program. The expectation is to be able to read the content of this non-static string argv[2] without making any modifications: Run the new bpftrace command: sudo bpftrace -e &#39;tracepoint:syscalls:sys_enter_execve{ printf(&#34;%s[%d]: filename: %s, argv[1]: %s, argv[2]: %s\n&#34;, comm, pid, str(args-&gt;filename), str(args-&gt;argv[1]), str(args-&gt;argv[2])); }&#39; Run ./reproduce The output example of the bpftrace command is as follows: bash[36523]: filename: ./reproduce, argv[1]: , argv[2]: reproduce[36524]: filename: , argv[1]: , argv[2]: ./reproduce page fault In modern Linux systems, when we run a binary executable file, the program loader (ELF executable loader) will use mmap for lazy loading based on the information defined in the ELF file, delaying the loading of some data. When the program actually tries to read these data, if the data being read has not been loaded into memory yet, it will trigger a page fault. The data stored in the .rodata section of ELF files is exactly the data that will be lazily loaded. .rodata The .rodata section in an ELF file stores some read-only data, such as static strings. Let&#39;s first take a look at the data in the .rodata section of the compiled example program binary ELF file. You can use the objdump command to view the contents: $ objdump -s -j .rodata ./reproduce ./reproduce: file format elf64-x86-64 Contents of section .rodata: 2000 01000200 2f757372 2f62696e 2f656368 ..../usr/bin/ech 2010 6f006164 6400 o.add. You can also use the pwntools library from the Python community for reading: &gt;&gt;&gt; from pwn import ELF &gt;&gt;&gt; elf = ELF(&#39;reproduce&#39;) &gt;&gt;&gt; elf.section(&#39;.rodata&#39;) b&#39;\x01\x00\x02\x00/usr/bin/echo\x00add\x00&#39; From the above output, it can be seen that it contains two static strings used in the source code. Observing page fault In the Linux system, when the kernel executes the execve() system call, it calls the kernel function strncpy_from_user (execve() -&gt; getname() -&gt; getname_flags(), strncpy_from_user()) to copy the string data contained in argv from user space to kernel space. This process involves reading user space data. If the user space data being read has not yet been loaded into memory, it will trigger a page fault. We can perceive this event by observing exceptions/page_fault_kernel and exceptions/page_fault_user: To simplify the verification process, we need to make a modification to the example code. Add a line of sleep(15) before executing the execv() function to ensure the program does not terminate too quickly (reproduce_sleep.c ): if (!fork()) { sleep(15); execv(args[0], (char *const *) args); } Run the following bpftrace script in a terminal to observe page faults: cat &lt;&lt;EOF | sudo bpftrace - tracepoint:exceptions:page_fault_kernel /comm == &#34;reproduce_sleep&#34;/ { printf(&#34;[%s] page_fault_kernel: %s[%d] addr=%llx ip=%llx err=%lld\n&#34;, strftime(&#34;%M:%S&#34;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code); } tracepoint:exceptions:page_fault_user /comm == &#34;reproduce_sleep&#34;/ { printf(&#34;[%s] page_fault_user: %s[%d] addr=%llx ip=%llx err=%lld\n&#34;, strftime(&#34;%M:%S&#34;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code); } EOF Then run ./reproduce_sleep in another terminal. View the memory mapping of the running reproduce_sleep process in the third terminal: $ sudo cat /proc/41291/maps | grep reproduce_sleep 55b4d9e31000-55b4d9e32000 r--p 00000000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e32000-55b4d9e33000 r-xp 00001000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e33000-55b4d9e34000 r--p 00002000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e34000-55b4d9e35000 r--p 00002000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e35000-55b4d9e36000 rw-p 00003000 08:01 1634479 /XXX/reproduce_sleep From the above, it can be seen that the memory mapping starting address of this process is 55b4d9e31000, that is, 0x55b4d9e. After the example program finishes running, the last two lines of the output of the bpftrace command will be similar to the following: [47:40] page_fault_user: reproduce_sleep[41290] addr=7f669db86a50 ip=7f669d9f8940 err=7 [47:55] page_fault_kernel: reproduce_sleep[41291] addr=55b4d9e33004 ip=ffffffff8e092a40 err=0 The 15-second gap between these two outputs confirms that the last page fault event was triggered when the execv() function was executed. Now let&#39;s locate the corresponding data based on the addr result in the event. The value of the addr output of the last page_fault_kernel event above is 55b4d9e33004, which means the virtual memory address that triggered this page fault event is 0x55b4d9e33004. Based on the recipe shared by @jschwinger233: real_addr = start_addr + (elf_address - section.Address + section.Offset) can be known: 0x55b4d9e33004 = 0x55b4d9e31000 + (elf_address - section.Address + section.Offset) (elf_address - section.Address + section.Offset) = 0x55b4d9e33004 - 0x55b4d9e31000 = 8196 = 0x2004 Use the readelf command to read the virtual address, offset, and data size of the ELF .rodata section in the binary file reproduce_sleep: $ readelf -S -W reproduce_sleep | egrep &#39;.rodata|Address&#39; [Nr] Name Type Address Off Size ES Flg Lk Inf Al [18] .rodata PROGBITS 0000000000002000 002000 000016 00 A 0 0 4 From the above output, it can be seen that the virtual address of the .rodata section in this ELF file is 0000000000002000 or 0x2000, the offset is 002000 or 0x2000, the data size is 0x16, that is, the address range is 0x2000-0x2016. Through 7 and 8, it can be known that the virtual memory address of the page fault event triggered when executing the execv() function is 0x55b4d9e33004, corresponding to the ELF address 0x2004. This address is within the range of the .rodata address in the ELF file (0x2000-0x2016), corresponding to the static string /usr/bin/echo used in argv[0]: $ objdump -s -j .rodata ./reproduce_sleep ./reproduce_sleep: file format elf64-x86-64 Contents of section .rodata: 2000 01000200 2f757372 2f62696e 2f656368 ..../usr/bin/ech 2010 6f006164 6400 o.add. &gt;&gt;&gt; elf = ELF(&#39;reproduce_sleep&#39;) &gt;&gt;&gt; elf.read(0x2004, 14) b&#39;/usr/bin/echo\x00&#39; $ gdb -ex &#39;disas/m main&#39; -ex q reproduce_sleep | grep &#39;args\[\]&#39; -A 13 9 const char *const args[] = { 0x00000000000011d6 &lt;+45&gt;: lea 0xe27(%rip),%rax # 0x2004 0x00000000000011dd &lt;+52&gt;: mov %rax,-0x30(%rbp) 0x00000000000011e1 &lt;+56&gt;: lea 0xe2a(%rip),%rax # 0x2012 0x00000000000011e8 &lt;+63&gt;: mov %rax,-0x28(%rbp) 0x00000000000011ec &lt;+67&gt;: mov -0x38(%rbp),%rax 0x00000000000011f0 &lt;+71&gt;: mov %rax,-0x20(%rbp) 0x00000000000011f4 &lt;+75&gt;: movq $0x0,-0x18(%rbp) 10 PATHNAME, 11 &#34;add&#34;, 12 hostname, 13 0 14 }; You can also confirm by printing the pointer address of args-&gt;filename in the eBPF program or bpftrace script. The value at this address will be consistent with the value of addr in the previous page fault event, both being 0x55b4d9e33004: tracepoint:syscalls:sys_enter_execve { printf(&#34;%s[%d]: %p\n&#34;, comm, pid, args-&gt;filename); } BTW, you can trace the function information that triggers page fault events by using the perf trace -F all command. Solution There are many methods to solve this problem, one of which is to change to tracking the tracepoint/sched/sched_process_exec event to obtain the values of the filename and argv parameters in the execve() system call. Below is an example program corresponding to the implementation: Example script for tracing the tracepoint/sched/sched_process_exec event using bpftrace(from @jschwinger233 ): tracepoint:sched:sched_process_exec { $task=curtask; $arg_start=$task-&gt;mm-&gt;arg_start; $arg_end=$task-&gt;mm-&gt;arg_end; printf(&#34;%s[%d]: filename: %s, argv: %r\n&#34;, comm, pid, str(args-&gt;filename), buf(uptr($arg_start), $arg_end-$arg_start)); } An example program that traces the tracepoint/sched/sched_process_exec event through eBPF C code: main.bpf.c References tmux/tmux: tmux source code Can&#39;t trace sys_execve inside a c program · Issue #2523 · bpftrace/bpftrace ELF - OSDev Wiki unix - Why an ELF executable could have 4 LOAD segments? - Stack Overflow strncpy_from_user Guidance from @jschwinger233" />

    <style>
      .js-toc {
        margin-bottom: 20px;
      }
      .donate-modal {
        text-align: center;
      }
      #donate-modal-container .donate-image {
        max-height: 300px !important;
        min-height: inherit !important;
      }
    </style>

        <meta property="og:site_name" content="mozillazg's Blog" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="A case in which tracing the execve system call with tracepoints does not accurately capture the system call parameters"/>
        <meta property="og:url" content="https://mozillazg.com/2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case-en.html"/>
        <meta property="og:description" content="Background Some time ago, a netizen consulted a problem he encountered in the ebpf channel on slack : When writing an eBPF program that uses tracepoint/syscalls/sys_enter_execve to trace the execve system call, encountered a situation where there is a failure in reading the filename parameter of execve using bpf_probe_read_user_str in the recorded events, with an error code of -14/EFAULT. Especially when executing the tmux command, there will always be an event of a failed read: ret = bpf_probe_read_user_str(event-&gt;args, ARGSIZE, (const char*)ctx-&gt;args[0]); if (ret &lt; 0) { bpf_printk(&#34;comm=%s XXX cannot read file name&#34;, tgid, pid, event-&gt;comm); return 0; } utempter-4031732 [027] d...1 3878624.643948: bpf_trace_printk: comm=tmux: server XXX cannot read file name &lt;...&gt;-4035723 [077] d...1 3878668.047954: bpf_trace_printk: comm=tmux: server XXX cannot read file name This article will delve into the causes of this problem and propose a solution specifically designed for this situation. Reproduce the Problem Code Since the problem mentioned that the issue always occurs when executing the tmux command, and we can see in the output of bpf_printk that the process name for the corresponding event is utempter, we can try to write a simple program to reproduce the problem based on these two pieces of information. After searching online for the relationship between tmux and utempter, and reading the relevant tmux source code, I learned the following information: tmux uses the utempter_add_record function provided by utempter.h to create the required pseudo-terminal: xasprintf(&amp;cp, &#34;tmux(%lu).%%%u&#34;, (long)getpid(), new_wp-&gt;id); utempter_add_record(new_wp-&gt;fd, cp); In the utempter_add_record function, it will first construct an args from the passed parameters and then invoke the execute_helper function: #define UTEMPTER_DEFAULT_PATHNAME LIBEXECDIR &#34;/utempter/utempter&#34; static const char *utempter_pathname; int utempter_add_record(int master_fd, const char *hostname) { const char *const args[] = { utempter_pathname ? : UTEMPTER_DEFAULT_PATHNAME, &#34;add&#34;, hostname, 0 }; int status = execute_helper(master_fd, args); // ... } In the execute_helper function, the passed args will eventually be used to call the fork() and execv() functions to start a new process ( source code ): static int execute_helper(int master_fd, const char *const argv[]) { // ... child = fork(); if (!child) { do_child(master_fd, argv[0], (char *const *) argv); } else if (child &lt; 0) { // ... } static void __attribute__((__noreturn__)) do_child(int master_fd, const char *path, char *const *argv) { // ... execv(path, argv); print_dbg(&#34;execv: %s&#34;, strerror(errno)); //... } Based on the above information, we can write the following program to reproduce this issue reproduce.c: #define PATHNAME &#34;/usr/bin/echo&#34; int main(int argc, char **argv) { const char *hostname = argv[0]; const char *const args[] = { PATHNAME, &#34;add&#34;, hostname, 0 }; if (!fork()) { execv(args[0], (char *const *) args); } } Let&#39;s test the effectiveness of this program below: Compile using GCC: gcc -o reproduce reproduce.c Trace the tracepoint/syscalls/sys_enter_execve event using bpftrace in another terminal: sudo bpftrace -e &#39;tracepoint:syscalls:sys_enter_execve{printf(&#34;%s[%d]: %s\n&#34;, comm, pid, str(args-&gt;filename));}&#39; Run the example program: ./reproduce At this time, the terminal running bpftrace will output results similar to the following: bash[34882]: ./reproduce reproduce[34883]: In the previous results, we did not capture the value of the filename parameter used during the execution of the execve() system call by the reproducing program. From this, it can be seen that our program has reproduced the original issue. Reason Reminded by @ssfdust, someone in the bpftrace community has previously raised a similar issue: #2523 . In this issue, @fbs provided an explanation : Like I said earlier, the data you&#39;re using isn&#39;t in memory yet. These static strings are compiled in and are not actually faulted into memory until they&#39;re accessed. The access won&#39;t happen until its read, which is after your bpftrace probe ran. BPF won&#39;t pull the data in so you get an EFAULT/-14. By printing the values or just a random print of a constant string you pull the small amount of data into memory (as it goes by page, not by var) and then it works That is: In the sample program, when executing execve(), the file name string referred to by argv[0] is a static string. These static strings are stored in the .rodata section of the ELF (Executable and Linkable Format) file after compilation. They are loaded into memory only when the program accesses them, specifically when accessing the data stored in the .rodata section. Based on point 1, the static string referenced by argv[0] in the sample program is only loaded into memory during the execution of the execve() system call. However, since our eBPF program runs before the execve() system call, attempting to read argv[0] using bpf_probe_read_user_str will fail and result in an EFAULT/-14 error code. By actively loading strings into memory through printf and other methods, this problem can be resolved. Summary from @jschwinger233 : bpf_probe_read_user can only read data that has been loaded into memory (page-faulted into memory), and the above code has not read .rodata until the execve(2) time, thus not triggering a page fault. This can be verified using tracepoint:exceptions:page_fault*. Verification Add a printf statement From the above, it can be seen that actually we only need to modify the program to proactively load the data in .rodata into memory before executing execve(), for example, using the printf function. You can use the printf function to print argv[0], or you can directly print a static string: if (!fork()) { printf(&#34;test\n&#34;); // or // printf(&#34;argv[0]: %s\n&#34;, args[0]); execv(args[0], (char *const *) args); } After verification, the modified program reproduce_printf1.c does allow the ebpf program to correctly read the value of filename. Not using static strings Since the issue is caused by the fact that argv[0] is a static string, you can try changing argv[0] to use a non-static string to see if the problem still exists. The modified content is as follows: const char *const args[] = { argv[1], &#34;add&#34;, hostname, 0 }; After verification, the modified program reproduce_non_static.c can also allow the ebpf program to correctly read the value of filename. I wonder if anyone has noticed that the value of argv[2] in our program reproducing the issue is actually a non-static string, so it can also be verified by reading the content of this data in the eBPF program. The expectation is to be able to read the content of this non-static string argv[2] without making any modifications: Run the new bpftrace command: sudo bpftrace -e &#39;tracepoint:syscalls:sys_enter_execve{ printf(&#34;%s[%d]: filename: %s, argv[1]: %s, argv[2]: %s\n&#34;, comm, pid, str(args-&gt;filename), str(args-&gt;argv[1]), str(args-&gt;argv[2])); }&#39; Run ./reproduce The output example of the bpftrace command is as follows: bash[36523]: filename: ./reproduce, argv[1]: , argv[2]: reproduce[36524]: filename: , argv[1]: , argv[2]: ./reproduce page fault In modern Linux systems, when we run a binary executable file, the program loader (ELF executable loader) will use mmap for lazy loading based on the information defined in the ELF file, delaying the loading of some data. When the program actually tries to read these data, if the data being read has not been loaded into memory yet, it will trigger a page fault. The data stored in the .rodata section of ELF files is exactly the data that will be lazily loaded. .rodata The .rodata section in an ELF file stores some read-only data, such as static strings. Let&#39;s first take a look at the data in the .rodata section of the compiled example program binary ELF file. You can use the objdump command to view the contents: $ objdump -s -j .rodata ./reproduce ./reproduce: file format elf64-x86-64 Contents of section .rodata: 2000 01000200 2f757372 2f62696e 2f656368 ..../usr/bin/ech 2010 6f006164 6400 o.add. You can also use the pwntools library from the Python community for reading: &gt;&gt;&gt; from pwn import ELF &gt;&gt;&gt; elf = ELF(&#39;reproduce&#39;) &gt;&gt;&gt; elf.section(&#39;.rodata&#39;) b&#39;\x01\x00\x02\x00/usr/bin/echo\x00add\x00&#39; From the above output, it can be seen that it contains two static strings used in the source code. Observing page fault In the Linux system, when the kernel executes the execve() system call, it calls the kernel function strncpy_from_user (execve() -&gt; getname() -&gt; getname_flags(), strncpy_from_user()) to copy the string data contained in argv from user space to kernel space. This process involves reading user space data. If the user space data being read has not yet been loaded into memory, it will trigger a page fault. We can perceive this event by observing exceptions/page_fault_kernel and exceptions/page_fault_user: To simplify the verification process, we need to make a modification to the example code. Add a line of sleep(15) before executing the execv() function to ensure the program does not terminate too quickly (reproduce_sleep.c ): if (!fork()) { sleep(15); execv(args[0], (char *const *) args); } Run the following bpftrace script in a terminal to observe page faults: cat &lt;&lt;EOF | sudo bpftrace - tracepoint:exceptions:page_fault_kernel /comm == &#34;reproduce_sleep&#34;/ { printf(&#34;[%s] page_fault_kernel: %s[%d] addr=%llx ip=%llx err=%lld\n&#34;, strftime(&#34;%M:%S&#34;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code); } tracepoint:exceptions:page_fault_user /comm == &#34;reproduce_sleep&#34;/ { printf(&#34;[%s] page_fault_user: %s[%d] addr=%llx ip=%llx err=%lld\n&#34;, strftime(&#34;%M:%S&#34;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code); } EOF Then run ./reproduce_sleep in another terminal. View the memory mapping of the running reproduce_sleep process in the third terminal: $ sudo cat /proc/41291/maps | grep reproduce_sleep 55b4d9e31000-55b4d9e32000 r--p 00000000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e32000-55b4d9e33000 r-xp 00001000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e33000-55b4d9e34000 r--p 00002000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e34000-55b4d9e35000 r--p 00002000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e35000-55b4d9e36000 rw-p 00003000 08:01 1634479 /XXX/reproduce_sleep From the above, it can be seen that the memory mapping starting address of this process is 55b4d9e31000, that is, 0x55b4d9e. After the example program finishes running, the last two lines of the output of the bpftrace command will be similar to the following: [47:40] page_fault_user: reproduce_sleep[41290] addr=7f669db86a50 ip=7f669d9f8940 err=7 [47:55] page_fault_kernel: reproduce_sleep[41291] addr=55b4d9e33004 ip=ffffffff8e092a40 err=0 The 15-second gap between these two outputs confirms that the last page fault event was triggered when the execv() function was executed. Now let&#39;s locate the corresponding data based on the addr result in the event. The value of the addr output of the last page_fault_kernel event above is 55b4d9e33004, which means the virtual memory address that triggered this page fault event is 0x55b4d9e33004. Based on the recipe shared by @jschwinger233: real_addr = start_addr + (elf_address - section.Address + section.Offset) can be known: 0x55b4d9e33004 = 0x55b4d9e31000 + (elf_address - section.Address + section.Offset) (elf_address - section.Address + section.Offset) = 0x55b4d9e33004 - 0x55b4d9e31000 = 8196 = 0x2004 Use the readelf command to read the virtual address, offset, and data size of the ELF .rodata section in the binary file reproduce_sleep: $ readelf -S -W reproduce_sleep | egrep &#39;.rodata|Address&#39; [Nr] Name Type Address Off Size ES Flg Lk Inf Al [18] .rodata PROGBITS 0000000000002000 002000 000016 00 A 0 0 4 From the above output, it can be seen that the virtual address of the .rodata section in this ELF file is 0000000000002000 or 0x2000, the offset is 002000 or 0x2000, the data size is 0x16, that is, the address range is 0x2000-0x2016. Through 7 and 8, it can be known that the virtual memory address of the page fault event triggered when executing the execv() function is 0x55b4d9e33004, corresponding to the ELF address 0x2004. This address is within the range of the .rodata address in the ELF file (0x2000-0x2016), corresponding to the static string /usr/bin/echo used in argv[0]: $ objdump -s -j .rodata ./reproduce_sleep ./reproduce_sleep: file format elf64-x86-64 Contents of section .rodata: 2000 01000200 2f757372 2f62696e 2f656368 ..../usr/bin/ech 2010 6f006164 6400 o.add. &gt;&gt;&gt; elf = ELF(&#39;reproduce_sleep&#39;) &gt;&gt;&gt; elf.read(0x2004, 14) b&#39;/usr/bin/echo\x00&#39; $ gdb -ex &#39;disas/m main&#39; -ex q reproduce_sleep | grep &#39;args\[\]&#39; -A 13 9 const char *const args[] = { 0x00000000000011d6 &lt;+45&gt;: lea 0xe27(%rip),%rax # 0x2004 0x00000000000011dd &lt;+52&gt;: mov %rax,-0x30(%rbp) 0x00000000000011e1 &lt;+56&gt;: lea 0xe2a(%rip),%rax # 0x2012 0x00000000000011e8 &lt;+63&gt;: mov %rax,-0x28(%rbp) 0x00000000000011ec &lt;+67&gt;: mov -0x38(%rbp),%rax 0x00000000000011f0 &lt;+71&gt;: mov %rax,-0x20(%rbp) 0x00000000000011f4 &lt;+75&gt;: movq $0x0,-0x18(%rbp) 10 PATHNAME, 11 &#34;add&#34;, 12 hostname, 13 0 14 }; You can also confirm by printing the pointer address of args-&gt;filename in the eBPF program or bpftrace script. The value at this address will be consistent with the value of addr in the previous page fault event, both being 0x55b4d9e33004: tracepoint:syscalls:sys_enter_execve { printf(&#34;%s[%d]: %p\n&#34;, comm, pid, args-&gt;filename); } BTW, you can trace the function information that triggers page fault events by using the perf trace -F all command. Solution There are many methods to solve this problem, one of which is to change to tracking the tracepoint/sched/sched_process_exec event to obtain the values of the filename and argv parameters in the execve() system call. Below is an example program corresponding to the implementation: Example script for tracing the tracepoint/sched/sched_process_exec event using bpftrace(from @jschwinger233 ): tracepoint:sched:sched_process_exec { $task=curtask; $arg_start=$task-&gt;mm-&gt;arg_start; $arg_end=$task-&gt;mm-&gt;arg_end; printf(&#34;%s[%d]: filename: %s, argv: %r\n&#34;, comm, pid, str(args-&gt;filename), buf(uptr($arg_start), $arg_end-$arg_start)); } An example program that traces the tracepoint/sched/sched_process_exec event through eBPF C code: main.bpf.c References tmux/tmux: tmux source code Can&#39;t trace sys_execve inside a c program · Issue #2523 · bpftrace/bpftrace ELF - OSDev Wiki unix - Why an ELF executable could have 4 LOAD segments? - Stack Overflow strncpy_from_user Guidance from @jschwinger233"/>
        <meta property="article:published_time" content="2024-03-31" />
            <meta property="article:section" content="ebpf" />
            <meta property="article:tag" content="ebpf" />
            <meta property="article:tag" content="tracepoint" />
            <meta property="article:tag" content="libbpf" />
            <meta property="article:tag" content="bpftrace" />
            <meta property="article:tag" content="ELF" />
            <meta property="article:tag" content="en-version" />
            <meta property="article:author" content="mozillazg" />
            <meta property="og:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>


    <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@mozillazg">
        <meta name="twitter:creator" content="@mozillazg">
    <meta name="twitter:domain" content="https://mozillazg.com">
            <meta property="twitter:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="/theme/cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/css/bootstrap.min.css" type="text/css"/>
    <link href="/theme/cdn.jsdelivr.net/npm/font-awesome@4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link href="/theme/cdn.jsdelivr.net/npm/pygments-css@1.0.0/github.css" rel="stylesheet">
    <link rel="stylesheet" href="https://mozillazg.com/theme/css/style.css" type="text/css"/>
            <link href="/static/han.min.css" rel="stylesheet">
            <link href="/static/yue.css" rel="stylesheet">
            <link href="/static/custom.css" rel="stylesheet">

        <link href="https://mozillazg.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog ATOM Feed"/>

        <link href="https://mozillazg.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="mozillazg's Blog RSS Feed"/>


        <link href="https://mozillazg.com/feeds/ebpf.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog ebpf ATOM Feed"/>


    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "publisher": {
            "@type": "Person",
            "name": "mozillazg",
            "logo": "https://mozillazg.com/static/avatar.jpeg"
        },
        "author": {
            "@type": "Person",
            "name": "mozillazg",
            "image": "https://mozillazg.com/static/avatar.jpeg",
            "url": "https://mozillazg.com",
            "sameAs": []
        },
        "headline": "A case in which tracing the execve system call with tracepoints does not accurately capture the system call parameters",
        "url": "https://mozillazg.com/2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case-en.html",
        "image": [
            "https://mozillazg.com/static/avatar.jpeg"
         ],
        "keywords": "ebpf, tracepoint, libbpf, bpftrace, ELF, en-version",
        "description": "Background Some time ago, a netizen consulted a problem he encountered in the ebpf channel on slack : When writing an eBPF program that uses tracepoint/syscalls/sys_enter_execve to trace the execve system call, encountered a situation where there is a failure in reading the filename parameter of execve using bpf_probe_read_user_str in the recorded events, with an error code of -14/EFAULT. Especially when executing the tmux command, there will always be an event of a failed read: ret = bpf_probe_read_user_str(event-&gt;args, ARGSIZE, (const char*)ctx-&gt;args[0]); if (ret &lt; 0) { bpf_printk(&#34;comm=%s XXX cannot read file name&#34;, tgid, pid, event-&gt;comm); return 0; } utempter-4031732 [027] d...1 3878624.643948: bpf_trace_printk: comm=tmux: server XXX cannot read file name &lt;...&gt;-4035723 [077] d...1 3878668.047954: bpf_trace_printk: comm=tmux: server XXX cannot read file name This article will delve into the causes of this problem and propose a solution specifically designed for this situation. Reproduce the Problem Code Since the problem mentioned that the issue always occurs when executing the tmux command, and we can see in the output of bpf_printk that the process name for the corresponding event is utempter, we can try to write a simple program to reproduce the problem based on these two pieces of information. After searching online for the relationship between tmux and utempter, and reading the relevant tmux source code, I learned the following information: tmux uses the utempter_add_record function provided by utempter.h to create the required pseudo-terminal: xasprintf(&amp;cp, &#34;tmux(%lu).%%%u&#34;, (long)getpid(), new_wp-&gt;id); utempter_add_record(new_wp-&gt;fd, cp); In the utempter_add_record function, it will first construct an args from the passed parameters and then invoke the execute_helper function: #define UTEMPTER_DEFAULT_PATHNAME LIBEXECDIR &#34;/utempter/utempter&#34; static const char *utempter_pathname; int utempter_add_record(int master_fd, const char *hostname) { const char *const args[] = { utempter_pathname ? : UTEMPTER_DEFAULT_PATHNAME, &#34;add&#34;, hostname, 0 }; int status = execute_helper(master_fd, args); // ... } In the execute_helper function, the passed args will eventually be used to call the fork() and execv() functions to start a new process ( source code ): static int execute_helper(int master_fd, const char *const argv[]) { // ... child = fork(); if (!child) { do_child(master_fd, argv[0], (char *const *) argv); } else if (child &lt; 0) { // ... } static void __attribute__((__noreturn__)) do_child(int master_fd, const char *path, char *const *argv) { // ... execv(path, argv); print_dbg(&#34;execv: %s&#34;, strerror(errno)); //... } Based on the above information, we can write the following program to reproduce this issue reproduce.c: #define PATHNAME &#34;/usr/bin/echo&#34; int main(int argc, char **argv) { const char *hostname = argv[0]; const char *const args[] = { PATHNAME, &#34;add&#34;, hostname, 0 }; if (!fork()) { execv(args[0], (char *const *) args); } } Let&#39;s test the effectiveness of this program below: Compile using GCC: gcc -o reproduce reproduce.c Trace the tracepoint/syscalls/sys_enter_execve event using bpftrace in another terminal: sudo bpftrace -e &#39;tracepoint:syscalls:sys_enter_execve{printf(&#34;%s[%d]: %s\\n&#34;, comm, pid, str(args-&gt;filename));}&#39; Run the example program: ./reproduce At this time, the terminal running bpftrace will output results similar to the following: bash[34882]: ./reproduce reproduce[34883]: In the previous results, we did not capture the value of the filename parameter used during the execution of the execve() system call by the reproducing program. From this, it can be seen that our program has reproduced the original issue. Reason Reminded by @ssfdust, someone in the bpftrace community has previously raised a similar issue: #2523 . In this issue, @fbs provided an explanation : Like I said earlier, the data you&#39;re using isn&#39;t in memory yet. These static strings are compiled in and are not actually faulted into memory until they&#39;re accessed. The access won&#39;t happen until its read, which is after your bpftrace probe ran. BPF won&#39;t pull the data in so you get an EFAULT/-14. By printing the values or just a random print of a constant string you pull the small amount of data into memory (as it goes by page, not by var) and then it works That is: In the sample program, when executing execve(), the file name string referred to by argv[0] is a static string. These static strings are stored in the .rodata section of the ELF (Executable and Linkable Format) file after compilation. They are loaded into memory only when the program accesses them, specifically when accessing the data stored in the .rodata section. Based on point 1, the static string referenced by argv[0] in the sample program is only loaded into memory during the execution of the execve() system call. However, since our eBPF program runs before the execve() system call, attempting to read argv[0] using bpf_probe_read_user_str will fail and result in an EFAULT/-14 error code. By actively loading strings into memory through printf and other methods, this problem can be resolved. Summary from @jschwinger233 : bpf_probe_read_user can only read data that has been loaded into memory (page-faulted into memory), and the above code has not read .rodata until the execve(2) time, thus not triggering a page fault. This can be verified using tracepoint:exceptions:page_fault*. Verification Add a printf statement From the above, it can be seen that actually we only need to modify the program to proactively load the data in .rodata into memory before executing execve(), for example, using the printf function. You can use the printf function to print argv[0], or you can directly print a static string: if (!fork()) { printf(&#34;test\\n&#34;); // or // printf(&#34;argv[0]: %s\\n&#34;, args[0]); execv(args[0], (char *const *) args); } After verification, the modified program reproduce_printf1.c does allow the ebpf program to correctly read the value of filename. Not using static strings Since the issue is caused by the fact that argv[0] is a static string, you can try changing argv[0] to use a non-static string to see if the problem still exists. The modified content is as follows: const char *const args[] = { argv[1], &#34;add&#34;, hostname, 0 }; After verification, the modified program reproduce_non_static.c can also allow the ebpf program to correctly read the value of filename. I wonder if anyone has noticed that the value of argv[2] in our program reproducing the issue is actually a non-static string, so it can also be verified by reading the content of this data in the eBPF program. The expectation is to be able to read the content of this non-static string argv[2] without making any modifications: Run the new bpftrace command: sudo bpftrace -e &#39;tracepoint:syscalls:sys_enter_execve{ printf(&#34;%s[%d]: filename: %s, argv[1]: %s, argv[2]: %s\\n&#34;, comm, pid, str(args-&gt;filename), str(args-&gt;argv[1]), str(args-&gt;argv[2])); }&#39; Run ./reproduce The output example of the bpftrace command is as follows: bash[36523]: filename: ./reproduce, argv[1]: , argv[2]: reproduce[36524]: filename: , argv[1]: , argv[2]: ./reproduce page fault In modern Linux systems, when we run a binary executable file, the program loader (ELF executable loader) will use mmap for lazy loading based on the information defined in the ELF file, delaying the loading of some data. When the program actually tries to read these data, if the data being read has not been loaded into memory yet, it will trigger a page fault. The data stored in the .rodata section of ELF files is exactly the data that will be lazily loaded. .rodata The .rodata section in an ELF file stores some read-only data, such as static strings. Let&#39;s first take a look at the data in the .rodata section of the compiled example program binary ELF file. You can use the objdump command to view the contents: $ objdump -s -j .rodata ./reproduce ./reproduce: file format elf64-x86-64 Contents of section .rodata: 2000 01000200 2f757372 2f62696e 2f656368 ..../usr/bin/ech 2010 6f006164 6400 o.add. You can also use the pwntools library from the Python community for reading: &gt;&gt;&gt; from pwn import ELF &gt;&gt;&gt; elf = ELF(&#39;reproduce&#39;) &gt;&gt;&gt; elf.section(&#39;.rodata&#39;) b&#39;\\x01\\x00\\x02\\x00/usr/bin/echo\\x00add\\x00&#39; From the above output, it can be seen that it contains two static strings used in the source code. Observing page fault In the Linux system, when the kernel executes the execve() system call, it calls the kernel function strncpy_from_user (execve() -&gt; getname() -&gt; getname_flags(), strncpy_from_user()) to copy the string data contained in argv from user space to kernel space. This process involves reading user space data. If the user space data being read has not yet been loaded into memory, it will trigger a page fault. We can perceive this event by observing exceptions/page_fault_kernel and exceptions/page_fault_user: To simplify the verification process, we need to make a modification to the example code. Add a line of sleep(15) before executing the execv() function to ensure the program does not terminate too quickly (reproduce_sleep.c ): if (!fork()) { sleep(15); execv(args[0], (char *const *) args); } Run the following bpftrace script in a terminal to observe page faults: cat &lt;&lt;EOF | sudo bpftrace - tracepoint:exceptions:page_fault_kernel /comm == &#34;reproduce_sleep&#34;/ { printf(&#34;[%s] page_fault_kernel: %s[%d] addr=%llx ip=%llx err=%lld\\n&#34;, strftime(&#34;%M:%S&#34;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code); } tracepoint:exceptions:page_fault_user /comm == &#34;reproduce_sleep&#34;/ { printf(&#34;[%s] page_fault_user: %s[%d] addr=%llx ip=%llx err=%lld\\n&#34;, strftime(&#34;%M:%S&#34;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code); } EOF Then run ./reproduce_sleep in another terminal. View the memory mapping of the running reproduce_sleep process in the third terminal: $ sudo cat /proc/41291/maps | grep reproduce_sleep 55b4d9e31000-55b4d9e32000 r--p 00000000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e32000-55b4d9e33000 r-xp 00001000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e33000-55b4d9e34000 r--p 00002000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e34000-55b4d9e35000 r--p 00002000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e35000-55b4d9e36000 rw-p 00003000 08:01 1634479 /XXX/reproduce_sleep From the above, it can be seen that the memory mapping starting address of this process is 55b4d9e31000, that is, 0x55b4d9e. After the example program finishes running, the last two lines of the output of the bpftrace command will be similar to the following: [47:40] page_fault_user: reproduce_sleep[41290] addr=7f669db86a50 ip=7f669d9f8940 err=7 [47:55] page_fault_kernel: reproduce_sleep[41291] addr=55b4d9e33004 ip=ffffffff8e092a40 err=0 The 15-second gap between these two outputs confirms that the last page fault event was triggered when the execv() function was executed. Now let&#39;s locate the corresponding data based on the addr result in the event. The value of the addr output of the last page_fault_kernel event above is 55b4d9e33004, which means the virtual memory address that triggered this page fault event is 0x55b4d9e33004. Based on the recipe shared by @jschwinger233: real_addr = start_addr + (elf_address - section.Address + section.Offset) can be known: 0x55b4d9e33004 = 0x55b4d9e31000 + (elf_address - section.Address + section.Offset) (elf_address - section.Address + section.Offset) = 0x55b4d9e33004 - 0x55b4d9e31000 = 8196 = 0x2004 Use the readelf command to read the virtual address, offset, and data size of the ELF .rodata section in the binary file reproduce_sleep: $ readelf -S -W reproduce_sleep | egrep &#39;.rodata|Address&#39; [Nr] Name Type Address Off Size ES Flg Lk Inf Al [18] .rodata PROGBITS 0000000000002000 002000 000016 00 A 0 0 4 From the above output, it can be seen that the virtual address of the .rodata section in this ELF file is 0000000000002000 or 0x2000, the offset is 002000 or 0x2000, the data size is 0x16, that is, the address range is 0x2000-0x2016. Through 7 and 8, it can be known that the virtual memory address of the page fault event triggered when executing the execv() function is 0x55b4d9e33004, corresponding to the ELF address 0x2004. This address is within the range of the .rodata address in the ELF file (0x2000-0x2016), corresponding to the static string /usr/bin/echo used in argv[0]: $ objdump -s -j .rodata ./reproduce_sleep ./reproduce_sleep: file format elf64-x86-64 Contents of section .rodata: 2000 01000200 2f757372 2f62696e 2f656368 ..../usr/bin/ech 2010 6f006164 6400 o.add. &gt;&gt;&gt; elf = ELF(&#39;reproduce_sleep&#39;) &gt;&gt;&gt; elf.read(0x2004, 14) b&#39;/usr/bin/echo\\x00&#39; $ gdb -ex &#39;disas/m main&#39; -ex q reproduce_sleep | grep &#39;args\\[\\]&#39; -A 13 9 const char *const args[] = { 0x00000000000011d6 &lt;+45&gt;: lea 0xe27(%rip),%rax # 0x2004 0x00000000000011dd &lt;+52&gt;: mov %rax,-0x30(%rbp) 0x00000000000011e1 &lt;+56&gt;: lea 0xe2a(%rip),%rax # 0x2012 0x00000000000011e8 &lt;+63&gt;: mov %rax,-0x28(%rbp) 0x00000000000011ec &lt;+67&gt;: mov -0x38(%rbp),%rax 0x00000000000011f0 &lt;+71&gt;: mov %rax,-0x20(%rbp) 0x00000000000011f4 &lt;+75&gt;: movq $0x0,-0x18(%rbp) 10 PATHNAME, 11 &#34;add&#34;, 12 hostname, 13 0 14 }; You can also confirm by printing the pointer address of args-&gt;filename in the eBPF program or bpftrace script. The value at this address will be consistent with the value of addr in the previous page fault event, both being 0x55b4d9e33004: tracepoint:syscalls:sys_enter_execve { printf(&#34;%s[%d]: %p\\n&#34;, comm, pid, args-&gt;filename); } BTW, you can trace the function information that triggers page fault events by using the perf trace -F all command. Solution There are many methods to solve this problem, one of which is to change to tracking the tracepoint/sched/sched_process_exec event to obtain the values of the filename and argv parameters in the execve() system call. Below is an example program corresponding to the implementation: Example script for tracing the tracepoint/sched/sched_process_exec event using bpftrace(from @jschwinger233 ): tracepoint:sched:sched_process_exec { $task=curtask; $arg_start=$task-&gt;mm-&gt;arg_start; $arg_end=$task-&gt;mm-&gt;arg_end; printf(&#34;%s[%d]: filename: %s, argv: %r\\n&#34;, comm, pid, str(args-&gt;filename), buf(uptr($arg_start), $arg_end-$arg_start)); } An example program that traces the tracepoint/sched/sched_process_exec event through eBPF C code: main.bpf.c References tmux/tmux: tmux source code Can&#39;t trace sys_execve inside a c program · Issue #2523 · bpftrace/bpftrace ELF - OSDev Wiki unix - Why an ELF executable could have 4 LOAD segments? - Stack Overflow strncpy_from_user Guidance from @jschwinger233",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "https://mozillazg.com/2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case-en.html"
        },
        "datePublished": "2024-03-31"
    }
    </script>

</head>
<body>

<div class="navbar" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://mozillazg.com/" class="navbar-brand">
mozillazg's Blog            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="https://mozillazg.com/feeds/all.atom.xml">Feed</a></li>
                    <li><a href="/2014/10/pages/about-me.html">About</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://mozillazg.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content" class="yue">
        <article>
            <header class="text-center">
                <h1>
                    <a href="https://mozillazg.com/2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case-en.html"
                       rel="bookmark"
                       title="Permalink to A case in which tracing the execve system call with tracepoints does not accurately capture the system call parameters">
                        A case in which tracing the execve system call with tracepoints does not accurately capture the system call parameters
                    </a>
                </h1>
                <p class="published">
                    <time datetime="2024-03-31T00:00:00+00:00">
                    2024-03-31
                    </time>
                </p>
            </header>
            <div class="entry-content">
                <div class="well-sm article-info">
<footer class="post-info">
        <a href="https://mozillazg.com/category/ebpf.html">ebpf</a>


<span class="label label-default hide">Tags</span>
	<a href="https://mozillazg.com/tag/tracepoint.html">tracepoint</a>
        /
	<a href="https://mozillazg.com/tag/libbpf.html">libbpf</a>
        /
	<a href="https://mozillazg.com/tag/bpftrace.html">bpftrace</a>
        /
	<a href="https://mozillazg.com/tag/elf.html">ELF</a>
        /
	<a href="https://mozillazg.com/tag/en-version.html">en-version</a>
    <span class="label label-default">Lang</span>
	<a href="https://mozillazg.com/2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case.html">zh</a>

</footer><!-- /.post-info -->                </div>
                <div class="js-toc"></div>
                <div>
                <div class="section" id="background">
<h2 id="hidbackground">Background<a class="headerlink" href="#hidbackground" title="Permalink to this headline">¶</a></h2>
<p>Some time ago, a netizen consulted a problem he encountered in the <a class="reference external" href="https://ebpf.io/slack">ebpf channel on slack</a> :</p>
<!-- `question <https://cilium.slack.com/archives/C4XCTGYEM/p1710380136906129?thread_ts=1710284853.310149&cid=C4XCTGYEM>`__ ： -->
<p>When writing an eBPF program that uses <tt class="docutils literal">tracepoint/syscalls/sys_enter_execve</tt> to trace the execve system call,
encountered a situation where there is a failure in reading the <tt class="docutils literal">filename</tt>
parameter of <tt class="docutils literal">execve</tt> using <tt class="docutils literal">bpf_probe_read_user_str</tt> in the recorded events,
with an error code of -14/EFAULT. Especially when executing the <tt class="docutils literal">tmux</tt> command,
there will always be an event of a failed read:</p>
<pre class="literal-block">
ret = bpf_probe_read_user_str(event-&gt;args, ARGSIZE, (const char*)ctx-&gt;args[0]);
if (ret &lt; 0) {
        bpf_printk(&quot;comm=%s XXX cannot read file name&quot;, tgid, pid, event-&gt;comm);
        return 0;
}

utempter-4031732 [027] d...1 3878624.643948: bpf_trace_printk: comm=tmux: server XXX cannot read file name
   &lt;...&gt;-4035723 [077] d...1 3878668.047954: bpf_trace_printk: comm=tmux: server XXX cannot read file name
</pre>
<p>This article will delve into the causes of this problem and propose a solution specifically designed for this situation.</p>
</div>
<div class="section" id="reproduce-the-problem-code">
<h2 id="hidreproduce-the-problem-code">Reproduce the Problem Code<a class="headerlink" href="#hidreproduce-the-problem-code" title="Permalink to this headline">¶</a></h2>
<p>Since the problem mentioned that the issue always occurs when executing the <tt class="docutils literal">tmux</tt> command,
and we can see in the output of <tt class="docutils literal">bpf_printk</tt> that the process name
for the corresponding event is <tt class="docutils literal">utempter</tt>, we can try to write
a simple program to reproduce the problem based on these two pieces of information.</p>
<p>After searching online for the relationship between tmux and utempter,
and reading the relevant tmux source code, I learned the following information:</p>
<ol class="arabic">
<li><p class="first">tmux uses the <a class="reference external" href="https://github.com/tmux/tmux/blob/b79e28b2c30e7ef9b1f7ec6233eeb70a1a177231/spawn.c#L473">utempter_add_record</a>
function provided by <tt class="docutils literal">utempter.h</tt> to create the required pseudo-terminal:</p>
<pre class="literal-block">
xasprintf(&amp;cp, &quot;tmux(%lu).%%%u&quot;, (long)getpid(), new_wp-&gt;id);
utempter_add_record(new_wp-&gt;fd, cp);
</pre>
</li>
<li><p class="first">In the <cite>utempter_add_record</cite> function, it will first construct an <cite>args</cite> from the passed parameters and then invoke the
<a class="reference external" href="https://github.com/altlinux/libutempter/blob/9f291816a746292547ac8aaea0c88e16fc2fb29a/libutempter/iface.c#L121">execute_helper</a>
function:</p>
<pre class="literal-block">
#define UTEMPTER_DEFAULT_PATHNAME     LIBEXECDIR &quot;/utempter/utempter&quot;
static const char *utempter_pathname;

int utempter_add_record(int master_fd, const char *hostname)
  {
      const char *const args[] = {
          utempter_pathname ? : UTEMPTER_DEFAULT_PATHNAME,
          &quot;add&quot;,
          hostname,
          0
      };
      int status = execute_helper(master_fd, args);
      // ...
  }
</pre>
</li>
<li><p class="first">In the <tt class="docutils literal">execute_helper</tt> function, the passed <tt class="docutils literal">args</tt> will eventually be used to call the
<tt class="docutils literal">fork()</tt> and <tt class="docutils literal">execv()</tt> functions to start a new process
( <a class="reference external" href="https://github.com/altlinux/libutempter/blob/9f291816a746292547ac8aaea0c88e16fc2fb29a/libutempter/iface.c#L84">source code</a> ):</p>
<pre class="literal-block">
static int execute_helper(int master_fd, const char *const argv[])
{
    // ...
    child = fork();
    if (!child) {
        do_child(master_fd, argv[0], (char *const *) argv);
    } else if (child &lt; 0) {
    // ...
}
static void __attribute__((__noreturn__))
do_child(int master_fd, const char *path, char *const *argv)
{
    // ...
    execv(path, argv);
    print_dbg(&quot;execv: %s&quot;, strerror(errno));
    //...
}
</pre>
</li>
</ol>
<p>Based on the above information, we can write the following program to reproduce this issue
<a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce.c">reproduce.c</a>:</p>
<pre class="literal-block">
#define PATHNAME &quot;/usr/bin/echo&quot;

int main(int argc, char **argv) {
    const char *hostname = argv[0];
    const char *const args[] = {
        PATHNAME,
        &quot;add&quot;,
        hostname,
        0
    };
    if (!fork()) {
        execv(args[0], (char *const *) args);
    }
}
</pre>
<p>Let's test the effectiveness of this program below:</p>
<ol class="arabic">
<li><p class="first">Compile using GCC:</p>
<pre class="literal-block">
gcc -o reproduce reproduce.c
</pre>
</li>
<li><p class="first">Trace the <tt class="docutils literal">tracepoint/syscalls/sys_enter_execve</tt> event using <a class="reference external" href="https://github.com/bpftrace/bpftrace">bpftrace</a>
in another terminal:</p>
<pre class="literal-block">
sudo bpftrace -e 'tracepoint:syscalls:sys_enter_execve{printf(&quot;%s[%d]: %s\n&quot;, comm, pid, str(args-&gt;filename));}'
</pre>
</li>
<li><p class="first">Run the example program:</p>
<pre class="literal-block">
./reproduce
</pre>
</li>
</ol>
<p>At this time, the terminal running bpftrace will output results similar to the following:</p>
<pre class="literal-block">
bash[34882]: ./reproduce
reproduce[34883]:
</pre>
<p>In the previous results, we did not capture the value of the <cite>filename</cite> parameter used during
the execution of the <cite>execve()</cite> system call by the reproducing program.
From this, it can be seen that our program has reproduced the original issue.</p>
</div>
<div class="section" id="reason">
<h2 id="hidreason">Reason<a class="headerlink" href="#hidreason" title="Permalink to this headline">¶</a></h2>
<p>Reminded by <a class="reference external" href="https://github.com/ssfdust">&#64;ssfdust</a>, someone in the bpftrace community
has previously raised a similar issue: <a class="reference external" href="https://github.com/bpftrace/bpftrace/issues/2523">#2523</a> .
In this issue, <a class="reference external" href="https://github.com/fbs">&#64;fbs</a> provided an
<a class="reference external" href="https://github.com/bpftrace/bpftrace/issues/2523#issuecomment-1466936511">explanation</a> :</p>
<blockquote>
<p>Like I said earlier, the data you're using isn't in memory yet. These static strings are compiled in and are not actually faulted into memory until they're accessed. The access won't happen until its read, which is after your bpftrace probe ran. BPF won't pull the data in so you get an EFAULT/-14.</p>
<p>By printing the values or just a random print of a constant string you pull the small amount of data into memory (as it goes by page, not by var) and then it works</p>
</blockquote>
<p>That is:</p>
<ol class="arabic simple">
<li>In the sample program, when executing <tt class="docutils literal">execve()</tt>, the file name string referred to by <tt class="docutils literal">argv[0]</tt> is a static string.
These static strings are stored in the <tt class="docutils literal">.rodata</tt> section of the ELF (Executable and Linkable Format) file
after compilation. They are loaded into memory only when the program accesses them,
specifically when accessing the data stored in the <tt class="docutils literal">.rodata</tt> section.</li>
<li>Based on point 1, the static string referenced by <tt class="docutils literal">argv[0]</tt> in the sample program is only
loaded into memory during the execution of the <tt class="docutils literal">execve()</tt> system call. However,
since our eBPF program runs before the <tt class="docutils literal">execve()</tt> system call, attempting to read <tt class="docutils literal">argv[0]</tt> using
bpf_probe_read_user_str will fail and result in an <tt class="docutils literal"><span class="pre">EFAULT/-14</span></tt> error code.</li>
<li>By actively loading strings into memory through <tt class="docutils literal">printf</tt> and other methods, this problem can be resolved.</li>
</ol>
<p>Summary from <a class="reference external" href="https://github.com/jschwinger233">&#64;jschwinger233</a> :</p>
<blockquote>
bpf_probe_read_user can only read data that has been loaded into memory (page-faulted into memory),
and the above code has not read .rodata until the execve(2) time, thus not triggering a page fault.
This can be verified using tracepoint:exceptions:page_fault*.</blockquote>
</div>
<div class="section" id="verification">
<h2 id="hidverification">Verification<a class="headerlink" href="#hidverification" title="Permalink to this headline">¶</a></h2>
<div class="section" id="add-a-printf-statement">
<h3 id="hidadd-a-printf-statement">Add a printf statement<a class="headerlink" href="#hidadd-a-printf-statement" title="Permalink to this headline">¶</a></h3>
<p>From the above, it can be seen that actually we only need to modify the program to proactively
load the data in <tt class="docutils literal">.rodata</tt> into memory before executing <tt class="docutils literal">execve()</tt>, for example, using the <tt class="docutils literal">printf</tt> function.</p>
<p>You can use the <tt class="docutils literal">printf</tt> function to print <tt class="docutils literal">argv[0]</tt>, or you can directly print a static string:</p>
<pre class="literal-block">
if (!fork()) {
    printf(&quot;test\n&quot;);
    // or
    // printf(&quot;argv[0]: %s\n&quot;, args[0]);
    execv(args[0], (char *const *) args);
}
</pre>
<p>After verification, the modified program
<a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce_printf1.c">reproduce_printf1.c</a>
does allow the ebpf program to correctly read the value of filename.</p>
</div>
<div class="section" id="not-using-static-strings">
<h3 id="hidnot-using-static-strings">Not using static strings<a class="headerlink" href="#hidnot-using-static-strings" title="Permalink to this headline">¶</a></h3>
<p>Since the issue is caused by the fact that <tt class="docutils literal">argv[0]</tt> is a static string, you can try changing
<tt class="docutils literal">argv[0]</tt> to use a non-static string to see if the problem still exists.
The modified content is as follows:</p>
<pre class="literal-block">
const char *const args[] = {
    argv[1],
    &quot;add&quot;,
    hostname,
    0
};
</pre>
<p>After verification, the modified program
<a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce_non_static.c">reproduce_non_static.c</a>
can also allow the ebpf program to correctly read the value of filename.</p>
<p>I wonder if anyone has noticed that the value of <tt class="docutils literal">argv[2]</tt> in
our program reproducing the issue is actually a non-static string,
so it can also be verified by reading the content of this data in the eBPF program.
The expectation is to be able to read the content of this non-static string <tt class="docutils literal">argv[2]</tt>
without making any modifications:</p>
<ol class="arabic">
<li><p class="first">Run the new bpftrace command:</p>
<pre class="literal-block">
sudo bpftrace -e 'tracepoint:syscalls:sys_enter_execve{
    printf(&quot;%s[%d]: filename: %s, argv[1]: %s, argv[2]: %s\n&quot;, comm, pid, str(args-&gt;filename), str(args-&gt;argv[1]), str(args-&gt;argv[2]));
}'
</pre>
</li>
<li><p class="first">Run <tt class="docutils literal">./reproduce</tt></p>
</li>
<li><p class="first">The output example of the bpftrace command is as follows:</p>
<pre class="literal-block">
bash[36523]: filename: ./reproduce, argv[1]: , argv[2]:
reproduce[36524]: filename: , argv[1]: , argv[2]: ./reproduce
</pre>
</li>
</ol>
</div>
<div class="section" id="page-fault">
<h3 id="hidpage-fault">page fault<a class="headerlink" href="#hidpage-fault" title="Permalink to this headline">¶</a></h3>
<p>In modern Linux systems, when we run a binary executable file,
the program loader (ELF executable loader) will use <tt class="docutils literal">mmap</tt> for lazy loading based on
the information defined in the ELF file, delaying the loading of some data.
When the program actually tries to read these data, if the data being read has
not been loaded into memory yet, it will trigger a page fault.</p>
<!-- CPU 就会生成一个缺页异常（page fault exception）。此时，内核中的缺页处理程序（page fault handler） -->
<!-- 会负责处理该异常，将缺失的页面加载到内存中，然后 CPU 重新执行引起缺页异常的指令。 -->
<p>The data stored in the <tt class="docutils literal">.rodata</tt> section of ELF files is exactly the data that will be lazily loaded.</p>
<div class="section" id="rodata">
<h4 id="hidrodata">.rodata<a class="headerlink" href="#hidrodata" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal">.rodata</tt> section in an ELF file stores some read-only data, such as static strings.
Let's first take a look at the data in the <tt class="docutils literal">.rodata</tt> section of the compiled example program binary ELF file.</p>
<ul>
<li><p class="first">You can use the <tt class="docutils literal">objdump</tt> command to view the contents:</p>
<pre class="literal-block">
$ objdump -s -j .rodata ./reproduce

./reproduce:     file format elf64-x86-64

Contents of section .rodata:
2000 01000200 2f757372 2f62696e 2f656368  ..../usr/bin/ech
2010 6f006164 6400                        o.add.
</pre>
</li>
<li><p class="first">You can also use the <a class="reference external" href="https://docs.pwntools.com/en/stable/">pwntools</a> library from the Python community for reading:</p>
<pre class="literal-block">
&gt;&gt;&gt; from pwn import ELF
&gt;&gt;&gt; elf = ELF('reproduce')
&gt;&gt;&gt; elf.section('.rodata')
b'\x01\x00\x02\x00/usr/bin/echo\x00add\x00'
</pre>
</li>
</ul>
<p>From the above output, it can be seen that it contains two static strings used in the source code.</p>
</div>
<div class="section" id="observing-page-fault">
<h4 id="hidobserving-page-fault">Observing page fault<a class="headerlink" href="#hidobserving-page-fault" title="Permalink to this headline">¶</a></h4>
<p>In the Linux system, when the kernel executes the <tt class="docutils literal">execve()</tt> system call, it calls the kernel function
<tt class="docutils literal">strncpy_from_user</tt> (<tt class="docutils literal">execve() <span class="pre">-&gt;</span> getname() <span class="pre">-&gt;</span> <span class="pre">getname_flags(),</span> strncpy_from_user()</tt>) to copy the string data
contained in <tt class="docutils literal">argv</tt> from user space to kernel space. This process involves reading user space data.
If the user space data being read has not yet been loaded into memory, it will trigger a page fault.</p>
<p>We can perceive this event by observing <tt class="docutils literal">exceptions/page_fault_kernel</tt> and <tt class="docutils literal">exceptions/page_fault_user</tt>:</p>
<ol class="arabic">
<li><p class="first">To simplify the verification process, we need to make a modification to the example code. Add a line of <tt class="docutils literal">sleep(15)</tt>
before executing the <tt class="docutils literal">execv()</tt> function to ensure the program does not terminate too quickly
(<a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce_sleep.c">reproduce_sleep.c</a> ):</p>
<pre class="literal-block">
if (!fork()) {
     sleep(15);
     execv(args[0], (char *const *) args);
}
</pre>
</li>
<li><p class="first">Run the following bpftrace script in a terminal to observe page faults:</p>
<pre class="literal-block">
cat &lt;&lt;EOF | sudo bpftrace -
tracepoint:exceptions:page_fault_kernel /comm == &quot;reproduce_sleep&quot;/ {
    printf(&quot;[%s] page_fault_kernel: %s[%d] addr=%llx ip=%llx err=%lld\n&quot;,
            strftime(&quot;%M:%S&quot;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code);
}

tracepoint:exceptions:page_fault_user /comm == &quot;reproduce_sleep&quot;/ {
    printf(&quot;[%s] page_fault_user:   %s[%d] addr=%llx ip=%llx err=%lld\n&quot;,
            strftime(&quot;%M:%S&quot;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code);
}
EOF
</pre>
</li>
<li><p class="first">Then run ./reproduce_sleep in another terminal.</p>
</li>
<li><p class="first">View the memory mapping of the running reproduce_sleep process in the third terminal:</p>
<pre class="literal-block">
$ sudo cat /proc/41291/maps | grep reproduce_sleep
55b4d9e31000-55b4d9e32000 r--p 00000000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e32000-55b4d9e33000 r-xp 00001000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e33000-55b4d9e34000 r--p 00002000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e34000-55b4d9e35000 r--p 00002000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e35000-55b4d9e36000 rw-p 00003000 08:01 1634479                    /XXX/reproduce_sleep
</pre>
<p>From the above, it can be seen that the memory mapping starting address of this process is <tt class="docutils literal">55b4d9e31000</tt>,
that is, <tt class="docutils literal">0x55b4d9e</tt>.</p>
</li>
<li><p class="first">After the example program finishes running, the last two lines of the output of the bpftrace command
will be similar to the following:</p>
<pre class="literal-block">
[47:40] page_fault_user:   reproduce_sleep[41290] addr=7f669db86a50 ip=7f669d9f8940 err=7
[47:55] page_fault_kernel: reproduce_sleep[41291] addr=55b4d9e33004 ip=ffffffff8e092a40 err=0
</pre>
<p>The 15-second gap between these two outputs confirms that the last page fault event was triggered
when the <tt class="docutils literal">execv()</tt> function was executed. Now let's locate the corresponding data based on
the <tt class="docutils literal">addr</tt> result in the event.</p>
</li>
<li><p class="first">The value of the <cite>addr</cite> output of the last <tt class="docutils literal">page_fault_kernel</tt> event above is <tt class="docutils literal">55b4d9e33004</tt>,
which means the virtual memory address that triggered this page fault event is <tt class="docutils literal">0x55b4d9e33004</tt>.</p>
</li>
<li><p class="first">Based on the recipe shared by <a class="reference external" href="https://github.com/jschwinger233">&#64;jschwinger233</a>:
<tt class="docutils literal">real_addr = start_addr + (elf_address - section.Address + section.Offset)</tt> can be known:</p>
<pre class="literal-block">
0x55b4d9e33004 = 0x55b4d9e31000 + (elf_address - section.Address + section.Offset)
(elf_address - section.Address + section.Offset) = 0x55b4d9e33004 - 0x55b4d9e31000 = 8196 = 0x2004
</pre>
</li>
<li><p class="first">Use the <tt class="docutils literal">readelf</tt> command to read the virtual address, offset, and data size of the ELF <tt class="docutils literal">.rodata</tt> section
in the binary file <tt class="docutils literal">reproduce_sleep</tt>:</p>
<pre class="literal-block">
$ readelf -S -W reproduce_sleep  | egrep '.rodata|Address'
  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
  [18] .rodata           PROGBITS        0000000000002000 002000 000016 00   A  0   0  4
</pre>
<p>From the above output, it can be seen that the virtual address of the <tt class="docutils literal">.rodata</tt> section in this ELF file
is <tt class="docutils literal">0000000000002000</tt> or <tt class="docutils literal">0x2000</tt>, the offset is <tt class="docutils literal">002000</tt> or <tt class="docutils literal">0x2000</tt>, the data size is <tt class="docutils literal">0x16</tt>, that is,
the address range is <tt class="docutils literal"><span class="pre">0x2000-0x2016</span></tt>.</p>
</li>
<li><p class="first">Through 7 and 8, it can be known that the virtual memory address of the page fault event triggered when
executing the <tt class="docutils literal">execv()</tt> function is <tt class="docutils literal">0x55b4d9e33004</tt>, corresponding to the ELF address <tt class="docutils literal">0x2004</tt>.
This address is within the range of the <tt class="docutils literal">.rodata</tt> address in the ELF file (<tt class="docutils literal"><span class="pre">0x2000-0x2016</span></tt>),
corresponding to the static string <tt class="docutils literal">/usr/bin/echo</tt> used in <tt class="docutils literal">argv[0]</tt>:</p>
<pre class="literal-block">
$ objdump -s -j .rodata ./reproduce_sleep

./reproduce_sleep:     file format elf64-x86-64

Contents of section .rodata:
 2000 01000200 2f757372 2f62696e 2f656368  ..../usr/bin/ech
 2010 6f006164 6400                        o.add.

&gt;&gt;&gt; elf = ELF('reproduce_sleep')
&gt;&gt;&gt; elf.read(0x2004, 14)
b'/usr/bin/echo\x00'

$ gdb -ex 'disas/m main' -ex q reproduce_sleep | grep 'args\[\]' -A 13
9       const char *const args[] = {
   0x00000000000011d6 &lt;+45&gt;:        lea    0xe27(%rip),%rax        # 0x2004
   0x00000000000011dd &lt;+52&gt;:        mov    %rax,-0x30(%rbp)
   0x00000000000011e1 &lt;+56&gt;:        lea    0xe2a(%rip),%rax        # 0x2012
   0x00000000000011e8 &lt;+63&gt;:        mov    %rax,-0x28(%rbp)
   0x00000000000011ec &lt;+67&gt;:        mov    -0x38(%rbp),%rax
   0x00000000000011f0 &lt;+71&gt;:        mov    %rax,-0x20(%rbp)
   0x00000000000011f4 &lt;+75&gt;:        movq   $0x0,-0x18(%rbp)

10          PATHNAME,
11          &quot;add&quot;,
12          hostname,
13          0
14      };
</pre>
</li>
<li><p class="first">You can also confirm by printing the pointer address of <tt class="docutils literal"><span class="pre">args-&gt;filename</span></tt> in the eBPF program or
bpftrace script. The value at this address will be consistent with the value of <tt class="docutils literal">addr</tt>
in the previous page fault event, both being <tt class="docutils literal">0x55b4d9e33004</tt>:</p>
<pre class="literal-block">
tracepoint:syscalls:sys_enter_execve {
    printf(&quot;%s[%d]: %p\n&quot;, comm, pid, args-&gt;filename);
}
</pre>
</li>
</ol>
<p>BTW, you can trace the function information that triggers page fault events by using the <tt class="docutils literal">perf trace <span class="pre">-F</span></tt> all command.</p>
</div>
</div>
</div>
<div class="section" id="solution">
<h2 id="hidsolution">Solution<a class="headerlink" href="#hidsolution" title="Permalink to this headline">¶</a></h2>
<p>There are many methods to solve this problem, one of which is to change to tracking the
<tt class="docutils literal">tracepoint/sched/sched_process_exec</tt> event to obtain the values of the filename and
argv parameters in the <tt class="docutils literal">execve()</tt> system call. Below is an example program corresponding to the implementation:</p>
<ul>
<li><p class="first">Example script for tracing the <tt class="docutils literal">tracepoint/sched/sched_process_exec</tt> event using bpftrace(from <a class="reference external" href="https://github.com/jschwinger233">&#64;jschwinger233</a> ):</p>
<pre class="literal-block">
tracepoint:sched:sched_process_exec {
  $task=curtask;
  $arg_start=$task-&gt;mm-&gt;arg_start;
  $arg_end=$task-&gt;mm-&gt;arg_end;
  printf(&quot;%s[%d]: filename: %s, argv: %r\n&quot;, comm, pid, str(args-&gt;filename), buf(uptr($arg_start), $arg_end-$arg_start));
}
</pre>
</li>
<li><p class="first">An example program that traces the <tt class="docutils literal">tracepoint/sched/sched_process_exec</tt> event through eBPF C code:
<a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/blob/master/37-tracepoint-sched_process_exec/main.bpf.c">main.bpf.c</a></p>
</li>
</ul>
</div>
<div class="section" id="references">
<h2 id="hidreferences">References<a class="headerlink" href="#hidreferences" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://github.com/tmux/tmux/tree/master">tmux/tmux: tmux source code</a></li>
<li><a class="reference external" href="https://github.com/bpftrace/bpftrace/issues/2523">Can't trace sys_execve inside a c program · Issue #2523 · bpftrace/bpftrace</a></li>
<li><a class="reference external" href="https://wiki.osdev.org/ELF">ELF - OSDev Wiki</a></li>
<li><a class="reference external" href="https://stackoverflow.com/questions/57761007/why-an-elf-executable-could-have-4-load-segments">unix - Why an ELF executable could have 4 LOAD segments? - Stack Overflow</a></li>
<li><a class="reference external" href="https://www.cs.bham.ac.uk/~exr/lectures/opsys/13_14/docs/kernelAPI/r4206.html">strncpy_from_user</a></li>
<li>Guidance from <a class="reference external" href="https://github.com/jschwinger233">&#64;jschwinger233</a></li>
</ul>
</div>

                </div>
            </div>
            <!-- /.entry-content -->
<section class="text-center">
  
<div id="donate"></div>

<div class="social-share"></div>
<div class="social-comment-note">
<p class="text-center">有任何建议和想法欢迎在下方评论区留言或者加我<a href="/static/wechat.png">微信</a>交流</p>
</div>

</section>
<section class="well" id="related-posts">
    <p>Related Posts:</p>
    <ul>
        <li><a href="https://mozillazg.com/2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case.html">一个使用 tracepoint 追踪 execve 系统调用时无法正确获取系统调用参数的场景</a></li>
        <li><a href="https://mozillazg.com/2022/06/ebpf-libbpf-btf-powered-enabled-raw-tracepoint-common-questions-en.html">Frequently asked questions about using btf raw tracepoint with ebpf/libbpf programs</a></li>
        <li><a href="https://mozillazg.com/2022/05/ebpf-libbpf-raw-tracepoint-common-questions-en.html">Frequently asked questions about using raw tracepoint with ebpf/libbpf programs</a></li>
        <li><a href="https://mozillazg.com/2022/05/ebpf-libbpf-tracepoint-common-questions-en.html">Frequently asked questions about using tracepoint with ebpf/libbpf programs</a></li>
        <li><a href="https://mozillazg.com/2022/06/ebpf-libbpf-btf-powered-enabled-raw-tracepoint-common-questions.html">ebpf/libbpf 程序使用 btf raw tracepoint 的常见问题</a></li>
    </ul>
</section>
<hr/>
<section class="comments" id="comments">
    <h2>Comments</h2>
    <script src="https://giscus.app/client.js"
            data-repo="mozillazg/mozillazg.github.com"
            data-repo-id="MDEwOlJlcG9zaXRvcnk3Njc4MTA2"
            data-category="Announcements"
            data-category-id="DIC_kwDOAHUoms4CckZl"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="0"
            data-input-position="bottom"
            data-theme="preferred_color_scheme"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
    </script>
</section>
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2024 mozillazg
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>
            &middot; <a href="/privacy-policy.html" target="_blank">Privacy</a>              <p><small>  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/static/images/by-sa-80x15.png" /></a>
    &quot;<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">mozillazg's Blog</span>&quot; by <a xmlns:cc="http://creativecommons.org/ns#" href="https://mozillazg.com" property="cc:attributionName" rel="cc:attributionURL">mozillazg</a> is
  licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="/theme/cdn.jsdelivr.net/npm/jquery@2.1.1/dist/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="/theme/cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->


<!-- share.js -->
<script src="/theme/cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>



<script src="/theme/cdn.jsdelivr.net/npm/tocbot@3.0.2/dist/tocbot.min.js"></script>
<script>
$(document).ready(function(){
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.js-toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.entry-content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h2, h3, h4,h5',
    // Headings that match the ignoreSelector will be skipped.
    ignoreSelector: '.js-toc-ignore',
    // Main class to add to links.
    linkClass: 'toc-link',
    // Extra classes to add to links.
    extraLinkClasses: '',
    // Class to add to active links,
    // the link corresponding to the top most heading on the page.
    activeLinkClass: 'is-active-link',
    // Main class to add to lists.
    listClass: 'toc-list',
    // Extra classes to add to lists.
    extraListClasses: '',
    // Class that gets added when a list should be collapsed.
    isCollapsedClass: 'is-collapsed',
    // Class that gets added when a list should be able
    // to be collapsed but isn't necessarily collpased.
    collapsibleClass: 'is-collapsible',
    // Class to add to list items.
    listItemClass: 'toc-list-item',
    // How many heading levels should not be collpased.
    // For example, number 6 will show everything since
    // there are only 6 heading levels and number 0 will collpase them all.
    // The sections that are hidden will open
    // and close as you scroll to headings within them.
    collapseDepth: 6,
    // Smooth scrolling enabled.
    smoothScroll: true,
    // Smooth scroll duration.
    smoothScrollDuration: 420,
    // Callback for scroll end (requires: smoothScroll).
    scrollEndCallback: function (e) {},
    // Headings offset between the headings and the top of the document (this is meant for minor adjustments).
    headingsOffset: 0,
    // Timeout between events firing to make sure it's
    // not too rapid (for performance reasons).
    throttleTimeout: 50,
    // Element to add the positionFixedClass to.
    positionFixedSelector: null,
    // Fixed position class to add to make sidebar fixed after scrolling
    // down past the fixedSidebarOffset.
    positionFixedClass: 'is-position-fixed',
    // fixedSidebarOffset can be any number but by default is set
    // to auto which sets the fixedSidebarOffset to the sidebar
    // element's offsetTop from the top of the document on init.
    fixedSidebarOffset: 'auto',
    // includeHtml can be set to true to include the HTML markup from the
    // heading node instead of just including the textContent.
    includeHtml: false
  });
});
</script>
</body>
</html>