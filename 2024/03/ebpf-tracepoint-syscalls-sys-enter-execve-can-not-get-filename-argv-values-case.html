<!DOCTYPE html>
<html lang="zh"  prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml" class="han-init">
<head>
    <title>一个使用 tracepoint 追踪 execve 系统调用时无法正确获取系统调用参数的场景 - mozillazg's Blog</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- share.css -->
    <link rel="stylesheet" href="/theme/cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">


    <link href="https://mozillazg.com/favicon.ico" rel="icon">

<link rel="canonical" href="https://mozillazg.com/2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case.html">

        <meta name="author" content="mozillazg" />
        <meta name="keywords" content="ebpf,tracepoint,bpftrace,ELF" />
    <meta name="description" content="背景 前段时间有网友在 slack 上的 ebpf 频道 中咨询一个他遇到的问题： 在编写使用 tracepoint/syscalls/sys_enter_execve 追踪 execve 系统调用的 ebpf 程序时， 遇到了记录的部分事件中存在使用 bpf_probe_read_user_str 读取 execve 的 filename 参数失败的现象，错误码为 -14/EFAULT。 尤其是在执行 tmux 命令的时候，必定会伴随一个读取失败的事件: ret = bpf_probe_read_user_str(event-&gt;args, ARGSIZE, (const char*)ctx-&gt;args[0]); if (ret &lt; 0) { bpf_printk(&#34;comm=%s XXX cannot read file name&#34;, tgid, pid, event-&gt;comm); return 0; } utempter-4031732 [027] d...1 3878624.643948: bpf_trace_printk: comm=tmux: server XXX cannot read file name &lt;...&gt;-4035723 [077] d...1 3878668.047954: bpf_trace_printk: comm=tmux: server XXX cannot read file name 本文将探讨一下该问题出现的原因以及针对该场景的一种解决方法。 复现问题的代码 因为问题中提到只要执行 tmux 命令就必定会复现该问题，并且我们在 bpf_printk 的输出中看到对应事件的进程名称为 utempter ， 因此，我们可以基于这两点信息来尝试编写一个简单的复现问题的程序。 通过在网络上查找 tmux 与 utempter 的关联关系，以及阅读了相关的 tmux 源代码后，我了解到了如下信息： tmux 会调用 utempter.h 提供的 utempter_add_record 函数创建所需的伪终端（pseudo-terminal）: xasprintf(&amp;cp, &#34;tmux(%lu).%%%u&#34;, (long)getpid(), new_wp-&gt;id); utempter_add_record(new_wp-&gt;fd, cp); utempter_add_record 函数中会首先使用传入的参数构造一个 args 然后调用 execute_helper 函数: #define UTEMPTER_DEFAULT_PATHNAME LIBEXECDIR &#34;/utempter/utempter&#34; static const char *utempter_pathname; int utempter_add_record(int master_fd, const char *hostname) { const char *const args[] = { utempter_pathname ? : UTEMPTER_DEFAULT_PATHNAME, &#34;add&#34;, hostname, 0 }; int status = execute_helper(master_fd, args); // ... } execute_helper 函数中最终会使用传入的 args 调用 fork() 和 execv() 函数启动一个新的进程 （ 源代码 ）: static int execute_helper(int master_fd, const char *const argv[]) { // ... child = fork(); if (!child) { do_child(master_fd, argv[0], (char *const *) argv); } else if (child &lt; 0) { // ... } static void __attribute__((__noreturn__)) do_child(int master_fd, const char *path, char *const *argv) { // ... execv(path, argv); print_dbg(&#34;execv: %s&#34;, strerror(errno)); //... } 根据上面这些信息，我们可以编写如下这个可复现该问题的程序 reproduce.c: #define PATHNAME &#34;/usr/bin/echo&#34; int main(int argc, char **argv) { const char *hostname = argv[0]; const char *const args[] = { PATHNAME, &#34;add&#34;, hostname, 0 }; if (!fork()) { execv(args[0], (char *const *) args); } } 下面测试一下这个程序的效果: 使用 gcc 编译: gcc -o reproduce reproduce.c 在另一个终端使用 bpftrace 追踪 tracepoint/syscalls/sys_enter_execve 事件: sudo bpftrace -e &#39;tracepoint:syscalls:sys_enter_execve{printf(&#34;%s[%d]: %s\n&#34;, comm, pid, str(args-&gt;filename));}&#39; 运行示例程序: ./reproduce 此时，运行 bpftrace 的终端将输出类似下面这样的结果: bash[34882]: ./reproduce reproduce[34883]: 在上面结果中，我们没有获取到 reproduce 进程执行 execve() 系统调用时使用的 filename 参数的值。 由此可见，我们的这个程序复现了最初的问题。 原因 经 @ssfdust 提醒，bpftrace 社区之前已经有人提过类似的问题： #2523 。 在这个 issue 中 @fbs 给出的 解释 是： Like I said earlier, the data you&#39;re using isn&#39;t in memory yet. These static strings are compiled in and are not actually faulted into memory until they&#39;re accessed. The access won&#39;t happen until its read, which is after your bpftrace probe ran. BPF won&#39;t pull the data in so you get an EFAULT/-14. By printing the values or just a random print of a constant string you pull the small amount of data into memory (as it goes by page, not by var) and then it works 即： 示例程序中，执行 execve() 时传入的 argv[0] 指向的文件名称字符串是一个静态字符串 （这些静态字符串在程序被编译后存储在 ELF（Executable and Linkable Format） 文件的 .rodata section）， 这些字符串只会在程序真正去访问他们的时候（访问 .rodata section 存储的数据时）才会被加载到内存中。 由1可知，示例程序中 argv[0] 指向的静态字符串只会在执行 execve() 系统调用的时候被读取到内存中， 但是我们的 ebpf 程序其实是在执行 execve() 系统调用之前被执行的，因此 ebpf 程序里使用 bpf_probe_read_user_str 读取 argv[0] 会失败并返回 EFAULT/-14 。 通过 printf 等方式主动将字符串加载到内存中可以让该问题消失。 来自 @jschwinger233 的总结： bpf_probe_read_user 只能读到已经载入内存 (page-faulted into memory) 的数据， 而上面代码直到 execve(2) 之时都还未读过 .rodata，未曾触发 page fault。 这可以用 tracepoint:exceptions:page_fault* 来验证。 验证 增加 printf 由上面可知，其实我们只需要修改程序在执行 execve() 之前主动将 .rodata 中的数据加载到内存中即可避免该问题， 比如使用 printf 函数。 即，可以使用 printf 函数打印 argv[0] ，也可以直接打印一个静态字符串: if (!fork()) { printf(&#34;test\n&#34;); // or // printf(&#34;argv[0]: %s\n&#34;, args[0]); execv(args[0], (char *const *) args); } 经验证，修改后的程序 reproduce_printf1.c 确实可以让 ebpf 程序正确读取到 filename 的值。 不使用静态字符串 既然是因为 argv[0] 是静态字符串导致的问题，那么可以尝试将 argv[0] 改为使用非静态字符串，看看问题是否还存在。 修改的内容如下: const char *const args[] = { argv[1], &#34;add&#34;, hostname, 0 }; 经验证，修改后的程序 reproduce_non_static.c 也可以让 ebpf 程序正确读取到 filename 的值。 不知道大家有没有注意到，我们的复现问题的程序里 argv[2] 的值其实是一个非静态字符串， 所以也可以通过在 ebpf 程序中读取这个数据的内容来验证， 预期是不做任何修改就可以读取到 argv[2] 这个非静态字符串的内容： 执行新的 bpftrace 命令: sudo bpftrace -e &#39;tracepoint:syscalls:sys_enter_execve{ printf(&#34;%s[%d]: filename: %s, argv[1]: %s, argv[2]: %s\n&#34;, comm, pid, str(args-&gt;filename), str(args-&gt;argv[1]), str(args-&gt;argv[2])); }&#39; 执行 ./reproduce bpftrace 命令的输出示例如下: bash[36523]: filename: ./reproduce, argv[1]: , argv[2]: reproduce[36524]: filename: , argv[1]: , argv[2]: ./reproduce page fault 在现代 Linux 系统中，当我们运行二进制可执行文件的时候，程序加载器（ELF executable loader） 会根据 ELF 文件中定义的信息使用 mmap 进行懒加载（lazy loading），延迟加载一些数据。 当程序真正去读取这些数据的时候，如果被读取的数据还没有被加载到内存里，就会触发 page fault。 ELF 文件的 .rodata section 中存储的数据恰好就是会被延迟加载的数据。 .rodata ELF 文件中的 .rodata section 存储了一些只读数据，比如静态字符串。 我们首先来看一下编译后的示例程序二进制 ELF 文件中的 .rodata section 的数据。 可以使用 objdump 命令进行查看: $ objdump -s -j .rodata ./reproduce ./reproduce: file format elf64-x86-64 Contents of section .rodata: 2000 01000200 2f757372 2f62696e 2f656368 ..../usr/bin/ech 2010 6f006164 6400 o.add. 也可以使用 python 社区的 pwntools 库进行读取: &gt;&gt;&gt; from pwn import ELF &gt;&gt;&gt; elf = ELF(&#39;reproduce&#39;) &gt;&gt;&gt; elf.section(&#39;.rodata&#39;) b&#39;\x01\x00\x02\x00/usr/bin/echo\x00add\x00&#39; 从上面的输出中可以看到其中包含了源码中使用的两个静态字符串。 观测 page fault 在 Linux 系统中，当内核执行 execve() 系统调用时， 会使用内核函数 strncpy_from_user 将 argv 中包含的字符串数据从用户态复制到内核态， 这个过程涉及读取用户态数据的操作。 如果被读取的用户态数据还未被加载到内存中，就会触发 page fault。 我们可以通过观测 exceptions/page_fault_kernel 和 exceptions/page_fault_user 感知到这个事件: 为了方便验证，我们需要先修改一下示例代码，在执行 execv() 函数前增加一行 sleep(15) ，避免程序太快结束 （reproduce_sleep.c ） if (!fork()) { sleep(15); execv(args[0], (char *const *) args); } 在一个终端中运行下面这个 bpftrace 脚本，观测 page fault: cat &lt;&lt;EOF | sudo bpftrace - tracepoint:exceptions:page_fault_kernel /comm == &#34;reproduce_sleep&#34;/ { printf(&#34;[%s] page_fault_kernel: %s[%d] addr=%llx ip=%llx err=%lld\n&#34;, strftime(&#34;%M:%S&#34;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code); } tracepoint:exceptions:page_fault_user /comm == &#34;reproduce_sleep&#34;/ { printf(&#34;[%s] page_fault_user: %s[%d] addr=%llx ip=%llx err=%lld\n&#34;, strftime(&#34;%M:%S&#34;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code); } EOF 然后在另一个终端中运行 ./reproduce_sleep 在第3个终端中查看运行中的 reproduce_sleep 进程的内存映射关系（memory mapping）: $ sudo cat /proc/41291/maps | grep reproduce_sleep 55b4d9e31000-55b4d9e32000 r--p 00000000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e32000-55b4d9e33000 r-xp 00001000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e33000-55b4d9e34000 r--p 00002000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e34000-55b4d9e35000 r--p 00002000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e35000-55b4d9e36000 rw-p 00003000 08:01 1634479 /XXX/reproduce_sleep 由上面可知，该进程的内存映射起始地址是 55b4d9e31000 ，即 0x55b4d9e31000 待示例程序运行结束后，bpftrace 命令的输出中的最后两条数据将类似下面这样: [47:40] page_fault_user: reproduce_sleep[41290] addr=7f669db86a50 ip=7f669d9f8940 err=7 [47:55] page_fault_kernel: reproduce_sleep[41291] addr=55b4d9e33004 ip=ffffffff8e092a40 err=0 这两个输出间隔了 15 秒，由此可以确定最后那个 page fault 事件是执行 execv() 函数的时候触发的。 下面来通过事件中的 addr 结果定位对应的数据。 上面最后那条 page_fault_kernel 事件输出的 addr 的值是 55b4d9e33004 ， 即触发这个 page fault 事件的虚拟内存地址是 0x55b4d9e33004 。 基于 @jschwinger233 分享的秘籍： real_addr = start_addr + (elf_address - section.Address + section.Offset) 可知: 0x55b4d9e33004 = 0x55b4d9e31000 + (elf_address - section.Address + section.Offset) (elf_address - section.Address + section.Offset) = 0x55b4d9e33004 - 0x55b4d9e31000 = 8196 = 0x2004 使用 readelf 命令读取二进制文件 reproduce_sleep 中 ELF .rodata section 的内存地址、偏移量以及数据大小: $ readelf -S -W reproduce_sleep | egrep &#39;.rodata|Address&#39; [Nr] Name Type Address Off Size ES Flg Lk Inf Al [18] .rodata PROGBITS 0000000000002000 002000 000016 00 A 0 0 4 由上面的输出可知，该 ELF 文件中 .rodata section 的虚拟地址是 0000000000002000 即 0x2000 ， 偏移量是 002000 即 0x2000 ， 数据大小是 0x16 ，即地址范围是 0x2000-0x2016 。 通过 7 和 8 可知，执行 execv() 函数时触发的 page fault 事件的虚拟内存地址 0x55b4d9e33004 对应的 ELF 地址是 0x2004 ，这个地址在 ELF 文件的 .rodata 地址范围（0x2000-0x2016）内， 对应的是 argv[0] 中使用的静态字符串 /usr/bin/echo: $ objdump -s -j .rodata ./reproduce_sleep ./reproduce_sleep: file format elf64-x86-64 Contents of section .rodata: 2000 01000200 2f757372 2f62696e 2f656368 ..../usr/bin/ech 2010 6f006164 6400 o.add. &gt;&gt;&gt; elf = ELF(&#39;reproduce_sleep&#39;) &gt;&gt;&gt; elf.read(0x2004, 14) b&#39;/usr/bin/echo\x00&#39; $ gdb -ex &#39;disas/m main&#39; -ex q reproduce_sleep | grep &#39;args\[\]&#39; -A 13 9 const char *const args[] = { 0x00000000000011d6 &lt;+45&gt;: lea 0xe27(%rip),%rax # 0x2004 0x00000000000011dd &lt;+52&gt;: mov %rax,-0x30(%rbp) 0x00000000000011e1 &lt;+56&gt;: lea 0xe2a(%rip),%rax # 0x2012 0x00000000000011e8 &lt;+63&gt;: mov %rax,-0x28(%rbp) 0x00000000000011ec &lt;+67&gt;: mov -0x38(%rbp),%rax 0x00000000000011f0 &lt;+71&gt;: mov %rax,-0x20(%rbp) 0x00000000000011f4 &lt;+75&gt;: movq $0x0,-0x18(%rbp) 10 PATHNAME, 11 &#34;add&#34;, 12 hostname, 13 0 14 }; 也可以通过在 ebpf 程序或 bpftrace 脚本中打印 args-&gt;filename 的指针地址来确认， 这个地址的值会跟前面 page fault 事件中 addr 的值一致，都是 0x55b4d9e33004 tracepoint:syscalls:sys_enter_execve { printf(&#34;%s[%d]: %p\n&#34;, comm, pid, args-&gt;filename); } BTW，可以通过 perf trace -F all 命令追踪触发 page fault 事件的函数信息。 解决方法 解决这个问题的方法有很多，其中一种解决方法是改为通过追踪 tracepoint/sched/sched_process_exec 事件来获取 execve() 系统调用中 filename 和 argv 参数的值。下面是对应实现的示例程序： 通过 bpftrace 追踪 tracepoint/sched/sched_process_exec 事件的示例脚本（来自 @jschwinger233 ）: tracepoint:sched:sched_process_exec { $task=curtask; $arg_start=$task-&gt;mm-&gt;arg_start; $arg_end=$task-&gt;mm-&gt;arg_end; printf(&#34;%s[%d]: filename: %s, argv: %r\n&#34;, comm, pid, str(args-&gt;filename), buf(uptr($arg_start), $arg_end-$arg_start)); } 通过 ebpf c 代码追踪 tracepoint/sched/sched_process_exec 事件的示例程序： main.bpf.c 参考资料 tmux/tmux: tmux source code Can&#39;t trace sys_execve inside a c program · Issue #2523 · bpftrace/bpftrace ELF - OSDev Wiki unix - Why an ELF executable could have 4 LOAD segments? - Stack Overflow strncpy_from_user @jschwinger233 的谆谆教诲" />

    <style>
      .js-toc {
        margin-bottom: 20px;
      }
      .donate-modal {
        text-align: center;
      }
      #donate-modal-container .donate-image {
        max-height: 300px !important;
        min-height: inherit !important;
      }
    </style>

        <meta property="og:site_name" content="mozillazg's Blog" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="一个使用 tracepoint 追踪 execve 系统调用时无法正确获取系统调用参数的场景"/>
        <meta property="og:url" content="https://mozillazg.com/2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case.html"/>
        <meta property="og:description" content="背景 前段时间有网友在 slack 上的 ebpf 频道 中咨询一个他遇到的问题： 在编写使用 tracepoint/syscalls/sys_enter_execve 追踪 execve 系统调用的 ebpf 程序时， 遇到了记录的部分事件中存在使用 bpf_probe_read_user_str 读取 execve 的 filename 参数失败的现象，错误码为 -14/EFAULT。 尤其是在执行 tmux 命令的时候，必定会伴随一个读取失败的事件: ret = bpf_probe_read_user_str(event-&gt;args, ARGSIZE, (const char*)ctx-&gt;args[0]); if (ret &lt; 0) { bpf_printk(&#34;comm=%s XXX cannot read file name&#34;, tgid, pid, event-&gt;comm); return 0; } utempter-4031732 [027] d...1 3878624.643948: bpf_trace_printk: comm=tmux: server XXX cannot read file name &lt;...&gt;-4035723 [077] d...1 3878668.047954: bpf_trace_printk: comm=tmux: server XXX cannot read file name 本文将探讨一下该问题出现的原因以及针对该场景的一种解决方法。 复现问题的代码 因为问题中提到只要执行 tmux 命令就必定会复现该问题，并且我们在 bpf_printk 的输出中看到对应事件的进程名称为 utempter ， 因此，我们可以基于这两点信息来尝试编写一个简单的复现问题的程序。 通过在网络上查找 tmux 与 utempter 的关联关系，以及阅读了相关的 tmux 源代码后，我了解到了如下信息： tmux 会调用 utempter.h 提供的 utempter_add_record 函数创建所需的伪终端（pseudo-terminal）: xasprintf(&amp;cp, &#34;tmux(%lu).%%%u&#34;, (long)getpid(), new_wp-&gt;id); utempter_add_record(new_wp-&gt;fd, cp); utempter_add_record 函数中会首先使用传入的参数构造一个 args 然后调用 execute_helper 函数: #define UTEMPTER_DEFAULT_PATHNAME LIBEXECDIR &#34;/utempter/utempter&#34; static const char *utempter_pathname; int utempter_add_record(int master_fd, const char *hostname) { const char *const args[] = { utempter_pathname ? : UTEMPTER_DEFAULT_PATHNAME, &#34;add&#34;, hostname, 0 }; int status = execute_helper(master_fd, args); // ... } execute_helper 函数中最终会使用传入的 args 调用 fork() 和 execv() 函数启动一个新的进程 （ 源代码 ）: static int execute_helper(int master_fd, const char *const argv[]) { // ... child = fork(); if (!child) { do_child(master_fd, argv[0], (char *const *) argv); } else if (child &lt; 0) { // ... } static void __attribute__((__noreturn__)) do_child(int master_fd, const char *path, char *const *argv) { // ... execv(path, argv); print_dbg(&#34;execv: %s&#34;, strerror(errno)); //... } 根据上面这些信息，我们可以编写如下这个可复现该问题的程序 reproduce.c: #define PATHNAME &#34;/usr/bin/echo&#34; int main(int argc, char **argv) { const char *hostname = argv[0]; const char *const args[] = { PATHNAME, &#34;add&#34;, hostname, 0 }; if (!fork()) { execv(args[0], (char *const *) args); } } 下面测试一下这个程序的效果: 使用 gcc 编译: gcc -o reproduce reproduce.c 在另一个终端使用 bpftrace 追踪 tracepoint/syscalls/sys_enter_execve 事件: sudo bpftrace -e &#39;tracepoint:syscalls:sys_enter_execve{printf(&#34;%s[%d]: %s\n&#34;, comm, pid, str(args-&gt;filename));}&#39; 运行示例程序: ./reproduce 此时，运行 bpftrace 的终端将输出类似下面这样的结果: bash[34882]: ./reproduce reproduce[34883]: 在上面结果中，我们没有获取到 reproduce 进程执行 execve() 系统调用时使用的 filename 参数的值。 由此可见，我们的这个程序复现了最初的问题。 原因 经 @ssfdust 提醒，bpftrace 社区之前已经有人提过类似的问题： #2523 。 在这个 issue 中 @fbs 给出的 解释 是： Like I said earlier, the data you&#39;re using isn&#39;t in memory yet. These static strings are compiled in and are not actually faulted into memory until they&#39;re accessed. The access won&#39;t happen until its read, which is after your bpftrace probe ran. BPF won&#39;t pull the data in so you get an EFAULT/-14. By printing the values or just a random print of a constant string you pull the small amount of data into memory (as it goes by page, not by var) and then it works 即： 示例程序中，执行 execve() 时传入的 argv[0] 指向的文件名称字符串是一个静态字符串 （这些静态字符串在程序被编译后存储在 ELF（Executable and Linkable Format） 文件的 .rodata section）， 这些字符串只会在程序真正去访问他们的时候（访问 .rodata section 存储的数据时）才会被加载到内存中。 由1可知，示例程序中 argv[0] 指向的静态字符串只会在执行 execve() 系统调用的时候被读取到内存中， 但是我们的 ebpf 程序其实是在执行 execve() 系统调用之前被执行的，因此 ebpf 程序里使用 bpf_probe_read_user_str 读取 argv[0] 会失败并返回 EFAULT/-14 。 通过 printf 等方式主动将字符串加载到内存中可以让该问题消失。 来自 @jschwinger233 的总结： bpf_probe_read_user 只能读到已经载入内存 (page-faulted into memory) 的数据， 而上面代码直到 execve(2) 之时都还未读过 .rodata，未曾触发 page fault。 这可以用 tracepoint:exceptions:page_fault* 来验证。 验证 增加 printf 由上面可知，其实我们只需要修改程序在执行 execve() 之前主动将 .rodata 中的数据加载到内存中即可避免该问题， 比如使用 printf 函数。 即，可以使用 printf 函数打印 argv[0] ，也可以直接打印一个静态字符串: if (!fork()) { printf(&#34;test\n&#34;); // or // printf(&#34;argv[0]: %s\n&#34;, args[0]); execv(args[0], (char *const *) args); } 经验证，修改后的程序 reproduce_printf1.c 确实可以让 ebpf 程序正确读取到 filename 的值。 不使用静态字符串 既然是因为 argv[0] 是静态字符串导致的问题，那么可以尝试将 argv[0] 改为使用非静态字符串，看看问题是否还存在。 修改的内容如下: const char *const args[] = { argv[1], &#34;add&#34;, hostname, 0 }; 经验证，修改后的程序 reproduce_non_static.c 也可以让 ebpf 程序正确读取到 filename 的值。 不知道大家有没有注意到，我们的复现问题的程序里 argv[2] 的值其实是一个非静态字符串， 所以也可以通过在 ebpf 程序中读取这个数据的内容来验证， 预期是不做任何修改就可以读取到 argv[2] 这个非静态字符串的内容： 执行新的 bpftrace 命令: sudo bpftrace -e &#39;tracepoint:syscalls:sys_enter_execve{ printf(&#34;%s[%d]: filename: %s, argv[1]: %s, argv[2]: %s\n&#34;, comm, pid, str(args-&gt;filename), str(args-&gt;argv[1]), str(args-&gt;argv[2])); }&#39; 执行 ./reproduce bpftrace 命令的输出示例如下: bash[36523]: filename: ./reproduce, argv[1]: , argv[2]: reproduce[36524]: filename: , argv[1]: , argv[2]: ./reproduce page fault 在现代 Linux 系统中，当我们运行二进制可执行文件的时候，程序加载器（ELF executable loader） 会根据 ELF 文件中定义的信息使用 mmap 进行懒加载（lazy loading），延迟加载一些数据。 当程序真正去读取这些数据的时候，如果被读取的数据还没有被加载到内存里，就会触发 page fault。 ELF 文件的 .rodata section 中存储的数据恰好就是会被延迟加载的数据。 .rodata ELF 文件中的 .rodata section 存储了一些只读数据，比如静态字符串。 我们首先来看一下编译后的示例程序二进制 ELF 文件中的 .rodata section 的数据。 可以使用 objdump 命令进行查看: $ objdump -s -j .rodata ./reproduce ./reproduce: file format elf64-x86-64 Contents of section .rodata: 2000 01000200 2f757372 2f62696e 2f656368 ..../usr/bin/ech 2010 6f006164 6400 o.add. 也可以使用 python 社区的 pwntools 库进行读取: &gt;&gt;&gt; from pwn import ELF &gt;&gt;&gt; elf = ELF(&#39;reproduce&#39;) &gt;&gt;&gt; elf.section(&#39;.rodata&#39;) b&#39;\x01\x00\x02\x00/usr/bin/echo\x00add\x00&#39; 从上面的输出中可以看到其中包含了源码中使用的两个静态字符串。 观测 page fault 在 Linux 系统中，当内核执行 execve() 系统调用时， 会使用内核函数 strncpy_from_user 将 argv 中包含的字符串数据从用户态复制到内核态， 这个过程涉及读取用户态数据的操作。 如果被读取的用户态数据还未被加载到内存中，就会触发 page fault。 我们可以通过观测 exceptions/page_fault_kernel 和 exceptions/page_fault_user 感知到这个事件: 为了方便验证，我们需要先修改一下示例代码，在执行 execv() 函数前增加一行 sleep(15) ，避免程序太快结束 （reproduce_sleep.c ） if (!fork()) { sleep(15); execv(args[0], (char *const *) args); } 在一个终端中运行下面这个 bpftrace 脚本，观测 page fault: cat &lt;&lt;EOF | sudo bpftrace - tracepoint:exceptions:page_fault_kernel /comm == &#34;reproduce_sleep&#34;/ { printf(&#34;[%s] page_fault_kernel: %s[%d] addr=%llx ip=%llx err=%lld\n&#34;, strftime(&#34;%M:%S&#34;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code); } tracepoint:exceptions:page_fault_user /comm == &#34;reproduce_sleep&#34;/ { printf(&#34;[%s] page_fault_user: %s[%d] addr=%llx ip=%llx err=%lld\n&#34;, strftime(&#34;%M:%S&#34;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code); } EOF 然后在另一个终端中运行 ./reproduce_sleep 在第3个终端中查看运行中的 reproduce_sleep 进程的内存映射关系（memory mapping）: $ sudo cat /proc/41291/maps | grep reproduce_sleep 55b4d9e31000-55b4d9e32000 r--p 00000000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e32000-55b4d9e33000 r-xp 00001000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e33000-55b4d9e34000 r--p 00002000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e34000-55b4d9e35000 r--p 00002000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e35000-55b4d9e36000 rw-p 00003000 08:01 1634479 /XXX/reproduce_sleep 由上面可知，该进程的内存映射起始地址是 55b4d9e31000 ，即 0x55b4d9e31000 待示例程序运行结束后，bpftrace 命令的输出中的最后两条数据将类似下面这样: [47:40] page_fault_user: reproduce_sleep[41290] addr=7f669db86a50 ip=7f669d9f8940 err=7 [47:55] page_fault_kernel: reproduce_sleep[41291] addr=55b4d9e33004 ip=ffffffff8e092a40 err=0 这两个输出间隔了 15 秒，由此可以确定最后那个 page fault 事件是执行 execv() 函数的时候触发的。 下面来通过事件中的 addr 结果定位对应的数据。 上面最后那条 page_fault_kernel 事件输出的 addr 的值是 55b4d9e33004 ， 即触发这个 page fault 事件的虚拟内存地址是 0x55b4d9e33004 。 基于 @jschwinger233 分享的秘籍： real_addr = start_addr + (elf_address - section.Address + section.Offset) 可知: 0x55b4d9e33004 = 0x55b4d9e31000 + (elf_address - section.Address + section.Offset) (elf_address - section.Address + section.Offset) = 0x55b4d9e33004 - 0x55b4d9e31000 = 8196 = 0x2004 使用 readelf 命令读取二进制文件 reproduce_sleep 中 ELF .rodata section 的内存地址、偏移量以及数据大小: $ readelf -S -W reproduce_sleep | egrep &#39;.rodata|Address&#39; [Nr] Name Type Address Off Size ES Flg Lk Inf Al [18] .rodata PROGBITS 0000000000002000 002000 000016 00 A 0 0 4 由上面的输出可知，该 ELF 文件中 .rodata section 的虚拟地址是 0000000000002000 即 0x2000 ， 偏移量是 002000 即 0x2000 ， 数据大小是 0x16 ，即地址范围是 0x2000-0x2016 。 通过 7 和 8 可知，执行 execv() 函数时触发的 page fault 事件的虚拟内存地址 0x55b4d9e33004 对应的 ELF 地址是 0x2004 ，这个地址在 ELF 文件的 .rodata 地址范围（0x2000-0x2016）内， 对应的是 argv[0] 中使用的静态字符串 /usr/bin/echo: $ objdump -s -j .rodata ./reproduce_sleep ./reproduce_sleep: file format elf64-x86-64 Contents of section .rodata: 2000 01000200 2f757372 2f62696e 2f656368 ..../usr/bin/ech 2010 6f006164 6400 o.add. &gt;&gt;&gt; elf = ELF(&#39;reproduce_sleep&#39;) &gt;&gt;&gt; elf.read(0x2004, 14) b&#39;/usr/bin/echo\x00&#39; $ gdb -ex &#39;disas/m main&#39; -ex q reproduce_sleep | grep &#39;args\[\]&#39; -A 13 9 const char *const args[] = { 0x00000000000011d6 &lt;+45&gt;: lea 0xe27(%rip),%rax # 0x2004 0x00000000000011dd &lt;+52&gt;: mov %rax,-0x30(%rbp) 0x00000000000011e1 &lt;+56&gt;: lea 0xe2a(%rip),%rax # 0x2012 0x00000000000011e8 &lt;+63&gt;: mov %rax,-0x28(%rbp) 0x00000000000011ec &lt;+67&gt;: mov -0x38(%rbp),%rax 0x00000000000011f0 &lt;+71&gt;: mov %rax,-0x20(%rbp) 0x00000000000011f4 &lt;+75&gt;: movq $0x0,-0x18(%rbp) 10 PATHNAME, 11 &#34;add&#34;, 12 hostname, 13 0 14 }; 也可以通过在 ebpf 程序或 bpftrace 脚本中打印 args-&gt;filename 的指针地址来确认， 这个地址的值会跟前面 page fault 事件中 addr 的值一致，都是 0x55b4d9e33004 tracepoint:syscalls:sys_enter_execve { printf(&#34;%s[%d]: %p\n&#34;, comm, pid, args-&gt;filename); } BTW，可以通过 perf trace -F all 命令追踪触发 page fault 事件的函数信息。 解决方法 解决这个问题的方法有很多，其中一种解决方法是改为通过追踪 tracepoint/sched/sched_process_exec 事件来获取 execve() 系统调用中 filename 和 argv 参数的值。下面是对应实现的示例程序： 通过 bpftrace 追踪 tracepoint/sched/sched_process_exec 事件的示例脚本（来自 @jschwinger233 ）: tracepoint:sched:sched_process_exec { $task=curtask; $arg_start=$task-&gt;mm-&gt;arg_start; $arg_end=$task-&gt;mm-&gt;arg_end; printf(&#34;%s[%d]: filename: %s, argv: %r\n&#34;, comm, pid, str(args-&gt;filename), buf(uptr($arg_start), $arg_end-$arg_start)); } 通过 ebpf c 代码追踪 tracepoint/sched/sched_process_exec 事件的示例程序： main.bpf.c 参考资料 tmux/tmux: tmux source code Can&#39;t trace sys_execve inside a c program · Issue #2523 · bpftrace/bpftrace ELF - OSDev Wiki unix - Why an ELF executable could have 4 LOAD segments? - Stack Overflow strncpy_from_user @jschwinger233 的谆谆教诲"/>
        <meta property="article:published_time" content="2024-03-31" />
            <meta property="article:section" content="ebpf" />
            <meta property="article:tag" content="ebpf" />
            <meta property="article:tag" content="tracepoint" />
            <meta property="article:tag" content="bpftrace" />
            <meta property="article:tag" content="ELF" />
            <meta property="article:author" content="mozillazg" />
            <meta property="og:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>


    <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@mozillazg">
        <meta name="twitter:creator" content="@mozillazg">
    <meta name="twitter:domain" content="https://mozillazg.com">
            <meta property="twitter:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="/theme/cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/css/bootstrap.min.css" type="text/css"/>
    <link href="/theme/cdn.jsdelivr.net/npm/font-awesome@4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link href="/theme/cdn.jsdelivr.net/npm/pygments-css@1.0.0/github.css" rel="stylesheet">
    <link rel="stylesheet" href="https://mozillazg.com/theme/css/style.css" type="text/css"/>
            <link href="/static/han.min.css" rel="stylesheet">
            <link href="/static/yue.css" rel="stylesheet">
            <link href="/static/custom.css" rel="stylesheet">

        <link href="https://mozillazg.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog ATOM Feed"/>

        <link href="https://mozillazg.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="mozillazg's Blog RSS Feed"/>


        <link href="https://mozillazg.com/feeds/ebpf.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog ebpf ATOM Feed"/>


    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "publisher": {
            "@type": "Person",
            "name": "mozillazg",
            "logo": "https://mozillazg.com/static/avatar.jpeg"
        },
        "author": {
            "@type": "Person",
            "name": "mozillazg",
            "image": "https://mozillazg.com/static/avatar.jpeg",
            "url": "https://mozillazg.com",
            "sameAs": []
        },
        "headline": "一个使用 tracepoint 追踪 execve 系统调用时无法正确获取系统调用参数的场景",
        "url": "https://mozillazg.com/2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case.html",
        "image": [
            "https://mozillazg.com/static/avatar.jpeg"
         ],
        "keywords": "ebpf, tracepoint, bpftrace, ELF",
        "description": "背景 前段时间有网友在 slack 上的 ebpf 频道 中咨询一个他遇到的问题： 在编写使用 tracepoint/syscalls/sys_enter_execve 追踪 execve 系统调用的 ebpf 程序时， 遇到了记录的部分事件中存在使用 bpf_probe_read_user_str 读取 execve 的 filename 参数失败的现象，错误码为 -14/EFAULT。 尤其是在执行 tmux 命令的时候，必定会伴随一个读取失败的事件: ret = bpf_probe_read_user_str(event-&gt;args, ARGSIZE, (const char*)ctx-&gt;args[0]); if (ret &lt; 0) { bpf_printk(&#34;comm=%s XXX cannot read file name&#34;, tgid, pid, event-&gt;comm); return 0; } utempter-4031732 [027] d...1 3878624.643948: bpf_trace_printk: comm=tmux: server XXX cannot read file name &lt;...&gt;-4035723 [077] d...1 3878668.047954: bpf_trace_printk: comm=tmux: server XXX cannot read file name 本文将探讨一下该问题出现的原因以及针对该场景的一种解决方法。 复现问题的代码 因为问题中提到只要执行 tmux 命令就必定会复现该问题，并且我们在 bpf_printk 的输出中看到对应事件的进程名称为 utempter ， 因此，我们可以基于这两点信息来尝试编写一个简单的复现问题的程序。 通过在网络上查找 tmux 与 utempter 的关联关系，以及阅读了相关的 tmux 源代码后，我了解到了如下信息： tmux 会调用 utempter.h 提供的 utempter_add_record 函数创建所需的伪终端（pseudo-terminal）: xasprintf(&amp;cp, &#34;tmux(%lu).%%%u&#34;, (long)getpid(), new_wp-&gt;id); utempter_add_record(new_wp-&gt;fd, cp); utempter_add_record 函数中会首先使用传入的参数构造一个 args 然后调用 execute_helper 函数: #define UTEMPTER_DEFAULT_PATHNAME LIBEXECDIR &#34;/utempter/utempter&#34; static const char *utempter_pathname; int utempter_add_record(int master_fd, const char *hostname) { const char *const args[] = { utempter_pathname ? : UTEMPTER_DEFAULT_PATHNAME, &#34;add&#34;, hostname, 0 }; int status = execute_helper(master_fd, args); // ... } execute_helper 函数中最终会使用传入的 args 调用 fork() 和 execv() 函数启动一个新的进程 （ 源代码 ）: static int execute_helper(int master_fd, const char *const argv[]) { // ... child = fork(); if (!child) { do_child(master_fd, argv[0], (char *const *) argv); } else if (child &lt; 0) { // ... } static void __attribute__((__noreturn__)) do_child(int master_fd, const char *path, char *const *argv) { // ... execv(path, argv); print_dbg(&#34;execv: %s&#34;, strerror(errno)); //... } 根据上面这些信息，我们可以编写如下这个可复现该问题的程序 reproduce.c: #define PATHNAME &#34;/usr/bin/echo&#34; int main(int argc, char **argv) { const char *hostname = argv[0]; const char *const args[] = { PATHNAME, &#34;add&#34;, hostname, 0 }; if (!fork()) { execv(args[0], (char *const *) args); } } 下面测试一下这个程序的效果: 使用 gcc 编译: gcc -o reproduce reproduce.c 在另一个终端使用 bpftrace 追踪 tracepoint/syscalls/sys_enter_execve 事件: sudo bpftrace -e &#39;tracepoint:syscalls:sys_enter_execve{printf(&#34;%s[%d]: %s\\n&#34;, comm, pid, str(args-&gt;filename));}&#39; 运行示例程序: ./reproduce 此时，运行 bpftrace 的终端将输出类似下面这样的结果: bash[34882]: ./reproduce reproduce[34883]: 在上面结果中，我们没有获取到 reproduce 进程执行 execve() 系统调用时使用的 filename 参数的值。 由此可见，我们的这个程序复现了最初的问题。 原因 经 @ssfdust 提醒，bpftrace 社区之前已经有人提过类似的问题： #2523 。 在这个 issue 中 @fbs 给出的 解释 是： Like I said earlier, the data you&#39;re using isn&#39;t in memory yet. These static strings are compiled in and are not actually faulted into memory until they&#39;re accessed. The access won&#39;t happen until its read, which is after your bpftrace probe ran. BPF won&#39;t pull the data in so you get an EFAULT/-14. By printing the values or just a random print of a constant string you pull the small amount of data into memory (as it goes by page, not by var) and then it works 即： 示例程序中，执行 execve() 时传入的 argv[0] 指向的文件名称字符串是一个静态字符串 （这些静态字符串在程序被编译后存储在 ELF（Executable and Linkable Format） 文件的 .rodata section）， 这些字符串只会在程序真正去访问他们的时候（访问 .rodata section 存储的数据时）才会被加载到内存中。 由1可知，示例程序中 argv[0] 指向的静态字符串只会在执行 execve() 系统调用的时候被读取到内存中， 但是我们的 ebpf 程序其实是在执行 execve() 系统调用之前被执行的，因此 ebpf 程序里使用 bpf_probe_read_user_str 读取 argv[0] 会失败并返回 EFAULT/-14 。 通过 printf 等方式主动将字符串加载到内存中可以让该问题消失。 来自 @jschwinger233 的总结： bpf_probe_read_user 只能读到已经载入内存 (page-faulted into memory) 的数据， 而上面代码直到 execve(2) 之时都还未读过 .rodata，未曾触发 page fault。 这可以用 tracepoint:exceptions:page_fault* 来验证。 验证 增加 printf 由上面可知，其实我们只需要修改程序在执行 execve() 之前主动将 .rodata 中的数据加载到内存中即可避免该问题， 比如使用 printf 函数。 即，可以使用 printf 函数打印 argv[0] ，也可以直接打印一个静态字符串: if (!fork()) { printf(&#34;test\\n&#34;); // or // printf(&#34;argv[0]: %s\\n&#34;, args[0]); execv(args[0], (char *const *) args); } 经验证，修改后的程序 reproduce_printf1.c 确实可以让 ebpf 程序正确读取到 filename 的值。 不使用静态字符串 既然是因为 argv[0] 是静态字符串导致的问题，那么可以尝试将 argv[0] 改为使用非静态字符串，看看问题是否还存在。 修改的内容如下: const char *const args[] = { argv[1], &#34;add&#34;, hostname, 0 }; 经验证，修改后的程序 reproduce_non_static.c 也可以让 ebpf 程序正确读取到 filename 的值。 不知道大家有没有注意到，我们的复现问题的程序里 argv[2] 的值其实是一个非静态字符串， 所以也可以通过在 ebpf 程序中读取这个数据的内容来验证， 预期是不做任何修改就可以读取到 argv[2] 这个非静态字符串的内容： 执行新的 bpftrace 命令: sudo bpftrace -e &#39;tracepoint:syscalls:sys_enter_execve{ printf(&#34;%s[%d]: filename: %s, argv[1]: %s, argv[2]: %s\\n&#34;, comm, pid, str(args-&gt;filename), str(args-&gt;argv[1]), str(args-&gt;argv[2])); }&#39; 执行 ./reproduce bpftrace 命令的输出示例如下: bash[36523]: filename: ./reproduce, argv[1]: , argv[2]: reproduce[36524]: filename: , argv[1]: , argv[2]: ./reproduce page fault 在现代 Linux 系统中，当我们运行二进制可执行文件的时候，程序加载器（ELF executable loader） 会根据 ELF 文件中定义的信息使用 mmap 进行懒加载（lazy loading），延迟加载一些数据。 当程序真正去读取这些数据的时候，如果被读取的数据还没有被加载到内存里，就会触发 page fault。 ELF 文件的 .rodata section 中存储的数据恰好就是会被延迟加载的数据。 .rodata ELF 文件中的 .rodata section 存储了一些只读数据，比如静态字符串。 我们首先来看一下编译后的示例程序二进制 ELF 文件中的 .rodata section 的数据。 可以使用 objdump 命令进行查看: $ objdump -s -j .rodata ./reproduce ./reproduce: file format elf64-x86-64 Contents of section .rodata: 2000 01000200 2f757372 2f62696e 2f656368 ..../usr/bin/ech 2010 6f006164 6400 o.add. 也可以使用 python 社区的 pwntools 库进行读取: &gt;&gt;&gt; from pwn import ELF &gt;&gt;&gt; elf = ELF(&#39;reproduce&#39;) &gt;&gt;&gt; elf.section(&#39;.rodata&#39;) b&#39;\\x01\\x00\\x02\\x00/usr/bin/echo\\x00add\\x00&#39; 从上面的输出中可以看到其中包含了源码中使用的两个静态字符串。 观测 page fault 在 Linux 系统中，当内核执行 execve() 系统调用时， 会使用内核函数 strncpy_from_user 将 argv 中包含的字符串数据从用户态复制到内核态， 这个过程涉及读取用户态数据的操作。 如果被读取的用户态数据还未被加载到内存中，就会触发 page fault。 我们可以通过观测 exceptions/page_fault_kernel 和 exceptions/page_fault_user 感知到这个事件: 为了方便验证，我们需要先修改一下示例代码，在执行 execv() 函数前增加一行 sleep(15) ，避免程序太快结束 （reproduce_sleep.c ） if (!fork()) { sleep(15); execv(args[0], (char *const *) args); } 在一个终端中运行下面这个 bpftrace 脚本，观测 page fault: cat &lt;&lt;EOF | sudo bpftrace - tracepoint:exceptions:page_fault_kernel /comm == &#34;reproduce_sleep&#34;/ { printf(&#34;[%s] page_fault_kernel: %s[%d] addr=%llx ip=%llx err=%lld\\n&#34;, strftime(&#34;%M:%S&#34;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code); } tracepoint:exceptions:page_fault_user /comm == &#34;reproduce_sleep&#34;/ { printf(&#34;[%s] page_fault_user: %s[%d] addr=%llx ip=%llx err=%lld\\n&#34;, strftime(&#34;%M:%S&#34;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code); } EOF 然后在另一个终端中运行 ./reproduce_sleep 在第3个终端中查看运行中的 reproduce_sleep 进程的内存映射关系（memory mapping）: $ sudo cat /proc/41291/maps | grep reproduce_sleep 55b4d9e31000-55b4d9e32000 r--p 00000000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e32000-55b4d9e33000 r-xp 00001000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e33000-55b4d9e34000 r--p 00002000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e34000-55b4d9e35000 r--p 00002000 08:01 1634479 /XXX/reproduce_sleep 55b4d9e35000-55b4d9e36000 rw-p 00003000 08:01 1634479 /XXX/reproduce_sleep 由上面可知，该进程的内存映射起始地址是 55b4d9e31000 ，即 0x55b4d9e31000 待示例程序运行结束后，bpftrace 命令的输出中的最后两条数据将类似下面这样: [47:40] page_fault_user: reproduce_sleep[41290] addr=7f669db86a50 ip=7f669d9f8940 err=7 [47:55] page_fault_kernel: reproduce_sleep[41291] addr=55b4d9e33004 ip=ffffffff8e092a40 err=0 这两个输出间隔了 15 秒，由此可以确定最后那个 page fault 事件是执行 execv() 函数的时候触发的。 下面来通过事件中的 addr 结果定位对应的数据。 上面最后那条 page_fault_kernel 事件输出的 addr 的值是 55b4d9e33004 ， 即触发这个 page fault 事件的虚拟内存地址是 0x55b4d9e33004 。 基于 @jschwinger233 分享的秘籍： real_addr = start_addr + (elf_address - section.Address + section.Offset) 可知: 0x55b4d9e33004 = 0x55b4d9e31000 + (elf_address - section.Address + section.Offset) (elf_address - section.Address + section.Offset) = 0x55b4d9e33004 - 0x55b4d9e31000 = 8196 = 0x2004 使用 readelf 命令读取二进制文件 reproduce_sleep 中 ELF .rodata section 的内存地址、偏移量以及数据大小: $ readelf -S -W reproduce_sleep | egrep &#39;.rodata|Address&#39; [Nr] Name Type Address Off Size ES Flg Lk Inf Al [18] .rodata PROGBITS 0000000000002000 002000 000016 00 A 0 0 4 由上面的输出可知，该 ELF 文件中 .rodata section 的虚拟地址是 0000000000002000 即 0x2000 ， 偏移量是 002000 即 0x2000 ， 数据大小是 0x16 ，即地址范围是 0x2000-0x2016 。 通过 7 和 8 可知，执行 execv() 函数时触发的 page fault 事件的虚拟内存地址 0x55b4d9e33004 对应的 ELF 地址是 0x2004 ，这个地址在 ELF 文件的 .rodata 地址范围（0x2000-0x2016）内， 对应的是 argv[0] 中使用的静态字符串 /usr/bin/echo: $ objdump -s -j .rodata ./reproduce_sleep ./reproduce_sleep: file format elf64-x86-64 Contents of section .rodata: 2000 01000200 2f757372 2f62696e 2f656368 ..../usr/bin/ech 2010 6f006164 6400 o.add. &gt;&gt;&gt; elf = ELF(&#39;reproduce_sleep&#39;) &gt;&gt;&gt; elf.read(0x2004, 14) b&#39;/usr/bin/echo\\x00&#39; $ gdb -ex &#39;disas/m main&#39; -ex q reproduce_sleep | grep &#39;args\\[\\]&#39; -A 13 9 const char *const args[] = { 0x00000000000011d6 &lt;+45&gt;: lea 0xe27(%rip),%rax # 0x2004 0x00000000000011dd &lt;+52&gt;: mov %rax,-0x30(%rbp) 0x00000000000011e1 &lt;+56&gt;: lea 0xe2a(%rip),%rax # 0x2012 0x00000000000011e8 &lt;+63&gt;: mov %rax,-0x28(%rbp) 0x00000000000011ec &lt;+67&gt;: mov -0x38(%rbp),%rax 0x00000000000011f0 &lt;+71&gt;: mov %rax,-0x20(%rbp) 0x00000000000011f4 &lt;+75&gt;: movq $0x0,-0x18(%rbp) 10 PATHNAME, 11 &#34;add&#34;, 12 hostname, 13 0 14 }; 也可以通过在 ebpf 程序或 bpftrace 脚本中打印 args-&gt;filename 的指针地址来确认， 这个地址的值会跟前面 page fault 事件中 addr 的值一致，都是 0x55b4d9e33004 tracepoint:syscalls:sys_enter_execve { printf(&#34;%s[%d]: %p\\n&#34;, comm, pid, args-&gt;filename); } BTW，可以通过 perf trace -F all 命令追踪触发 page fault 事件的函数信息。 解决方法 解决这个问题的方法有很多，其中一种解决方法是改为通过追踪 tracepoint/sched/sched_process_exec 事件来获取 execve() 系统调用中 filename 和 argv 参数的值。下面是对应实现的示例程序： 通过 bpftrace 追踪 tracepoint/sched/sched_process_exec 事件的示例脚本（来自 @jschwinger233 ）: tracepoint:sched:sched_process_exec { $task=curtask; $arg_start=$task-&gt;mm-&gt;arg_start; $arg_end=$task-&gt;mm-&gt;arg_end; printf(&#34;%s[%d]: filename: %s, argv: %r\\n&#34;, comm, pid, str(args-&gt;filename), buf(uptr($arg_start), $arg_end-$arg_start)); } 通过 ebpf c 代码追踪 tracepoint/sched/sched_process_exec 事件的示例程序： main.bpf.c 参考资料 tmux/tmux: tmux source code Can&#39;t trace sys_execve inside a c program · Issue #2523 · bpftrace/bpftrace ELF - OSDev Wiki unix - Why an ELF executable could have 4 LOAD segments? - Stack Overflow strncpy_from_user @jschwinger233 的谆谆教诲",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "https://mozillazg.com/2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case.html"
        },
        "datePublished": "2024-03-31"
    }
    </script>

</head>
<body>

<div class="navbar" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://mozillazg.com/" class="navbar-brand">
mozillazg's Blog            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="https://mozillazg.com/feeds/all.atom.xml">Feed</a></li>
                    <li><a href="/2014/10/pages/about-me.html">About</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://mozillazg.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content" class="yue">
        <article>
            <header class="text-center">
                <h1>
                    <a href="https://mozillazg.com/2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case.html"
                       rel="bookmark"
                       title="Permalink to 一个使用 tracepoint 追踪 execve 系统调用时无法正确获取系统调用参数的场景">
                        一个使用 tracepoint 追踪 execve 系统调用时无法正确获取系统调用参数的场景
                    </a>
                </h1>
                <p class="published">
                    <time datetime="2024-03-31T00:00:00+00:00">
                    2024-03-31
                    </time>
                </p>
            </header>
            <div class="entry-content">
                <div class="well-sm article-info">
<footer class="post-info">
        <a href="https://mozillazg.com/category/ebpf.html">ebpf</a>


<span class="label label-default hide">Tags</span>
	<a href="https://mozillazg.com/tag/tracepoint.html">tracepoint</a>
        /
	<a href="https://mozillazg.com/tag/bpftrace.html">bpftrace</a>
        /
	<a href="https://mozillazg.com/tag/elf.html">ELF</a>
    
</footer><!-- /.post-info -->                </div>
                <div class="js-toc"></div>
                <div>
                <div class="section" id="section-1">
<h2 id="hidsection-1">背景<a class="headerlink" href="#hidsection-1" title="Permalink to this headline">¶</a></h2>
<p>前段时间有网友在 slack 上的 <a class="reference external" href="https://ebpf.io/slack">ebpf 频道</a>
中咨询一个他遇到的问题：</p>
<!-- `问题 <https://cilium.slack.com/archives/C4XCTGYEM/p1710380136906129?thread_ts=1710284853.310149&cid=C4XCTGYEM>`__ ： -->
<p>在编写使用 <tt class="docutils literal">tracepoint/syscalls/sys_enter_execve</tt> 追踪 execve 系统调用的 ebpf 程序时，
遇到了记录的部分事件中存在使用 <tt class="docutils literal">bpf_probe_read_user_str</tt> 读取
<tt class="docutils literal">execve</tt> 的 <tt class="docutils literal">filename</tt> 参数失败的现象，错误码为 -14/EFAULT。
尤其是在执行 tmux 命令的时候，必定会伴随一个读取失败的事件:</p>
<pre class="literal-block">
ret = bpf_probe_read_user_str(event-&gt;args, ARGSIZE, (const char*)ctx-&gt;args[0]);
if (ret &lt; 0) {
        bpf_printk(&quot;comm=%s XXX cannot read file name&quot;, tgid, pid, event-&gt;comm);
        return 0;
}

utempter-4031732 [027] d...1 3878624.643948: bpf_trace_printk: comm=tmux: server XXX cannot read file name
   &lt;...&gt;-4035723 [077] d...1 3878668.047954: bpf_trace_printk: comm=tmux: server XXX cannot read file name
</pre>
<p>本文将探讨一下该问题出现的原因以及针对该场景的一种解决方法。</p>
</div>
<div class="section" id="section-2">
<h2 id="hidsection-2">复现问题的代码<a class="headerlink" href="#hidsection-2" title="Permalink to this headline">¶</a></h2>
<p>因为问题中提到只要执行 tmux 命令就必定会复现该问题，并且我们在 <tt class="docutils literal">bpf_printk</tt> 的输出中看到对应事件的进程名称为 <tt class="docutils literal">utempter</tt> ，
因此，我们可以基于这两点信息来尝试编写一个简单的复现问题的程序。</p>
<p>通过在网络上查找 tmux 与 utempter 的关联关系，以及阅读了相关的 tmux 源代码后，我了解到了如下信息：</p>
<ol class="arabic">
<li><p class="first">tmux 会调用 <tt class="docutils literal">utempter.h</tt> 提供的
<a class="reference external" href="https://github.com/tmux/tmux/blob/b79e28b2c30e7ef9b1f7ec6233eeb70a1a177231/spawn.c#L473">utempter_add_record</a>
函数创建所需的伪终端（pseudo-terminal）:</p>
<pre class="literal-block">
xasprintf(&amp;cp, &quot;tmux(%lu).%%%u&quot;, (long)getpid(), new_wp-&gt;id);
utempter_add_record(new_wp-&gt;fd, cp);
</pre>
</li>
<li><p class="first"><tt class="docutils literal">utempter_add_record</tt> 函数中会首先使用传入的参数构造一个 <tt class="docutils literal">args</tt> 然后调用
<a class="reference external" href="https://github.com/altlinux/libutempter/blob/9f291816a746292547ac8aaea0c88e16fc2fb29a/libutempter/iface.c#L121">execute_helper</a>
函数:</p>
<pre class="literal-block">
#define UTEMPTER_DEFAULT_PATHNAME     LIBEXECDIR &quot;/utempter/utempter&quot;
static const char *utempter_pathname;

int utempter_add_record(int master_fd, const char *hostname)
  {
      const char *const args[] = {
          utempter_pathname ? : UTEMPTER_DEFAULT_PATHNAME,
          &quot;add&quot;,
          hostname,
          0
      };
      int status = execute_helper(master_fd, args);
      // ...
  }
</pre>
</li>
<li><p class="first"><tt class="docutils literal">execute_helper</tt> 函数中最终会使用传入的 <tt class="docutils literal">args</tt> 调用 <tt class="docutils literal">fork()</tt> 和 <tt class="docutils literal">execv()</tt> 函数启动一个新的进程
（ <a class="reference external" href="https://github.com/altlinux/libutempter/blob/9f291816a746292547ac8aaea0c88e16fc2fb29a/libutempter/iface.c#L84">源代码</a> ）:</p>
<pre class="literal-block">
static int execute_helper(int master_fd, const char *const argv[])
{
    // ...
    child = fork();
    if (!child) {
        do_child(master_fd, argv[0], (char *const *) argv);
    } else if (child &lt; 0) {
    // ...
}
static void __attribute__((__noreturn__))
do_child(int master_fd, const char *path, char *const *argv)
{
    // ...
    execv(path, argv);
    print_dbg(&quot;execv: %s&quot;, strerror(errno));
    //...
}
</pre>
</li>
</ol>
<p>根据上面这些信息，我们可以编写如下这个可复现该问题的程序
<a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce.c">reproduce.c</a>:</p>
<pre class="literal-block">
#define PATHNAME &quot;/usr/bin/echo&quot;

int main(int argc, char **argv) {
    const char *hostname = argv[0];
    const char *const args[] = {
        PATHNAME,
        &quot;add&quot;,
        hostname,
        0
    };
    if (!fork()) {
        execv(args[0], (char *const *) args);
    }
}
</pre>
<p>下面测试一下这个程序的效果:</p>
<ol class="arabic">
<li><p class="first">使用 gcc 编译:</p>
<pre class="literal-block">
gcc -o reproduce reproduce.c
</pre>
</li>
<li><p class="first">在另一个终端使用 <a class="reference external" href="https://github.com/bpftrace/bpftrace">bpftrace</a> 追踪 tracepoint/syscalls/sys_enter_execve 事件:</p>
<pre class="literal-block">
sudo bpftrace -e 'tracepoint:syscalls:sys_enter_execve{printf(&quot;%s[%d]: %s\n&quot;, comm, pid, str(args-&gt;filename));}'
</pre>
</li>
<li><p class="first">运行示例程序:</p>
<pre class="literal-block">
./reproduce
</pre>
</li>
</ol>
<p>此时，运行 bpftrace 的终端将输出类似下面这样的结果:</p>
<pre class="literal-block">
bash[34882]: ./reproduce
reproduce[34883]:
</pre>
<p>在上面结果中，我们没有获取到 reproduce 进程执行 <tt class="docutils literal">execve()</tt> 系统调用时使用的 <tt class="docutils literal">filename</tt> 参数的值。
由此可见，我们的这个程序复现了最初的问题。</p>
</div>
<div class="section" id="section-3">
<h2 id="hidsection-3">原因<a class="headerlink" href="#hidsection-3" title="Permalink to this headline">¶</a></h2>
<p>经 <a class="reference external" href="https://github.com/ssfdust">&#64;ssfdust</a> 提醒，bpftrace 社区之前已经有人提过类似的问题：
<a class="reference external" href="https://github.com/bpftrace/bpftrace/issues/2523">#2523</a> 。
在这个 issue 中 <a class="reference external" href="https://github.com/fbs">&#64;fbs</a>
给出的 <a class="reference external" href="https://github.com/bpftrace/bpftrace/issues/2523#issuecomment-1466936511">解释</a> 是：</p>
<blockquote>
<p>Like I said earlier, the data you're using isn't in memory yet. These static strings are compiled in and are not actually faulted into memory until they're accessed. The access won't happen until its read, which is after your bpftrace probe ran. BPF won't pull the data in so you get an EFAULT/-14.</p>
<p>By printing the values or just a random print of a constant string you pull the small amount of data into memory (as it goes by page, not by var) and then it works</p>
</blockquote>
<p>即：</p>
<ol class="arabic simple">
<li>示例程序中，执行 <tt class="docutils literal">execve()</tt> 时传入的 <tt class="docutils literal">argv[0]</tt> 指向的文件名称字符串是一个静态字符串
（这些静态字符串在程序被编译后存储在 ELF（Executable and Linkable Format） 文件的 <tt class="docutils literal">.rodata</tt> section），
这些字符串只会在程序真正去访问他们的时候（访问 <tt class="docutils literal">.rodata</tt> section 存储的数据时）才会被加载到内存中。</li>
<li>由1可知，示例程序中 <tt class="docutils literal">argv[0]</tt> 指向的静态字符串只会在执行 <tt class="docutils literal">execve()</tt> 系统调用的时候被读取到内存中，
但是我们的 ebpf 程序其实是在执行 <tt class="docutils literal">execve()</tt> 系统调用之前被执行的，因此 ebpf 程序里使用 <tt class="docutils literal">bpf_probe_read_user_str</tt>
读取 <tt class="docutils literal">argv[0]</tt> 会失败并返回 <tt class="docutils literal"><span class="pre">EFAULT/-14</span></tt> 。</li>
<li>通过 <tt class="docutils literal">printf</tt> 等方式主动将字符串加载到内存中可以让该问题消失。</li>
</ol>
<p>来自 <a class="reference external" href="https://github.com/jschwinger233">&#64;jschwinger233</a> 的总结：</p>
<blockquote>
bpf_probe_read_user 只能读到已经载入内存 (page-faulted into memory) 的数据，
而上面代码直到 execve(2) 之时都还未读过 .rodata，未曾触发 page fault。
这可以用 tracepoint:exceptions:page_fault* 来验证。</blockquote>
</div>
<div class="section" id="section-4">
<h2 id="hidsection-4">验证<a class="headerlink" href="#hidsection-4" title="Permalink to this headline">¶</a></h2>
<div class="section" id="printf">
<h3 id="hidprintf">增加 printf<a class="headerlink" href="#hidprintf" title="Permalink to this headline">¶</a></h3>
<p>由上面可知，其实我们只需要修改程序在执行 <tt class="docutils literal">execve()</tt> 之前主动将 <tt class="docutils literal">.rodata</tt> 中的数据加载到内存中即可避免该问题，
比如使用 <tt class="docutils literal">printf</tt> 函数。</p>
<p>即，可以使用 <tt class="docutils literal">printf</tt> 函数打印 <tt class="docutils literal">argv[0]</tt> ，也可以直接打印一个静态字符串:</p>
<pre class="literal-block">
if (!fork()) {
    printf(&quot;test\n&quot;);
    // or
    // printf(&quot;argv[0]: %s\n&quot;, args[0]);
    execv(args[0], (char *const *) args);
}
</pre>
<p>经验证，修改后的程序
<a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce_printf1.c">reproduce_printf1.c</a>
确实可以让 ebpf 程序正确读取到 filename 的值。</p>
</div>
<div class="section" id="section-5">
<h3 id="hidsection-5">不使用静态字符串<a class="headerlink" href="#hidsection-5" title="Permalink to this headline">¶</a></h3>
<p>既然是因为 <tt class="docutils literal">argv[0]</tt> 是静态字符串导致的问题，那么可以尝试将 <tt class="docutils literal">argv[0]</tt> 改为使用非静态字符串，看看问题是否还存在。
修改的内容如下:</p>
<pre class="literal-block">
const char *const args[] = {
    argv[1],
    &quot;add&quot;,
    hostname,
    0
};
</pre>
<p>经验证，修改后的程序
<a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce_non_static.c">reproduce_non_static.c</a>
也可以让 ebpf 程序正确读取到 filename 的值。</p>
<p>不知道大家有没有注意到，我们的复现问题的程序里 <tt class="docutils literal">argv[2]</tt> 的值其实是一个非静态字符串，
所以也可以通过在 ebpf 程序中读取这个数据的内容来验证，
预期是不做任何修改就可以读取到 <tt class="docutils literal">argv[2]</tt> 这个非静态字符串的内容：</p>
<ol class="arabic">
<li><p class="first">执行新的 bpftrace 命令:</p>
<pre class="literal-block">
sudo bpftrace -e 'tracepoint:syscalls:sys_enter_execve{
    printf(&quot;%s[%d]: filename: %s, argv[1]: %s, argv[2]: %s\n&quot;, comm, pid, str(args-&gt;filename), str(args-&gt;argv[1]), str(args-&gt;argv[2]));
}'
</pre>
</li>
<li><p class="first">执行 <tt class="docutils literal">./reproduce</tt></p>
</li>
<li><p class="first">bpftrace 命令的输出示例如下:</p>
<pre class="literal-block">
bash[36523]: filename: ./reproduce, argv[1]: , argv[2]:
reproduce[36524]: filename: , argv[1]: , argv[2]: ./reproduce
</pre>
</li>
</ol>
</div>
<div class="section" id="page-fault">
<h3 id="hidpage-fault">page fault<a class="headerlink" href="#hidpage-fault" title="Permalink to this headline">¶</a></h3>
<p>在现代 Linux 系统中，当我们运行二进制可执行文件的时候，程序加载器（ELF executable loader）
会根据 ELF 文件中定义的信息使用 <tt class="docutils literal">mmap</tt> 进行懒加载（lazy loading），延迟加载一些数据。
当程序真正去读取这些数据的时候，如果被读取的数据还没有被加载到内存里，就会触发 page fault。</p>
<!-- CPU 就会生成一个缺页异常（page fault exception）。此时，内核中的缺页处理程序（page fault handler） -->
<!-- 会负责处理该异常，将缺失的页面加载到内存中，然后 CPU 重新执行引起缺页异常的指令。 -->
<p>ELF 文件的 .rodata section 中存储的数据恰好就是会被延迟加载的数据。</p>
<div class="section" id="rodata">
<h4 id="hidrodata">.rodata<a class="headerlink" href="#hidrodata" title="Permalink to this headline">¶</a></h4>
<p>ELF 文件中的 .rodata section 存储了一些只读数据，比如静态字符串。
我们首先来看一下编译后的示例程序二进制 ELF 文件中的 .rodata section 的数据。</p>
<ul>
<li><p class="first">可以使用 <tt class="docutils literal">objdump</tt> 命令进行查看:</p>
<pre class="literal-block">
$ objdump -s -j .rodata ./reproduce

./reproduce:     file format elf64-x86-64

Contents of section .rodata:
2000 01000200 2f757372 2f62696e 2f656368  ..../usr/bin/ech
2010 6f006164 6400                        o.add.
</pre>
</li>
<li><p class="first">也可以使用 python 社区的 <a class="reference external" href="https://docs.pwntools.com/en/stable/">pwntools</a> 库进行读取:</p>
<pre class="literal-block">
&gt;&gt;&gt; from pwn import ELF
&gt;&gt;&gt; elf = ELF('reproduce')
&gt;&gt;&gt; elf.section('.rodata')
b'\x01\x00\x02\x00/usr/bin/echo\x00add\x00'
</pre>
</li>
</ul>
<p>从上面的输出中可以看到其中包含了源码中使用的两个静态字符串。</p>
</div>
<div class="section" id="page-fault-1">
<h4 id="hidpage-fault-1">观测 page fault<a class="headerlink" href="#hidpage-fault-1" title="Permalink to this headline">¶</a></h4>
<p>在 Linux 系统中，当内核执行 <tt class="docutils literal">execve()</tt> 系统调用时，
会使用内核函数 <tt class="docutils literal">strncpy_from_user</tt> 将 <tt class="docutils literal">argv</tt> 中包含的字符串数据从用户态复制到内核态，
这个过程涉及读取用户态数据的操作。
如果被读取的用户态数据还未被加载到内存中，就会触发 page fault。</p>
<p>我们可以通过观测 <tt class="docutils literal">exceptions/page_fault_kernel</tt> 和 <tt class="docutils literal">exceptions/page_fault_user</tt> 感知到这个事件:</p>
<ol class="arabic">
<li><p class="first">为了方便验证，我们需要先修改一下示例代码，在执行 <tt class="docutils literal">execv()</tt> 函数前增加一行 <tt class="docutils literal">sleep(15)</tt> ，避免程序太快结束
（<a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce_sleep.c">reproduce_sleep.c</a> ）</p>
<pre class="literal-block">
if (!fork()) {
     sleep(15);
     execv(args[0], (char *const *) args);
}
</pre>
</li>
<li><p class="first">在一个终端中运行下面这个 bpftrace 脚本，观测 page fault:</p>
<pre class="literal-block">
cat &lt;&lt;EOF | sudo bpftrace -
tracepoint:exceptions:page_fault_kernel /comm == &quot;reproduce_sleep&quot;/ {
    printf(&quot;[%s] page_fault_kernel: %s[%d] addr=%llx ip=%llx err=%lld\n&quot;,
            strftime(&quot;%M:%S&quot;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code);
}

tracepoint:exceptions:page_fault_user /comm == &quot;reproduce_sleep&quot;/ {
    printf(&quot;[%s] page_fault_user:   %s[%d] addr=%llx ip=%llx err=%lld\n&quot;,
            strftime(&quot;%M:%S&quot;, nsecs), comm, pid, args-&gt;address, args-&gt;ip, args-&gt;error_code);
}
EOF
</pre>
</li>
<li><p class="first">然后在另一个终端中运行 <tt class="docutils literal">./reproduce_sleep</tt></p>
</li>
<li><p class="first">在第3个终端中查看运行中的 reproduce_sleep 进程的内存映射关系（memory mapping）:</p>
<pre class="literal-block">
$ sudo cat /proc/41291/maps | grep reproduce_sleep
55b4d9e31000-55b4d9e32000 r--p 00000000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e32000-55b4d9e33000 r-xp 00001000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e33000-55b4d9e34000 r--p 00002000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e34000-55b4d9e35000 r--p 00002000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e35000-55b4d9e36000 rw-p 00003000 08:01 1634479                    /XXX/reproduce_sleep
</pre>
<p>由上面可知，该进程的内存映射起始地址是 <tt class="docutils literal">55b4d9e31000</tt> ，即 <tt class="docutils literal">0x55b4d9e31000</tt></p>
</li>
<li><p class="first">待示例程序运行结束后，bpftrace 命令的输出中的最后两条数据将类似下面这样:</p>
<pre class="literal-block">
[47:40] page_fault_user:   reproduce_sleep[41290] addr=7f669db86a50 ip=7f669d9f8940 err=7
[47:55] page_fault_kernel: reproduce_sleep[41291] addr=55b4d9e33004 ip=ffffffff8e092a40 err=0
</pre>
<p>这两个输出间隔了 15 秒，由此可以确定最后那个 page fault 事件是执行 <tt class="docutils literal">execv()</tt> 函数的时候触发的。
下面来通过事件中的 <tt class="docutils literal">addr</tt> 结果定位对应的数据。</p>
</li>
<li><p class="first">上面最后那条 <tt class="docutils literal">page_fault_kernel</tt> 事件输出的 addr 的值是 <tt class="docutils literal">55b4d9e33004</tt> ，
即触发这个 page fault 事件的虚拟内存地址是 <tt class="docutils literal">0x55b4d9e33004</tt> 。</p>
</li>
<li><p class="first">基于 <a class="reference external" href="https://github.com/jschwinger233">&#64;jschwinger233</a>  分享的秘籍：
<tt class="docutils literal">real_addr = start_addr + (elf_address - section.Address + section.Offset)</tt> 可知:</p>
<pre class="literal-block">
0x55b4d9e33004 = 0x55b4d9e31000 + (elf_address - section.Address + section.Offset)
(elf_address - section.Address + section.Offset) = 0x55b4d9e33004 - 0x55b4d9e31000 = 8196 = 0x2004
</pre>
</li>
<li><p class="first">使用 readelf 命令读取二进制文件 reproduce_sleep 中 ELF .rodata section 的内存地址、偏移量以及数据大小:</p>
<pre class="literal-block">
$ readelf -S -W reproduce_sleep  | egrep '.rodata|Address'
  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
  [18] .rodata           PROGBITS        0000000000002000 002000 000016 00   A  0   0  4
</pre>
<p>由上面的输出可知，该 ELF 文件中 .rodata section 的虚拟地址是 <tt class="docutils literal">0000000000002000</tt> 即 <tt class="docutils literal">0x2000</tt> ，
偏移量是 <tt class="docutils literal">002000</tt> 即 <tt class="docutils literal">0x2000</tt> ， 数据大小是 <tt class="docutils literal">0x16</tt> ，即地址范围是 <tt class="docutils literal"><span class="pre">0x2000-0x2016</span></tt> 。</p>
</li>
<li><p class="first">通过 7 和 8 可知，执行 <tt class="docutils literal">execv()</tt> 函数时触发的 page fault 事件的虚拟内存地址
<tt class="docutils literal">0x55b4d9e33004</tt> 对应的 ELF 地址是 <tt class="docutils literal">0x2004</tt> ，这个地址在 ELF 文件的 .rodata 地址范围（0x2000-0x2016）内，
对应的是 <tt class="docutils literal">argv[0]</tt> 中使用的静态字符串 <tt class="docutils literal">/usr/bin/echo</tt>:</p>
<pre class="literal-block">
$ objdump -s -j .rodata ./reproduce_sleep

./reproduce_sleep:     file format elf64-x86-64

Contents of section .rodata:
 2000 01000200 2f757372 2f62696e 2f656368  ..../usr/bin/ech
 2010 6f006164 6400                        o.add.

&gt;&gt;&gt; elf = ELF('reproduce_sleep')
&gt;&gt;&gt; elf.read(0x2004, 14)
b'/usr/bin/echo\x00'

$ gdb -ex 'disas/m main' -ex q reproduce_sleep | grep 'args\[\]' -A 13
9       const char *const args[] = {
   0x00000000000011d6 &lt;+45&gt;:        lea    0xe27(%rip),%rax        # 0x2004
   0x00000000000011dd &lt;+52&gt;:        mov    %rax,-0x30(%rbp)
   0x00000000000011e1 &lt;+56&gt;:        lea    0xe2a(%rip),%rax        # 0x2012
   0x00000000000011e8 &lt;+63&gt;:        mov    %rax,-0x28(%rbp)
   0x00000000000011ec &lt;+67&gt;:        mov    -0x38(%rbp),%rax
   0x00000000000011f0 &lt;+71&gt;:        mov    %rax,-0x20(%rbp)
   0x00000000000011f4 &lt;+75&gt;:        movq   $0x0,-0x18(%rbp)

10          PATHNAME,
11          &quot;add&quot;,
12          hostname,
13          0
14      };
</pre>
</li>
<li><p class="first">也可以通过在 ebpf 程序或 bpftrace 脚本中打印 <tt class="docutils literal"><span class="pre">args-&gt;filename</span></tt> 的指针地址来确认，
这个地址的值会跟前面 page fault 事件中 addr 的值一致，都是 <tt class="docutils literal">0x55b4d9e33004</tt></p>
<pre class="literal-block">
tracepoint:syscalls:sys_enter_execve {
    printf(&quot;%s[%d]: %p\n&quot;, comm, pid, args-&gt;filename);
}
</pre>
</li>
</ol>
<p>BTW，可以通过 <tt class="docutils literal">perf trace <span class="pre">-F</span> all</tt> 命令追踪触发 page fault 事件的函数信息。</p>
</div>
</div>
</div>
<div class="section" id="section-6">
<h2 id="hidsection-6">解决方法<a class="headerlink" href="#hidsection-6" title="Permalink to this headline">¶</a></h2>
<p>解决这个问题的方法有很多，其中一种解决方法是改为通过追踪 <tt class="docutils literal">tracepoint/sched/sched_process_exec</tt>
事件来获取 <tt class="docutils literal">execve()</tt> 系统调用中 <tt class="docutils literal">filename</tt> 和 <tt class="docutils literal">argv</tt> 参数的值。下面是对应实现的示例程序：</p>
<ul>
<li><p class="first">通过 bpftrace 追踪 <tt class="docutils literal">tracepoint/sched/sched_process_exec</tt> 事件的示例脚本（来自 <a class="reference external" href="https://github.com/jschwinger233">&#64;jschwinger233</a> ）:</p>
<pre class="literal-block">
tracepoint:sched:sched_process_exec {
  $task=curtask;
  $arg_start=$task-&gt;mm-&gt;arg_start;
  $arg_end=$task-&gt;mm-&gt;arg_end;
  printf(&quot;%s[%d]: filename: %s, argv: %r\n&quot;, comm, pid, str(args-&gt;filename), buf(uptr($arg_start), $arg_end-$arg_start));
}
</pre>
</li>
<li><p class="first">通过 ebpf c 代码追踪 <tt class="docutils literal">tracepoint/sched/sched_process_exec</tt> 事件的示例程序：
<a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/blob/master/37-tracepoint-sched_process_exec/main.bpf.c">main.bpf.c</a></p>
</li>
</ul>
</div>
<div class="section" id="section-7">
<h2 id="hidsection-7">参考资料<a class="headerlink" href="#hidsection-7" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://github.com/tmux/tmux/tree/master">tmux/tmux: tmux source code</a></li>
<li><a class="reference external" href="https://github.com/bpftrace/bpftrace/issues/2523">Can't trace sys_execve inside a c program · Issue #2523 · bpftrace/bpftrace</a></li>
<li><a class="reference external" href="https://wiki.osdev.org/ELF">ELF - OSDev Wiki</a></li>
<li><a class="reference external" href="https://stackoverflow.com/questions/57761007/why-an-elf-executable-could-have-4-load-segments">unix - Why an ELF executable could have 4 LOAD segments? - Stack Overflow</a></li>
<li><a class="reference external" href="https://www.cs.bham.ac.uk/~exr/lectures/opsys/13_14/docs/kernelAPI/r4206.html">strncpy_from_user</a></li>
<li><a class="reference external" href="https://github.com/jschwinger233">&#64;jschwinger233</a> 的谆谆教诲</li>
</ul>
</div>

                </div>
            </div>
            <!-- /.entry-content -->
<section class="text-center">
  
<div id="donate"></div>

<div class="social-share"></div>
<div class="social-comment-note">
<p class="text-center">有任何建议和想法欢迎在下方评论区留言或者加我<a href="/static/wechat.png">微信</a>交流</p>
</div>

</section>
<section class="well" id="related-posts">
    <p>Related Posts:</p>
    <ul>
        <li><a href="https://mozillazg.com/2022/05/ebpf-libbpf-tracepoint-common-questions.html">ebpf/libbpf 程序使用 tracepoint 的常见问题</a></li>
    </ul>
</section>
<hr/>
<section class="comments" id="comments">
    <h2>Comments</h2>
    <script src="https://giscus.app/client.js"
            data-repo="mozillazg/mozillazg.github.com"
            data-repo-id="MDEwOlJlcG9zaXRvcnk3Njc4MTA2"
            data-category="Announcements"
            data-category-id="DIC_kwDOAHUoms4CckZl"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="0"
            data-input-position="bottom"
            data-theme="preferred_color_scheme"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
    </script>
</section>
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2024 mozillazg
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>
            &middot; <a href="/privacy-policy.html" target="_blank">Privacy</a>              <p><small>  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/static/images/by-sa-80x15.png" /></a>
    &quot;<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">mozillazg's Blog</span>&quot; by <a xmlns:cc="http://creativecommons.org/ns#" href="https://mozillazg.com" property="cc:attributionName" rel="cc:attributionURL">mozillazg</a> is
  licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="/theme/cdn.jsdelivr.net/npm/jquery@2.1.1/dist/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="/theme/cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->


<!-- share.js -->
<script src="/theme/cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>



<script src="/theme/cdn.jsdelivr.net/npm/tocbot@3.0.2/dist/tocbot.min.js"></script>
<script>
$(document).ready(function(){
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.js-toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.entry-content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h2, h3, h4,h5',
    // Headings that match the ignoreSelector will be skipped.
    ignoreSelector: '.js-toc-ignore',
    // Main class to add to links.
    linkClass: 'toc-link',
    // Extra classes to add to links.
    extraLinkClasses: '',
    // Class to add to active links,
    // the link corresponding to the top most heading on the page.
    activeLinkClass: 'is-active-link',
    // Main class to add to lists.
    listClass: 'toc-list',
    // Extra classes to add to lists.
    extraListClasses: '',
    // Class that gets added when a list should be collapsed.
    isCollapsedClass: 'is-collapsed',
    // Class that gets added when a list should be able
    // to be collapsed but isn't necessarily collpased.
    collapsibleClass: 'is-collapsible',
    // Class to add to list items.
    listItemClass: 'toc-list-item',
    // How many heading levels should not be collpased.
    // For example, number 6 will show everything since
    // there are only 6 heading levels and number 0 will collpase them all.
    // The sections that are hidden will open
    // and close as you scroll to headings within them.
    collapseDepth: 6,
    // Smooth scrolling enabled.
    smoothScroll: true,
    // Smooth scroll duration.
    smoothScrollDuration: 420,
    // Callback for scroll end (requires: smoothScroll).
    scrollEndCallback: function (e) {},
    // Headings offset between the headings and the top of the document (this is meant for minor adjustments).
    headingsOffset: 0,
    // Timeout between events firing to make sure it's
    // not too rapid (for performance reasons).
    throttleTimeout: 50,
    // Element to add the positionFixedClass to.
    positionFixedSelector: null,
    // Fixed position class to add to make sidebar fixed after scrolling
    // down past the fixedSidebarOffset.
    positionFixedClass: 'is-position-fixed',
    // fixedSidebarOffset can be any number but by default is set
    // to auto which sets the fixedSidebarOffset to the sidebar
    // element's offsetTop from the top of the document on init.
    fixedSidebarOffset: 'auto',
    // includeHtml can be set to true to include the HTML markup from the
    // heading node instead of just including the textContent.
    includeHtml: false
  });
});
</script>
</body>
</html>