<!DOCTYPE html>
<html lang="zh"  prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml" class="han-init">
<head>
    <title>tcpdump 常用操作 - mozillazg's Blog</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- share.css -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">


    <link href="https://mozillazg.com/favicon.ico" rel="icon">

<link rel="canonical" href="https://mozillazg.com/2018/01/tcpdump-common-useful-examples-cookbook.html">

        <meta name="author" content="mozillazg" />
        <meta name="keywords" content="linux,tcpdump" />
    <meta name="description" content="常用参数 -i interface: 设置抓取的网卡名（可以使用 -i any 抓取所有网卡的数据包） tcpdump -i eth0 -D: 列出可用的网卡列表 $ sudo tcpdump -D 1.eth0 2.nflog (Linux netfilter log (NFLOG) interface) 3.nfqueue (Linux netfilter queue (NFQUEUE) interface) 4.usbmon1 (USB bus number 1) 5.any (Pseudo-device that captures on all interfaces) 6.lo -w file: 把捕获的包数据写入到文件中（可以使用 -w - 输出到标准输出） tcpdump -i eth0 -w debug.cap -C size: 使用 -w 写入文件时，限制文件的最大大小，超出时新开一个文件（单位是 1,000,000 bytes） $ sudo tcpdump -i eth0 -w debug.cap -C 1 $ ls debug* -l -rw-r--r-- 1 tcpdump tcpdump 1000956 Jan 14 10:16 debug.cap -rw-r--r-- 1 tcpdump tcpdump 1000323 Jan 14 10:32 debug.cap1 -rw-r--r-- 1 tcpdump tcpdump 1000017 Jan 14 10:51 debug.cap2 -rw-r--r-- 1 tcpdump tcpdump 970705 Jan 14 11:08 debug.cap3 -r file: 从文件中读取包数据 tcpdump -r debug.cap -v: 启用 verbose output，抓包时输出包的附加信息（可以使用多个 -v: -v, -vv, -vvv 多个 v 会显示更多更详细的信息） tcpdump -v tcpdump -vv -A: 以 ASCII 码方式显示每一个数据包(不会显示数据包中链路层头部信息). 在抓取包含网页数据的数据包时, 可方便查看数据 -x: 打印每个包的头部数据, 同时会以16进制打印出每个包的数据(但不包括连接层的头部) -xx: 打印每个包的头部数据, 同时会以16进制打印出每个包的数据, 其中包括数据链路层的头部 -X: 打印每个包的头部数据, 同时会以16进制和 ASCII 码形式打印出每个包的数据(但不包括连接层的头部) -XX: 打印每个包的头部数据, 同时会以16进制和 ASCII 码形式打印出每个包的数据, 其中包括数据链路层的头部 -c count: 设置抓取到多少个包后就退出 tcpdump -i eth0 -c 100 -n: 不要把地址转换为主机名（直接显示 ip 不要解析为域名） tcpdump -n -nn: 不要把转换协议和端口号（直接显示协议和端口号，不要转换为协议名称，比如 http） tcpdump -nn -s snaplen: 设置 tcpdump 的数据包抓取长度为 snaplen , 为 0 时表示让 tcpdump 自动选择合适的长度来抓取数据包. tcpdump -s 0 -S: 打印TCP 数据包的顺序号时, 使用绝对的顺序号, 而不是相对的顺序号. tcpdump -S -Z user: 使tcpdump 放弃自己的超级权限(如果以root用户启动tcpdump, tcpdump将会有超级用户权限), 并把当前tcpdump的用户ID设置为user, 组ID设置为user首要所属组的ID sudo tcpdump -Z user2 常用的参数组合: sudo tcpdump -i eth0 -nnS -s 0 -c 100 -Avvv [&lt;expression&gt;] sudo tcpdump -i eth0 -nnS -s 1024 -c 100 -Avvv [&lt;expression&gt;] sudo tcpdump -i eth0 -nnS -s 1024 -C 10 -c 10000 -v -w debug.cap [&lt;expression&gt;] 默认 tcpdump 会抓取所有的数据，可以通过指定过滤规则来过滤数据包。 常用过滤规则 过滤规则一般包含三种修饰符的组合： type: 指定id 所代表的对象类型, id可以是名字也可以是数字. 可选的对象类型有: host, net, port 以及portrange，默认是 host dir: 描述id 所对应的传输方向, 即发往id 还是从id 接收（而id 到底指什么需要看其前面的type 修饰符）.可取的方向为: src, dst, src or dst, src and dst proto: 描述id 所属的协议. 可选的协议有: ether, fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp以及 upd 通过括号(\( xxx \)) 和 bool 操作符可以组合多种过滤规则，一对括号是一组: 否定操作: ! 或 not 与操作: &amp;&amp; 或 and 或操作: || 或 or 详情见文档：Manpage of PCAP-FILTER 下面列出一下常用的过滤规则: 过滤 ip/域名 过滤目标域名是 baidu.com: dst host baidu.com 源 ip 或者目标 ip 是 192.168.1.3: host 192.168.1.3 源 ip 是 192.168.1.3: src host 192.168.1.3 目标 ip 是 192.168.1.3: dst host 192.168.1.3 过滤范围内的 ip /网段 ip: net 192.168.0.0/24 net 192.168.0.0 mask 255.255.255.0 过滤端口 过滤 80 端口: port 80 排除端口: not port 80 host www.example.com and not \(port 80 or port 25\) host www.example.com and not port 80 and not port 25 端口范围: (tcp[0:2] &gt; 1500 and tcp[0:2] &lt; 1550) or (tcp[2:2] &gt; 1500 and tcp[2:2] &lt; 1550) tcp portrange 1501-1549 DNS 53 端口: port 53 过滤协议 ipv4: ip ipv6: ip6 tcp: tcp udp: udp arp: arp icmp: icmp 过滤协议头 过滤 tcp SYN 消息包: &#39;tcp[tcpflags] &amp; (tcp-syn) != 0&#39; 过滤 tcp SYN/ACK 消息包: &#39;tcp[tcpflags] &amp; (tcp-syn|tcp-ack) != 0&#39; 常用的 tcp 标记: tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-ack, tcp-urg, tcp-ece, tcp-cwr 源端口大于1024的TCP数据包: &#39;tcp[0:2] &gt; 1024&#39; 注意要用引号引起来。 过滤 HTTP 过滤 GET 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420&#39; 上面的 0x47455420 是 &#39;GET &#39; 的 16 进制: &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;GET &#39;])) [&#39;0x47&#39;, &#39;0x45&#39;, &#39;0x54&#39;, &#39;0x20&#39;] 过滤 POST 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x504f5354 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:1] = 0x20&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;POST &#39;])) [&#39;0x50&#39;, &#39;0x4f&#39;, &#39;0x53&#39;, &#39;0x54&#39;, &#39;0x20&#39;] 过滤 PUT 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x50555420&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;PUT &#39;])) [&#39;0x50&#39;, &#39;0x55&#39;, &#39;0x54&#39;, &#39;0x20&#39;] 过滤 PATH 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x50415443 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:2] = 0x4820&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;PATCH &#39;])) [&#39;0x50&#39;, &#39;0x41&#39;, &#39;0x54&#39;, &#39;0x43&#39;, &#39;0x48&#39;, &#39;0x20&#39;] 之所以拆分成了多个条件是因为 tcpdump: data size must be 1, 2, or 4 过滤 DELETE 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x44454c45 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:2] = 0x5445 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 6:1] = 0x20&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;DELETE &#39;])) [&#39;0x44&#39;, &#39;0x45&#39;, &#39;0x4c&#39;, &#39;0x45&#39;, &#39;0x54&#39;, &#39;0x45&#39;, &#39;0x20&#39;] 过滤 HEAD 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x48454144 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:1] = 0x20&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;HEAD &#39;])) [&#39;0x48&#39;, &#39;0x45&#39;, &#39;0x41&#39;, &#39;0x44&#39;, &#39;0x20&#39;] 过滤 OPTIONS 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x4f505449 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:4] = 0x4f4e5320&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;OPTIONS &#39;])) [&#39;0x4f&#39;, &#39;0x50&#39;, &#39;0x54&#39;, &#39;0x49&#39;, &#39;0x4f&#39;, &#39;0x4e&#39;, &#39;0x53&#39;, &#39;0x20&#39;] 过滤 HTTP 响应 (HTTP/1.): &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x48545450 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:2] = 0x2f31 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 6:1] = 0x2e&#39; HTTP request header &amp;&amp; body &amp;&amp; response header &amp;&amp; body: &#39;(((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&#39; 自动生成 HTTP 相关过滤规则的脚本: https://www.wireshark.org/tools/string-cf.html 上面的规则可以通过括号和操作符进行各种组合，从而组合出复杂的过滤规则。 sudo tcpdump host 192.168.8.3 -Avv sudo tcpdump dst host baidu.com and dst port 80 -i eth0 -vv sudo tcpdump dst host baidu.com and not dst port 80 -i eth0 -vv sudo tcpdump dst host baidu.com and not \(dst port 80 or dst port 443\) -i en0 -vv sudo tcpdump dst host baidu.com and &#39;tcp[tcpflags] &amp; (tcp-syn) != 0&#39; 参考资料 CaptureFilters - The Wireshark Wiki Manpage of PCAP-FILTER Linux tcpdump命令详解 - ggjucheng - 博客园 tcpdump命令常用方法 | 卡卡罗特 tcpdump - Linux Wiki Tcpdump advanced filters - Sebastien Wains - A blog about Linux and Open Source android - Can I use tcpdump to get HTTP requests, response header and response body? - Stack Overflow" />

    <style>
      .js-toc {
        margin-bottom: 20px;
      }
      .donate-modal {
        text-align: center;
      }
      #donate-modal-container .donate-image {
        max-height: 300px !important;
        min-height: inherit !important;
      }
    </style>

        <meta property="og:site_name" content="mozillazg's Blog" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="tcpdump 常用操作"/>
        <meta property="og:url" content="https://mozillazg.com/2018/01/tcpdump-common-useful-examples-cookbook.html"/>
        <meta property="og:description" content="常用参数 -i interface: 设置抓取的网卡名（可以使用 -i any 抓取所有网卡的数据包） tcpdump -i eth0 -D: 列出可用的网卡列表 $ sudo tcpdump -D 1.eth0 2.nflog (Linux netfilter log (NFLOG) interface) 3.nfqueue (Linux netfilter queue (NFQUEUE) interface) 4.usbmon1 (USB bus number 1) 5.any (Pseudo-device that captures on all interfaces) 6.lo -w file: 把捕获的包数据写入到文件中（可以使用 -w - 输出到标准输出） tcpdump -i eth0 -w debug.cap -C size: 使用 -w 写入文件时，限制文件的最大大小，超出时新开一个文件（单位是 1,000,000 bytes） $ sudo tcpdump -i eth0 -w debug.cap -C 1 $ ls debug* -l -rw-r--r-- 1 tcpdump tcpdump 1000956 Jan 14 10:16 debug.cap -rw-r--r-- 1 tcpdump tcpdump 1000323 Jan 14 10:32 debug.cap1 -rw-r--r-- 1 tcpdump tcpdump 1000017 Jan 14 10:51 debug.cap2 -rw-r--r-- 1 tcpdump tcpdump 970705 Jan 14 11:08 debug.cap3 -r file: 从文件中读取包数据 tcpdump -r debug.cap -v: 启用 verbose output，抓包时输出包的附加信息（可以使用多个 -v: -v, -vv, -vvv 多个 v 会显示更多更详细的信息） tcpdump -v tcpdump -vv -A: 以 ASCII 码方式显示每一个数据包(不会显示数据包中链路层头部信息). 在抓取包含网页数据的数据包时, 可方便查看数据 -x: 打印每个包的头部数据, 同时会以16进制打印出每个包的数据(但不包括连接层的头部) -xx: 打印每个包的头部数据, 同时会以16进制打印出每个包的数据, 其中包括数据链路层的头部 -X: 打印每个包的头部数据, 同时会以16进制和 ASCII 码形式打印出每个包的数据(但不包括连接层的头部) -XX: 打印每个包的头部数据, 同时会以16进制和 ASCII 码形式打印出每个包的数据, 其中包括数据链路层的头部 -c count: 设置抓取到多少个包后就退出 tcpdump -i eth0 -c 100 -n: 不要把地址转换为主机名（直接显示 ip 不要解析为域名） tcpdump -n -nn: 不要把转换协议和端口号（直接显示协议和端口号，不要转换为协议名称，比如 http） tcpdump -nn -s snaplen: 设置 tcpdump 的数据包抓取长度为 snaplen , 为 0 时表示让 tcpdump 自动选择合适的长度来抓取数据包. tcpdump -s 0 -S: 打印TCP 数据包的顺序号时, 使用绝对的顺序号, 而不是相对的顺序号. tcpdump -S -Z user: 使tcpdump 放弃自己的超级权限(如果以root用户启动tcpdump, tcpdump将会有超级用户权限), 并把当前tcpdump的用户ID设置为user, 组ID设置为user首要所属组的ID sudo tcpdump -Z user2 常用的参数组合: sudo tcpdump -i eth0 -nnS -s 0 -c 100 -Avvv [&lt;expression&gt;] sudo tcpdump -i eth0 -nnS -s 1024 -c 100 -Avvv [&lt;expression&gt;] sudo tcpdump -i eth0 -nnS -s 1024 -C 10 -c 10000 -v -w debug.cap [&lt;expression&gt;] 默认 tcpdump 会抓取所有的数据，可以通过指定过滤规则来过滤数据包。 常用过滤规则 过滤规则一般包含三种修饰符的组合： type: 指定id 所代表的对象类型, id可以是名字也可以是数字. 可选的对象类型有: host, net, port 以及portrange，默认是 host dir: 描述id 所对应的传输方向, 即发往id 还是从id 接收（而id 到底指什么需要看其前面的type 修饰符）.可取的方向为: src, dst, src or dst, src and dst proto: 描述id 所属的协议. 可选的协议有: ether, fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp以及 upd 通过括号(\( xxx \)) 和 bool 操作符可以组合多种过滤规则，一对括号是一组: 否定操作: ! 或 not 与操作: &amp;&amp; 或 and 或操作: || 或 or 详情见文档：Manpage of PCAP-FILTER 下面列出一下常用的过滤规则: 过滤 ip/域名 过滤目标域名是 baidu.com: dst host baidu.com 源 ip 或者目标 ip 是 192.168.1.3: host 192.168.1.3 源 ip 是 192.168.1.3: src host 192.168.1.3 目标 ip 是 192.168.1.3: dst host 192.168.1.3 过滤范围内的 ip /网段 ip: net 192.168.0.0/24 net 192.168.0.0 mask 255.255.255.0 过滤端口 过滤 80 端口: port 80 排除端口: not port 80 host www.example.com and not \(port 80 or port 25\) host www.example.com and not port 80 and not port 25 端口范围: (tcp[0:2] &gt; 1500 and tcp[0:2] &lt; 1550) or (tcp[2:2] &gt; 1500 and tcp[2:2] &lt; 1550) tcp portrange 1501-1549 DNS 53 端口: port 53 过滤协议 ipv4: ip ipv6: ip6 tcp: tcp udp: udp arp: arp icmp: icmp 过滤协议头 过滤 tcp SYN 消息包: &#39;tcp[tcpflags] &amp; (tcp-syn) != 0&#39; 过滤 tcp SYN/ACK 消息包: &#39;tcp[tcpflags] &amp; (tcp-syn|tcp-ack) != 0&#39; 常用的 tcp 标记: tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-ack, tcp-urg, tcp-ece, tcp-cwr 源端口大于1024的TCP数据包: &#39;tcp[0:2] &gt; 1024&#39; 注意要用引号引起来。 过滤 HTTP 过滤 GET 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420&#39; 上面的 0x47455420 是 &#39;GET &#39; 的 16 进制: &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;GET &#39;])) [&#39;0x47&#39;, &#39;0x45&#39;, &#39;0x54&#39;, &#39;0x20&#39;] 过滤 POST 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x504f5354 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:1] = 0x20&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;POST &#39;])) [&#39;0x50&#39;, &#39;0x4f&#39;, &#39;0x53&#39;, &#39;0x54&#39;, &#39;0x20&#39;] 过滤 PUT 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x50555420&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;PUT &#39;])) [&#39;0x50&#39;, &#39;0x55&#39;, &#39;0x54&#39;, &#39;0x20&#39;] 过滤 PATH 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x50415443 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:2] = 0x4820&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;PATCH &#39;])) [&#39;0x50&#39;, &#39;0x41&#39;, &#39;0x54&#39;, &#39;0x43&#39;, &#39;0x48&#39;, &#39;0x20&#39;] 之所以拆分成了多个条件是因为 tcpdump: data size must be 1, 2, or 4 过滤 DELETE 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x44454c45 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:2] = 0x5445 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 6:1] = 0x20&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;DELETE &#39;])) [&#39;0x44&#39;, &#39;0x45&#39;, &#39;0x4c&#39;, &#39;0x45&#39;, &#39;0x54&#39;, &#39;0x45&#39;, &#39;0x20&#39;] 过滤 HEAD 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x48454144 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:1] = 0x20&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;HEAD &#39;])) [&#39;0x48&#39;, &#39;0x45&#39;, &#39;0x41&#39;, &#39;0x44&#39;, &#39;0x20&#39;] 过滤 OPTIONS 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x4f505449 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:4] = 0x4f4e5320&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;OPTIONS &#39;])) [&#39;0x4f&#39;, &#39;0x50&#39;, &#39;0x54&#39;, &#39;0x49&#39;, &#39;0x4f&#39;, &#39;0x4e&#39;, &#39;0x53&#39;, &#39;0x20&#39;] 过滤 HTTP 响应 (HTTP/1.): &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x48545450 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:2] = 0x2f31 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 6:1] = 0x2e&#39; HTTP request header &amp;&amp; body &amp;&amp; response header &amp;&amp; body: &#39;(((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&#39; 自动生成 HTTP 相关过滤规则的脚本: https://www.wireshark.org/tools/string-cf.html 上面的规则可以通过括号和操作符进行各种组合，从而组合出复杂的过滤规则。 sudo tcpdump host 192.168.8.3 -Avv sudo tcpdump dst host baidu.com and dst port 80 -i eth0 -vv sudo tcpdump dst host baidu.com and not dst port 80 -i eth0 -vv sudo tcpdump dst host baidu.com and not \(dst port 80 or dst port 443\) -i en0 -vv sudo tcpdump dst host baidu.com and &#39;tcp[tcpflags] &amp; (tcp-syn) != 0&#39; 参考资料 CaptureFilters - The Wireshark Wiki Manpage of PCAP-FILTER Linux tcpdump命令详解 - ggjucheng - 博客园 tcpdump命令常用方法 | 卡卡罗特 tcpdump - Linux Wiki Tcpdump advanced filters - Sebastien Wains - A blog about Linux and Open Source android - Can I use tcpdump to get HTTP requests, response header and response body? - Stack Overflow"/>
        <meta property="article:published_time" content="2018-01-14" />
            <meta property="article:section" content="linux" />
            <meta property="article:tag" content="linux" />
            <meta property="article:tag" content="tcpdump" />
            <meta property="article:author" content="mozillazg" />
            <meta property="og:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>


    <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@mozillazg">
        <meta name="twitter:creator" content="@mozillazg">
    <meta name="twitter:domain" content="https://mozillazg.com">
            <meta property="twitter:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/css/bootstrap.min.css" type="text/css"/>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link href="https://cdn.jsdelivr.net/npm/pygments-css@1.0.0/github.css" rel="stylesheet">
    <link rel="stylesheet" href="https://mozillazg.com/theme/css/style.css" type="text/css"/>
            <link href="https://mozillazg.com/static/han.min.css" rel="stylesheet">
            <link href="https://mozillazg.com/static/yue.css" rel="stylesheet">
            <link href="https://mozillazg.com/static/custom.css" rel="stylesheet">

        <link href="https://mozillazg.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog ATOM Feed"/>

        <link href="https://mozillazg.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="mozillazg's Blog RSS Feed"/>


        <link href="https://mozillazg.com/feeds/linux.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog linux ATOM Feed"/>


    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "publisher": {
            "@type": "Person",
            "name": "mozillazg",
            "logo": "https://mozillazg.com/static/avatar.jpeg"
        },
        "author": {
            "@type": "Person",
            "name": "mozillazg",
            "image": "https://mozillazg.com/static/avatar.jpeg",
            "url": "https://mozillazg.com",
            "sameAs": []
        },
        "headline": "tcpdump 常用操作",
        "url": "https://mozillazg.com/2018/01/tcpdump-common-useful-examples-cookbook.html",
        "image": [
            "https://mozillazg.com/static/avatar.jpeg"
         ],
        "keywords": "linux, tcpdump",
        "description": "常用参数 -i interface: 设置抓取的网卡名（可以使用 -i any 抓取所有网卡的数据包） tcpdump -i eth0 -D: 列出可用的网卡列表 $ sudo tcpdump -D 1.eth0 2.nflog (Linux netfilter log (NFLOG) interface) 3.nfqueue (Linux netfilter queue (NFQUEUE) interface) 4.usbmon1 (USB bus number 1) 5.any (Pseudo-device that captures on all interfaces) 6.lo -w file: 把捕获的包数据写入到文件中（可以使用 -w - 输出到标准输出） tcpdump -i eth0 -w debug.cap -C size: 使用 -w 写入文件时，限制文件的最大大小，超出时新开一个文件（单位是 1,000,000 bytes） $ sudo tcpdump -i eth0 -w debug.cap -C 1 $ ls debug* -l -rw-r--r-- 1 tcpdump tcpdump 1000956 Jan 14 10:16 debug.cap -rw-r--r-- 1 tcpdump tcpdump 1000323 Jan 14 10:32 debug.cap1 -rw-r--r-- 1 tcpdump tcpdump 1000017 Jan 14 10:51 debug.cap2 -rw-r--r-- 1 tcpdump tcpdump 970705 Jan 14 11:08 debug.cap3 -r file: 从文件中读取包数据 tcpdump -r debug.cap -v: 启用 verbose output，抓包时输出包的附加信息（可以使用多个 -v: -v, -vv, -vvv 多个 v 会显示更多更详细的信息） tcpdump -v tcpdump -vv -A: 以 ASCII 码方式显示每一个数据包(不会显示数据包中链路层头部信息). 在抓取包含网页数据的数据包时, 可方便查看数据 -x: 打印每个包的头部数据, 同时会以16进制打印出每个包的数据(但不包括连接层的头部) -xx: 打印每个包的头部数据, 同时会以16进制打印出每个包的数据, 其中包括数据链路层的头部 -X: 打印每个包的头部数据, 同时会以16进制和 ASCII 码形式打印出每个包的数据(但不包括连接层的头部) -XX: 打印每个包的头部数据, 同时会以16进制和 ASCII 码形式打印出每个包的数据, 其中包括数据链路层的头部 -c count: 设置抓取到多少个包后就退出 tcpdump -i eth0 -c 100 -n: 不要把地址转换为主机名（直接显示 ip 不要解析为域名） tcpdump -n -nn: 不要把转换协议和端口号（直接显示协议和端口号，不要转换为协议名称，比如 http） tcpdump -nn -s snaplen: 设置 tcpdump 的数据包抓取长度为 snaplen , 为 0 时表示让 tcpdump 自动选择合适的长度来抓取数据包. tcpdump -s 0 -S: 打印TCP 数据包的顺序号时, 使用绝对的顺序号, 而不是相对的顺序号. tcpdump -S -Z user: 使tcpdump 放弃自己的超级权限(如果以root用户启动tcpdump, tcpdump将会有超级用户权限), 并把当前tcpdump的用户ID设置为user, 组ID设置为user首要所属组的ID sudo tcpdump -Z user2 常用的参数组合: sudo tcpdump -i eth0 -nnS -s 0 -c 100 -Avvv [&lt;expression&gt;] sudo tcpdump -i eth0 -nnS -s 1024 -c 100 -Avvv [&lt;expression&gt;] sudo tcpdump -i eth0 -nnS -s 1024 -C 10 -c 10000 -v -w debug.cap [&lt;expression&gt;] 默认 tcpdump 会抓取所有的数据，可以通过指定过滤规则来过滤数据包。 常用过滤规则 过滤规则一般包含三种修饰符的组合： type: 指定id 所代表的对象类型, id可以是名字也可以是数字. 可选的对象类型有: host, net, port 以及portrange，默认是 host dir: 描述id 所对应的传输方向, 即发往id 还是从id 接收（而id 到底指什么需要看其前面的type 修饰符）.可取的方向为: src, dst, src or dst, src and dst proto: 描述id 所属的协议. 可选的协议有: ether, fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp以及 upd 通过括号(\\( xxx \\)) 和 bool 操作符可以组合多种过滤规则，一对括号是一组: 否定操作: ! 或 not 与操作: &amp;&amp; 或 and 或操作: || 或 or 详情见文档：Manpage of PCAP-FILTER 下面列出一下常用的过滤规则: 过滤 ip/域名 过滤目标域名是 baidu.com: dst host baidu.com 源 ip 或者目标 ip 是 192.168.1.3: host 192.168.1.3 源 ip 是 192.168.1.3: src host 192.168.1.3 目标 ip 是 192.168.1.3: dst host 192.168.1.3 过滤范围内的 ip /网段 ip: net 192.168.0.0/24 net 192.168.0.0 mask 255.255.255.0 过滤端口 过滤 80 端口: port 80 排除端口: not port 80 host www.example.com and not \\(port 80 or port 25\\) host www.example.com and not port 80 and not port 25 端口范围: (tcp[0:2] &gt; 1500 and tcp[0:2] &lt; 1550) or (tcp[2:2] &gt; 1500 and tcp[2:2] &lt; 1550) tcp portrange 1501-1549 DNS 53 端口: port 53 过滤协议 ipv4: ip ipv6: ip6 tcp: tcp udp: udp arp: arp icmp: icmp 过滤协议头 过滤 tcp SYN 消息包: &#39;tcp[tcpflags] &amp; (tcp-syn) != 0&#39; 过滤 tcp SYN/ACK 消息包: &#39;tcp[tcpflags] &amp; (tcp-syn|tcp-ack) != 0&#39; 常用的 tcp 标记: tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-ack, tcp-urg, tcp-ece, tcp-cwr 源端口大于1024的TCP数据包: &#39;tcp[0:2] &gt; 1024&#39; 注意要用引号引起来。 过滤 HTTP 过滤 GET 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420&#39; 上面的 0x47455420 是 &#39;GET &#39; 的 16 进制: &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;GET &#39;])) [&#39;0x47&#39;, &#39;0x45&#39;, &#39;0x54&#39;, &#39;0x20&#39;] 过滤 POST 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x504f5354 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:1] = 0x20&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;POST &#39;])) [&#39;0x50&#39;, &#39;0x4f&#39;, &#39;0x53&#39;, &#39;0x54&#39;, &#39;0x20&#39;] 过滤 PUT 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x50555420&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;PUT &#39;])) [&#39;0x50&#39;, &#39;0x55&#39;, &#39;0x54&#39;, &#39;0x20&#39;] 过滤 PATH 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x50415443 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:2] = 0x4820&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;PATCH &#39;])) [&#39;0x50&#39;, &#39;0x41&#39;, &#39;0x54&#39;, &#39;0x43&#39;, &#39;0x48&#39;, &#39;0x20&#39;] 之所以拆分成了多个条件是因为 tcpdump: data size must be 1, 2, or 4 过滤 DELETE 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x44454c45 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:2] = 0x5445 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 6:1] = 0x20&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;DELETE &#39;])) [&#39;0x44&#39;, &#39;0x45&#39;, &#39;0x4c&#39;, &#39;0x45&#39;, &#39;0x54&#39;, &#39;0x45&#39;, &#39;0x20&#39;] 过滤 HEAD 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x48454144 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:1] = 0x20&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;HEAD &#39;])) [&#39;0x48&#39;, &#39;0x45&#39;, &#39;0x41&#39;, &#39;0x44&#39;, &#39;0x20&#39;] 过滤 OPTIONS 请求: &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x4f505449 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:4] = 0x4f4e5320&#39; &gt;&gt;&gt; list(map(hex, [ord(x) for x in &#39;OPTIONS &#39;])) [&#39;0x4f&#39;, &#39;0x50&#39;, &#39;0x54&#39;, &#39;0x49&#39;, &#39;0x4f&#39;, &#39;0x4e&#39;, &#39;0x53&#39;, &#39;0x20&#39;] 过滤 HTTP 响应 (HTTP/1.): &#39;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x48545450 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:2] = 0x2f31 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 6:1] = 0x2e&#39; HTTP request header &amp;&amp; body &amp;&amp; response header &amp;&amp; body: &#39;(((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)&#39; 自动生成 HTTP 相关过滤规则的脚本: https://www.wireshark.org/tools/string-cf.html 上面的规则可以通过括号和操作符进行各种组合，从而组合出复杂的过滤规则。 sudo tcpdump host 192.168.8.3 -Avv sudo tcpdump dst host baidu.com and dst port 80 -i eth0 -vv sudo tcpdump dst host baidu.com and not dst port 80 -i eth0 -vv sudo tcpdump dst host baidu.com and not \\(dst port 80 or dst port 443\\) -i en0 -vv sudo tcpdump dst host baidu.com and &#39;tcp[tcpflags] &amp; (tcp-syn) != 0&#39; 参考资料 CaptureFilters - The Wireshark Wiki Manpage of PCAP-FILTER Linux tcpdump命令详解 - ggjucheng - 博客园 tcpdump命令常用方法 | 卡卡罗特 tcpdump - Linux Wiki Tcpdump advanced filters - Sebastien Wains - A blog about Linux and Open Source android - Can I use tcpdump to get HTTP requests, response header and response body? - Stack Overflow",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "https://mozillazg.com/2018/01/tcpdump-common-useful-examples-cookbook.html"
        },
        "datePublished": "2018-01-14"
    }
    </script>

</head>
<body>

<div class="navbar" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://mozillazg.com/" class="navbar-brand">
mozillazg's Blog            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="https://mozillazg.com/feeds/all.atom.xml">Feed</a></li>
                    <li><a href="/2014/10/pages/about-me.html">About</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://mozillazg.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content" class="yue">
        <article>
            <header class="text-center">
                <h1>
                    <a href="https://mozillazg.com/2018/01/tcpdump-common-useful-examples-cookbook.html"
                       rel="bookmark"
                       title="Permalink to tcpdump 常用操作">
                        tcpdump 常用操作
                    </a>
                </h1>
                <p class="published">
                    <time datetime="2018-01-14T00:00:00+00:00">
                    2018-01-14
                    </time>
                </p>
            </header>
            <div class="entry-content">
                <div class="well-sm article-info">
<footer class="post-info">
        <a href="https://mozillazg.com/category/linux.html">linux</a>


<span class="label label-default hide">Tags</span>
	<a href="https://mozillazg.com/tag/tcpdump.html">tcpdump</a>
    
</footer><!-- /.post-info -->                </div>
                <div class="js-toc"></div>
                <div>
                <div class="section" id="section-1">
<h2 id="hidsection-1">常用参数<a class="headerlink" href="#hidsection-1" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-i</span> interface</tt>: 设置抓取的网卡名（可以使用 <tt class="docutils literal"><span class="pre">-i</span> any</tt> 抓取所有网卡的数据包）</li>
</ul>
<div class="highlight"><pre><span></span>tcpdump<span class="w"> </span>-i<span class="w"> </span>eth0
</pre></div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-D</span></tt>: 列出可用的网卡列表</li>
</ul>
<div class="highlight"><pre><span></span>$<span class="w"> </span>sudo<span class="w"> </span>tcpdump<span class="w"> </span>-D
<span class="m">1</span>.eth0
<span class="m">2</span>.nflog<span class="w"> </span><span class="o">(</span>Linux<span class="w"> </span>netfilter<span class="w"> </span>log<span class="w"> </span><span class="o">(</span>NFLOG<span class="o">)</span><span class="w"> </span>interface<span class="o">)</span>
<span class="m">3</span>.nfqueue<span class="w"> </span><span class="o">(</span>Linux<span class="w"> </span>netfilter<span class="w"> </span>queue<span class="w"> </span><span class="o">(</span>NFQUEUE<span class="o">)</span><span class="w"> </span>interface<span class="o">)</span>
<span class="m">4</span>.usbmon1<span class="w"> </span><span class="o">(</span>USB<span class="w"> </span>bus<span class="w"> </span>number<span class="w"> </span><span class="m">1</span><span class="o">)</span>
<span class="m">5</span>.any<span class="w"> </span><span class="o">(</span>Pseudo-device<span class="w"> </span>that<span class="w"> </span>captures<span class="w"> </span>on<span class="w"> </span>all<span class="w"> </span>interfaces<span class="o">)</span>
<span class="m">6</span>.lo
</pre></div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-w</span> file</tt>: 把捕获的包数据写入到文件中（可以使用 <tt class="docutils literal"><span class="pre">-w</span> -</tt> 输出到标准输出）</li>
</ul>
<div class="highlight"><pre><span></span>tcpdump<span class="w"> </span>-i<span class="w"> </span>eth0<span class="w"> </span>-w<span class="w"> </span>debug.cap
</pre></div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-C</span> size</tt>: 使用 <tt class="docutils literal"><span class="pre">-w</span></tt> 写入文件时，限制文件的最大大小，超出时新开一个文件（单位是 1,000,000 bytes）</li>
</ul>
<div class="highlight"><pre><span></span>$<span class="w"> </span>sudo<span class="w"> </span>tcpdump<span class="w"> </span>-i<span class="w"> </span>eth0<span class="w"> </span>-w<span class="w"> </span>debug.cap<span class="w"> </span>-C<span class="w"> </span><span class="m">1</span>
$<span class="w"> </span>ls<span class="w"> </span>debug*<span class="w"> </span>-l
-rw-r--r--<span class="w"> </span><span class="m">1</span><span class="w"> </span>tcpdump<span class="w"> </span>tcpdump<span class="w"> </span><span class="m">1000956</span><span class="w"> </span>Jan<span class="w"> </span><span class="m">14</span><span class="w"> </span><span class="m">10</span>:16<span class="w"> </span>debug.cap
-rw-r--r--<span class="w"> </span><span class="m">1</span><span class="w"> </span>tcpdump<span class="w"> </span>tcpdump<span class="w"> </span><span class="m">1000323</span><span class="w"> </span>Jan<span class="w"> </span><span class="m">14</span><span class="w"> </span><span class="m">10</span>:32<span class="w"> </span>debug.cap1
-rw-r--r--<span class="w"> </span><span class="m">1</span><span class="w"> </span>tcpdump<span class="w"> </span>tcpdump<span class="w"> </span><span class="m">1000017</span><span class="w"> </span>Jan<span class="w"> </span><span class="m">14</span><span class="w"> </span><span class="m">10</span>:51<span class="w"> </span>debug.cap2
-rw-r--r--<span class="w"> </span><span class="m">1</span><span class="w"> </span>tcpdump<span class="w"> </span>tcpdump<span class="w">  </span><span class="m">970705</span><span class="w"> </span>Jan<span class="w"> </span><span class="m">14</span><span class="w"> </span><span class="m">11</span>:08<span class="w"> </span>debug.cap3
</pre></div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-r</span> file</tt>: 从文件中读取包数据</li>
</ul>
<div class="highlight"><pre><span></span>tcpdump<span class="w"> </span>-r<span class="w"> </span>debug.cap
</pre></div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-v</span></tt>: 启用 verbose output，抓包时输出包的附加信息（可以使用多个 <tt class="docutils literal"><span class="pre">-v</span></tt>: <tt class="docutils literal"><span class="pre">-v</span></tt>, <tt class="docutils literal"><span class="pre">-vv</span></tt>, <tt class="docutils literal"><span class="pre">-vvv</span></tt> 多个 <tt class="docutils literal">v</tt> 会显示更多更详细的信息）</li>
</ul>
<div class="highlight"><pre><span></span>tcpdump<span class="w"> </span>-v
tcpdump<span class="w"> </span>-vv
</pre></div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-A</span></tt>: 以 ASCII 码方式显示每一个数据包(不会显示数据包中链路层头部信息). 在抓取包含网页数据的数据包时, 可方便查看数据</li>
<li><tt class="docutils literal"><span class="pre">-x</span></tt>: 打印每个包的头部数据, 同时会以16进制打印出每个包的数据(但不包括连接层的头部)</li>
<li><tt class="docutils literal"><span class="pre">-xx</span></tt>: 打印每个包的头部数据, 同时会以16进制打印出每个包的数据, 其中包括数据链路层的头部</li>
<li><tt class="docutils literal"><span class="pre">-X</span></tt>: 打印每个包的头部数据, 同时会以16进制和 ASCII 码形式打印出每个包的数据(但不包括连接层的头部)</li>
<li><tt class="docutils literal"><span class="pre">-XX</span></tt>: 打印每个包的头部数据, 同时会以16进制和 ASCII 码形式打印出每个包的数据, 其中包括数据链路层的头部</li>
<li><tt class="docutils literal"><span class="pre">-c</span> count</tt>: 设置抓取到多少个包后就退出</li>
</ul>
<div class="highlight"><pre><span></span>tcpdump<span class="w"> </span>-i<span class="w"> </span>eth0<span class="w"> </span>-c<span class="w"> </span><span class="m">100</span>
</pre></div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-n</span></tt>: 不要把地址转换为主机名（直接显示 ip 不要解析为域名）</li>
</ul>
<div class="highlight"><pre><span></span>tcpdump<span class="w"> </span>-n
</pre></div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-nn</span></tt>: 不要把转换协议和端口号（直接显示协议和端口号，不要转换为协议名称，比如 http）</li>
</ul>
<div class="highlight"><pre><span></span>tcpdump<span class="w"> </span>-nn
</pre></div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-s</span> snaplen</tt>: 设置 tcpdump 的数据包抓取长度为 snaplen , 为 0 时表示让 tcpdump 自动选择合适的长度来抓取数据包.</li>
</ul>
<div class="highlight"><pre><span></span>tcpdump<span class="w"> </span>-s<span class="w"> </span><span class="m">0</span>
</pre></div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-S</span></tt>: 打印TCP 数据包的顺序号时, 使用绝对的顺序号, 而不是相对的顺序号.</li>
</ul>
<div class="highlight"><pre><span></span>tcpdump<span class="w"> </span>-S
</pre></div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">-Z</span> user</tt>: 使tcpdump 放弃自己的超级权限(如果以root用户启动tcpdump, tcpdump将会有超级用户权限), 并把当前tcpdump的用户ID设置为user, 组ID设置为user首要所属组的ID</li>
</ul>
<div class="highlight"><pre><span></span>sudo<span class="w"> </span>tcpdump<span class="w"> </span>-Z<span class="w"> </span>user2
</pre></div>
<p>常用的参数组合:</p>
<div class="highlight"><pre><span></span>sudo<span class="w"> </span>tcpdump<span class="w"> </span>-i<span class="w"> </span>eth0<span class="w"> </span>-nnS<span class="w"> </span>-s<span class="w"> </span><span class="m">0</span><span class="w"> </span>-c<span class="w"> </span><span class="m">100</span><span class="w"> </span>-Avvv<span class="w"> </span><span class="o">[</span>&lt;expression&gt;<span class="o">]</span>
sudo<span class="w"> </span>tcpdump<span class="w"> </span>-i<span class="w"> </span>eth0<span class="w"> </span>-nnS<span class="w"> </span>-s<span class="w"> </span><span class="m">1024</span><span class="w"> </span>-c<span class="w"> </span><span class="m">100</span><span class="w"> </span>-Avvv<span class="w"> </span><span class="o">[</span>&lt;expression&gt;<span class="o">]</span>
sudo<span class="w"> </span>tcpdump<span class="w"> </span>-i<span class="w"> </span>eth0<span class="w"> </span>-nnS<span class="w"> </span>-s<span class="w"> </span><span class="m">1024</span><span class="w"> </span>-C<span class="w"> </span><span class="m">10</span><span class="w"> </span>-c<span class="w"> </span><span class="m">10000</span><span class="w"> </span>-v<span class="w"> </span>-w<span class="w"> </span>debug.cap<span class="w"> </span><span class="o">[</span>&lt;expression&gt;<span class="o">]</span>
</pre></div>
<p>默认 tcpdump 会抓取所有的数据，可以通过指定过滤规则来过滤数据包。</p>
</div>
<div class="section" id="section-2">
<h2 id="hidsection-2">常用过滤规则<a class="headerlink" href="#hidsection-2" title="Permalink to this headline">¶</a></h2>
<p>过滤规则一般包含三种修饰符的组合：</p>
<ul class="simple">
<li>type: 指定id 所代表的对象类型, id可以是名字也可以是数字. 可选的对象类型有: host, net, port 以及portrange，默认是 host</li>
<li>dir: 描述id 所对应的传输方向, 即发往id 还是从id 接收（而id 到底指什么需要看其前面的type 修饰符）.可取的方向为: src, dst, src or dst, src and dst</li>
<li>proto: 描述id 所属的协议. 可选的协议有: ether, fddi, tr, wlan, ip, ip6, arp, rarp, decnet, tcp以及 upd</li>
</ul>
<p>通过括号(<tt class="docutils literal">\( xxx \)</tt>) 和 bool 操作符可以组合多种过滤规则，一对括号是一组:</p>
<ul class="simple">
<li>否定操作: <tt class="docutils literal">!</tt> 或 <tt class="docutils literal">not</tt></li>
<li>与操作: <tt class="docutils literal">&amp;&amp;</tt> 或 <tt class="docutils literal">and</tt></li>
<li>或操作: <tt class="docutils literal">||</tt> 或 <tt class="docutils literal">or</tt></li>
</ul>
<p>详情见文档：<a class="reference external" href="http://www.tcpdump.org/manpages/pcap-filter.7.html">Manpage of PCAP-FILTER</a></p>
<p>下面列出一下常用的过滤规则:</p>
<div class="section" id="ip">
<h3 id="hidip">过滤 ip/域名<a class="headerlink" href="#hidip" title="Permalink to this headline">¶</a></h3>
<p>过滤目标域名是 baidu.com:</p>
<pre class="literal-block">
dst host baidu.com
</pre>
<p>源 ip 或者目标 ip 是 192.168.1.3:</p>
<pre class="literal-block">
host 192.168.1.3
</pre>
<p>源 ip 是 192.168.1.3:</p>
<pre class="literal-block">
src host 192.168.1.3
</pre>
<p>目标 ip 是 192.168.1.3:</p>
<pre class="literal-block">
dst host 192.168.1.3
</pre>
<p>过滤范围内的 ip /网段 ip:</p>
<pre class="literal-block">
net 192.168.0.0/24
net 192.168.0.0 mask 255.255.255.0
</pre>
</div>
<div class="section" id="section-3">
<h3 id="hidsection-3">过滤端口<a class="headerlink" href="#hidsection-3" title="Permalink to this headline">¶</a></h3>
<p>过滤 80 端口:</p>
<pre class="literal-block">
port 80
</pre>
<p>排除端口:</p>
<pre class="literal-block">
not port 80
host www.example.com and not \(port 80 or port 25\)
host www.example.com and not port 80 and not port 25
</pre>
<p>端口范围:</p>
<pre class="literal-block">
(tcp[0:2] &gt; 1500 and tcp[0:2] &lt; 1550) or (tcp[2:2] &gt; 1500 and tcp[2:2] &lt; 1550)

tcp portrange 1501-1549
</pre>
<p>DNS 53 端口:</p>
<pre class="literal-block">
port 53
</pre>
</div>
<div class="section" id="section-4">
<h3 id="hidsection-4">过滤协议<a class="headerlink" href="#hidsection-4" title="Permalink to this headline">¶</a></h3>
<p>ipv4: <tt class="docutils literal">ip</tt></p>
<p>ipv6: <tt class="docutils literal">ip6</tt></p>
<p>tcp: <tt class="docutils literal">tcp</tt></p>
<p>udp: <tt class="docutils literal">udp</tt></p>
<p>arp: <tt class="docutils literal">arp</tt></p>
<p>icmp: <tt class="docutils literal">icmp</tt></p>
</div>
<div class="section" id="section-5">
<h3 id="hidsection-5">过滤协议头<a class="headerlink" href="#hidsection-5" title="Permalink to this headline">¶</a></h3>
<p>过滤 tcp SYN 消息包:</p>
<pre class="literal-block">
'tcp[tcpflags] &amp; (tcp-syn) != 0'
</pre>
<p>过滤 tcp SYN/ACK 消息包:</p>
<pre class="literal-block">
'tcp[tcpflags] &amp; (tcp-syn|tcp-ack) != 0'
</pre>
<p>常用的 tcp 标记:</p>
<pre class="literal-block">
tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-ack, tcp-urg, tcp-ece, tcp-cwr
</pre>
<p>源端口大于1024的TCP数据包:</p>
<pre class="literal-block">
'tcp[0:2] &gt; 1024'
</pre>
<p>注意要用引号引起来。</p>
</div>
<div class="section" id="http">
<h3 id="hidhttp">过滤 HTTP<a class="headerlink" href="#hidhttp" title="Permalink to this headline">¶</a></h3>
<p>过滤 GET 请求:</p>
<pre class="literal-block">
'tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x47455420'
</pre>
<p>上面的 <tt class="docutils literal">0x47455420</tt> 是 <tt class="docutils literal">'GET '</tt> 的 16 进制:</p>
<pre class="literal-block">
&gt;&gt;&gt; list(map(hex, [ord(x) for x in 'GET ']))
['0x47', '0x45', '0x54', '0x20']
</pre>
<p>过滤 POST 请求:</p>
<pre class="literal-block">
'tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x504f5354 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:1] = 0x20'

&gt;&gt;&gt; list(map(hex, [ord(x) for x in 'POST ']))
['0x50', '0x4f', '0x53', '0x54', '0x20']
</pre>
<p>过滤 PUT 请求:</p>
<pre class="literal-block">
'tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x50555420'

&gt;&gt;&gt; list(map(hex, [ord(x) for x in 'PUT ']))
['0x50', '0x55', '0x54', '0x20']
</pre>
<p>过滤 PATH 请求:</p>
<pre class="literal-block">
'tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x50415443 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:2] = 0x4820'

&gt;&gt;&gt; list(map(hex, [ord(x) for x in 'PATCH ']))
['0x50', '0x41', '0x54', '0x43', '0x48', '0x20']
</pre>
<p>之所以拆分成了多个条件是因为 <tt class="docutils literal">tcpdump: data size must be 1, 2, or 4</tt></p>
<p>过滤 DELETE 请求:</p>
<pre class="literal-block">
'tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x44454c45 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:2] = 0x5445 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 6:1] = 0x20'

&gt;&gt;&gt; list(map(hex, [ord(x) for x in 'DELETE ']))
['0x44', '0x45', '0x4c', '0x45', '0x54', '0x45', '0x20']
</pre>
<p>过滤 HEAD 请求:</p>
<pre class="literal-block">
'tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x48454144 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:1] = 0x20'

&gt;&gt;&gt; list(map(hex, [ord(x) for x in 'HEAD ']))
['0x48', '0x45', '0x41', '0x44', '0x20']
</pre>
<p>过滤 OPTIONS 请求:</p>
<pre class="literal-block">
'tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x4f505449 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:4] = 0x4f4e5320'

&gt;&gt;&gt; list(map(hex, [ord(x) for x in 'OPTIONS ']))
['0x4f', '0x50', '0x54', '0x49', '0x4f', '0x4e', '0x53', '0x20']
</pre>
<p>过滤 HTTP 响应 (<tt class="docutils literal">HTTP/1.</tt>):</p>
<pre class="literal-block">
'tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4] = 0x48545450 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 4:2] = 0x2f31 &amp;&amp; tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2) + 6:1] = 0x2e'
</pre>
<p>HTTP request header &amp;&amp; body &amp;&amp; response header &amp;&amp; body:</p>
<pre class="literal-block">
'(((ip[2:2] - ((ip[0]&amp;0xf)&lt;&lt;2)) - ((tcp[12]&amp;0xf0)&gt;&gt;2)) != 0)'
</pre>
<p>自动生成 HTTP 相关过滤规则的脚本: <a class="reference external" href="https://www.wireshark.org/tools/string-cf.html">https://www.wireshark.org/tools/string-cf.html</a></p>
<p>上面的规则可以通过括号和操作符进行各种组合，从而组合出复杂的过滤规则。</p>
<div class="highlight"><pre><span></span>sudo<span class="w"> </span>tcpdump<span class="w"> </span>host<span class="w"> </span><span class="m">192</span>.168.8.3<span class="w"> </span>-Avv
sudo<span class="w"> </span>tcpdump<span class="w"> </span>dst<span class="w"> </span>host<span class="w"> </span>baidu.com<span class="w"> </span>and<span class="w"> </span>dst<span class="w"> </span>port<span class="w"> </span><span class="m">80</span><span class="w"> </span>-i<span class="w"> </span>eth0<span class="w"> </span>-vv
sudo<span class="w"> </span>tcpdump<span class="w"> </span>dst<span class="w"> </span>host<span class="w"> </span>baidu.com<span class="w"> </span>and<span class="w"> </span>not<span class="w"> </span>dst<span class="w"> </span>port<span class="w"> </span><span class="m">80</span><span class="w"> </span>-i<span class="w"> </span>eth0<span class="w"> </span>-vv
sudo<span class="w"> </span>tcpdump<span class="w"> </span>dst<span class="w"> </span>host<span class="w"> </span>baidu.com<span class="w"> </span>and<span class="w"> </span>not<span class="w"> </span><span class="se">\(</span>dst<span class="w"> </span>port<span class="w"> </span><span class="m">80</span><span class="w"> </span>or<span class="w"> </span>dst<span class="w"> </span>port<span class="w"> </span><span class="m">443</span><span class="se">\)</span><span class="w"> </span>-i<span class="w"> </span>en0<span class="w"> </span>-vv
sudo<span class="w"> </span>tcpdump<span class="w"> </span>dst<span class="w"> </span>host<span class="w"> </span>baidu.com<span class="w"> </span>and<span class="w"> </span><span class="s1">&#39;tcp[tcpflags] &amp; (tcp-syn) != 0&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-6">
<h2 id="hidsection-6">参考资料<a class="headerlink" href="#hidsection-6" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://wiki.wireshark.org/CaptureFilters">CaptureFilters - The Wireshark Wiki</a></li>
<li><a class="reference external" href="http://www.tcpdump.org/manpages/pcap-filter.7.html">Manpage of PCAP-FILTER</a></li>
<li><a class="reference external" href="http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html">Linux tcpdump命令详解 - ggjucheng - 博客园</a></li>
<li><a class="reference external" href="http://www.zioer.org/2017/07/14/linux-command-for-tcpdump/">tcpdump命令常用方法 | 卡卡罗特</a></li>
<li><a class="reference external" href="http://linuxwiki.github.io/NetTools/tcpdump.html#210http-get">tcpdump - Linux Wiki</a></li>
<li><a class="reference external" href="https://blog.wains.be/2007/2007-10-01-tcpdump-advanced-filters/">Tcpdump advanced filters - Sebastien Wains - A blog about Linux and Open Source</a></li>
<li><a class="reference external" href="https://stackoverflow.com/questions/4777042/can-i-use-tcpdump-to-get-http-requests-response-header-and-response-body">android - Can I use tcpdump to get HTTP requests, response header and response body? - Stack Overflow</a></li>
</ul>
</div>

                </div>
            </div>
            <!-- /.entry-content -->
<section class="text-center">
  
<div id="donate"></div>

<div class="social-share"></div>
<div class="social-comment-note">
<p class="text-center">有任何建议和想法欢迎在下方评论区留言或者加我<a href="/static/wechat.png">微信</a>交流</p>
</div>

</section>
<section class="well" id="related-posts">
    <p>Related Posts:</p>
    <ul>
        <li><a href="https://mozillazg.com/2020/04/use-tcpdump-for-a-container-but-outside-container.html">一个在容器外用 tcpdump 命令对容器内的网络请求抓包的方法</a></li>
        <li><a href="https://mozillazg.com/2015/05/open-tcpdump-result-with-wireshark-gui.html">使用 wireshark 查看 tcpdump 的抓包结果</a></li>
    </ul>
</section>
<hr/>
<section class="comments" id="comments">
    <h2>Comments</h2>
    <script src="https://giscus.app/client.js"
            data-repo="mozillazg/mozillazg.github.com"
            data-repo-id="MDEwOlJlcG9zaXRvcnk3Njc4MTA2"
            data-category="Announcements"
            data-category-id="DIC_kwDOAHUoms4CckZl"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="0"
            data-input-position="bottom"
            data-theme="preferred_color_scheme"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
    </script>
</section>
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2024 mozillazg
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>
            &middot; <a href="/privacy-policy.html" target="_blank">Privacy</a>              <p><small>  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/static/images/by-sa-80x15.png" /></a>
    &quot;<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">mozillazg's Blog</span>&quot; by <a xmlns:cc="http://creativecommons.org/ns#" href="https://mozillazg.com" property="cc:attributionName" rel="cc:attributionURL">mozillazg</a> is
  licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="https://cdn.jsdelivr.net/npm/jquery@2.1.1/dist/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->

    <!-- Google Analytics Universal -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-77172981-1', 'auto');
        ga('send', 'pageview');
    </script>
    <!-- End Google Analytics Universal Code -->

<!-- share.js -->
<script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>



<script src="https://cdn.jsdelivr.net/npm/tocbot@3.0.2/dist/tocbot.min.js"></script>
<script>
$(document).ready(function(){
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.js-toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.entry-content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h2, h3, h4,h5',
    // Headings that match the ignoreSelector will be skipped.
    ignoreSelector: '.js-toc-ignore',
    // Main class to add to links.
    linkClass: 'toc-link',
    // Extra classes to add to links.
    extraLinkClasses: '',
    // Class to add to active links,
    // the link corresponding to the top most heading on the page.
    activeLinkClass: 'is-active-link',
    // Main class to add to lists.
    listClass: 'toc-list',
    // Extra classes to add to lists.
    extraListClasses: '',
    // Class that gets added when a list should be collapsed.
    isCollapsedClass: 'is-collapsed',
    // Class that gets added when a list should be able
    // to be collapsed but isn't necessarily collpased.
    collapsibleClass: 'is-collapsible',
    // Class to add to list items.
    listItemClass: 'toc-list-item',
    // How many heading levels should not be collpased.
    // For example, number 6 will show everything since
    // there are only 6 heading levels and number 0 will collpase them all.
    // The sections that are hidden will open
    // and close as you scroll to headings within them.
    collapseDepth: 6,
    // Smooth scrolling enabled.
    smoothScroll: true,
    // Smooth scroll duration.
    smoothScrollDuration: 420,
    // Callback for scroll end (requires: smoothScroll).
    scrollEndCallback: function (e) {},
    // Headings offset between the headings and the top of the document (this is meant for minor adjustments).
    headingsOffset: 0,
    // Timeout between events firing to make sure it's
    // not too rapid (for performance reasons).
    throttleTimeout: 50,
    // Element to add the positionFixedClass to.
    positionFixedSelector: null,
    // Fixed position class to add to make sidebar fixed after scrolling
    // down past the fixedSidebarOffset.
    positionFixedClass: 'is-position-fixed',
    // fixedSidebarOffset can be any number but by default is set
    // to auto which sets the fixedSidebarOffset to the sidebar
    // element's offsetTop from the top of the document on init.
    fixedSidebarOffset: 'auto',
    // includeHtml can be set to true to include the HTML markup from the
    // heading node instead of just including the textContent.
    includeHtml: false
  });
});
</script>
</body>
</html>