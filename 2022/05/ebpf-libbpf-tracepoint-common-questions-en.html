<!DOCTYPE html>
<html lang="en"  prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml" class="han-init">
<head>
    <title>Frequently asked questions about using tracepoint with ebpf/libbpf programs - mozillazg's Blog</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- share.css -->
    <link rel="stylesheet" href="/theme/cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">


    <link href="https://mozillazg.com/favicon.ico" rel="icon">

<link rel="canonical" href="https://mozillazg.com/2022/05/ebpf-libbpf-tracepoint-common-questions-en.html">

        <meta name="author" content="mozillazg" />
        <meta name="keywords" content="ebpf,tracepoint,libbpf,libbpfgo,go,golang,en-version" />
    <meta name="description" content="Preface This article aims to address common issues related to tracepoints when writing eBPF/libbpf programs (such as writing ebpf programs of type BPF_PROG_TYPE_TRACEPOINT). Types of eBPF Programs This article focuses on the eBPF program type called BPF_PROG_TYPE_TRACEPOINT. Events that can be Monitored by Tracepoints You can find the events that can be monitored by tracepoints by viewing the contents of the file /sys/kernel/debug/tracing/available_events. Each line in the file follows the format: &lt;category&gt;:&lt;name&gt; For example: syscalls:sys_enter_execve Format of SEC Content The SEC format corresponding to the tracepoint event is: SEC(&#34;tracepoint/&lt;category&gt;/&lt;name&gt;&#34;) // For example: // SEC(&#34;tracepoint/syscalls/sys_enter_openat&#34;) or: SEC(&#34;tp/&lt;category&gt;/&lt;name&gt;&#34;) // For example: // SEC(&#34;tp/syscalls/sys_enter_openat&#34;) The values of &lt;category&gt; and &lt;name&gt; are taken from the contents listed in the available_events file. SEC(&#34;tp/xx/yy&#34;) and SEC(&#34;tracepoint/xx/yy&#34;) are actually equivalent, and you can use either one according to personal preference. How to Determine the Parameter Types of the Tracepoint Event Handling Function and Obtain the Corresponding Kernel Call Parameters Suppose we want to trace the chmod command and the fchmodat system call involved in it. Then, how do we determine the parameter types of the event handling function in the ebpf program and how to obtain the content of the corresponding parameters involved in the fchmodat system call, such as the file name and the value of the mode permission. Determining the Tracepoint Event to be Tracked The first step is to determine the system call used by chmod, which can be done in various ways, such as using the strace command: $ strace chmod 600 a.txt ... fchmodat(AT_FDCWD, &#34;a.txt&#34;, 0600) = 0 ... The second step is to find the tracepoint event that can be used for this system call: $ sudo cat /sys/kernel/debug/tracing/available_events |grep fchmodat syscalls:sys_exit_fchmodat syscalls:sys_enter_fchmodat We can see that there are two events: sys_enter_fchmodat and sys_exit_fchmodat. Here, we choose the sys_enter_fchmodat event for further explanation. Determining the Information Included in the Event The third step is to determine what information the event itself can provide. Although we know that the fchmodat system call requires the file name and mode information, we are not sure if we can obtain this information in the ebpf program. You can obtain the information by viewing the contents of the file /sys/kernel/debug/tracing/events/&lt;category&gt;/&lt;name&gt;/format. For example, the contents of the file /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format for the sys_enter_fchmodat event are as follows: $ sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format name: sys_enter_fchmodat ID: 647 format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:int dfd; offset:16; size:8; signed:0; field:const char * filename; offset:24; size:8; signed:0; field:umode_t mode; offset:32; size:8; signed:0; print fmt: &#34;dfd: 0x%08lx, filename: 0x%08lx, mode: 0x%08lx&#34;, ((unsigned long)(REC-&gt;dfd)), ((unsigned long)(REC-&gt;filename)), ((unsigned long)(REC-&gt;mode)) The fields listed in format cannot be directly accessed by ordinary ebpf programs for the first 8 bytes (some bpf helpers can access them) [1]. Other fields can generally be accessed, and the fields referenced in print fmt are the information we can obtain in the ebpf program. From the above, we can see that we can obtain the dfd, filename, and mode information of the sys_enter_fchmodat event, which includes the file name and permission mode information mentioned earlier. Determining the Parameters of the Event Handling Function The fourth step is to determine the parameter types of the function. After knowing the information that the event itself can provide, we also need to know how to read this information in the ebpf program. This involves how to confirm what the parameters of the ebpf event handling function are so that we can obtain the information contained in the event from the function&#39;s input parameters. Based on vmlinux.h One way is to search in the vmlinux.h file. Generally, sys_enter_xx corresponds to trace_event_raw_sys_enter, sys_exit_xx corresponds to trace_event_raw_sys_exit, and others generally correspond to trace_event_raw_&lt;name&gt;. If not found, you can refer to the example of trace_event_raw_sys_enter to find a similar struct. For sys_enter_fchmodat, we use the struct trace_event_raw_sys_enter: struct trace_event_raw_sys_enter { struct trace_entry ent; long int id; long unsigned int args[6]; char __data[0]; }; In this struct, the field args stores the information that the event is related to, which corresponds to the fields included in the fmt in the format file in the third step. Therefore, we can obtain the dfd with args[0], filename with args[1], and so on. Now that the information is determined, we can write the program. For example, the example ebpf program for the sys_enter_fchmodat event is as follows: SEC(&#34;tracepoint/syscalls/sys_enter_fchmodat&#34;) int tracepoint__syscalls__sys_enter_fchmodat(struct trace_event_raw_sys_enter *ctx) { // ... char *filename_ptr = (char *) BPF_CORE_READ(ctx, args[1]); bpf_core_read_user_str(&amp;event-&gt;filename, sizeof(event-&gt;filename), filename_ptr); event-&gt;mode = BPF_CORE_READ(ctx, args[2]); // ... } Refer to the following links for complete examples using this method: tracepoint/syscalls/sys_enter_fchmodat: 07-tracepoint-args tracepoint/sched/sched_switch: 14-tracepoint-args-sched_switch Manually Constructing the Parameter Structure In addition to using the pre-defined structures in vmlinux.h, we can also customize a structure based on the content of the format file in the third step as the parameter of the eBPF program. For example, the contents of the file /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format for the sys_enter_fchmodat event are as follows: $ sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format name: sys_enter_fchmodat ID: 647 format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:int dfd; offset:16; size:8; signed:0; field:const char * filename; offset:24; size:8; signed:0; field:umode_t mode; offset:32; size:8; signed:0; print fmt: &#34;dfd: 0x%08lx, filename: 0x%08lx, mode: 0x%08lx&#34;, ((unsigned long)(REC-&gt;dfd)), ((unsigned long)(REC-&gt;filename)), ((unsigned long)(REC-&gt;mode)) Based on this information, we can define the following structure as the parameter of the eBPF event handling function: struct sys_enter_fchmodat_args { char _[16]; long dfd; long filename_ptr; long mode; }; In this structure, we first represent the content of the first 16 bytes with char _[16], which corresponds to all the fields before dfd in the format file. Then we define the dfd, filename, and mode fields that our program wants to obtain one by one. The reason for using the long type is to ensure that the size of each member is 8 bytes as indicated in the format (the size of each field member in each event is different and needs to be adjusted according to the actual content of the format file), and you can also use other types, but you need to ensure that the offset of each field member is consistent with the description in the format. The example ebpf program using the manually constructed custom structure as a parameter for the sys_enter_fchmodat event is as follows: SEC(&#34;tracepoint/syscalls/sys_enter_fchmodat&#34;) int tracepoint__syscalls__sys_enter_fchmodat(struct sys_enter_fchmodat_args *ctx) { // ... char *filename_ptr = (char *)ctx-&gt;filename_ptr; bpf_core_read_user_str(&amp;event-&gt;filename, sizeof(event-&gt;filename), filename_ptr); event-&gt;mode = (u32)ctx-&gt;mode; // ... } Refer to the following links for complete examples using this method: tracepoint/syscalls/sys_enter_fchmodat: 35-tracepoint-args-use-custom-struct tracepoint/sched/sched_switch: 36-tracepoint-args-sched_switch-use-custom-struct References BPF CO-RE reference guide libbpf/libbpf.c at 12e932ac0e18546dd7247e66ea1b4aa236d2ef38 · libbpf/libbpf BCC to libbpf conversion guide [1]perf, bpf: allow bpf programs attach to tracepoints · torvalds/linux@98b5c2c" />

    <style>
      .js-toc {
        margin-bottom: 20px;
      }
      .donate-modal {
        text-align: center;
      }
      #donate-modal-container .donate-image {
        max-height: 300px !important;
        min-height: inherit !important;
      }
    </style>

        <meta property="og:site_name" content="mozillazg's Blog" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Frequently asked questions about using tracepoint with ebpf/libbpf programs"/>
        <meta property="og:url" content="https://mozillazg.com/2022/05/ebpf-libbpf-tracepoint-common-questions-en.html"/>
        <meta property="og:description" content="Preface This article aims to address common issues related to tracepoints when writing eBPF/libbpf programs (such as writing ebpf programs of type BPF_PROG_TYPE_TRACEPOINT). Types of eBPF Programs This article focuses on the eBPF program type called BPF_PROG_TYPE_TRACEPOINT. Events that can be Monitored by Tracepoints You can find the events that can be monitored by tracepoints by viewing the contents of the file /sys/kernel/debug/tracing/available_events. Each line in the file follows the format: &lt;category&gt;:&lt;name&gt; For example: syscalls:sys_enter_execve Format of SEC Content The SEC format corresponding to the tracepoint event is: SEC(&#34;tracepoint/&lt;category&gt;/&lt;name&gt;&#34;) // For example: // SEC(&#34;tracepoint/syscalls/sys_enter_openat&#34;) or: SEC(&#34;tp/&lt;category&gt;/&lt;name&gt;&#34;) // For example: // SEC(&#34;tp/syscalls/sys_enter_openat&#34;) The values of &lt;category&gt; and &lt;name&gt; are taken from the contents listed in the available_events file. SEC(&#34;tp/xx/yy&#34;) and SEC(&#34;tracepoint/xx/yy&#34;) are actually equivalent, and you can use either one according to personal preference. How to Determine the Parameter Types of the Tracepoint Event Handling Function and Obtain the Corresponding Kernel Call Parameters Suppose we want to trace the chmod command and the fchmodat system call involved in it. Then, how do we determine the parameter types of the event handling function in the ebpf program and how to obtain the content of the corresponding parameters involved in the fchmodat system call, such as the file name and the value of the mode permission. Determining the Tracepoint Event to be Tracked The first step is to determine the system call used by chmod, which can be done in various ways, such as using the strace command: $ strace chmod 600 a.txt ... fchmodat(AT_FDCWD, &#34;a.txt&#34;, 0600) = 0 ... The second step is to find the tracepoint event that can be used for this system call: $ sudo cat /sys/kernel/debug/tracing/available_events |grep fchmodat syscalls:sys_exit_fchmodat syscalls:sys_enter_fchmodat We can see that there are two events: sys_enter_fchmodat and sys_exit_fchmodat. Here, we choose the sys_enter_fchmodat event for further explanation. Determining the Information Included in the Event The third step is to determine what information the event itself can provide. Although we know that the fchmodat system call requires the file name and mode information, we are not sure if we can obtain this information in the ebpf program. You can obtain the information by viewing the contents of the file /sys/kernel/debug/tracing/events/&lt;category&gt;/&lt;name&gt;/format. For example, the contents of the file /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format for the sys_enter_fchmodat event are as follows: $ sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format name: sys_enter_fchmodat ID: 647 format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:int dfd; offset:16; size:8; signed:0; field:const char * filename; offset:24; size:8; signed:0; field:umode_t mode; offset:32; size:8; signed:0; print fmt: &#34;dfd: 0x%08lx, filename: 0x%08lx, mode: 0x%08lx&#34;, ((unsigned long)(REC-&gt;dfd)), ((unsigned long)(REC-&gt;filename)), ((unsigned long)(REC-&gt;mode)) The fields listed in format cannot be directly accessed by ordinary ebpf programs for the first 8 bytes (some bpf helpers can access them) [1]. Other fields can generally be accessed, and the fields referenced in print fmt are the information we can obtain in the ebpf program. From the above, we can see that we can obtain the dfd, filename, and mode information of the sys_enter_fchmodat event, which includes the file name and permission mode information mentioned earlier. Determining the Parameters of the Event Handling Function The fourth step is to determine the parameter types of the function. After knowing the information that the event itself can provide, we also need to know how to read this information in the ebpf program. This involves how to confirm what the parameters of the ebpf event handling function are so that we can obtain the information contained in the event from the function&#39;s input parameters. Based on vmlinux.h One way is to search in the vmlinux.h file. Generally, sys_enter_xx corresponds to trace_event_raw_sys_enter, sys_exit_xx corresponds to trace_event_raw_sys_exit, and others generally correspond to trace_event_raw_&lt;name&gt;. If not found, you can refer to the example of trace_event_raw_sys_enter to find a similar struct. For sys_enter_fchmodat, we use the struct trace_event_raw_sys_enter: struct trace_event_raw_sys_enter { struct trace_entry ent; long int id; long unsigned int args[6]; char __data[0]; }; In this struct, the field args stores the information that the event is related to, which corresponds to the fields included in the fmt in the format file in the third step. Therefore, we can obtain the dfd with args[0], filename with args[1], and so on. Now that the information is determined, we can write the program. For example, the example ebpf program for the sys_enter_fchmodat event is as follows: SEC(&#34;tracepoint/syscalls/sys_enter_fchmodat&#34;) int tracepoint__syscalls__sys_enter_fchmodat(struct trace_event_raw_sys_enter *ctx) { // ... char *filename_ptr = (char *) BPF_CORE_READ(ctx, args[1]); bpf_core_read_user_str(&amp;event-&gt;filename, sizeof(event-&gt;filename), filename_ptr); event-&gt;mode = BPF_CORE_READ(ctx, args[2]); // ... } Refer to the following links for complete examples using this method: tracepoint/syscalls/sys_enter_fchmodat: 07-tracepoint-args tracepoint/sched/sched_switch: 14-tracepoint-args-sched_switch Manually Constructing the Parameter Structure In addition to using the pre-defined structures in vmlinux.h, we can also customize a structure based on the content of the format file in the third step as the parameter of the eBPF program. For example, the contents of the file /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format for the sys_enter_fchmodat event are as follows: $ sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format name: sys_enter_fchmodat ID: 647 format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:int dfd; offset:16; size:8; signed:0; field:const char * filename; offset:24; size:8; signed:0; field:umode_t mode; offset:32; size:8; signed:0; print fmt: &#34;dfd: 0x%08lx, filename: 0x%08lx, mode: 0x%08lx&#34;, ((unsigned long)(REC-&gt;dfd)), ((unsigned long)(REC-&gt;filename)), ((unsigned long)(REC-&gt;mode)) Based on this information, we can define the following structure as the parameter of the eBPF event handling function: struct sys_enter_fchmodat_args { char _[16]; long dfd; long filename_ptr; long mode; }; In this structure, we first represent the content of the first 16 bytes with char _[16], which corresponds to all the fields before dfd in the format file. Then we define the dfd, filename, and mode fields that our program wants to obtain one by one. The reason for using the long type is to ensure that the size of each member is 8 bytes as indicated in the format (the size of each field member in each event is different and needs to be adjusted according to the actual content of the format file), and you can also use other types, but you need to ensure that the offset of each field member is consistent with the description in the format. The example ebpf program using the manually constructed custom structure as a parameter for the sys_enter_fchmodat event is as follows: SEC(&#34;tracepoint/syscalls/sys_enter_fchmodat&#34;) int tracepoint__syscalls__sys_enter_fchmodat(struct sys_enter_fchmodat_args *ctx) { // ... char *filename_ptr = (char *)ctx-&gt;filename_ptr; bpf_core_read_user_str(&amp;event-&gt;filename, sizeof(event-&gt;filename), filename_ptr); event-&gt;mode = (u32)ctx-&gt;mode; // ... } Refer to the following links for complete examples using this method: tracepoint/syscalls/sys_enter_fchmodat: 35-tracepoint-args-use-custom-struct tracepoint/sched/sched_switch: 36-tracepoint-args-sched_switch-use-custom-struct References BPF CO-RE reference guide libbpf/libbpf.c at 12e932ac0e18546dd7247e66ea1b4aa236d2ef38 · libbpf/libbpf BCC to libbpf conversion guide [1]perf, bpf: allow bpf programs attach to tracepoints · torvalds/linux@98b5c2c"/>
        <meta property="article:published_time" content="2022-05-15" />
            <meta property="article:section" content="ebpf" />
            <meta property="article:tag" content="ebpf" />
            <meta property="article:tag" content="tracepoint" />
            <meta property="article:tag" content="libbpf" />
            <meta property="article:tag" content="libbpfgo" />
            <meta property="article:tag" content="go" />
            <meta property="article:tag" content="golang" />
            <meta property="article:tag" content="en-version" />
            <meta property="article:author" content="mozillazg" />
            <meta property="og:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>


    <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@mozillazg">
        <meta name="twitter:creator" content="@mozillazg">
    <meta name="twitter:domain" content="https://mozillazg.com">
            <meta property="twitter:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="/theme/cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/css/bootstrap.min.css" type="text/css"/>
    <link href="/theme/cdn.jsdelivr.net/npm/font-awesome@4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link href="/theme/cdn.jsdelivr.net/npm/pygments-css@1.0.0/github.css" rel="stylesheet">
    <link rel="stylesheet" href="https://mozillazg.com/theme/css/style.css" type="text/css"/>
            <link href="/static/han.min.css" rel="stylesheet">
            <link href="/static/yue.css" rel="stylesheet">
            <link href="/static/custom.css" rel="stylesheet">

        <link href="https://mozillazg.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog ATOM Feed"/>

        <link href="https://mozillazg.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="mozillazg's Blog RSS Feed"/>


        <link href="https://mozillazg.com/feeds/ebpf.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog ebpf ATOM Feed"/>


    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "publisher": {
            "@type": "Person",
            "name": "mozillazg",
            "logo": "https://mozillazg.com/static/avatar.jpeg"
        },
        "author": {
            "@type": "Person",
            "name": "mozillazg",
            "image": "https://mozillazg.com/static/avatar.jpeg",
            "url": "https://mozillazg.com",
            "sameAs": []
        },
        "headline": "Frequently asked questions about using tracepoint with ebpf/libbpf programs",
        "url": "https://mozillazg.com/2022/05/ebpf-libbpf-tracepoint-common-questions-en.html",
        "image": [
            "https://mozillazg.com/static/avatar.jpeg"
         ],
        "keywords": "ebpf, tracepoint, libbpf, libbpfgo, go, golang, en-version",
        "description": "Preface This article aims to address common issues related to tracepoints when writing eBPF/libbpf programs (such as writing ebpf programs of type BPF_PROG_TYPE_TRACEPOINT). Types of eBPF Programs This article focuses on the eBPF program type called BPF_PROG_TYPE_TRACEPOINT. Events that can be Monitored by Tracepoints You can find the events that can be monitored by tracepoints by viewing the contents of the file /sys/kernel/debug/tracing/available_events. Each line in the file follows the format: &lt;category&gt;:&lt;name&gt; For example: syscalls:sys_enter_execve Format of SEC Content The SEC format corresponding to the tracepoint event is: SEC(&#34;tracepoint/&lt;category&gt;/&lt;name&gt;&#34;) // For example: // SEC(&#34;tracepoint/syscalls/sys_enter_openat&#34;) or: SEC(&#34;tp/&lt;category&gt;/&lt;name&gt;&#34;) // For example: // SEC(&#34;tp/syscalls/sys_enter_openat&#34;) The values of &lt;category&gt; and &lt;name&gt; are taken from the contents listed in the available_events file. SEC(&#34;tp/xx/yy&#34;) and SEC(&#34;tracepoint/xx/yy&#34;) are actually equivalent, and you can use either one according to personal preference. How to Determine the Parameter Types of the Tracepoint Event Handling Function and Obtain the Corresponding Kernel Call Parameters Suppose we want to trace the chmod command and the fchmodat system call involved in it. Then, how do we determine the parameter types of the event handling function in the ebpf program and how to obtain the content of the corresponding parameters involved in the fchmodat system call, such as the file name and the value of the mode permission. Determining the Tracepoint Event to be Tracked The first step is to determine the system call used by chmod, which can be done in various ways, such as using the strace command: $ strace chmod 600 a.txt ... fchmodat(AT_FDCWD, &#34;a.txt&#34;, 0600) = 0 ... The second step is to find the tracepoint event that can be used for this system call: $ sudo cat /sys/kernel/debug/tracing/available_events |grep fchmodat syscalls:sys_exit_fchmodat syscalls:sys_enter_fchmodat We can see that there are two events: sys_enter_fchmodat and sys_exit_fchmodat. Here, we choose the sys_enter_fchmodat event for further explanation. Determining the Information Included in the Event The third step is to determine what information the event itself can provide. Although we know that the fchmodat system call requires the file name and mode information, we are not sure if we can obtain this information in the ebpf program. You can obtain the information by viewing the contents of the file /sys/kernel/debug/tracing/events/&lt;category&gt;/&lt;name&gt;/format. For example, the contents of the file /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format for the sys_enter_fchmodat event are as follows: $ sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format name: sys_enter_fchmodat ID: 647 format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:int dfd; offset:16; size:8; signed:0; field:const char * filename; offset:24; size:8; signed:0; field:umode_t mode; offset:32; size:8; signed:0; print fmt: &#34;dfd: 0x%08lx, filename: 0x%08lx, mode: 0x%08lx&#34;, ((unsigned long)(REC-&gt;dfd)), ((unsigned long)(REC-&gt;filename)), ((unsigned long)(REC-&gt;mode)) The fields listed in format cannot be directly accessed by ordinary ebpf programs for the first 8 bytes (some bpf helpers can access them) [1]. Other fields can generally be accessed, and the fields referenced in print fmt are the information we can obtain in the ebpf program. From the above, we can see that we can obtain the dfd, filename, and mode information of the sys_enter_fchmodat event, which includes the file name and permission mode information mentioned earlier. Determining the Parameters of the Event Handling Function The fourth step is to determine the parameter types of the function. After knowing the information that the event itself can provide, we also need to know how to read this information in the ebpf program. This involves how to confirm what the parameters of the ebpf event handling function are so that we can obtain the information contained in the event from the function&#39;s input parameters. Based on vmlinux.h One way is to search in the vmlinux.h file. Generally, sys_enter_xx corresponds to trace_event_raw_sys_enter, sys_exit_xx corresponds to trace_event_raw_sys_exit, and others generally correspond to trace_event_raw_&lt;name&gt;. If not found, you can refer to the example of trace_event_raw_sys_enter to find a similar struct. For sys_enter_fchmodat, we use the struct trace_event_raw_sys_enter: struct trace_event_raw_sys_enter { struct trace_entry ent; long int id; long unsigned int args[6]; char __data[0]; }; In this struct, the field args stores the information that the event is related to, which corresponds to the fields included in the fmt in the format file in the third step. Therefore, we can obtain the dfd with args[0], filename with args[1], and so on. Now that the information is determined, we can write the program. For example, the example ebpf program for the sys_enter_fchmodat event is as follows: SEC(&#34;tracepoint/syscalls/sys_enter_fchmodat&#34;) int tracepoint__syscalls__sys_enter_fchmodat(struct trace_event_raw_sys_enter *ctx) { // ... char *filename_ptr = (char *) BPF_CORE_READ(ctx, args[1]); bpf_core_read_user_str(&amp;event-&gt;filename, sizeof(event-&gt;filename), filename_ptr); event-&gt;mode = BPF_CORE_READ(ctx, args[2]); // ... } Refer to the following links for complete examples using this method: tracepoint/syscalls/sys_enter_fchmodat: 07-tracepoint-args tracepoint/sched/sched_switch: 14-tracepoint-args-sched_switch Manually Constructing the Parameter Structure In addition to using the pre-defined structures in vmlinux.h, we can also customize a structure based on the content of the format file in the third step as the parameter of the eBPF program. For example, the contents of the file /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format for the sys_enter_fchmodat event are as follows: $ sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format name: sys_enter_fchmodat ID: 647 format: field:unsigned short common_type; offset:0; size:2; signed:0; field:unsigned char common_flags; offset:2; size:1; signed:0; field:unsigned char common_preempt_count; offset:3; size:1; signed:0; field:int common_pid; offset:4; size:4; signed:1; field:int __syscall_nr; offset:8; size:4; signed:1; field:int dfd; offset:16; size:8; signed:0; field:const char * filename; offset:24; size:8; signed:0; field:umode_t mode; offset:32; size:8; signed:0; print fmt: &#34;dfd: 0x%08lx, filename: 0x%08lx, mode: 0x%08lx&#34;, ((unsigned long)(REC-&gt;dfd)), ((unsigned long)(REC-&gt;filename)), ((unsigned long)(REC-&gt;mode)) Based on this information, we can define the following structure as the parameter of the eBPF event handling function: struct sys_enter_fchmodat_args { char _[16]; long dfd; long filename_ptr; long mode; }; In this structure, we first represent the content of the first 16 bytes with char _[16], which corresponds to all the fields before dfd in the format file. Then we define the dfd, filename, and mode fields that our program wants to obtain one by one. The reason for using the long type is to ensure that the size of each member is 8 bytes as indicated in the format (the size of each field member in each event is different and needs to be adjusted according to the actual content of the format file), and you can also use other types, but you need to ensure that the offset of each field member is consistent with the description in the format. The example ebpf program using the manually constructed custom structure as a parameter for the sys_enter_fchmodat event is as follows: SEC(&#34;tracepoint/syscalls/sys_enter_fchmodat&#34;) int tracepoint__syscalls__sys_enter_fchmodat(struct sys_enter_fchmodat_args *ctx) { // ... char *filename_ptr = (char *)ctx-&gt;filename_ptr; bpf_core_read_user_str(&amp;event-&gt;filename, sizeof(event-&gt;filename), filename_ptr); event-&gt;mode = (u32)ctx-&gt;mode; // ... } Refer to the following links for complete examples using this method: tracepoint/syscalls/sys_enter_fchmodat: 35-tracepoint-args-use-custom-struct tracepoint/sched/sched_switch: 36-tracepoint-args-sched_switch-use-custom-struct References BPF CO-RE reference guide libbpf/libbpf.c at 12e932ac0e18546dd7247e66ea1b4aa236d2ef38 · libbpf/libbpf BCC to libbpf conversion guide [1]perf, bpf: allow bpf programs attach to tracepoints · torvalds/linux@98b5c2c",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "https://mozillazg.com/2022/05/ebpf-libbpf-tracepoint-common-questions-en.html"
        },
        "datePublished": "2022-05-15"
    }
    </script>

</head>
<body>

<div class="navbar" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://mozillazg.com/" class="navbar-brand">
mozillazg's Blog            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="https://mozillazg.com/feeds/all.atom.xml">Feed</a></li>
                    <li><a href="/2014/10/pages/about-me.html">About</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://mozillazg.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content" class="yue">
        <article>
            <header class="text-center">
                <h1>
                    <a href="https://mozillazg.com/2022/05/ebpf-libbpf-tracepoint-common-questions-en.html"
                       rel="bookmark"
                       title="Permalink to Frequently asked questions about using tracepoint with ebpf/libbpf programs">
                        Frequently asked questions about using tracepoint with ebpf/libbpf programs
                    </a>
                </h1>
                <p class="published">
                    <time datetime="2022-05-15T00:00:00+00:00">
                    2022-05-15
                    </time>
                </p>
            </header>
            <div class="entry-content">
                <div class="well-sm article-info">
<footer class="post-info">
        <a href="https://mozillazg.com/category/ebpf.html">ebpf</a>


<span class="label label-default hide">Tags</span>
	<a href="https://mozillazg.com/tag/tracepoint.html">tracepoint</a>
        /
	<a href="https://mozillazg.com/tag/libbpf.html">libbpf</a>
        /
	<a href="https://mozillazg.com/tag/libbpfgo.html">libbpfgo</a>
        /
	<a href="https://mozillazg.com/tag/go.html">go</a>
        /
	<a href="https://mozillazg.com/tag/golang.html">golang</a>
        /
	<a href="https://mozillazg.com/tag/en-version.html">en-version</a>
    <span class="label label-default">Lang</span>
	<a href="https://mozillazg.com/2022/05/ebpf-libbpf-tracepoint-common-questions.html">zh</a>

</footer><!-- /.post-info -->                </div>
                <div class="js-toc"></div>
                <div>
                <div class="section" id="preface">
<h2 id="hidpreface">Preface<a class="headerlink" href="#hidpreface" title="Permalink to this headline">¶</a></h2>
<p>This article aims to address common issues related to tracepoints when writing eBPF/libbpf programs (such as writing ebpf programs of type <tt class="docutils literal">BPF_PROG_TYPE_TRACEPOINT</tt>).</p>
</div>
<div class="section" id="types-of-ebpf-programs">
<h2 id="hidtypes-of-ebpf-programs">Types of eBPF Programs<a class="headerlink" href="#hidtypes-of-ebpf-programs" title="Permalink to this headline">¶</a></h2>
<p>This article focuses on the eBPF program type called <tt class="docutils literal">BPF_PROG_TYPE_TRACEPOINT</tt>.</p>
</div>
<div class="section" id="events-that-can-be-monitored-by-tracepoints">
<h2 id="hidevents-that-can-be-monitored-by-tracepoints">Events that can be Monitored by Tracepoints<a class="headerlink" href="#hidevents-that-can-be-monitored-by-tracepoints" title="Permalink to this headline">¶</a></h2>
<p>You can find the events that can be monitored by tracepoints by viewing the contents of the file <tt class="docutils literal">/sys/kernel/debug/tracing/available_events</tt>.
Each line in the file follows the format:</p>
<pre class="literal-block">
&lt;category&gt;:&lt;name&gt;
</pre>
<p>For example:</p>
<pre class="literal-block">
syscalls:sys_enter_execve
</pre>
</div>
<div class="section" id="format-of-sec-content">
<h2 id="hidformat-of-sec-content">Format of SEC Content<a class="headerlink" href="#hidformat-of-sec-content" title="Permalink to this headline">¶</a></h2>
<p>The SEC format corresponding to the tracepoint event is:</p>
<pre class="literal-block">
SEC(&quot;tracepoint/&lt;category&gt;/&lt;name&gt;&quot;)

// For example:
// SEC(&quot;tracepoint/syscalls/sys_enter_openat&quot;)
</pre>
<p>or:</p>
<pre class="literal-block">
SEC(&quot;tp/&lt;category&gt;/&lt;name&gt;&quot;)

// For example:
// SEC(&quot;tp/syscalls/sys_enter_openat&quot;)
</pre>
<p>The values of <tt class="docutils literal">&lt;category&gt;</tt> and <tt class="docutils literal">&lt;name&gt;</tt> are taken from the contents listed in the available_events file.</p>
<p><tt class="docutils literal"><span class="pre">SEC(&quot;tp/xx/yy&quot;)</span></tt> and <tt class="docutils literal"><span class="pre">SEC(&quot;tracepoint/xx/yy&quot;)</span></tt> are actually equivalent, and you can use either one according to personal preference.</p>
</div>
<div class="section" id="how-to-determine-the-parameter-types-of-the-tracepoint-event-handling-function-and-obtain-the-corresponding-kernel-call-parameters">
<h2 id="hidhow-to-determine-the-parameter-types-of-the-tracepoint-event-handling-function-and-obtain-the-corresponding-kernel-call-parameters">How to Determine the Parameter Types of the Tracepoint Event Handling Function and Obtain the Corresponding Kernel Call Parameters<a class="headerlink" href="#hidhow-to-determine-the-parameter-types-of-the-tracepoint-event-handling-function-and-obtain-the-corresponding-kernel-call-parameters" title="Permalink to this headline">¶</a></h2>
<p>Suppose we want to trace the <tt class="docutils literal">chmod</tt> command and the <tt class="docutils literal">fchmodat</tt> system call involved in it.
Then, how do we determine the parameter types of the event handling function in the ebpf program and how to obtain the content of the corresponding parameters involved in the <tt class="docutils literal">fchmodat</tt> system call, such as the file name and the value of the mode permission.</p>
<div class="section" id="determining-the-tracepoint-event-to-be-tracked">
<h3 id="hiddetermining-the-tracepoint-event-to-be-tracked">Determining the Tracepoint Event to be Tracked<a class="headerlink" href="#hiddetermining-the-tracepoint-event-to-be-tracked" title="Permalink to this headline">¶</a></h3>
<p>The first step is to determine the system call used by <tt class="docutils literal">chmod</tt>, which can be done in various ways, such as using the <tt class="docutils literal">strace</tt> command:</p>
<pre class="literal-block">
$ strace chmod 600 a.txt
...
fchmodat(AT_FDCWD, &quot;a.txt&quot;, 0600)       = 0
...
</pre>
<p>The second step is to find the tracepoint event that can be used for this system call:</p>
<pre class="literal-block">
$ sudo cat /sys/kernel/debug/tracing/available_events |grep fchmodat
syscalls:sys_exit_fchmodat
syscalls:sys_enter_fchmodat
</pre>
<p>We can see that there are two events: <tt class="docutils literal">sys_enter_fchmodat</tt> and <tt class="docutils literal">sys_exit_fchmodat</tt>. Here, we choose the <tt class="docutils literal">sys_enter_fchmodat</tt> event for further explanation.</p>
</div>
<div class="section" id="determining-the-information-included-in-the-event">
<h3 id="hiddetermining-the-information-included-in-the-event">Determining the Information Included in the Event<a class="headerlink" href="#hiddetermining-the-information-included-in-the-event" title="Permalink to this headline">¶</a></h3>
<p>The third step is to determine what information the event itself can provide. Although we know that the <tt class="docutils literal">fchmodat</tt> system call requires the file name and mode information, we are not sure if we can obtain this information in the ebpf program.</p>
<p>You can obtain the information by viewing the contents of the file <tt class="docutils literal"><span class="pre">/sys/kernel/debug/tracing/events/&lt;category&gt;/&lt;name&gt;/format</span></tt>.</p>
<p>For example, the contents of the file <tt class="docutils literal">/sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format</tt> for the <tt class="docutils literal">sys_enter_fchmodat</tt> event are as follows:</p>
<pre class="literal-block">
$ sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format
name: sys_enter_fchmodat
ID: 647
format:
        field:unsigned short common_type;       offset:0;       size:2; signed:0;
        field:unsigned char common_flags;       offset:2;       size:1; signed:0;
        field:unsigned char common_preempt_count;       offset:3;       size:1; signed:0;
        field:int common_pid;   offset:4;       size:4; signed:1;

        field:int __syscall_nr; offset:8;       size:4; signed:1;
        field:int dfd;  offset:16;      size:8; signed:0;
        field:const char * filename;    offset:24;      size:8; signed:0;
        field:umode_t mode;     offset:32;      size:8; signed:0;

print fmt: &quot;dfd: 0x%08lx, filename: 0x%08lx, mode: 0x%08lx&quot;, ((unsigned long)(REC-&gt;dfd)), ((unsigned long)(REC-&gt;filename)), ((unsigned long)(REC-&gt;mode))
</pre>
<p>The fields listed in <tt class="docutils literal">format</tt> cannot be directly accessed by ordinary ebpf programs for the first 8 bytes (some bpf helpers can access them) <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a>.
Other fields can generally be accessed, and the fields referenced in <tt class="docutils literal">print fmt</tt> are the information we can obtain in the ebpf program.</p>
<p>From the above, we can see that we can obtain the <tt class="docutils literal">dfd</tt>, <tt class="docutils literal">filename</tt>, and <tt class="docutils literal">mode</tt> information of the <tt class="docutils literal">sys_enter_fchmodat</tt> event, which includes the file name and permission mode information mentioned earlier.</p>
</div>
<div class="section" id="determining-the-parameters-of-the-event-handling-function">
<h3 id="hiddetermining-the-parameters-of-the-event-handling-function">Determining the Parameters of the Event Handling Function<a class="headerlink" href="#hiddetermining-the-parameters-of-the-event-handling-function" title="Permalink to this headline">¶</a></h3>
<p>The fourth step is to determine the parameter types of the function. After knowing the information that the event itself can provide, we also need to know how to read this information in the ebpf program.
This involves how to confirm what the parameters of the ebpf event handling function are so that we can obtain the information contained in the event from the function's input parameters.</p>
<div class="section" id="based-on-vmlinux-h">
<h4 id="hidbased-on-vmlinux-h">Based on vmlinux.h<a class="headerlink" href="#hidbased-on-vmlinux-h" title="Permalink to this headline">¶</a></h4>
<p>One way is to search in the <tt class="docutils literal">vmlinux.h</tt> file.
Generally, <tt class="docutils literal">sys_enter_xx</tt> corresponds to <tt class="docutils literal">trace_event_raw_sys_enter</tt>,
<tt class="docutils literal">sys_exit_xx</tt> corresponds to <tt class="docutils literal">trace_event_raw_sys_exit</tt>,
and others generally correspond to <tt class="docutils literal">trace_event_raw_&lt;name&gt;</tt>.
If not found, you can refer to the example of <tt class="docutils literal">trace_event_raw_sys_enter</tt> to find a similar struct.</p>
<p>For <tt class="docutils literal">sys_enter_fchmodat</tt>, we use the struct <tt class="docutils literal">trace_event_raw_sys_enter</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">trace_event_raw_sys_enter</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">trace_entry</span><span class="w"> </span><span class="n">ent</span><span class="p">;</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">__data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
<p>In this struct, the field <tt class="docutils literal">args</tt> stores the information that the event is related to, which corresponds to the fields included in the <tt class="docutils literal">fmt</tt> in the format file in the third step.
Therefore, we can obtain the <tt class="docutils literal">dfd</tt> with <tt class="docutils literal">args[0]</tt>, <tt class="docutils literal">filename</tt> with <tt class="docutils literal">args[1]</tt>, and so on.</p>
<p>Now that the information is determined, we can write the program. For example, the example ebpf program for the <tt class="docutils literal">sys_enter_fchmodat</tt> event is as follows:</p>
<div class="highlight"><pre><span></span><span class="n">SEC</span><span class="p">(</span><span class="s">&quot;tracepoint/syscalls/sys_enter_fchmodat&quot;</span><span class="p">)</span>
<span class="kt">int</span><span class="w"> </span><span class="n">tracepoint__syscalls__sys_enter_fchmodat</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">trace_event_raw_sys_enter</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>

<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">filename_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">BPF_CORE_READ</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">        </span><span class="n">bpf_core_read_user_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">),</span><span class="w"> </span><span class="n">filename_ptr</span><span class="p">);</span>
<span class="w">        </span><span class="n">event</span><span class="o">-&gt;</span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BPF_CORE_READ</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

<span class="w">        </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>Refer to the following links for complete examples using this method:</p>
<ul class="simple">
<li><tt class="docutils literal">tracepoint/syscalls/sys_enter_fchmodat</tt>: <a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/07-tracepoint-args">07-tracepoint-args</a></li>
<li><tt class="docutils literal">tracepoint/sched/sched_switch</tt>: <a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/14-tracepoint-args-sched_switch">14-tracepoint-args-sched_switch</a></li>
</ul>
</div>
<div class="section" id="manually-constructing-the-parameter-structure">
<h4 id="hidmanually-constructing-the-parameter-structure">Manually Constructing the Parameter Structure<a class="headerlink" href="#hidmanually-constructing-the-parameter-structure" title="Permalink to this headline">¶</a></h4>
<p>In addition to using the pre-defined structures in vmlinux.h, we can also customize a structure based on the content of the format file in the third step as the parameter of the eBPF program.
For example, the contents of the file <tt class="docutils literal">/sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format</tt> for the <tt class="docutils literal">sys_enter_fchmodat</tt> event are as follows:</p>
<pre class="literal-block">
$ sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format
name: sys_enter_fchmodat
ID: 647
format:
        field:unsigned short common_type;       offset:0;       size:2; signed:0;
        field:unsigned char common_flags;       offset:2;       size:1; signed:0;
        field:unsigned char common_preempt_count;       offset:3;       size:1; signed:0;
        field:int common_pid;   offset:4;       size:4; signed:1;

        field:int __syscall_nr; offset:8;       size:4; signed:1;
        field:int dfd;  offset:16;      size:8; signed:0;
        field:const char * filename;    offset:24;      size:8; signed:0;
        field:umode_t mode;     offset:32;      size:8; signed:0;

print fmt: &quot;dfd: 0x%08lx, filename: 0x%08lx, mode: 0x%08lx&quot;, ((unsigned long)(REC-&gt;dfd)), ((unsigned long)(REC-&gt;filename)), ((unsigned long)(REC-&gt;mode))
</pre>
<p>Based on this information, we can define the following structure as the parameter of the eBPF event handling function:</p>
<div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">sys_enter_fchmodat_args</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">_</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">dfd</span><span class="p">;</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">filename_ptr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">mode</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>In this structure, we first represent the content of the first 16 bytes with <tt class="docutils literal">char _[16]</tt>, which corresponds to all the fields before <tt class="docutils literal">dfd</tt> in the format file.
Then we define the <tt class="docutils literal">dfd</tt>, <tt class="docutils literal">filename</tt>, and <tt class="docutils literal">mode</tt> fields that our program wants to obtain one by one.
The reason for using the <tt class="docutils literal">long</tt> type is to ensure that the size of each member is 8 bytes as indicated in the format (the size of each field member in each event is different and needs to be adjusted according to the actual content of the format file),
and you can also use other types, but you need to ensure that the offset of each field member is consistent with the description in the format.</p>
<p>The example ebpf program using the manually constructed custom structure as a parameter for the <tt class="docutils literal">sys_enter_fchmodat</tt> event is as follows:</p>
<div class="highlight"><pre><span></span><span class="n">SEC</span><span class="p">(</span><span class="s">&quot;tracepoint/syscalls/sys_enter_fchmodat&quot;</span><span class="p">)</span>
<span class="kt">int</span><span class="w"> </span><span class="n">tracepoint__syscalls__sys_enter_fchmodat</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sys_enter_fchmodat_args</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>

<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">filename_ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">filename_ptr</span><span class="p">;</span>
<span class="w">    </span><span class="n">bpf_core_read_user_str</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">),</span><span class="w"> </span><span class="n">filename_ptr</span><span class="p">);</span>
<span class="w">    </span><span class="n">event</span><span class="o">-&gt;</span><span class="n">mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
<p>Refer to the following links for complete examples using this method:</p>
<ul class="simple">
<li><tt class="docutils literal">tracepoint/syscalls/sys_enter_fchmodat</tt>: <a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/35-tracepoint-args-use-custom-struct">35-tracepoint-args-use-custom-struct</a></li>
<li><tt class="docutils literal">tracepoint/sched/sched_switch</tt>: <a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/36-tracepoint-args-sched_switch-use-custom-struct">36-tracepoint-args-sched_switch-use-custom-struct</a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="references">
<h2 id="hidreferences">References<a class="headerlink" href="#hidreferences" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://nakryiko.com/posts/bpf-core-reference-guide/">BPF CO-RE reference guide</a></li>
<li><a class="reference external" href="https://github.com/libbpf/libbpf/blob/12e932ac0e18546dd7247e66ea1b4aa236d2ef38/src/libbpf.c#L9002-L9081">libbpf/libbpf.c at 12e932ac0e18546dd7247e66ea1b4aa236d2ef38 · libbpf/libbpf</a></li>
<li><a class="reference external" href="https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/">BCC to libbpf conversion guide</a></li>
</ul>
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td><a class="reference external" href="https://github.com/torvalds/linux/commit/98b5c2c65c2951772a8fc661f50d675e450e8bce">perf, bpf: allow bpf programs attach to tracepoints · torvalds/linux&#64;98b5c2c</a></td></tr>
</tbody>
</table>
</div>

                </div>
            </div>
            <!-- /.entry-content -->
<section class="text-center">
  
<div id="donate"></div>

<div class="social-share"></div>
<div class="social-comment-note">
<p class="text-center">有任何建议和想法欢迎在下方评论区留言或者加我<a href="/static/wechat.png">微信</a>交流</p>
</div>

</section>
<hr/>
<section class="comments" id="comments">
    <h2>Comments</h2>
    <script src="https://giscus.app/client.js"
            data-repo="mozillazg/mozillazg.github.com"
            data-repo-id="MDEwOlJlcG9zaXRvcnk3Njc4MTA2"
            data-category="Announcements"
            data-category-id="DIC_kwDOAHUoms4CckZl"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="0"
            data-input-position="bottom"
            data-theme="preferred_color_scheme"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
    </script>
</section>
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2024 mozillazg
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>
            &middot; <a href="/privacy-policy.html" target="_blank">Privacy</a>              <p><small>  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/static/images/by-sa-80x15.png" /></a>
    &quot;<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">mozillazg's Blog</span>&quot; by <a xmlns:cc="http://creativecommons.org/ns#" href="https://mozillazg.com" property="cc:attributionName" rel="cc:attributionURL">mozillazg</a> is
  licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="/theme/cdn.jsdelivr.net/npm/jquery@2.1.1/dist/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="/theme/cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->


<!-- share.js -->
<script src="/theme/cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>



<script src="/theme/cdn.jsdelivr.net/npm/tocbot@3.0.2/dist/tocbot.min.js"></script>
<script>
$(document).ready(function(){
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.js-toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.entry-content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h2, h3, h4,h5',
    // Headings that match the ignoreSelector will be skipped.
    ignoreSelector: '.js-toc-ignore',
    // Main class to add to links.
    linkClass: 'toc-link',
    // Extra classes to add to links.
    extraLinkClasses: '',
    // Class to add to active links,
    // the link corresponding to the top most heading on the page.
    activeLinkClass: 'is-active-link',
    // Main class to add to lists.
    listClass: 'toc-list',
    // Extra classes to add to lists.
    extraListClasses: '',
    // Class that gets added when a list should be collapsed.
    isCollapsedClass: 'is-collapsed',
    // Class that gets added when a list should be able
    // to be collapsed but isn't necessarily collpased.
    collapsibleClass: 'is-collapsible',
    // Class to add to list items.
    listItemClass: 'toc-list-item',
    // How many heading levels should not be collpased.
    // For example, number 6 will show everything since
    // there are only 6 heading levels and number 0 will collpase them all.
    // The sections that are hidden will open
    // and close as you scroll to headings within them.
    collapseDepth: 6,
    // Smooth scrolling enabled.
    smoothScroll: true,
    // Smooth scroll duration.
    smoothScrollDuration: 420,
    // Callback for scroll end (requires: smoothScroll).
    scrollEndCallback: function (e) {},
    // Headings offset between the headings and the top of the document (this is meant for minor adjustments).
    headingsOffset: 0,
    // Timeout between events firing to make sure it's
    // not too rapid (for performance reasons).
    throttleTimeout: 50,
    // Element to add the positionFixedClass to.
    positionFixedSelector: null,
    // Fixed position class to add to make sidebar fixed after scrolling
    // down past the fixedSidebarOffset.
    positionFixedClass: 'is-position-fixed',
    // fixedSidebarOffset can be any number but by default is set
    // to auto which sets the fixedSidebarOffset to the sidebar
    // element's offsetTop from the top of the document on init.
    fixedSidebarOffset: 'auto',
    // includeHtml can be set to true to include the HTML markup from the
    // heading node instead of just including the textContent.
    includeHtml: false
  });
});
</script>
</body>
</html>