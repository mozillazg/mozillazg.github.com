<!DOCTYPE html>
<html lang="zh"  prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml" class="han-init">
<head>
    <title>Python: time.sleep 与 signal 一起使用可能会出现 sleep 被提前终止的情况 - mozillazg's Blog</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- share.css -->
    <link rel="stylesheet" href="/theme/cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">


    <link href="https://mozillazg.com/favicon.ico" rel="icon">

<link rel="canonical" href="https://mozillazg.com/2017/07/python-time-sleep-terminate-by-signal.html">

        <meta name="author" content="mozillazg" />
        <meta name="keywords" content="python,signal" />
    <meta name="description" content="如题所述，当 time.sleep 与 signal 一起使用时可能会出现 time.sleep 失效，提前结束 sleep 的问题。 我们先来看一下 time.sleep 的文档: Python 2.7.13: time.sleep(secs) Suspend execution of the current thread for the given number of seconds. The argument may be a floating point number to indicate a more precise sleep time. The actual suspension time may be less than that requested because any caught signal will terminate the sleep() following execution of that signal’s catching routine. Also, the suspension time may be longer than requested by an arbitrary amount because of the scheduling of other activity in the system. Python 3.6.2: time.sleep(secs) Suspend execution of the calling thread for the given number of seconds. The argument may be a floating point number to indicate a more precise sleep time. The actual suspension time may be less than that requested because any caught signal will terminate the sleep() following execution of that signal’s catching routine. Also, the suspension time may be longer than requested by an arbitrary amount because of the scheduling of other activity in the system. Changed in version 3.5: The function now sleeps at least secs even if the sleep is interrupted by a signal, except if the signal handler raises an exception (see PEP 475 for the rationale). 通过文档可以看到，在 Python 2 下，当定义了 signal handler 并接收到 signal 时， time.sleep 会提前返回， 在 Python 3.5+ 下，没有这个问题，只是在 signal handler 抛异常时 sleep 会被终止 。 下面我们就来验证一下这个问题。 测试环境 os: mac os python: python2.7, python3.6 Python 2 普通 sleep 程序 先来看一个正常 sleep 的程序: $ cat time_a.py import logging import time logging.basicConfig( level=logging.DEBUG, format=&#39;%(asctime)-15s - %(levelname)s - %(message)s&#39; ) n = 60 logging.info(&#39;start sleep %s seconds&#39;, n) start = time.time() time.sleep(n) logging.info(&#39;end sleep %s seconds, spend %s&#39;, n, time.time() - start) 测试: $ python time_a.py 2017-07-16 15:29:05,323 - INFO - start sleep 60 seconds 2017-07-16 15:30:05,327 - INFO - end sleep 60 seconds, spend 60.0042099953 可以看到确实 sleep 了 60 秒。 signal 给普通的 sleep 程序发个 signal 试试: $ python time_a.py &amp; [1] 6208 $ 2017-07-16 15:44:01,290 - INFO - start sleep 60 seconds $ kill -s SIGHUP 6208 [1]+ Hangup: 1 python time_a.py 因为 SIGHUP 的默认行为就是终止程序，所以程序终止了。 我们下面来测试自定义 signal handler 的影响。 signal handler 测试程序如下： $ cat time_b.py import logging import signal import time logging.basicConfig( level=logging.DEBUG, format=&#39;%(asctime)-15s - %(levelname)s - %(message)s&#39; ) n = 60 def handler(sig, strace): logging.info(&#39;recived %s&#39;, sig) signal.signal(signal.SIGHUP, handler) logging.info(&#39;start sleep %s seconds&#39;, n) start = time.time() time.sleep(n) logging.info(&#39;end sleep %s seconds, spend %s&#39;, n, time.time() - start) 测试: $ python time_b.py &amp; [1] 5910 2017-07-16 15:31:46,448 - INFO - start sleep 60 seconds $ kill -s SIGHUP 5910 2017-07-16 15:31:52,180 - INFO - recived 1 2017-07-16 15:31:52,181 - INFO - end sleep 60 seconds, spend 5.73180794716 [1]+ Done python time_b.py 从测试结果可以看到，当收到 signal 后，sleep 就提前结束了， 60 秒的 sleep 实际只花了 6 秒钟。 下面再看看 Python 3 文档中提到的 handler 抛异常的情况。 signal handler raise exception 测试程序： $ cat time_c.py import logging import signal import time logging.basicConfig( level=logging.DEBUG, format=&#39;%(asctime)-15s - %(levelname)s - %(message)s&#39; ) n = 60 def handler(sig, strace): logging.info(&#39;recived %s&#39;, sig) raise Exception(&#39;test&#39;) signal.signal(signal.SIGHUP, handler) logging.info(&#39;start sleep %s seconds&#39;, n) start = time.time() try: time.sleep(n) except Exception as e: logging.exception(e) logging.info(&#39;end sleep %s seconds, spend %s&#39;, n, time.time() - start) 测试： $ python time_c.py &amp; [1] 6390 2017-07-16 16:09:31,340 - INFO - start sleep 60 seconds $ kill -s SIGHUP 6390 2017-07-16 16:09:35,328 - INFO - recived 1 2017-07-16 16:09:35,329 - ERROR - test Traceback (most recent call last): File &#34;time_c.py&#34;, line 21, in &lt;module&gt; time.sleep(n) File &#34;time_c.py&#34;, line 14, in handler raise Exception(&#39;test&#39;) Exception: test 2017-07-16 16:09:35,329 - INFO - end sleep 60 seconds, spend 3.988664150238037 [1]+ Done python time_c.py 可以看到，当 signal handler 抛异常时， time.sleep 会抛出异常提前终止 sleep 操作。 下面来测试 Python 3.5+ 下这四种情况的行为。 Python 3.5+ 普通 sleep 程序 用的还是之前的 time_a.py 文件，测试结果： $ python3.6 time_a.py 2017-07-16 16:12:28,566 - INFO - start sleep 60 seconds 2017-07-16 16:13:28,571 - INFO - end sleep 60 seconds, spend 60.00386714935303 可以看到，跟 Python 2 一样，正常 sleep. signal 同样试试给 time_a.py 进程发送 signal: $ python3.6 time_a.py &amp; [1] 6790 $ 2017-07-16 16:15:53,529 - INFO - start sleep 60 seconds $ kill -s SIGHUP 6790 [1]+ Hangup: 1 python3.6 time_a.py 跟 Python 2 下也是一样，进程终止。 signal handler 按照文档，当 signal handler 不错误的时候，应该可以正常 sleep, 下面我们试试看： $ python3.6 time_b.py &amp; [1] 6848 $ 2017-07-16 16:17:25,144 - INFO - start sleep 60 seconds $ kill -s SIGHUP 6848 2017-07-16 16:17:31,252 - INFO - recived 1 $ jobs [1]+ Running python3.6 time_b.py &amp; $ 2017-07-16 16:18:25,147 - INFO - end sleep 60 seconds, spend 60.00310564041138 [1]+ Done python3.6 time_b.py 确实跟文档中说的一样，就算收到并处理了 signal 还是可以正常 sleep 。👍 下面再看看 signal handler raise exception 的情况。 signal handler raise exception 测试： $ python3.6 time_c.py &amp; [1] 42908 2017-07-16 16:20:00,679 - INFO - start sleep 60 seconds $ kill -s SIGHUP 42908 2017-07-16 16:20:06,126 - INFO - recived 1 2017-07-16 16:20:06,126 - ERROR - test Traceback (most recent call last): File &#34;time_c.py&#34;, line 21, in &lt;module&gt; time.sleep(n) File &#34;time_c.py&#34;, line 14, in handler raise Exception(&#39;test&#39;) Exception: test 2017-07-16 16:20:06,127 - INFO - end sleep 60 seconds, spend 5.4475321769714355 [1]+ Done python3.6 time_c.py 可以看到，跟在 Python 2 下一样，当 signal handler 抛异常时，time.sleep 会抛出异常提前终止 sleep 操作。 原因 那么，为什么 Python 2 下 time.sleep 遇到 signal 时会出现提前返回的情况呢？ 在 gevent 的一个 issue 中 @jamadden 是 这样解释的 : The stdlib time.sleep method is implemented by calling select, passing in a timeout value, and no file descriptors to actually select on. The intended effect is to block in the operating system, sleeping until the timeout has elapsed. However, select is one of those system calls that is vulnerable to signals. When a signal is delivered to the process, select prematurely wakes up and sets errno to EINTR (interrupted). In that case, time.sleep makes no attempt to account for any unelapsed time; it simple returns. Therefore, time.sleep can sometimes return early. This is documented. 查看 python 2.7 的源代码以及 select 的文档可以确认这个解释： python 2.7 源码中 time.sleep 的 实现片段 如下： static int floatsleep(double secs) { /* XXX Should test for MS_WINDOWS first! */ #if defined(HAVE_SELECT) &amp;&amp; !defined(__BEOS__) &amp;&amp; !defined(__EMX__) struct timeval t; double frac; frac = fmod(secs, 1.0); secs = floor(secs); t.tv_sec = (long)secs; t.tv_usec = (long)(frac*1000000.0); Py_BEGIN_ALLOW_THREADS if (select(0, (fd_set *)0, (fd_set *)0, (fd_set *)0, &amp;t) != 0) { #ifdef EINTR if (errno != EINTR) { #else if (1) { #endif Py_BLOCK_THREADS PyErr_SetFromErrno(PyExc_IOError); return -1; } } 可以看到确实是用 select 来实现的 time.sleep 。 select 的 文档 中关于 signal 的说明如下： The timeout argument specifies the interval that select() should block waiting for a file descriptor to become ready. The call will block until either: a file descriptor becomes ready; the call is interrupted by a signal handler; or the timeout expires. 通过文档我们知道， select 的 timeout 的阻塞效果确实会被 signal handler 所中断。 至于 Python 3.5+ 为什么不会提前返回，是因为它的 time.sleep 实现中对于这种情况增加了判断，如果时间没到会用剩下的时间再次 sleep： static int pysleep(_PyTime_t secs) { // ... do { // ... monotonic = _PyTime_GetMonotonicClock(); secs = deadline - monotonic; if (secs &lt; 0) break; /* retry with the recomputed delay */ } while (1); return 0; } 启示 如果想在 Python 2 下实现类似 Python 3.5+ 下的效果，可以仿照 Python 3.5+ 下的实现增加“如果时间没到会用剩下的时间再次 sleep”的逻辑： 参考代码（修改自 time_b.py） $ cat time_d.py import logging import signal import time logging.basicConfig( level=logging.DEBUG, format=&#39;%(asctime)-15s - %(levelname)s - %(message)s&#39; ) n = 60 def handler(sig, strace): logging.info(&#39;recived %s&#39;, sig) signal.signal(signal.SIGHUP, handler) logging.info(&#39;start sleep %s seconds&#39;, n) start = time.time() remain = n while True: time.sleep(remain) remain = (start + n) - time.time() if remain &lt; 0: break else: logging.warn(&#39;retry sleep %s&#39;, remain) logging.info(&#39;end sleep %s seconds, spend %s&#39;, n, time.time() - start) 测试： $ python time_d.py &amp; [1] 14751 $ 2017-07-16 17:10:53,235 - INFO - start sleep 60 seconds $ kill -s SIGHUP 14751 2017-07-16 17:10:59,803 - INFO - recived 1 2017-07-16 17:10:59,803 - WARNING - retry sleep 53.4323399067 $ kill -s SIGHUP 14751 2017-07-16 17:11:44,792 - INFO - recived 1 2017-07-16 17:11:44,792 - WARNING - retry sleep 8.44309687614 $ 2017-07-16 17:11:53,239 - INFO - end sleep 60 seconds, spend 60.0035960674 [1]+ Done python time_d.py 最重要的一点是 ：不要觉得 time.sleep 会非常的精确，它有可能变快也有可能变慢，不要对它有过高的期望，不要依赖这个功能来实现需要精确 sleep 的需求。 目测可能也可以利用 python 2 下的这一行为实现一些特殊的需求。 好了，本文的内容就是这些了，希望这篇文章能对你有所帮助。 参考资料 15.3. time — Time access and conversions — Python 2.7.13 documentation 16.3. time — Time access and conversions — Python 3.6.2rc2 documentation gevent.subprocess.Popen alters the behavior of time.sleep · Issue #280 · gevent/gevent cpython/timemodule.c at 2.7 · python/cpython cpython/timemodule.c at 3.6 · python/cpython" />

    <style>
      .js-toc {
        margin-bottom: 20px;
      }
      .donate-modal {
        text-align: center;
      }
      #donate-modal-container .donate-image {
        max-height: 300px !important;
        min-height: inherit !important;
      }
    </style>

        <meta property="og:site_name" content="mozillazg's Blog" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Python: time.sleep 与 signal 一起使用可能会出现 sleep 被提前终止的情况"/>
        <meta property="og:url" content="https://mozillazg.com/2017/07/python-time-sleep-terminate-by-signal.html"/>
        <meta property="og:description" content="如题所述，当 time.sleep 与 signal 一起使用时可能会出现 time.sleep 失效，提前结束 sleep 的问题。 我们先来看一下 time.sleep 的文档: Python 2.7.13: time.sleep(secs) Suspend execution of the current thread for the given number of seconds. The argument may be a floating point number to indicate a more precise sleep time. The actual suspension time may be less than that requested because any caught signal will terminate the sleep() following execution of that signal’s catching routine. Also, the suspension time may be longer than requested by an arbitrary amount because of the scheduling of other activity in the system. Python 3.6.2: time.sleep(secs) Suspend execution of the calling thread for the given number of seconds. The argument may be a floating point number to indicate a more precise sleep time. The actual suspension time may be less than that requested because any caught signal will terminate the sleep() following execution of that signal’s catching routine. Also, the suspension time may be longer than requested by an arbitrary amount because of the scheduling of other activity in the system. Changed in version 3.5: The function now sleeps at least secs even if the sleep is interrupted by a signal, except if the signal handler raises an exception (see PEP 475 for the rationale). 通过文档可以看到，在 Python 2 下，当定义了 signal handler 并接收到 signal 时， time.sleep 会提前返回， 在 Python 3.5+ 下，没有这个问题，只是在 signal handler 抛异常时 sleep 会被终止 。 下面我们就来验证一下这个问题。 测试环境 os: mac os python: python2.7, python3.6 Python 2 普通 sleep 程序 先来看一个正常 sleep 的程序: $ cat time_a.py import logging import time logging.basicConfig( level=logging.DEBUG, format=&#39;%(asctime)-15s - %(levelname)s - %(message)s&#39; ) n = 60 logging.info(&#39;start sleep %s seconds&#39;, n) start = time.time() time.sleep(n) logging.info(&#39;end sleep %s seconds, spend %s&#39;, n, time.time() - start) 测试: $ python time_a.py 2017-07-16 15:29:05,323 - INFO - start sleep 60 seconds 2017-07-16 15:30:05,327 - INFO - end sleep 60 seconds, spend 60.0042099953 可以看到确实 sleep 了 60 秒。 signal 给普通的 sleep 程序发个 signal 试试: $ python time_a.py &amp; [1] 6208 $ 2017-07-16 15:44:01,290 - INFO - start sleep 60 seconds $ kill -s SIGHUP 6208 [1]+ Hangup: 1 python time_a.py 因为 SIGHUP 的默认行为就是终止程序，所以程序终止了。 我们下面来测试自定义 signal handler 的影响。 signal handler 测试程序如下： $ cat time_b.py import logging import signal import time logging.basicConfig( level=logging.DEBUG, format=&#39;%(asctime)-15s - %(levelname)s - %(message)s&#39; ) n = 60 def handler(sig, strace): logging.info(&#39;recived %s&#39;, sig) signal.signal(signal.SIGHUP, handler) logging.info(&#39;start sleep %s seconds&#39;, n) start = time.time() time.sleep(n) logging.info(&#39;end sleep %s seconds, spend %s&#39;, n, time.time() - start) 测试: $ python time_b.py &amp; [1] 5910 2017-07-16 15:31:46,448 - INFO - start sleep 60 seconds $ kill -s SIGHUP 5910 2017-07-16 15:31:52,180 - INFO - recived 1 2017-07-16 15:31:52,181 - INFO - end sleep 60 seconds, spend 5.73180794716 [1]+ Done python time_b.py 从测试结果可以看到，当收到 signal 后，sleep 就提前结束了， 60 秒的 sleep 实际只花了 6 秒钟。 下面再看看 Python 3 文档中提到的 handler 抛异常的情况。 signal handler raise exception 测试程序： $ cat time_c.py import logging import signal import time logging.basicConfig( level=logging.DEBUG, format=&#39;%(asctime)-15s - %(levelname)s - %(message)s&#39; ) n = 60 def handler(sig, strace): logging.info(&#39;recived %s&#39;, sig) raise Exception(&#39;test&#39;) signal.signal(signal.SIGHUP, handler) logging.info(&#39;start sleep %s seconds&#39;, n) start = time.time() try: time.sleep(n) except Exception as e: logging.exception(e) logging.info(&#39;end sleep %s seconds, spend %s&#39;, n, time.time() - start) 测试： $ python time_c.py &amp; [1] 6390 2017-07-16 16:09:31,340 - INFO - start sleep 60 seconds $ kill -s SIGHUP 6390 2017-07-16 16:09:35,328 - INFO - recived 1 2017-07-16 16:09:35,329 - ERROR - test Traceback (most recent call last): File &#34;time_c.py&#34;, line 21, in &lt;module&gt; time.sleep(n) File &#34;time_c.py&#34;, line 14, in handler raise Exception(&#39;test&#39;) Exception: test 2017-07-16 16:09:35,329 - INFO - end sleep 60 seconds, spend 3.988664150238037 [1]+ Done python time_c.py 可以看到，当 signal handler 抛异常时， time.sleep 会抛出异常提前终止 sleep 操作。 下面来测试 Python 3.5+ 下这四种情况的行为。 Python 3.5+ 普通 sleep 程序 用的还是之前的 time_a.py 文件，测试结果： $ python3.6 time_a.py 2017-07-16 16:12:28,566 - INFO - start sleep 60 seconds 2017-07-16 16:13:28,571 - INFO - end sleep 60 seconds, spend 60.00386714935303 可以看到，跟 Python 2 一样，正常 sleep. signal 同样试试给 time_a.py 进程发送 signal: $ python3.6 time_a.py &amp; [1] 6790 $ 2017-07-16 16:15:53,529 - INFO - start sleep 60 seconds $ kill -s SIGHUP 6790 [1]+ Hangup: 1 python3.6 time_a.py 跟 Python 2 下也是一样，进程终止。 signal handler 按照文档，当 signal handler 不错误的时候，应该可以正常 sleep, 下面我们试试看： $ python3.6 time_b.py &amp; [1] 6848 $ 2017-07-16 16:17:25,144 - INFO - start sleep 60 seconds $ kill -s SIGHUP 6848 2017-07-16 16:17:31,252 - INFO - recived 1 $ jobs [1]+ Running python3.6 time_b.py &amp; $ 2017-07-16 16:18:25,147 - INFO - end sleep 60 seconds, spend 60.00310564041138 [1]+ Done python3.6 time_b.py 确实跟文档中说的一样，就算收到并处理了 signal 还是可以正常 sleep 。👍 下面再看看 signal handler raise exception 的情况。 signal handler raise exception 测试： $ python3.6 time_c.py &amp; [1] 42908 2017-07-16 16:20:00,679 - INFO - start sleep 60 seconds $ kill -s SIGHUP 42908 2017-07-16 16:20:06,126 - INFO - recived 1 2017-07-16 16:20:06,126 - ERROR - test Traceback (most recent call last): File &#34;time_c.py&#34;, line 21, in &lt;module&gt; time.sleep(n) File &#34;time_c.py&#34;, line 14, in handler raise Exception(&#39;test&#39;) Exception: test 2017-07-16 16:20:06,127 - INFO - end sleep 60 seconds, spend 5.4475321769714355 [1]+ Done python3.6 time_c.py 可以看到，跟在 Python 2 下一样，当 signal handler 抛异常时，time.sleep 会抛出异常提前终止 sleep 操作。 原因 那么，为什么 Python 2 下 time.sleep 遇到 signal 时会出现提前返回的情况呢？ 在 gevent 的一个 issue 中 @jamadden 是 这样解释的 : The stdlib time.sleep method is implemented by calling select, passing in a timeout value, and no file descriptors to actually select on. The intended effect is to block in the operating system, sleeping until the timeout has elapsed. However, select is one of those system calls that is vulnerable to signals. When a signal is delivered to the process, select prematurely wakes up and sets errno to EINTR (interrupted). In that case, time.sleep makes no attempt to account for any unelapsed time; it simple returns. Therefore, time.sleep can sometimes return early. This is documented. 查看 python 2.7 的源代码以及 select 的文档可以确认这个解释： python 2.7 源码中 time.sleep 的 实现片段 如下： static int floatsleep(double secs) { /* XXX Should test for MS_WINDOWS first! */ #if defined(HAVE_SELECT) &amp;&amp; !defined(__BEOS__) &amp;&amp; !defined(__EMX__) struct timeval t; double frac; frac = fmod(secs, 1.0); secs = floor(secs); t.tv_sec = (long)secs; t.tv_usec = (long)(frac*1000000.0); Py_BEGIN_ALLOW_THREADS if (select(0, (fd_set *)0, (fd_set *)0, (fd_set *)0, &amp;t) != 0) { #ifdef EINTR if (errno != EINTR) { #else if (1) { #endif Py_BLOCK_THREADS PyErr_SetFromErrno(PyExc_IOError); return -1; } } 可以看到确实是用 select 来实现的 time.sleep 。 select 的 文档 中关于 signal 的说明如下： The timeout argument specifies the interval that select() should block waiting for a file descriptor to become ready. The call will block until either: a file descriptor becomes ready; the call is interrupted by a signal handler; or the timeout expires. 通过文档我们知道， select 的 timeout 的阻塞效果确实会被 signal handler 所中断。 至于 Python 3.5+ 为什么不会提前返回，是因为它的 time.sleep 实现中对于这种情况增加了判断，如果时间没到会用剩下的时间再次 sleep： static int pysleep(_PyTime_t secs) { // ... do { // ... monotonic = _PyTime_GetMonotonicClock(); secs = deadline - monotonic; if (secs &lt; 0) break; /* retry with the recomputed delay */ } while (1); return 0; } 启示 如果想在 Python 2 下实现类似 Python 3.5+ 下的效果，可以仿照 Python 3.5+ 下的实现增加“如果时间没到会用剩下的时间再次 sleep”的逻辑： 参考代码（修改自 time_b.py） $ cat time_d.py import logging import signal import time logging.basicConfig( level=logging.DEBUG, format=&#39;%(asctime)-15s - %(levelname)s - %(message)s&#39; ) n = 60 def handler(sig, strace): logging.info(&#39;recived %s&#39;, sig) signal.signal(signal.SIGHUP, handler) logging.info(&#39;start sleep %s seconds&#39;, n) start = time.time() remain = n while True: time.sleep(remain) remain = (start + n) - time.time() if remain &lt; 0: break else: logging.warn(&#39;retry sleep %s&#39;, remain) logging.info(&#39;end sleep %s seconds, spend %s&#39;, n, time.time() - start) 测试： $ python time_d.py &amp; [1] 14751 $ 2017-07-16 17:10:53,235 - INFO - start sleep 60 seconds $ kill -s SIGHUP 14751 2017-07-16 17:10:59,803 - INFO - recived 1 2017-07-16 17:10:59,803 - WARNING - retry sleep 53.4323399067 $ kill -s SIGHUP 14751 2017-07-16 17:11:44,792 - INFO - recived 1 2017-07-16 17:11:44,792 - WARNING - retry sleep 8.44309687614 $ 2017-07-16 17:11:53,239 - INFO - end sleep 60 seconds, spend 60.0035960674 [1]+ Done python time_d.py 最重要的一点是 ：不要觉得 time.sleep 会非常的精确，它有可能变快也有可能变慢，不要对它有过高的期望，不要依赖这个功能来实现需要精确 sleep 的需求。 目测可能也可以利用 python 2 下的这一行为实现一些特殊的需求。 好了，本文的内容就是这些了，希望这篇文章能对你有所帮助。 参考资料 15.3. time — Time access and conversions — Python 2.7.13 documentation 16.3. time — Time access and conversions — Python 3.6.2rc2 documentation gevent.subprocess.Popen alters the behavior of time.sleep · Issue #280 · gevent/gevent cpython/timemodule.c at 2.7 · python/cpython cpython/timemodule.c at 3.6 · python/cpython"/>
        <meta property="article:published_time" content="2017-07-18" />
            <meta property="article:section" content="python" />
            <meta property="article:tag" content="python" />
            <meta property="article:tag" content="signal" />
            <meta property="article:author" content="mozillazg" />
            <meta property="og:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>


    <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@mozillazg">
        <meta name="twitter:creator" content="@mozillazg">
    <meta name="twitter:domain" content="https://mozillazg.com">
            <meta property="twitter:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="/theme/cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/css/bootstrap.min.css" type="text/css"/>
    <link href="/theme/cdn.jsdelivr.net/npm/font-awesome@4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link href="/theme/cdn.jsdelivr.net/npm/pygments-css@1.0.0/github.css" rel="stylesheet">
    <link rel="stylesheet" href="https://mozillazg.com/theme/css/style.css" type="text/css"/>
            <link href="/static/han.min.css" rel="stylesheet">
            <link href="/static/yue.css" rel="stylesheet">
            <link href="/static/custom.css" rel="stylesheet">

        <link href="https://mozillazg.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog ATOM Feed"/>

        <link href="https://mozillazg.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="mozillazg's Blog RSS Feed"/>


        <link href="https://mozillazg.com/feeds/python.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog python ATOM Feed"/>


    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "publisher": {
            "@type": "Person",
            "name": "mozillazg",
            "logo": "https://mozillazg.com/static/avatar.jpeg"
        },
        "author": {
            "@type": "Person",
            "name": "mozillazg",
            "image": "https://mozillazg.com/static/avatar.jpeg",
            "url": "https://mozillazg.com",
            "sameAs": []
        },
        "headline": "Python: time.sleep 与 signal 一起使用可能会出现 sleep 被提前终止的情况",
        "url": "https://mozillazg.com/2017/07/python-time-sleep-terminate-by-signal.html",
        "image": [
            "https://mozillazg.com/static/avatar.jpeg"
         ],
        "keywords": "python, signal",
        "description": "如题所述，当 time.sleep 与 signal 一起使用时可能会出现 time.sleep 失效，提前结束 sleep 的问题。 我们先来看一下 time.sleep 的文档: Python 2.7.13: time.sleep(secs) Suspend execution of the current thread for the given number of seconds. The argument may be a floating point number to indicate a more precise sleep time. The actual suspension time may be less than that requested because any caught signal will terminate the sleep() following execution of that signal’s catching routine. Also, the suspension time may be longer than requested by an arbitrary amount because of the scheduling of other activity in the system. Python 3.6.2: time.sleep(secs) Suspend execution of the calling thread for the given number of seconds. The argument may be a floating point number to indicate a more precise sleep time. The actual suspension time may be less than that requested because any caught signal will terminate the sleep() following execution of that signal’s catching routine. Also, the suspension time may be longer than requested by an arbitrary amount because of the scheduling of other activity in the system. Changed in version 3.5: The function now sleeps at least secs even if the sleep is interrupted by a signal, except if the signal handler raises an exception (see PEP 475 for the rationale). 通过文档可以看到，在 Python 2 下，当定义了 signal handler 并接收到 signal 时， time.sleep 会提前返回， 在 Python 3.5+ 下，没有这个问题，只是在 signal handler 抛异常时 sleep 会被终止 。 下面我们就来验证一下这个问题。 测试环境 os: mac os python: python2.7, python3.6 Python 2 普通 sleep 程序 先来看一个正常 sleep 的程序: $ cat time_a.py import logging import time logging.basicConfig( level=logging.DEBUG, format=&#39;%(asctime)-15s - %(levelname)s - %(message)s&#39; ) n = 60 logging.info(&#39;start sleep %s seconds&#39;, n) start = time.time() time.sleep(n) logging.info(&#39;end sleep %s seconds, spend %s&#39;, n, time.time() - start) 测试: $ python time_a.py 2017-07-16 15:29:05,323 - INFO - start sleep 60 seconds 2017-07-16 15:30:05,327 - INFO - end sleep 60 seconds, spend 60.0042099953 可以看到确实 sleep 了 60 秒。 signal 给普通的 sleep 程序发个 signal 试试: $ python time_a.py &amp; [1] 6208 $ 2017-07-16 15:44:01,290 - INFO - start sleep 60 seconds $ kill -s SIGHUP 6208 [1]+ Hangup: 1 python time_a.py 因为 SIGHUP 的默认行为就是终止程序，所以程序终止了。 我们下面来测试自定义 signal handler 的影响。 signal handler 测试程序如下： $ cat time_b.py import logging import signal import time logging.basicConfig( level=logging.DEBUG, format=&#39;%(asctime)-15s - %(levelname)s - %(message)s&#39; ) n = 60 def handler(sig, strace): logging.info(&#39;recived %s&#39;, sig) signal.signal(signal.SIGHUP, handler) logging.info(&#39;start sleep %s seconds&#39;, n) start = time.time() time.sleep(n) logging.info(&#39;end sleep %s seconds, spend %s&#39;, n, time.time() - start) 测试: $ python time_b.py &amp; [1] 5910 2017-07-16 15:31:46,448 - INFO - start sleep 60 seconds $ kill -s SIGHUP 5910 2017-07-16 15:31:52,180 - INFO - recived 1 2017-07-16 15:31:52,181 - INFO - end sleep 60 seconds, spend 5.73180794716 [1]+ Done python time_b.py 从测试结果可以看到，当收到 signal 后，sleep 就提前结束了， 60 秒的 sleep 实际只花了 6 秒钟。 下面再看看 Python 3 文档中提到的 handler 抛异常的情况。 signal handler raise exception 测试程序： $ cat time_c.py import logging import signal import time logging.basicConfig( level=logging.DEBUG, format=&#39;%(asctime)-15s - %(levelname)s - %(message)s&#39; ) n = 60 def handler(sig, strace): logging.info(&#39;recived %s&#39;, sig) raise Exception(&#39;test&#39;) signal.signal(signal.SIGHUP, handler) logging.info(&#39;start sleep %s seconds&#39;, n) start = time.time() try: time.sleep(n) except Exception as e: logging.exception(e) logging.info(&#39;end sleep %s seconds, spend %s&#39;, n, time.time() - start) 测试： $ python time_c.py &amp; [1] 6390 2017-07-16 16:09:31,340 - INFO - start sleep 60 seconds $ kill -s SIGHUP 6390 2017-07-16 16:09:35,328 - INFO - recived 1 2017-07-16 16:09:35,329 - ERROR - test Traceback (most recent call last): File &#34;time_c.py&#34;, line 21, in &lt;module&gt; time.sleep(n) File &#34;time_c.py&#34;, line 14, in handler raise Exception(&#39;test&#39;) Exception: test 2017-07-16 16:09:35,329 - INFO - end sleep 60 seconds, spend 3.988664150238037 [1]+ Done python time_c.py 可以看到，当 signal handler 抛异常时， time.sleep 会抛出异常提前终止 sleep 操作。 下面来测试 Python 3.5+ 下这四种情况的行为。 Python 3.5+ 普通 sleep 程序 用的还是之前的 time_a.py 文件，测试结果： $ python3.6 time_a.py 2017-07-16 16:12:28,566 - INFO - start sleep 60 seconds 2017-07-16 16:13:28,571 - INFO - end sleep 60 seconds, spend 60.00386714935303 可以看到，跟 Python 2 一样，正常 sleep. signal 同样试试给 time_a.py 进程发送 signal: $ python3.6 time_a.py &amp; [1] 6790 $ 2017-07-16 16:15:53,529 - INFO - start sleep 60 seconds $ kill -s SIGHUP 6790 [1]+ Hangup: 1 python3.6 time_a.py 跟 Python 2 下也是一样，进程终止。 signal handler 按照文档，当 signal handler 不错误的时候，应该可以正常 sleep, 下面我们试试看： $ python3.6 time_b.py &amp; [1] 6848 $ 2017-07-16 16:17:25,144 - INFO - start sleep 60 seconds $ kill -s SIGHUP 6848 2017-07-16 16:17:31,252 - INFO - recived 1 $ jobs [1]+ Running python3.6 time_b.py &amp; $ 2017-07-16 16:18:25,147 - INFO - end sleep 60 seconds, spend 60.00310564041138 [1]+ Done python3.6 time_b.py 确实跟文档中说的一样，就算收到并处理了 signal 还是可以正常 sleep 。👍 下面再看看 signal handler raise exception 的情况。 signal handler raise exception 测试： $ python3.6 time_c.py &amp; [1] 42908 2017-07-16 16:20:00,679 - INFO - start sleep 60 seconds $ kill -s SIGHUP 42908 2017-07-16 16:20:06,126 - INFO - recived 1 2017-07-16 16:20:06,126 - ERROR - test Traceback (most recent call last): File &#34;time_c.py&#34;, line 21, in &lt;module&gt; time.sleep(n) File &#34;time_c.py&#34;, line 14, in handler raise Exception(&#39;test&#39;) Exception: test 2017-07-16 16:20:06,127 - INFO - end sleep 60 seconds, spend 5.4475321769714355 [1]+ Done python3.6 time_c.py 可以看到，跟在 Python 2 下一样，当 signal handler 抛异常时，time.sleep 会抛出异常提前终止 sleep 操作。 原因 那么，为什么 Python 2 下 time.sleep 遇到 signal 时会出现提前返回的情况呢？ 在 gevent 的一个 issue 中 @jamadden 是 这样解释的 : The stdlib time.sleep method is implemented by calling select, passing in a timeout value, and no file descriptors to actually select on. The intended effect is to block in the operating system, sleeping until the timeout has elapsed. However, select is one of those system calls that is vulnerable to signals. When a signal is delivered to the process, select prematurely wakes up and sets errno to EINTR (interrupted). In that case, time.sleep makes no attempt to account for any unelapsed time; it simple returns. Therefore, time.sleep can sometimes return early. This is documented. 查看 python 2.7 的源代码以及 select 的文档可以确认这个解释： python 2.7 源码中 time.sleep 的 实现片段 如下： static int floatsleep(double secs) { /* XXX Should test for MS_WINDOWS first! */ #if defined(HAVE_SELECT) &amp;&amp; !defined(__BEOS__) &amp;&amp; !defined(__EMX__) struct timeval t; double frac; frac = fmod(secs, 1.0); secs = floor(secs); t.tv_sec = (long)secs; t.tv_usec = (long)(frac*1000000.0); Py_BEGIN_ALLOW_THREADS if (select(0, (fd_set *)0, (fd_set *)0, (fd_set *)0, &amp;t) != 0) { #ifdef EINTR if (errno != EINTR) { #else if (1) { #endif Py_BLOCK_THREADS PyErr_SetFromErrno(PyExc_IOError); return -1; } } 可以看到确实是用 select 来实现的 time.sleep 。 select 的 文档 中关于 signal 的说明如下： The timeout argument specifies the interval that select() should block waiting for a file descriptor to become ready. The call will block until either: a file descriptor becomes ready; the call is interrupted by a signal handler; or the timeout expires. 通过文档我们知道， select 的 timeout 的阻塞效果确实会被 signal handler 所中断。 至于 Python 3.5+ 为什么不会提前返回，是因为它的 time.sleep 实现中对于这种情况增加了判断，如果时间没到会用剩下的时间再次 sleep： static int pysleep(_PyTime_t secs) { // ... do { // ... monotonic = _PyTime_GetMonotonicClock(); secs = deadline - monotonic; if (secs &lt; 0) break; /* retry with the recomputed delay */ } while (1); return 0; } 启示 如果想在 Python 2 下实现类似 Python 3.5+ 下的效果，可以仿照 Python 3.5+ 下的实现增加“如果时间没到会用剩下的时间再次 sleep”的逻辑： 参考代码（修改自 time_b.py） $ cat time_d.py import logging import signal import time logging.basicConfig( level=logging.DEBUG, format=&#39;%(asctime)-15s - %(levelname)s - %(message)s&#39; ) n = 60 def handler(sig, strace): logging.info(&#39;recived %s&#39;, sig) signal.signal(signal.SIGHUP, handler) logging.info(&#39;start sleep %s seconds&#39;, n) start = time.time() remain = n while True: time.sleep(remain) remain = (start + n) - time.time() if remain &lt; 0: break else: logging.warn(&#39;retry sleep %s&#39;, remain) logging.info(&#39;end sleep %s seconds, spend %s&#39;, n, time.time() - start) 测试： $ python time_d.py &amp; [1] 14751 $ 2017-07-16 17:10:53,235 - INFO - start sleep 60 seconds $ kill -s SIGHUP 14751 2017-07-16 17:10:59,803 - INFO - recived 1 2017-07-16 17:10:59,803 - WARNING - retry sleep 53.4323399067 $ kill -s SIGHUP 14751 2017-07-16 17:11:44,792 - INFO - recived 1 2017-07-16 17:11:44,792 - WARNING - retry sleep 8.44309687614 $ 2017-07-16 17:11:53,239 - INFO - end sleep 60 seconds, spend 60.0035960674 [1]+ Done python time_d.py 最重要的一点是 ：不要觉得 time.sleep 会非常的精确，它有可能变快也有可能变慢，不要对它有过高的期望，不要依赖这个功能来实现需要精确 sleep 的需求。 目测可能也可以利用 python 2 下的这一行为实现一些特殊的需求。 好了，本文的内容就是这些了，希望这篇文章能对你有所帮助。 参考资料 15.3. time — Time access and conversions — Python 2.7.13 documentation 16.3. time — Time access and conversions — Python 3.6.2rc2 documentation gevent.subprocess.Popen alters the behavior of time.sleep · Issue #280 · gevent/gevent cpython/timemodule.c at 2.7 · python/cpython cpython/timemodule.c at 3.6 · python/cpython",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "https://mozillazg.com/2017/07/python-time-sleep-terminate-by-signal.html"
        },
        "datePublished": "2017-07-18"
    }
    </script>

</head>
<body>

<div class="navbar" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://mozillazg.com/" class="navbar-brand">
mozillazg's Blog            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="https://mozillazg.com/feeds/all.atom.xml">Feed</a></li>
                    <li><a href="/2014/10/pages/about-me.html">About</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://mozillazg.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content" class="yue">
        <article>
            <header class="text-center">
                <h1>
                    <a href="https://mozillazg.com/2017/07/python-time-sleep-terminate-by-signal.html"
                       rel="bookmark"
                       title="Permalink to Python: time.sleep 与 signal 一起使用可能会出现 sleep 被提前终止的情况">
                        Python: time.sleep 与 signal 一起使用可能会出现 sleep 被提前终止的情况
                    </a>
                </h1>
                <p class="published">
                    <time datetime="2017-07-18T00:00:00+00:00">
                    2017-07-18
                    </time>
                </p>
            </header>
            <div class="entry-content">
                <div class="well-sm article-info">
<footer class="post-info">
        <a href="https://mozillazg.com/category/python.html">python</a>


<span class="label label-default hide">Tags</span>
	<a href="https://mozillazg.com/tag/signal.html">signal</a>
    
</footer><!-- /.post-info -->                </div>
                <div class="js-toc"></div>
                <div>
                <p>如题所述，当 <tt class="docutils literal">time.sleep</tt> 与 <tt class="docutils literal">signal</tt> 一起使用时可能会出现 <tt class="docutils literal">time.sleep</tt>
失效，提前结束 sleep 的问题。</p>
<p>我们先来看一下 <tt class="docutils literal">time.sleep</tt> 的文档:</p>
<p>Python 2.7.13:</p>
<blockquote>
<p>time.sleep(secs)</p>
<blockquote>
Suspend execution of the current thread for the given number of seconds. The argument may be a floating point number to indicate a more precise sleep time. <strong>The actual suspension time may be less than that requested because any caught signal will terminate the sleep() following execution of that signal’s catching routine.</strong> Also, the suspension time may be longer than requested by an arbitrary amount because of the scheduling of other activity in the system.</blockquote>
</blockquote>
<p>Python 3.6.2:</p>
<blockquote>
<p>time.sleep(secs)</p>
<blockquote>
<p>Suspend execution of the calling thread for the given number of seconds. The argument may be a floating point number to indicate a more precise sleep time. <strong>The actual suspension time may be less than that requested because any caught signal will terminate the sleep() following execution of that signal’s catching routine.</strong> Also, the suspension time may be longer than requested by an arbitrary amount because of the scheduling of other activity in the system.</p>
<p>Changed in version 3.5: <strong>The function now sleeps at least secs even if the sleep is interrupted by a signal, except if the signal handler raises an exception</strong> (see <a class="reference external" href="https://www.python.org/dev/peps/pep-0475">PEP 475</a> for the rationale).</p>
</blockquote>
</blockquote>
<p>通过文档可以看到，在 Python 2 下，当定义了 signal handler 并接收到
signal 时， <tt class="docutils literal">time.sleep</tt> 会提前返回， 在 Python 3.5+
下，没有这个问题，只是在 signal handler 抛异常时 sleep 会被终止 。</p>
<p>下面我们就来验证一下这个问题。</p>
<div class="section" id="section-1">
<h2 id="hidsection-1">测试环境<a class="headerlink" href="#hidsection-1" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>os: mac os</li>
<li>python: python2.7, python3.6</li>
</ul>
</div>
<div class="section" id="python-2">
<h2 id="hidpython-2">Python 2<a class="headerlink" href="#hidpython-2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sleep">
<h3 id="hidsleep">普通 sleep 程序<a class="headerlink" href="#hidsleep" title="Permalink to this headline">¶</a></h3>
<p>先来看一个正常 sleep 的程序:</p>
<div class="highlight"><pre><span></span><span class="err">$</span> <span class="n">cat</span> <span class="n">time_a</span><span class="o">.</span><span class="n">py</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">,</span>
    <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(asctime)-15s</span><span class="s1"> - </span><span class="si">%(levelname)s</span><span class="s1"> - </span><span class="si">%(message)s</span><span class="s1">&#39;</span>
<span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">60</span>

<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;start sleep </span><span class="si">%s</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;end sleep </span><span class="si">%s</span><span class="s1"> seconds, spend </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
</pre></div>
<p>测试:</p>
<pre class="literal-block">
$ python time_a.py
2017-07-16 15:29:05,323 - INFO - start sleep 60 seconds
2017-07-16 15:30:05,327 - INFO - end sleep 60 seconds, spend 60.0042099953
</pre>
<p>可以看到确实 sleep 了 60 秒。</p>
</div>
<div class="section" id="signal">
<h3 id="hidsignal">signal<a class="headerlink" href="#hidsignal" title="Permalink to this headline">¶</a></h3>
<p>给普通的 sleep 程序发个 signal 试试:</p>
<pre class="literal-block">
$ python time_a.py &amp;
[1] 6208
$ 2017-07-16 15:44:01,290 - INFO - start sleep 60 seconds

$ kill -s SIGHUP 6208
[1]+  Hangup: 1               python time_a.py
</pre>
<p>因为 <tt class="docutils literal">SIGHUP</tt> 的默认行为就是终止程序，所以程序终止了。</p>
<p>我们下面来测试自定义 signal handler 的影响。</p>
</div>
<div class="section" id="signal-handler">
<h3 id="hidsignal-handler">signal handler<a class="headerlink" href="#hidsignal-handler" title="Permalink to this headline">¶</a></h3>
<p>测试程序如下：</p>
<div class="highlight"><pre><span></span><span class="err">$</span> <span class="n">cat</span> <span class="n">time_b</span><span class="o">.</span><span class="n">py</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">signal</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">,</span>
    <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(asctime)-15s</span><span class="s1"> - </span><span class="si">%(levelname)s</span><span class="s1"> - </span><span class="si">%(message)s</span><span class="s1">&#39;</span>
<span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">60</span>

<span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">strace</span><span class="p">):</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;recived </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>

<span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGHUP</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>

<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;start sleep </span><span class="si">%s</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;end sleep </span><span class="si">%s</span><span class="s1"> seconds, spend </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
</pre></div>
<p>测试:</p>
<pre class="literal-block">
$ python time_b.py &amp;
[1] 5910
2017-07-16 15:31:46,448 - INFO - start sleep 60 seconds
$ kill -s SIGHUP 5910
2017-07-16 15:31:52,180 - INFO - recived 1
2017-07-16 15:31:52,181 - INFO - end sleep 60 seconds, spend 5.73180794716
[1]+  Done                    python time_b.py
</pre>
<p>从测试结果可以看到，当收到 signal 后，sleep 就提前结束了， 60 秒的 sleep
实际只花了 6 秒钟。</p>
<p>下面再看看 Python 3 文档中提到的 handler 抛异常的情况。</p>
</div>
<div class="section" id="signal-handler-raise-exception">
<h3 id="hidsignal-handler-raise-exception">signal handler raise exception<a class="headerlink" href="#hidsignal-handler-raise-exception" title="Permalink to this headline">¶</a></h3>
<p>测试程序：</p>
<div class="highlight"><pre><span></span><span class="err">$</span> <span class="n">cat</span> <span class="n">time_c</span><span class="o">.</span><span class="n">py</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">signal</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">,</span>
    <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(asctime)-15s</span><span class="s1"> - </span><span class="si">%(levelname)s</span><span class="s1"> - </span><span class="si">%(message)s</span><span class="s1">&#39;</span>
<span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">60</span>

<span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">strace</span><span class="p">):</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;recived </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;test&#39;</span><span class="p">)</span>

<span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGHUP</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>

<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;start sleep </span><span class="si">%s</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;end sleep </span><span class="si">%s</span><span class="s1"> seconds, spend </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
</pre></div>
<p>测试：</p>
<pre class="literal-block">
$ python time_c.py &amp;
[1] 6390
2017-07-16 16:09:31,340 - INFO - start sleep 60 seconds

$ kill -s SIGHUP 6390
2017-07-16 16:09:35,328 - INFO - recived 1
2017-07-16 16:09:35,329 - ERROR - test
Traceback (most recent call last):
  File &quot;time_c.py&quot;, line 21, in &lt;module&gt;
    time.sleep(n)
  File &quot;time_c.py&quot;, line 14, in handler
    raise Exception('test')
Exception: test
2017-07-16 16:09:35,329 - INFO - end sleep 60 seconds, spend 3.988664150238037
[1]+  Done                    python time_c.py
</pre>
<p>可以看到，当 signal handler 抛异常时， <tt class="docutils literal">time.sleep</tt> 会抛出异常提前终止 sleep 操作。</p>
<p>下面来测试 Python 3.5+ 下这四种情况的行为。</p>
</div>
</div>
<div class="section" id="python-3-5">
<h2 id="hidpython-3-5">Python 3.5+<a class="headerlink" href="#hidpython-3-5" title="Permalink to this headline">¶</a></h2>
<div class="section" id="sleep-1">
<h3 id="hidsleep-1">普通 sleep 程序<a class="headerlink" href="#hidsleep-1" title="Permalink to this headline">¶</a></h3>
<p>用的还是之前的 time_a.py 文件，测试结果：</p>
<pre class="literal-block">
$ python3.6 time_a.py
2017-07-16 16:12:28,566 - INFO - start sleep 60 seconds
2017-07-16 16:13:28,571 - INFO - end sleep 60 seconds, spend 60.00386714935303
</pre>
<p>可以看到，跟 Python 2 一样，正常 sleep.</p>
</div>
<div class="section" id="signal-1">
<h3 id="hidsignal-1">signal<a class="headerlink" href="#hidsignal-1" title="Permalink to this headline">¶</a></h3>
<p>同样试试给 time_a.py 进程发送 signal:</p>
<pre class="literal-block">
$ python3.6 time_a.py  &amp;
[1] 6790
$ 2017-07-16 16:15:53,529 - INFO - start sleep 60 seconds

$ kill -s SIGHUP 6790
[1]+  Hangup: 1               python3.6 time_a.py
</pre>
<p>跟 Python 2 下也是一样，进程终止。</p>
</div>
<div class="section" id="signal-handler-1">
<h3 id="hidsignal-handler-1">signal handler<a class="headerlink" href="#hidsignal-handler-1" title="Permalink to this headline">¶</a></h3>
<p>按照文档，当 signal handler 不错误的时候，应该可以正常 sleep,
下面我们试试看：</p>
<pre class="literal-block">
$ python3.6 time_b.py &amp;
[1] 6848
$ 2017-07-16 16:17:25,144 - INFO - start sleep 60 seconds

$ kill -s SIGHUP 6848
2017-07-16 16:17:31,252 - INFO - recived 1
$ jobs
[1]+  Running                 python3.6 time_b.py &amp;
$ 2017-07-16 16:18:25,147 - INFO - end sleep 60 seconds, spend 60.00310564041138

[1]+  Done                    python3.6 time_b.py
</pre>
<p>确实跟文档中说的一样，就算收到并处理了 signal 还是可以正常 sleep 。👍</p>
<p>下面再看看 signal handler raise exception 的情况。</p>
</div>
<div class="section" id="signal-handler-raise-exception-1">
<h3 id="hidsignal-handler-raise-exception-1">signal handler raise exception<a class="headerlink" href="#hidsignal-handler-raise-exception-1" title="Permalink to this headline">¶</a></h3>
<p>测试：</p>
<pre class="literal-block">
$ python3.6 time_c.py &amp;
[1] 42908
2017-07-16 16:20:00,679 - INFO - start sleep 60 seconds

$ kill -s SIGHUP 42908
2017-07-16 16:20:06,126 - INFO - recived 1
2017-07-16 16:20:06,126 - ERROR - test
Traceback (most recent call last):
  File &quot;time_c.py&quot;, line 21, in &lt;module&gt;
    time.sleep(n)
  File &quot;time_c.py&quot;, line 14, in handler
    raise Exception('test')
Exception: test
2017-07-16 16:20:06,127 - INFO - end sleep 60 seconds, spend 5.4475321769714355
[1]+  Done                    python3.6 time_c.py
</pre>
<p>可以看到，跟在 Python 2 下一样，当 signal handler
抛异常时，<tt class="docutils literal">time.sleep</tt> 会抛出异常提前终止 sleep 操作。</p>
</div>
</div>
<div class="section" id="section-2">
<h2 id="hidsection-2">原因<a class="headerlink" href="#hidsection-2" title="Permalink to this headline">¶</a></h2>
<p>那么，为什么 Python 2 下 <tt class="docutils literal">time.sleep</tt> 遇到 signal
时会出现提前返回的情况呢？</p>
<p>在 gevent 的一个 <a class="reference external" href="https://github.com/gevent/gevent/issues/280">issue</a>
中 <a class="reference external" href="https://github.com/jamadden">&#64;jamadden</a> 是 <a class="reference external" href="https://github.com/gevent/gevent/issues/280#issuecomment-120123286">这样解释的</a> :</p>
<blockquote>
<p>The stdlib <strong>time.sleep</strong> method is implemented by calling <strong>select</strong>,
passing in a timeout value, and no file descriptors to actually
select on. The intended effect is to block in the operating system,
sleeping until the timeout has elapsed.</p>
<p>However, <strong>select</strong> is one of those system calls that is vulnerable to
signals. When a signal is delivered to the process, <strong>select</strong>
prematurely wakes up and sets <strong>errno</strong> to <strong>EINTR</strong> (interrupted). In that
case, <strong>time.sleep</strong> makes no attempt to account for any unelapsed time;
it simple returns. Therefore, <strong>time.sleep</strong> can sometimes return early.
<a class="reference external" href="https://docs.python.org/3/library/time.html#time.sleep">This is
documented</a>.</p>
</blockquote>
<p>查看 python 2.7 的源代码以及 <tt class="docutils literal">select</tt> 的文档可以确认这个解释：</p>
<p>python 2.7 源码中 <tt class="docutils literal">time.sleep</tt> 的
<a class="reference external" href="https://github.com/python/cpython/blob/2.7/Modules/timemodule.c#L937">实现片段</a>
如下：</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span>

<span class="nf">floatsleep</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">secs</span><span class="p">)</span>

<span class="p">{</span>
<span class="cm">/* XXX Should test for MS_WINDOWS first! */</span>
<span class="cp">#if defined(HAVE_SELECT) &amp;&amp; !defined(__BEOS__) &amp;&amp; !defined(__EMX__)</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">timeval</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">frac</span><span class="p">;</span>
<span class="w">    </span><span class="n">frac</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fmod</span><span class="p">(</span><span class="n">secs</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span><span class="n">secs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">floor</span><span class="p">(</span><span class="n">secs</span><span class="p">);</span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">tv_sec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="p">)</span><span class="n">secs</span><span class="p">;</span>
<span class="w">    </span><span class="n">t</span><span class="p">.</span><span class="n">tv_usec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">long</span><span class="p">)(</span><span class="n">frac</span><span class="o">*</span><span class="mf">1000000.0</span><span class="p">);</span>
<span class="w">    </span><span class="n">Py_BEGIN_ALLOW_THREADS</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">fd_set</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">fd_set</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">fd_set</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#ifdef EINTR</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">errno</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">EINTR</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#else</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#endif</span>
<span class="w">            </span><span class="n">Py_BLOCK_THREADS</span>
<span class="w">            </span><span class="n">PyErr_SetFromErrno</span><span class="p">(</span><span class="n">PyExc_IOError</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
<p>可以看到确实是用 <tt class="docutils literal">select</tt> 来实现的 <tt class="docutils literal">time.sleep</tt> 。</p>
<p><tt class="docutils literal">select</tt> 的
<a class="reference external" href="http://man7.org/linux/man-pages/man2/select.2.html">文档</a> 中关于
signal 的说明如下：</p>
<blockquote>
<p>The <strong>timeout</strong> argument specifies the interval that <strong>select()</strong> should
block waiting for a file descriptor to become ready.  <strong>The call will
block until either</strong>:</p>
<ul class="simple">
<li>a file descriptor becomes ready;</li>
<li><strong>the call is interrupted by a signal handler</strong>; or</li>
<li>the timeout expires.</li>
</ul>
</blockquote>
<p>通过文档我们知道， <tt class="docutils literal">select</tt> 的 <strong>timeout</strong> 的阻塞效果确实会被 signal handler 所中断。</p>
<p>至于 Python 3.5+ 为什么不会提前返回，是因为它的 <tt class="docutils literal">time.sleep</tt>
实现中对于这种情况增加了判断，<a class="reference external" href="https://github.com/python/cpython/blob/3.6/Modules/timemodule.c#L1482-L1487">如果时间没到会用剩下的时间再次
sleep</a>：</p>
<div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">pysleep</span><span class="p">(</span><span class="n">_PyTime_t</span><span class="w"> </span><span class="n">secs</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">     </span><span class="c1">// ...</span>
<span class="w">     </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="n">monotonic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_PyTime_GetMonotonicClock</span><span class="p">();</span>
<span class="w">        </span><span class="n">secs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deadline</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">monotonic</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">secs</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="cm">/* retry with the recomputed delay */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="section-3">
<h2 id="hidsection-3">启示<a class="headerlink" href="#hidsection-3" title="Permalink to this headline">¶</a></h2>
<p>如果想在 Python 2 下实现类似 Python 3.5+ 下的效果，可以仿照 Python 3.5+
下的实现增加“如果时间没到会用剩下的时间再次 sleep”的逻辑：</p>
<p>参考代码（修改自 time_b.py）</p>
<div class="highlight"><pre><span></span><span class="err">$</span> <span class="n">cat</span> <span class="n">time_d</span><span class="o">.</span><span class="n">py</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">signal</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">,</span>
    <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%(asctime)-15s</span><span class="s1"> - </span><span class="si">%(levelname)s</span><span class="s1"> - </span><span class="si">%(message)s</span><span class="s1">&#39;</span>
<span class="p">)</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">60</span>


<span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">strace</span><span class="p">):</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;recived </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>


<span class="n">signal</span><span class="o">.</span><span class="n">signal</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">SIGHUP</span><span class="p">,</span> <span class="n">handler</span><span class="p">)</span>

<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;start sleep </span><span class="si">%s</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">remain</span> <span class="o">=</span> <span class="n">n</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">remain</span><span class="p">)</span>
    <span class="n">remain</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">remain</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;retry sleep </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">remain</span><span class="p">)</span>
<span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;end sleep </span><span class="si">%s</span><span class="s1"> seconds, spend </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
</pre></div>
<p>测试：</p>
<pre class="literal-block">
$ python time_d.py &amp;
[1] 14751
$ 2017-07-16 17:10:53,235 - INFO - start sleep 60 seconds

$ kill -s SIGHUP 14751
2017-07-16 17:10:59,803 - INFO - recived 1
2017-07-16 17:10:59,803 - WARNING - retry sleep 53.4323399067

$ kill -s SIGHUP 14751
2017-07-16 17:11:44,792 - INFO - recived 1
2017-07-16 17:11:44,792 - WARNING - retry sleep 8.44309687614
$ 2017-07-16 17:11:53,239 - INFO - end sleep 60 seconds, spend 60.0035960674

[1]+  Done                    python time_d.py
</pre>
<p><strong>最重要的一点是</strong> ：不要觉得 <tt class="docutils literal">time.sleep</tt>
会非常的精确，它有可能变快也有可能变慢，不要对它有过高的期望，不要依赖这个功能来实现需要精确
sleep 的需求。</p>
<p>目测可能也可以利用 python 2 下的这一行为实现一些特殊的需求。</p>
<p>好了，本文的内容就是这些了，希望这篇文章能对你有所帮助。</p>
</div>
<div class="section" id="section-4">
<h2 id="hidsection-4">参考资料<a class="headerlink" href="#hidsection-4" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://docs.python.org/2/library/time.html#time.sleep">15.3. time — Time access and conversions — Python 2.7.13
documentation</a></li>
<li><a class="reference external" href="https://docs.python.org/3/library/time.html#time.sleep">16.3. time — Time access and conversions — Python 3.6.2rc2
documentation</a></li>
<li><a class="reference external" href="https://github.com/gevent/gevent/issues/280">gevent.subprocess.Popen alters the behavior of time.sleep · Issue
#280 · gevent/gevent</a></li>
<li><a class="reference external" href="https://github.com/python/cpython/blob/2.7/Modules/timemodule.c#L937">cpython/timemodule.c at 2.7 ·
python/cpython</a></li>
<li><a class="reference external" href="https://github.com/python/cpython/blob/3.6/Modules/timemodule.c#L1482-L1487">cpython/timemodule.c at 3.6 ·
python/cpython</a></li>
</ul>
</div>

                </div>
            </div>
            <!-- /.entry-content -->
<section class="text-center">
  
<div id="donate"></div>

<div class="social-share"></div>
<div class="social-comment-note">
<p class="text-center">有任何建议和想法欢迎在下方评论区留言或者加我<a href="/static/wechat.png">微信</a>交流</p>
</div>

</section>
<hr/>
<section class="comments" id="comments">
    <h2>Comments</h2>
    <script src="https://giscus.app/client.js"
            data-repo="mozillazg/mozillazg.github.com"
            data-repo-id="MDEwOlJlcG9zaXRvcnk3Njc4MTA2"
            data-category="Announcements"
            data-category-id="DIC_kwDOAHUoms4CckZl"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="0"
            data-input-position="bottom"
            data-theme="preferred_color_scheme"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
    </script>
</section>
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2024 mozillazg
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>
            &middot; <a href="/privacy-policy.html" target="_blank">Privacy</a>              <p><small>  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/static/images/by-sa-80x15.png" /></a>
    &quot;<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">mozillazg's Blog</span>&quot; by <a xmlns:cc="http://creativecommons.org/ns#" href="https://mozillazg.com" property="cc:attributionName" rel="cc:attributionURL">mozillazg</a> is
  licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="/theme/cdn.jsdelivr.net/npm/jquery@2.1.1/dist/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="/theme/cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->


<!-- share.js -->
<script src="/theme/cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>



<script src="/theme/cdn.jsdelivr.net/npm/tocbot@3.0.2/dist/tocbot.min.js"></script>
<script>
$(document).ready(function(){
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.js-toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.entry-content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h2, h3, h4,h5',
    // Headings that match the ignoreSelector will be skipped.
    ignoreSelector: '.js-toc-ignore',
    // Main class to add to links.
    linkClass: 'toc-link',
    // Extra classes to add to links.
    extraLinkClasses: '',
    // Class to add to active links,
    // the link corresponding to the top most heading on the page.
    activeLinkClass: 'is-active-link',
    // Main class to add to lists.
    listClass: 'toc-list',
    // Extra classes to add to lists.
    extraListClasses: '',
    // Class that gets added when a list should be collapsed.
    isCollapsedClass: 'is-collapsed',
    // Class that gets added when a list should be able
    // to be collapsed but isn't necessarily collpased.
    collapsibleClass: 'is-collapsible',
    // Class to add to list items.
    listItemClass: 'toc-list-item',
    // How many heading levels should not be collpased.
    // For example, number 6 will show everything since
    // there are only 6 heading levels and number 0 will collpase them all.
    // The sections that are hidden will open
    // and close as you scroll to headings within them.
    collapseDepth: 6,
    // Smooth scrolling enabled.
    smoothScroll: true,
    // Smooth scroll duration.
    smoothScrollDuration: 420,
    // Callback for scroll end (requires: smoothScroll).
    scrollEndCallback: function (e) {},
    // Headings offset between the headings and the top of the document (this is meant for minor adjustments).
    headingsOffset: 0,
    // Timeout between events firing to make sure it's
    // not too rapid (for performance reasons).
    throttleTimeout: 50,
    // Element to add the positionFixedClass to.
    positionFixedSelector: null,
    // Fixed position class to add to make sidebar fixed after scrolling
    // down past the fixedSidebarOffset.
    positionFixedClass: 'is-position-fixed',
    // fixedSidebarOffset can be any number but by default is set
    // to auto which sets the fixedSidebarOffset to the sidebar
    // element's offsetTop from the top of the document on init.
    fixedSidebarOffset: 'auto',
    // includeHtml can be set to true to include the HTML markup from the
    // heading node instead of just including the textContent.
    includeHtml: false
  });
});
</script>
</body>
</html>