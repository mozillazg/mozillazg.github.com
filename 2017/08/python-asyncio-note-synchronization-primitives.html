<!DOCTYPE html>
<html lang="zh-hans" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml" class="han-init">
<head>
    <title>asyncio 学习笔记：同步原语 - Huang Huang 的博客</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- share.css -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
    <!-- share.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


    <link href="https://mozillazg.com/favicon.ico" rel="icon">

<link rel="canonical" href="https://mozillazg.com/2017/08/python-asyncio-note-synchronization-primitives.html">

        <meta name="author" content="mozillazg" />
        <meta name="keywords" content="asyncio" />
    <meta name="description" content="本文是 https://pymotw.com/3/asyncio/synchronization.html 的学习笔记，强烈推荐直接阅读原文。 虽然 asyncio 应用一般都是单线程程序，但是它们仍然是并发程序。 为了支持安全的并发，asyncio 实现了一些 threading 和 multiprocessing 模块中比较常用的类似的同步原语。 Lock¶ Lock 可以用来安全的访问共享资源。 # asyncio_lock.py import asyncio import functools def unlock(lock): print(&#39;callback releasing lock&#39;) lock.release() async def coro1(lock): print(&#39;coro1 wating for the lock&#39;) with await lock: print(&#39;coro1 acquired lock&#39;) print(&#39;coro1 released lock&#39;) async def coro2(lock): print(&#39;coro2 wating for the lock&#39;) await lock try: print(&#39;coro2 acquired lock&#39;) finally: print(&#39;coro2 released lock&#39;) lock.release() async def main(loop): lock = asyncio.Lock() print(&#39;acquiring the lock before starting coroutines&#39;) await lock.acquire() print(&#39;lock acquired: {}&#39;.format(lock.locked())) loop.call_later(0.1, functools.partial(unlock, lock)) print(&#39;waiting for coroutines&#39;) await asyncio.wait([coro1(lock), coro2(lock)]) event_loop = asyncio.get_event_loop() try: event_loop.run_until_complete(main(event_loop)) finally: event_loop.close() 可以使用 await 来获取锁，使用 release() 方法来释放锁。也可以用 with await 上下文语句来获取和释放锁。 $ python3.6 asyncio_lock.py acquiring the lock before starting coroutines lock acquired: True waiting for coroutines coro1 wating for the lock coro2 wating for the lock callback releasing lock coro1 acquired lock coro1 released lock coro2 acquired lock coro2 released lock Event¶ asyncio.Event 类似 threading.Event 用来允许多个消费者等待某个事情发生，不用通过监听一个特殊的值的来说实现类似通知的功能。 # asyncio_event.py import asyncio import functools def set_event(event): print(&#39;setting event in callback&#39;) event.set() async def coro1(event): print(&#39;coro1 waiting for event&#39;) await event.wait() print(&#39;coro1 triggered&#39;) async def coro2(event): print(&#39;coro2 waiting for event&#39;) await event.wait() print(&#39;coro2 triggered&#39;) async def main(loop): event = asyncio.Event() print(&#39;event start state: {}&#39;.format(event.is_set())) loop.call_later( 0.1, functools.partial(set_event, event) ) await asyncio.wait([coro1(event), coro2(event)]) print(&#39;event end state: {}&#39;.format(event.is_set())) event_loop = asyncio.get_event_loop() try: event_loop.run_until_complete(main(event_loop)) finally: event_loop.close() 和 Lock 一样，coro1() 和 coro2() 都在等待 event 被设置。 不同的是它们都在 event 状态一发生变化的时候就启动了，它们不需要对 event 对象获取一个唯一的所有权。 $ python3.6 asyncio_event.py event start state: False coro1 waiting for event coro2 waiting for event setting event in callback coro1 triggered coro2 triggered event end state: True Condition¶ Condition 的效果类似 Event，不同的是它不是唤醒所有等待中的 coroutine, 而是通过 notify() 唤醒指定数量的待唤醒 coroutine。 # asyncio_condition.py import asyncio async def consumer(condition, n): with await condition: print(&#39;consumer {} is waiting&#39;.format(n)) await condition.wait() print(&#39;consumer {} triggered&#39;.format(n)) print(&#39;ending consumer {}&#39;.format(n)) async def manipulate_condition(condition): print(&#39;starting manipulate_condition&#39;) await asyncio.sleep(0.1) for i in range(1, 3): with await condition: print(&#39;notifying {} consumers&#39;.format(i)) condition.notify(n=i) await asyncio.sleep(0.1) with await condition: print(&#39;notifying remaining consumers&#39;) condition.notify_all() print(&#39;ending manipulate_condition&#39;) async def main(loop): condition = asyncio.Condition() consumers = [ consumer(condition, i) for i in range(5) ] loop.create_task(manipulate_condition(condition)) await asyncio.wait(consumers) event_loop = asyncio.get_event_loop() try: result = event_loop.run_until_complete(main(event_loop)) finally: event_loop.close() 在这个例子中，我们启动了五个 Condition 的消费者，每个都使用 wait() 方法来等待它们可以继续处理的通知。manipulate_condition() 首先通知了一个消费者，然后有通知了两个消费者，最后通知剩下的所有消费者。 $ python3.6 asyncio_condition.py starting manipulate_condition consumer 0 is waiting consumer 4 is waiting consumer 1 is waiting consumer 2 is waiting consumer 3 is waiting notifying 1 consumers consumer 0 triggered ending consumer 0 notifying 2 consumers consumer 4 triggered ending consumer 4 consumer 1 triggered ending consumer 1 notifying remaining consumers ending manipulate_condition consumer 2 triggered ending consumer 2 consumer 3 triggered ending consumer 3 Queue¶ asyncio.Queue 为 coroutines 实现了一个先进先出的数据结构，类似多线程中的 queue.Queue ，多进程中的 multiprocessing.Queue # asyncio_queue.py import asyncio async def consumer(n, q): print(&#39;consumer {}: waiting for item&#39;.format(n)) while True: print(&#39;consumer {}: waiting for item&#39;.format(n)) item = await q.get() print(&#39;consumer {}: has item {}&#39;.format(n, item)) # 在这个程序中 None 是个特殊的值，表示终止信号 if item is None: q.task_done() break else: await asyncio.sleep(0.01 * item) q.task_done() print(&#39;consumer {}: ending&#39;.format(n)) async def producer(q, num_workers): print(&#39;producer: starting&#39;) # 向队列中添加一些数据 for i in range(num_workers * 3): await q.put(i) print(&#39;producer: added task {} to the queue&#39;.format(i)) # 通过 None 这个特殊值来通知消费者退出 print(&#39;producer: adding stop signals to the queue&#39;) for i in range(num_workers): await q.put(None) print(&#39;producer: waiting for queue to empty&#39;) await q.join() print(&#39;producer: ending&#39;) async def main(loop, num_consumers): # 创建指定大小的队列，这样的话生产者将会阻塞 # 直到有消费者获取数据 q = asyncio.Queue(maxsize=num_consumers) # 调度消费者 consumers = [ loop.create_task(consumer(i, q)) for i in range(num_consumers) ] # 调度生产者 prod = loop.create_task(producer(q, num_consumers)) # 等待所有 coroutines 都完成 await asyncio.wait(consumers + [prod]) event_loop = asyncio.get_event_loop() try: event_loop.run_until_complete(main(event_loop, 2)) finally: event_loop.close() 通过 put() 添加项或者通过 get() 移除项都是异步操作，同时有可能队列大小达到指定大小（阻塞添加操作）或者队列变空（阻塞所有获取项的调用）。 $ python3.6 asyncio_queue.py consumer 0: waiting for item consumer 0: waiting for item consumer 1: waiting for item consumer 1: waiting for item producer: starting producer: added task 0 to the queue producer: added task 1 to the queue consumer 0: has item 0 consumer 1: has item 1 producer: added task 2 to the queue producer: added task 3 to the queue consumer 0: waiting for item consumer 0: has item 2 producer: added task 4 to the queue consumer 1: waiting for item consumer 1: has item 3 producer: added task 5 to the queue producer: adding stop signals to the queue consumer 0: waiting for item consumer 0: has item 4 consumer 1: waiting for item consumer 1: has item 5 producer: waiting for queue to empty consumer 0: waiting for item consumer 0: has item None consumer 0: ending consumer 1: waiting for item consumer 1: has item None consumer 1: ending producer: ending 参考资料¶ Synchronization Primitives — PyMOTW 3 18.5.7. Synchronization primitives — Python 3.6.2 documentation" />

    <style>
      .js-toc {
        margin-bottom: 20px;
      }
      .donate-modal {
        text-align: center;
      }
      #donate-modal-container .donate-image {
        max-height: 300px !important;
        min-height: inherit !important;
      }
    </style>

        <meta property="og:site_name" content="Huang Huang 的博客" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="asyncio 学习笔记：同步原语"/>
        <meta property="og:url" content="https://mozillazg.com/2017/08/python-asyncio-note-synchronization-primitives.html"/>
        <meta property="og:description" content="本文是 https://pymotw.com/3/asyncio/synchronization.html 的学习笔记，强烈推荐直接阅读原文。 虽然 asyncio 应用一般都是单线程程序，但是它们仍然是并发程序。 为了支持安全的并发，asyncio 实现了一些 threading 和 multiprocessing 模块中比较常用的类似的同步原语。 Lock¶ Lock 可以用来安全的访问共享资源。 # asyncio_lock.py import asyncio import functools def unlock(lock): print(&#39;callback releasing lock&#39;) lock.release() async def coro1(lock): print(&#39;coro1 wating for the lock&#39;) with await lock: print(&#39;coro1 acquired lock&#39;) print(&#39;coro1 released lock&#39;) async def coro2(lock): print(&#39;coro2 wating for the lock&#39;) await lock try: print(&#39;coro2 acquired lock&#39;) finally: print(&#39;coro2 released lock&#39;) lock.release() async def main(loop): lock = asyncio.Lock() print(&#39;acquiring the lock before starting coroutines&#39;) await lock.acquire() print(&#39;lock acquired: {}&#39;.format(lock.locked())) loop.call_later(0.1, functools.partial(unlock, lock)) print(&#39;waiting for coroutines&#39;) await asyncio.wait([coro1(lock), coro2(lock)]) event_loop = asyncio.get_event_loop() try: event_loop.run_until_complete(main(event_loop)) finally: event_loop.close() 可以使用 await 来获取锁，使用 release() 方法来释放锁。也可以用 with await 上下文语句来获取和释放锁。 $ python3.6 asyncio_lock.py acquiring the lock before starting coroutines lock acquired: True waiting for coroutines coro1 wating for the lock coro2 wating for the lock callback releasing lock coro1 acquired lock coro1 released lock coro2 acquired lock coro2 released lock Event¶ asyncio.Event 类似 threading.Event 用来允许多个消费者等待某个事情发生，不用通过监听一个特殊的值的来说实现类似通知的功能。 # asyncio_event.py import asyncio import functools def set_event(event): print(&#39;setting event in callback&#39;) event.set() async def coro1(event): print(&#39;coro1 waiting for event&#39;) await event.wait() print(&#39;coro1 triggered&#39;) async def coro2(event): print(&#39;coro2 waiting for event&#39;) await event.wait() print(&#39;coro2 triggered&#39;) async def main(loop): event = asyncio.Event() print(&#39;event start state: {}&#39;.format(event.is_set())) loop.call_later( 0.1, functools.partial(set_event, event) ) await asyncio.wait([coro1(event), coro2(event)]) print(&#39;event end state: {}&#39;.format(event.is_set())) event_loop = asyncio.get_event_loop() try: event_loop.run_until_complete(main(event_loop)) finally: event_loop.close() 和 Lock 一样，coro1() 和 coro2() 都在等待 event 被设置。 不同的是它们都在 event 状态一发生变化的时候就启动了，它们不需要对 event 对象获取一个唯一的所有权。 $ python3.6 asyncio_event.py event start state: False coro1 waiting for event coro2 waiting for event setting event in callback coro1 triggered coro2 triggered event end state: True Condition¶ Condition 的效果类似 Event，不同的是它不是唤醒所有等待中的 coroutine, 而是通过 notify() 唤醒指定数量的待唤醒 coroutine。 # asyncio_condition.py import asyncio async def consumer(condition, n): with await condition: print(&#39;consumer {} is waiting&#39;.format(n)) await condition.wait() print(&#39;consumer {} triggered&#39;.format(n)) print(&#39;ending consumer {}&#39;.format(n)) async def manipulate_condition(condition): print(&#39;starting manipulate_condition&#39;) await asyncio.sleep(0.1) for i in range(1, 3): with await condition: print(&#39;notifying {} consumers&#39;.format(i)) condition.notify(n=i) await asyncio.sleep(0.1) with await condition: print(&#39;notifying remaining consumers&#39;) condition.notify_all() print(&#39;ending manipulate_condition&#39;) async def main(loop): condition = asyncio.Condition() consumers = [ consumer(condition, i) for i in range(5) ] loop.create_task(manipulate_condition(condition)) await asyncio.wait(consumers) event_loop = asyncio.get_event_loop() try: result = event_loop.run_until_complete(main(event_loop)) finally: event_loop.close() 在这个例子中，我们启动了五个 Condition 的消费者，每个都使用 wait() 方法来等待它们可以继续处理的通知。manipulate_condition() 首先通知了一个消费者，然后有通知了两个消费者，最后通知剩下的所有消费者。 $ python3.6 asyncio_condition.py starting manipulate_condition consumer 0 is waiting consumer 4 is waiting consumer 1 is waiting consumer 2 is waiting consumer 3 is waiting notifying 1 consumers consumer 0 triggered ending consumer 0 notifying 2 consumers consumer 4 triggered ending consumer 4 consumer 1 triggered ending consumer 1 notifying remaining consumers ending manipulate_condition consumer 2 triggered ending consumer 2 consumer 3 triggered ending consumer 3 Queue¶ asyncio.Queue 为 coroutines 实现了一个先进先出的数据结构，类似多线程中的 queue.Queue ，多进程中的 multiprocessing.Queue # asyncio_queue.py import asyncio async def consumer(n, q): print(&#39;consumer {}: waiting for item&#39;.format(n)) while True: print(&#39;consumer {}: waiting for item&#39;.format(n)) item = await q.get() print(&#39;consumer {}: has item {}&#39;.format(n, item)) # 在这个程序中 None 是个特殊的值，表示终止信号 if item is None: q.task_done() break else: await asyncio.sleep(0.01 * item) q.task_done() print(&#39;consumer {}: ending&#39;.format(n)) async def producer(q, num_workers): print(&#39;producer: starting&#39;) # 向队列中添加一些数据 for i in range(num_workers * 3): await q.put(i) print(&#39;producer: added task {} to the queue&#39;.format(i)) # 通过 None 这个特殊值来通知消费者退出 print(&#39;producer: adding stop signals to the queue&#39;) for i in range(num_workers): await q.put(None) print(&#39;producer: waiting for queue to empty&#39;) await q.join() print(&#39;producer: ending&#39;) async def main(loop, num_consumers): # 创建指定大小的队列，这样的话生产者将会阻塞 # 直到有消费者获取数据 q = asyncio.Queue(maxsize=num_consumers) # 调度消费者 consumers = [ loop.create_task(consumer(i, q)) for i in range(num_consumers) ] # 调度生产者 prod = loop.create_task(producer(q, num_consumers)) # 等待所有 coroutines 都完成 await asyncio.wait(consumers + [prod]) event_loop = asyncio.get_event_loop() try: event_loop.run_until_complete(main(event_loop, 2)) finally: event_loop.close() 通过 put() 添加项或者通过 get() 移除项都是异步操作，同时有可能队列大小达到指定大小（阻塞添加操作）或者队列变空（阻塞所有获取项的调用）。 $ python3.6 asyncio_queue.py consumer 0: waiting for item consumer 0: waiting for item consumer 1: waiting for item consumer 1: waiting for item producer: starting producer: added task 0 to the queue producer: added task 1 to the queue consumer 0: has item 0 consumer 1: has item 1 producer: added task 2 to the queue producer: added task 3 to the queue consumer 0: waiting for item consumer 0: has item 2 producer: added task 4 to the queue consumer 1: waiting for item consumer 1: has item 3 producer: added task 5 to the queue producer: adding stop signals to the queue consumer 0: waiting for item consumer 0: has item 4 consumer 1: waiting for item consumer 1: has item 5 producer: waiting for queue to empty consumer 0: waiting for item consumer 0: has item None consumer 0: ending consumer 1: waiting for item consumer 1: has item None consumer 1: ending producer: ending 参考资料¶ Synchronization Primitives — PyMOTW 3 18.5.7. Synchronization primitives — Python 3.6.2 documentation"/>
        <meta property="article:published_time" content="2017-08-26" />
            <meta property="article:section" content="python" />
            <meta property="article:tag" content="asyncio" />
            <meta property="article:author" content="mozillazg" />
            <meta property="og:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>


    <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@mozillazg">
        <meta name="twitter:creator" content="@mozillazg">
    <meta name="twitter:domain" content="https://mozillazg.com">
            <meta property="twitter:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://mozillazg.com/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="https://mozillazg.com/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="https://mozillazg.com/theme/css/pygments/github.css" rel="stylesheet">
    <link rel="stylesheet" href="https://mozillazg.com/theme/css/style.css" type="text/css"/>
            <link href="https://mozillazg.com/static/custom.css" rel="stylesheet">

        <link href="https://mozillazg.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Huang Huang 的博客 ATOM Feed"/>

        <link href="https://mozillazg.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="Huang Huang 的博客 RSS Feed"/>


        <link href="https://mozillazg.com/feeds/python.atom.xml" type="application/atom+xml" rel="alternate"
              title="Huang Huang 的博客 python ATOM Feed"/>


    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Website",
        "publisher": {
            "@type": "Person",
            "name": "mozillazg",
            "logo": "https://mozillazg.com/static/avatar.jpeg"
        },
        "author": {
            "@type": "Person",
            "name": "mozillazg",
            "image": "https://mozillazg.com/static/avatar.jpeg",
            "url": "https://mozillazg.com",
            "sameAs": []
        },
        // "headline": "",
        "url": "https://mozillazg.com/2017/08/python-asyncio-note-synchronization-primitives.html",
        "datePublished": "2017-08-26",
        // "dateModified": "",
        "image": "https://mozillazg.com/static/avatar.jpeg",
        "keywords": "asyncio",
        "description": "本文是 https://pymotw.com/3/asyncio/synchronization.html 的学习笔记，强烈推荐直接阅读原文。 虽然 asyncio 应用一般都是单线程程序，但是它们仍然是并发程序。 为了支持安全的并发，asyncio 实现了一些 threading 和 multiprocessing 模块中比较常用的类似的同步原语。 Lock¶ Lock 可以用来安全的访问共享资源。 # asyncio_lock.py import asyncio import functools def unlock(lock): print(&#39;callback releasing lock&#39;) lock.release() async def coro1(lock): print(&#39;coro1 wating for the lock&#39;) with await lock: print(&#39;coro1 acquired lock&#39;) print(&#39;coro1 released lock&#39;) async def coro2(lock): print(&#39;coro2 wating for the lock&#39;) await lock try: print(&#39;coro2 acquired lock&#39;) finally: print(&#39;coro2 released lock&#39;) lock.release() async def main(loop): lock = asyncio.Lock() print(&#39;acquiring the lock before starting coroutines&#39;) await lock.acquire() print(&#39;lock acquired: {}&#39;.format(lock.locked())) loop.call_later(0.1, functools.partial(unlock, lock)) print(&#39;waiting for coroutines&#39;) await asyncio.wait([coro1(lock), coro2(lock)]) event_loop = asyncio.get_event_loop() try: event_loop.run_until_complete(main(event_loop)) finally: event_loop.close() 可以使用 await 来获取锁，使用 release() 方法来释放锁。也可以用 with await 上下文语句来获取和释放锁。 $ python3.6 asyncio_lock.py acquiring the lock before starting coroutines lock acquired: True waiting for coroutines coro1 wating for the lock coro2 wating for the lock callback releasing lock coro1 acquired lock coro1 released lock coro2 acquired lock coro2 released lock Event¶ asyncio.Event 类似 threading.Event 用来允许多个消费者等待某个事情发生，不用通过监听一个特殊的值的来说实现类似通知的功能。 # asyncio_event.py import asyncio import functools def set_event(event): print(&#39;setting event in callback&#39;) event.set() async def coro1(event): print(&#39;coro1 waiting for event&#39;) await event.wait() print(&#39;coro1 triggered&#39;) async def coro2(event): print(&#39;coro2 waiting for event&#39;) await event.wait() print(&#39;coro2 triggered&#39;) async def main(loop): event = asyncio.Event() print(&#39;event start state: {}&#39;.format(event.is_set())) loop.call_later( 0.1, functools.partial(set_event, event) ) await asyncio.wait([coro1(event), coro2(event)]) print(&#39;event end state: {}&#39;.format(event.is_set())) event_loop = asyncio.get_event_loop() try: event_loop.run_until_complete(main(event_loop)) finally: event_loop.close() 和 Lock 一样，coro1() 和 coro2() 都在等待 event 被设置。 不同的是它们都在 event 状态一发生变化的时候就启动了，它们不需要对 event 对象获取一个唯一的所有权。 $ python3.6 asyncio_event.py event start state: False coro1 waiting for event coro2 waiting for event setting event in callback coro1 triggered coro2 triggered event end state: True Condition¶ Condition 的效果类似 Event，不同的是它不是唤醒所有等待中的 coroutine, 而是通过 notify() 唤醒指定数量的待唤醒 coroutine。 # asyncio_condition.py import asyncio async def consumer(condition, n): with await condition: print(&#39;consumer {} is waiting&#39;.format(n)) await condition.wait() print(&#39;consumer {} triggered&#39;.format(n)) print(&#39;ending consumer {}&#39;.format(n)) async def manipulate_condition(condition): print(&#39;starting manipulate_condition&#39;) await asyncio.sleep(0.1) for i in range(1, 3): with await condition: print(&#39;notifying {} consumers&#39;.format(i)) condition.notify(n=i) await asyncio.sleep(0.1) with await condition: print(&#39;notifying remaining consumers&#39;) condition.notify_all() print(&#39;ending manipulate_condition&#39;) async def main(loop): condition = asyncio.Condition() consumers = [ consumer(condition, i) for i in range(5) ] loop.create_task(manipulate_condition(condition)) await asyncio.wait(consumers) event_loop = asyncio.get_event_loop() try: result = event_loop.run_until_complete(main(event_loop)) finally: event_loop.close() 在这个例子中，我们启动了五个 Condition 的消费者，每个都使用 wait() 方法来等待它们可以继续处理的通知。manipulate_condition() 首先通知了一个消费者，然后有通知了两个消费者，最后通知剩下的所有消费者。 $ python3.6 asyncio_condition.py starting manipulate_condition consumer 0 is waiting consumer 4 is waiting consumer 1 is waiting consumer 2 is waiting consumer 3 is waiting notifying 1 consumers consumer 0 triggered ending consumer 0 notifying 2 consumers consumer 4 triggered ending consumer 4 consumer 1 triggered ending consumer 1 notifying remaining consumers ending manipulate_condition consumer 2 triggered ending consumer 2 consumer 3 triggered ending consumer 3 Queue¶ asyncio.Queue 为 coroutines 实现了一个先进先出的数据结构，类似多线程中的 queue.Queue ，多进程中的 multiprocessing.Queue # asyncio_queue.py import asyncio async def consumer(n, q): print(&#39;consumer {}: waiting for item&#39;.format(n)) while True: print(&#39;consumer {}: waiting for item&#39;.format(n)) item = await q.get() print(&#39;consumer {}: has item {}&#39;.format(n, item)) # 在这个程序中 None 是个特殊的值，表示终止信号 if item is None: q.task_done() break else: await asyncio.sleep(0.01 * item) q.task_done() print(&#39;consumer {}: ending&#39;.format(n)) async def producer(q, num_workers): print(&#39;producer: starting&#39;) # 向队列中添加一些数据 for i in range(num_workers * 3): await q.put(i) print(&#39;producer: added task {} to the queue&#39;.format(i)) # 通过 None 这个特殊值来通知消费者退出 print(&#39;producer: adding stop signals to the queue&#39;) for i in range(num_workers): await q.put(None) print(&#39;producer: waiting for queue to empty&#39;) await q.join() print(&#39;producer: ending&#39;) async def main(loop, num_consumers): # 创建指定大小的队列，这样的话生产者将会阻塞 # 直到有消费者获取数据 q = asyncio.Queue(maxsize=num_consumers) # 调度消费者 consumers = [ loop.create_task(consumer(i, q)) for i in range(num_consumers) ] # 调度生产者 prod = loop.create_task(producer(q, num_consumers)) # 等待所有 coroutines 都完成 await asyncio.wait(consumers + [prod]) event_loop = asyncio.get_event_loop() try: event_loop.run_until_complete(main(event_loop, 2)) finally: event_loop.close() 通过 put() 添加项或者通过 get() 移除项都是异步操作，同时有可能队列大小达到指定大小（阻塞添加操作）或者队列变空（阻塞所有获取项的调用）。 $ python3.6 asyncio_queue.py consumer 0: waiting for item consumer 0: waiting for item consumer 1: waiting for item consumer 1: waiting for item producer: starting producer: added task 0 to the queue producer: added task 1 to the queue consumer 0: has item 0 consumer 1: has item 1 producer: added task 2 to the queue producer: added task 3 to the queue consumer 0: waiting for item consumer 0: has item 2 producer: added task 4 to the queue consumer 1: waiting for item consumer 1: has item 3 producer: added task 5 to the queue producer: adding stop signals to the queue consumer 0: waiting for item consumer 0: has item 4 consumer 1: waiting for item consumer 1: has item 5 producer: waiting for queue to empty consumer 0: waiting for item consumer 0: has item None consumer 0: ending consumer 1: waiting for item consumer 1: has item None consumer 1: ending producer: ending 参考资料¶ Synchronization Primitives — PyMOTW 3 18.5.7. Synchronization primitives — Python 3.6.2 documentation",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://mozillazg.com"
        }
    }
    </script>

</head>
<body>

<div class="navbar" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://mozillazg.com/" class="navbar-brand">
Huang Huang 的博客            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="https://mozillazg.com/feeds/all.atom.xml">Feed</a></li>
                    <li><a href="/2014/10/pages/about-me.html">About</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://mozillazg.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content" class="yue">
        <article>
            <header class="text-center">
                <h1>
                    <a href="https://mozillazg.com/2017/08/python-asyncio-note-synchronization-primitives.html"
                       rel="bookmark"
                       title="Permalink to asyncio 学习笔记：同步原语">
                        asyncio 学习笔记：同步原语
                    </a>
                </h1>
                <p class="published">
                    <time datetime="2017-08-26T00:00:00+00:00">
                    2017-08-26
                    </time>
                </p>
            </header>
            <div class="entry-content">
                <div class="well-sm article-info">
<footer class="post-info">
        <a href="https://mozillazg.com/category/python.html">python</a>


<span class="label label-default hide">Tags</span>
	<a href="https://mozillazg.com/tag/asyncio.html">asyncio</a>
    
</footer><!-- /.post-info -->                </div>
                <div class="js-toc"></div>
                <div>
                <p>本文是 <a class="reference external" href="https://pymotw.com/3/asyncio/synchronization.html">https://pymotw.com/3/asyncio/synchronization.html</a>
的学习笔记，强烈推荐直接阅读原文。</p>
<p>虽然 <tt class="docutils literal">asyncio</tt> 应用一般都是单线程程序，但是它们仍然是并发程序。
为了支持安全的并发，<tt class="docutils literal">asyncio</tt> 实现了一些 <tt class="docutils literal">threading</tt> 和
<tt class="docutils literal">multiprocessing</tt> 模块中比较常用的类似的同步原语。</p>
<div class="section" id="lock">
<h2 id="hidlock">Lock<a class="headerlink" href="#hidlock" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal">Lock</tt> 可以用来安全的访问共享资源。</p>
<pre class="code python literal-block">
<span class="c1"># asyncio_lock.py</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>


<span class="k">def</span> <span class="nf">unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'callback releasing lock'</span><span class="p">)</span>
    <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">coro1</span><span class="p">(</span><span class="n">lock</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'coro1 wating for the lock'</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">await</span> <span class="n">lock</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">'coro1 acquired lock'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'coro1 released lock'</span><span class="p">)</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">coro2</span><span class="p">(</span><span class="n">lock</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'coro2 wating for the lock'</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">lock</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">'coro2 acquired lock'</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">'coro2 released lock'</span><span class="p">)</span>
        <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
    <span class="n">lock</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'acquiring the lock before starting coroutines'</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'lock acquired: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lock</span><span class="o">.</span><span class="n">locked</span><span class="p">()))</span>

    <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">unlock</span><span class="p">,</span> <span class="n">lock</span><span class="p">))</span>

    <span class="k">print</span><span class="p">(</span><span class="s1">'waiting for coroutines'</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">([</span><span class="n">coro1</span><span class="p">(</span><span class="n">lock</span><span class="p">),</span> <span class="n">coro2</span><span class="p">(</span><span class="n">lock</span><span class="p">)])</span>


<span class="n">event_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="n">event_loop</span><span class="p">))</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre>
<p>可以使用 <tt class="docutils literal">await</tt> 来获取锁，使用 <tt class="docutils literal">release()</tt> 方法来释放锁。也可以用
<tt class="docutils literal">with await</tt> 上下文语句来获取和释放锁。</p>
<pre class="literal-block">
$ python3.6 asyncio_lock.py
acquiring the lock before starting coroutines
lock acquired: True
waiting for coroutines
coro1 wating for the lock
coro2 wating for the lock
callback releasing lock
coro1 acquired lock
coro1 released lock
coro2 acquired lock
coro2 released lock
</pre>
</div>
<div class="section" id="event">
<h2 id="hidevent">Event<a class="headerlink" href="#hidevent" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal">asyncio.Event</tt> 类似 <tt class="docutils literal">threading.Event</tt>
用来允许多个消费者等待某个事情发生，不用通过监听一个特殊的值的来说实现类似通知的功能。</p>
<pre class="code python literal-block">
<span class="c1"># asyncio_event.py</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>


<span class="k">def</span> <span class="nf">set_event</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'setting event in callback'</span><span class="p">)</span>
    <span class="n">event</span><span class="o">.</span><span class="n">set</span><span class="p">()</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">coro1</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'coro1 waiting for event'</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">event</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'coro1 triggered'</span><span class="p">)</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">coro2</span><span class="p">(</span><span class="n">event</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'coro2 waiting for event'</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">event</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'coro2 triggered'</span><span class="p">)</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
    <span class="n">event</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Event</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'event start state: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">is_set</span><span class="p">()))</span>
    <span class="n">loop</span><span class="o">.</span><span class="n">call_later</span><span class="p">(</span>
        <span class="mf">0.1</span><span class="p">,</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">set_event</span><span class="p">,</span> <span class="n">event</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">([</span><span class="n">coro1</span><span class="p">(</span><span class="n">event</span><span class="p">),</span> <span class="n">coro2</span><span class="p">(</span><span class="n">event</span><span class="p">)])</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'event end state: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">is_set</span><span class="p">()))</span>


<span class="n">event_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="n">event_loop</span><span class="p">))</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre>
<div class="line-block">
<div class="line">和 <tt class="docutils literal">Lock</tt> 一样，<tt class="docutils literal">coro1()</tt> 和 <tt class="docutils literal">coro2()</tt> 都在等待 event 被设置。</div>
<div class="line">不同的是它们都在 event 状态一发生变化的时候就启动了，它们不需要对
event 对象获取一个唯一的所有权。</div>
</div>
<pre class="literal-block">
$ python3.6 asyncio_event.py
event start state: False
coro1 waiting for event
coro2 waiting for event
setting event in callback
coro1 triggered
coro2 triggered
event end state: True
</pre>
</div>
<div class="section" id="condition">
<h2 id="hidcondition">Condition<a class="headerlink" href="#hidcondition" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal">Condition</tt> 的效果类似 <tt class="docutils literal">Event</tt>，不同的是它不是唤醒所有等待中的
coroutine, 而是通过 <tt class="docutils literal">notify()</tt> 唤醒指定数量的待唤醒 coroutine。</p>
<pre class="code python literal-block">
<span class="c1"># asyncio_condition.py</span>
<span class="kn">import</span> <span class="nn">asyncio</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">await</span> <span class="n">condition</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">'consumer {} is waiting'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">await</span> <span class="n">condition</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">'consumer {} triggered'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'ending consumer {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">manipulate_condition</span><span class="p">(</span><span class="n">condition</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'starting manipulate_condition'</span><span class="p">)</span>

    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">await</span> <span class="n">condition</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">'notifying {} consumers'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">condition</span><span class="o">.</span><span class="n">notify</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">await</span> <span class="n">condition</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">'notifying remaining consumers'</span><span class="p">)</span>
        <span class="n">condition</span><span class="o">.</span><span class="n">notify_all</span><span class="p">()</span>

    <span class="k">print</span><span class="p">(</span><span class="s1">'ending manipulate_condition'</span><span class="p">)</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
    <span class="n">condition</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Condition</span><span class="p">()</span>

    <span class="n">consumers</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">consumer</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">manipulate_condition</span><span class="p">(</span><span class="n">condition</span><span class="p">))</span>

    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">consumers</span><span class="p">)</span>


<span class="n">event_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">event_loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="n">event_loop</span><span class="p">))</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre>
<p>在这个例子中，我们启动了五个 Condition 的消费者，每个都使用 <tt class="docutils literal">wait()</tt>
方法来等待它们可以继续处理的通知。<tt class="docutils literal">manipulate_condition()</tt>
首先通知了一个消费者，然后有通知了两个消费者，最后通知剩下的所有消费者。</p>
<pre class="literal-block">
$ python3.6 asyncio_condition.py
starting manipulate_condition
consumer 0 is waiting
consumer 4 is waiting
consumer 1 is waiting
consumer 2 is waiting
consumer 3 is waiting
notifying 1 consumers
consumer 0 triggered
ending consumer 0
notifying 2 consumers
consumer 4 triggered
ending consumer 4
consumer 1 triggered
ending consumer 1
notifying remaining consumers
ending manipulate_condition
consumer 2 triggered
ending consumer 2
consumer 3 triggered
ending consumer 3
</pre>
</div>
<div class="section" id="queue">
<h2 id="hidqueue">Queue<a class="headerlink" href="#hidqueue" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal">asyncio.Queue</tt> 为 coroutines
实现了一个先进先出的数据结构，类似多线程中的 <tt class="docutils literal">queue.Queue</tt>
，多进程中的 <tt class="docutils literal">multiprocessing.Queue</tt></p>
<pre class="code python literal-block">
<span class="c1"># asyncio_queue.py</span>
<span class="kn">import</span> <span class="nn">asyncio</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">consumer</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'consumer {}: waiting for item'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">'consumer {}: waiting for item'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">await</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">'consumer {}: has item {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span>
        <span class="c1"># 在这个程序中 None 是个特殊的值，表示终止信号</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">q</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>
            <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span> <span class="o">*</span> <span class="n">item</span><span class="p">)</span>
            <span class="n">q</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>

    <span class="k">print</span><span class="p">(</span><span class="s1">'consumer {}: ending'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">producer</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">num_workers</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'producer: starting'</span><span class="p">)</span>
    <span class="c1"># 向队列中添加一些数据</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_workers</span> <span class="o">*</span> <span class="mi">3</span><span class="p">):</span>
        <span class="n">await</span> <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">'producer: added task {} to the queue'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

    <span class="c1"># 通过 None 这个特殊值来通知消费者退出</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'producer: adding stop signals to the queue'</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_workers</span><span class="p">):</span>
        <span class="n">await</span> <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'producer: waiting for queue to empty'</span><span class="p">)</span>
    <span class="n">await</span> <span class="n">q</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">'producer: ending'</span><span class="p">)</span>


<span class="n">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">num_consumers</span><span class="p">):</span>
    <span class="c1"># 创建指定大小的队列，这样的话生产者将会阻塞</span>
    <span class="c1"># 直到有消费者获取数据</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="n">num_consumers</span><span class="p">)</span>

    <span class="c1"># 调度消费者</span>
    <span class="n">consumers</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">consumer</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_consumers</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># 调度生产者</span>
    <span class="n">prod</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">create_task</span><span class="p">(</span><span class="n">producer</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">num_consumers</span><span class="p">))</span>

    <span class="c1"># 等待所有 coroutines 都完成</span>
    <span class="n">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">wait</span><span class="p">(</span><span class="n">consumers</span> <span class="o">+</span> <span class="p">[</span><span class="n">prod</span><span class="p">])</span>


<span class="n">event_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">main</span><span class="p">(</span><span class="n">event_loop</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre>
<p>通过 <tt class="docutils literal">put()</tt> 添加项或者通过 <tt class="docutils literal">get()</tt>
移除项都是异步操作，同时有可能队列大小达到指定大小（阻塞添加操作）或者队列变空（阻塞所有获取项的调用）。</p>
<pre class="literal-block">
$ python3.6 asyncio_queue.py
consumer 0: waiting for item
consumer 0: waiting for item
consumer 1: waiting for item
consumer 1: waiting for item
producer: starting
producer: added task 0 to the queue
producer: added task 1 to the queue
consumer 0: has item 0
consumer 1: has item 1
producer: added task 2 to the queue
producer: added task 3 to the queue
consumer 0: waiting for item
consumer 0: has item 2
producer: added task 4 to the queue
consumer 1: waiting for item
consumer 1: has item 3
producer: added task 5 to the queue
producer: adding stop signals to the queue
consumer 0: waiting for item
consumer 0: has item 4
consumer 1: waiting for item
consumer 1: has item 5
producer: waiting for queue to empty
consumer 0: waiting for item
consumer 0: has item None
consumer 0: ending
consumer 1: waiting for item
consumer 1: has item None
consumer 1: ending
producer: ending
</pre>
</div>
<div class="section" id="id1">
<h2 id="hidid1">参考资料<a class="headerlink" href="#hidid1" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://pymotw.com/3/asyncio/synchronization.html">Synchronization Primitives — PyMOTW
3</a></li>
<li><a class="reference external" href="https://docs.python.org/3.6/library/asyncio-sync.html">18.5.7. Synchronization primitives — Python 3.6.2
documentation</a></li>
</ul>
</div>

                </div>
            </div>
            <!-- /.entry-content -->
<section class="text-center">
  
<div id="donate"></div>

<div class="social-share"></div>
<div>
<p>有任何意见欢迎在下方留言或者加我微信交流</p>
<img src="/static/wechat.png" height="200px" width="200px"/>
</div>

</section>
<section class="well" id="related-posts">
    <p>Related Posts:</p>
    <ul>
        <li><a href="https://mozillazg.com/2017/08/python-asyncio-note-coroutine-schedule.html">asyncio 学习笔记：调用定时函数</a></li>
        <li><a href="https://mozillazg.com/2017/08/python-asyncio-note-task-usage.html">asyncio 学习笔记：并发执行 Task</a></li>
        <li><a href="https://mozillazg.com/2017/08/python-asyncio-note-control-Coroutines.html">asyncio 学习笔记：控制组合式 Coroutines</a></li>
        <li><a href="https://mozillazg.com/2017/08/python-asyncio-note-future-usage.html">asyncio 学习笔记：产生异步结果</a></li>
        <li><a href="https://mozillazg.com/2017/08/python-asyncio-note-io-protocol.html">asyncio 学习笔记：使用抽象类 Protocol 实现异步 I/O</a></li>
    </ul>
</section>
    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'my-github-blog'; // required: replace example with your forum shortname

                    var disqus_identifier = 'python-asyncio-note-synchronization-primitives';
                var disqus_url = 'https://mozillazg.com/2017/08/python-asyncio-note-synchronization-primitives.html';

            var disqus_config = function () {
                this.language = "zh-hans";
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2019 mozillazg
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>              <p><small>  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/static/images/by-sa-80x15.png" /></a>
    &quot;<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Huang Huang 的博客</span>&quot; by <a xmlns:cc="http://creativecommons.org/ns#" href="https://mozillazg.com" property="cc:attributionName" rel="cc:attributionURL">mozillazg</a> is
  licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="https://mozillazg.com/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://mozillazg.com/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="https://mozillazg.com/theme/js/respond.min.js"></script>

    <!-- Disqus -->
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'my-github-blog'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script');
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <!-- End Disqus Code -->
    <!-- Google Analytics Universal -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-77172981-1', 'auto');
        ga('send', 'pageview');
    </script>
    <!-- End Google Analytics Universal Code -->


<script src="https://mozillazg.com/theme/js/vdonate.js"></script>
<script>
$(document).ready(function(){
new vdonate({
  title: '如果觉得我的文章对您有用，请随意打赏。您的支持将鼓励我继续创作!', // 可选参数，打赏标题
  btnText: '打赏支持', // 可选参数，打赏按钮文字
  el: document.getElementById('donate'), // 必选参数，打赏按钮的容器
  wechatImage: 'https://mozillazg.com/static/wechat_donate.png', // 必选参数，微信收款二维码
  alipayImage: 'https://mozillazg.com/static/alipay_donate.jpg' // 必选参数，支付宝收款二维码
});
});
</script>

<script src="https://mozillazg.com/theme/js/tocbot.min.js"></script>
<script>
$(document).ready(function(){
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.js-toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.entry-content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h2, h3, h4,h5',
    // Headings that match the ignoreSelector will be skipped.
    ignoreSelector: '.js-toc-ignore',
    // Main class to add to links.
    linkClass: 'toc-link',
    // Extra classes to add to links.
    extraLinkClasses: '',
    // Class to add to active links,
    // the link corresponding to the top most heading on the page.
    activeLinkClass: 'is-active-link',
    // Main class to add to lists.
    listClass: 'toc-list',
    // Extra classes to add to lists.
    extraListClasses: '',
    // Class that gets added when a list should be collapsed.
    isCollapsedClass: 'is-collapsed',
    // Class that gets added when a list should be able
    // to be collapsed but isn't necessarily collpased.
    collapsibleClass: 'is-collapsible',
    // Class to add to list items.
    listItemClass: 'toc-list-item',
    // How many heading levels should not be collpased.
    // For example, number 6 will show everything since
    // there are only 6 heading levels and number 0 will collpase them all.
    // The sections that are hidden will open
    // and close as you scroll to headings within them.
    collapseDepth: 6,
    // Smooth scrolling enabled.
    smoothScroll: true,
    // Smooth scroll duration.
    smoothScrollDuration: 420,
    // Callback for scroll end (requires: smoothScroll).
    scrollEndCallback: function (e) {},
    // Headings offset between the headings and the top of the document (this is meant for minor adjustments).
    headingsOffset: 0,
    // Timeout between events firing to make sure it's
    // not too rapid (for performance reasons).
    throttleTimeout: 50,
    // Element to add the positionFixedClass to.
    positionFixedSelector: null,
    // Fixed position class to add to make sidebar fixed after scrolling
    // down past the fixedSidebarOffset.
    positionFixedClass: 'is-position-fixed',
    // fixedSidebarOffset can be any number but by default is set
    // to auto which sets the fixedSidebarOffset to the sidebar
    // element's offsetTop from the top of the document on init.
    fixedSidebarOffset: 'auto',
    // includeHtml can be set to true to include the HTML markup from the
    // heading node instead of just including the textContent.
    includeHtml: false
  });
});
</script>
</body>
</html>