<!DOCTYPE html>
<html lang="zh"  prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml" class="han-init">
<head>
    <title>asyncio 学习笔记：使用抽象类 Protocol 实现异步 I/O - Huang Huang 的博客</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- share.css -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">


    <link href="https://mozillazg.com/favicon.ico" rel="icon">

<link rel="canonical" href="https://mozillazg.com/2017/08/python-asyncio-note-io-protocol.html">

        <meta name="author" content="mozillazg" />
        <meta name="keywords" content="python,asyncio" />
    <meta name="description" content="本文是 https://pymotw.com/3/asyncio/io_protocol.html 的学习笔记，强烈推荐直接阅读原文。 这次将用两个程序介绍使用 asyncio 实现一个简单的 echo 服务端和客户端程序 echo 服务端程序¶ 首先导入必需的一些模块，设置一下 asyncio 和 logging，然后再创建一个事件循环对象. # asyncio_echo_server_protocol.py import asyncio import logging import sys SERVER_ADDRESS = (&#39;localhost&#39;, 10000) logging.basicConfig( level=logging.DEBUG, format=&#39;%(name)s: %(message)s&#39;, stream=sys.stderr, ) log = logging.getLogger(&#39;main&#39;) event_loop = asyncio.get_event_loop() 然后定义一个继承 asyncio.Protocol 的子类，用来处理与客户端的通信。 protocol 的方法是基于服务端 socket 事件来触发的。 class EchoServer(asyncio.Protocol): 每当有一个新的客户端连接的时候，就会触发调用 connection_made() 方法。 transport 参数 是一个 asyncio.Transport 实例对象，这个对象抽象了一系列使用 socket 进行异步 I/O 操作的方法。不同的通信协议提供了不同的 transport 实现，但是它们都有同样的 API. 比如，有一些 transport 类用来与 socket 通信，有些用来跟子进程通过管道通信。 可以通过 get_extra_info() 获取进来的客户端的地址信息。 def connection_made(self, transport): self.transport = transport self.address = transport.get_extra_info(&#39;peername&#39;) self.log = logging.getLogger( &#39;EchoServer_{}_{}&#39;.format(*self.address) ) self.log.debug(&#39;connection accepted&#39;) 连接建立以后，当有数据从客户端发到服务端的时候会使用传输过来的数据调用 data_received() 方法。这里我们记录一下收到的数据，然后立即发收到的数据通过 transport.write() 发回客户端。 def data_received(self, data): self.log.debug(&#39;received {!r}&#39;.format(data)) self.transport.write(data) self.log.debug(&#39;sent {!r}&#39;.format(data)) 一些 transport 支持一个特殊的 end-of-file 标识符(EOF)。当遇到一个 EOF 的时候，eof_received() 方法会被调用。在本次实现中，EOF 会被发送会客户端，表示这个信号已经被收到。因为不是所有的 transport 都支持这个 EOF ，这个协议会首先询问 transport 是否可以安全的发送 EOF . def eof_received(self): self.log.debug(&#39;received EOF&#39;) if self.transport.can_write_eof(): self.transport.write_eof() 当一个连接被关闭的时候，无论是正常关闭还是因为一个错误导致的关闭，协议的 connection_lost() 方法都会被调用，如果是因为出错，参数中会包含一个相关的异常对象，否则这个对象就是 None. def connection_lost(self, error): if error: self.log.error(&#39;ERROR: {}&#39;.format(error)) else: self.log.debug(&#39;closing&#39;) super().connection_lost(error) 需要两步来启动这个服务器。首先，应用告诉事件循环创建使用 protocol 类和 hostname 以及 socket 监听的端口信息来创建一个新的 server 对象。 create_server() 方法是一个 coroutine, 所以它的结果必须通过事件循环来处理这样才能真正的启动服务器。这个 coroutine 完成的时候会返回一个 与事件循环相关联的 asyncio.Server 实例. factory = event_loop.create_server(EchoServer, *SERVER_ADDRESS) server = event_loop.run_until_complete(factory) log.debug(&#39;starting up on {} port {}&#39;.format(*SERVER_ADDRESS)) 然后这个事件循环需要被运行，以便接收客户端请求以及处理相关事件。 对于一个长时间运行的服务器程序来说， run_forever() 方法是最简便的实现这个功能的方法。 当事件循环被停止的时候，无论是通过应用程序代码还是通过进程信号停止的，server 都可以被关闭以便能够正确的清理 socket 资源 try: event_loop.run_forever() finally: log.debug(&#39;closing server&#39;) server.close() event_loop.run_until_complete(server.wait_closed()) log.debug(&#39;closing event loop&#39;) event_loop.close() echo 客户端¶ 使用 protocol 类实现一个客户端的代码跟实现一个服务器端非常的相似. # asyncio_echo_client_protocol.py import asyncio import functools import logging import sys MESSAGES = [ b&#39;This is the message. &#39;, b&#39;It will be sent &#39;, b&#39;in parts.&#39;, ] SERVER_ADDRESS = (&#39;localhost&#39;, 10000) logging.basicConfig( level=logging.DEBUG, format=&#39;%(name)s: %(message)s&#39;, stream=sys.stderr, ) log = logging.getLogger(&#39;main&#39;) event_loop = asyncio.get_event_loop() 客户端 protocol 类定义了跟服务器端相同的方法，但是是不同的实现。 future 参数是一个 Future 实例，用来作为客户端已经完成了一次接收来只服务端数据操作的信号。 class EchoClient(asyncio.Protocol): def __init__(self, messages, future): super().__init__() self.messages = messages self.log = logging.getLogger(&#39;EchoClient&#39;) self.f = future 当客户端成功连接到服务器时，会立即开始通信。客户端一次发送了一堆数据，因为网络等原因可能会把多个消息合并到一个消息中。当所有消息都送达的时候，将发送一个 EOF。 虽然看起你所有的数据都立即被发送了，事实上 transport 对象会缓冲发出去的数据并且会设置一个回调来传输最终的数据，当 socket 的缓冲区准备好可以发送的时候会调用这个回调。这些都是由 transport 来实现的，所以应用代码可以按照 I/O 操作就像看起来那么发生的样子来实现. def connection_made(self, transport): self.transport = transport self.address = transport.get_extra_info(&#39;peername&#39;) self.log.debug( &#39;connectiong to {} port {}&#39;.format(*self.address) ) # 也可以使用 transport.writelines() # 这里使用 transport.write() 是为了方便 # 记录发送的每一行内容 for msg in self.messages: transport.write(msg) self.log.debug(&#39;sending {!r}&#39;.format(msg)) if transport.can_write_eof(): transport.write_eof() 当接收到来着服务器端的响应时，将会把这个响应记录下来 def data_received(self, data): self.log.debug(&#39;received {!r}&#39;.format(data)) 无论是收到 end-of-file 标记还是服务器端断开了连接，本地 transport 对象都将关闭并且 future 对象都会被通过设置一个结果值的方式标记为已完成。 def eof_received(self): self.log.debug(&#39;received EOF&#39;) self.transport.close() if not self.f.done(): self.f.set_result(True) def connnection_lost(self, exc): self.log.debug(&#39;server closed connection&#39;) self.transport.close() if not self.f.done(): self.f.set_result(True) super().connectiong_lost(exc) 然后创建所需的 future, 以及客户端 coroutine client_completed = asyncio.Future() client_factory = functools.partial( EchoClient, messages=MESSAGES, future=client_completed ) factory_coroutine = event_loop.create_connection( client_factory, *SERVER_ADDRESS, ) 然后使用两次 wait 来处理客户端发送完成并退出的操作 log.debug(&#39;waiting for client to complete&#39;) try: event_loop.run_until_complete(factory_coroutine) event_loop.run_until_complete(client_completed) finally: log.debug(&#39;closing event loop&#39;) event_loop.close() 输出¶ 在一个窗口运行服务端程序，然后在另一个窗口中运行三次客户端程序，客户端程序的输出如下: $ python3.6 asyncio_echo_client_protocol.py asyncio: Using selector: KqueueSelector main: waiting for client to complete EchoClient: connectiong to ::1 port 10000 EchoClient: sending b&#39;This is the message. &#39; EchoClient: sending b&#39;It will be sent &#39; EchoClient: sending b&#39;in parts.&#39; EchoClient: received b&#39;This is the message. It will be sent in parts.&#39; EchoClient: received EOF main: closing event loop $ python3.6 asyncio_echo_client_protocol.py asyncio: Using selector: KqueueSelector main: waiting for client to complete EchoClient: connectiong to ::1 port 10000 EchoClient: sending b&#39;This is the message. &#39; EchoClient: sending b&#39;It will be sent &#39; EchoClient: sending b&#39;in parts.&#39; EchoClient: received b&#39;This is the message. It will be sent in parts.&#39; EchoClient: received EOF main: closing event loop $ python3.6 asyncio_echo_client_protocol.py asyncio: Using selector: KqueueSelector main: waiting for client to complete EchoClient: connectiong to ::1 port 10000 EchoClient: sending b&#39;This is the message. &#39; EchoClient: sending b&#39;It will be sent &#39; EchoClient: sending b&#39;in parts.&#39; EchoClient: received b&#39;This is the message. It will be sent &#39; EchoClient: received b&#39;in parts.&#39; EchoClient: received EOF main: closing event loop 尽管客户端是分批发送的数据，但是服务器端其实有时收到的其实是合并后的整个数据。 $ asyncio_echo_server_protocol.py asyncio: Using selector: KqueueSelector main: starting up on localhost port 10000 EchoServer_::1_56353: connection accepted EchoServer_::1_56353: received b&#39;This is the message. It will be sent in parts.&#39; EchoServer_::1_56353: sent b&#39;This is the message. It will be sent in parts.&#39; EchoServer_::1_56353: received EOF EchoServer_::1_56353: closing EchoServer_::1_56354: connection accepted EchoServer_::1_56354: received b&#39;This is the message. It will be sent in parts.&#39; EchoServer_::1_56354: sent b&#39;This is the message. It will be sent in parts.&#39; EchoServer_::1_56354: received EOF EchoServer_::1_56354: closing EchoServer_::1_56355: connection accepted EchoServer_::1_56355: received b&#39;This is the message. It will be sent &#39; EchoServer_::1_56355: sent b&#39;This is the message. It will be sent &#39; EchoServer_::1_56355: received b&#39;in parts.&#39; EchoServer_::1_56355: sent b&#39;in parts.&#39; EchoServer_::1_56355: received EOF EchoServer_::1_56355: closing 完整代码¶ 服务端代码¶ # asyncio_echo_server_protocol.py import asyncio import logging import sys SERVER_ADDRESS = (&#39;localhost&#39;, 10000) logging.basicConfig( level=logging.DEBUG, format=&#39;%(name)s: %(message)s&#39;, stream=sys.stderr, ) log = logging.getLogger(&#39;main&#39;) event_loop = asyncio.get_event_loop() class EchoServer(asyncio.Protocol): def connection_made(self, transport): self.transport = transport self.address = transport.get_extra_info(&#39;peername&#39;) self.log = logging.getLogger( &#39;EchoServer_{}_{}&#39;.format(*self.address) ) self.log.debug(&#39;connection accepted&#39;) def data_received(self, data): self.log.debug(&#39;received {!r}&#39;.format(data)) self.transport.write(data) self.log.debug(&#39;sent {!r}&#39;.format(data)) def eof_received(self): self.log.debug(&#39;received EOF&#39;) if self.transport.can_write_eof(): self.transport.write_eof() def connection_lost(self, error): if error: self.log.error(&#39;ERROR: {}&#39;.format(error)) else: self.log.debug(&#39;closing&#39;) super().connection_lost(error) factory = event_loop.create_server(EchoServer, *SERVER_ADDRESS) server = event_loop.run_until_complete(factory) log.debug(&#39;starting up on {} port {}&#39;.format(*SERVER_ADDRESS)) try: event_loop.run_forever() finally: log.debug(&#39;closing server&#39;) server.close() event_loop.run_until_complete(server.wait_closed()) log.debug(&#39;closing event loop&#39;) event_loop.close() 客户端代码¶ # asyncio_echo_client_protocol.py import asyncio import functools import logging import sys MESSAGES = [ b&#39;This is the message. &#39;, b&#39;It will be sent &#39;, b&#39;in parts.&#39;, ] SERVER_ADDRESS = (&#39;localhost&#39;, 10000) logging.basicConfig( level=logging.DEBUG, format=&#39;%(name)s: %(message)s&#39;, stream=sys.stderr, ) log = logging.getLogger(&#39;main&#39;) event_loop = asyncio.get_event_loop() class EchoClient(asyncio.Protocol): def __init__(self, messages, future): super().__init__() self.messages = messages self.log = logging.getLogger(&#39;EchoClient&#39;) self.f = future def connection_made(self, transport): self.transport = transport self.address = transport.get_extra_info(&#39;peername&#39;) self.log.debug( &#39;connectiong to {} port {}&#39;.format(*self.address) ) # 也可以使用 transport.writelines() # 这里使用 transport.write() 是为了方便 # 记录发送的每一行内容 for msg in self.messages: transport.write(msg) self.log.debug(&#39;sending {!r}&#39;.format(msg)) if transport.can_write_eof(): transport.write_eof() def data_received(self, data): self.log.debug(&#39;received {!r}&#39;.format(data)) def eof_received(self): self.log.debug(&#39;received EOF&#39;) self.transport.close() if not self.f.done(): self.f.set_result(True) def connnection_lost(self, exc): self.log.debug(&#39;server closed connection&#39;) self.transport.close() if not self.f.done(): self.f.set_result(True) super().connectiong_lost(exc) client_completed = asyncio.Future() client_factory = functools.partial( EchoClient, messages=MESSAGES, future=client_completed ) factory_coroutine = event_loop.create_connection( client_factory, *SERVER_ADDRESS, ) log.debug(&#39;waiting for client to complete&#39;) try: event_loop.run_until_complete(factory_coroutine) event_loop.run_until_complete(client_completed) finally: log.debug(&#39;closing event loop&#39;) event_loop.close() 参考资料¶ Asynchronous I/O with Protocol Class Abstractions — PyMOTW 3 18.5.4. Transports and protocols (callback based API) — Python 3.6.2 documentation" />
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4941850466486001"
     crossorigin="anonymous"></script>

    <style>
      .js-toc {
        margin-bottom: 20px;
      }
      .donate-modal {
        text-align: center;
      }
      #donate-modal-container .donate-image {
        max-height: 300px !important;
        min-height: inherit !important;
      }
    </style>

        <meta property="og:site_name" content="Huang Huang 的博客" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="asyncio 学习笔记：使用抽象类 Protocol 实现异步 I/O"/>
        <meta property="og:url" content="https://mozillazg.com/2017/08/python-asyncio-note-io-protocol.html"/>
        <meta property="og:description" content="本文是 https://pymotw.com/3/asyncio/io_protocol.html 的学习笔记，强烈推荐直接阅读原文。 这次将用两个程序介绍使用 asyncio 实现一个简单的 echo 服务端和客户端程序 echo 服务端程序¶ 首先导入必需的一些模块，设置一下 asyncio 和 logging，然后再创建一个事件循环对象. # asyncio_echo_server_protocol.py import asyncio import logging import sys SERVER_ADDRESS = (&#39;localhost&#39;, 10000) logging.basicConfig( level=logging.DEBUG, format=&#39;%(name)s: %(message)s&#39;, stream=sys.stderr, ) log = logging.getLogger(&#39;main&#39;) event_loop = asyncio.get_event_loop() 然后定义一个继承 asyncio.Protocol 的子类，用来处理与客户端的通信。 protocol 的方法是基于服务端 socket 事件来触发的。 class EchoServer(asyncio.Protocol): 每当有一个新的客户端连接的时候，就会触发调用 connection_made() 方法。 transport 参数 是一个 asyncio.Transport 实例对象，这个对象抽象了一系列使用 socket 进行异步 I/O 操作的方法。不同的通信协议提供了不同的 transport 实现，但是它们都有同样的 API. 比如，有一些 transport 类用来与 socket 通信，有些用来跟子进程通过管道通信。 可以通过 get_extra_info() 获取进来的客户端的地址信息。 def connection_made(self, transport): self.transport = transport self.address = transport.get_extra_info(&#39;peername&#39;) self.log = logging.getLogger( &#39;EchoServer_{}_{}&#39;.format(*self.address) ) self.log.debug(&#39;connection accepted&#39;) 连接建立以后，当有数据从客户端发到服务端的时候会使用传输过来的数据调用 data_received() 方法。这里我们记录一下收到的数据，然后立即发收到的数据通过 transport.write() 发回客户端。 def data_received(self, data): self.log.debug(&#39;received {!r}&#39;.format(data)) self.transport.write(data) self.log.debug(&#39;sent {!r}&#39;.format(data)) 一些 transport 支持一个特殊的 end-of-file 标识符(EOF)。当遇到一个 EOF 的时候，eof_received() 方法会被调用。在本次实现中，EOF 会被发送会客户端，表示这个信号已经被收到。因为不是所有的 transport 都支持这个 EOF ，这个协议会首先询问 transport 是否可以安全的发送 EOF . def eof_received(self): self.log.debug(&#39;received EOF&#39;) if self.transport.can_write_eof(): self.transport.write_eof() 当一个连接被关闭的时候，无论是正常关闭还是因为一个错误导致的关闭，协议的 connection_lost() 方法都会被调用，如果是因为出错，参数中会包含一个相关的异常对象，否则这个对象就是 None. def connection_lost(self, error): if error: self.log.error(&#39;ERROR: {}&#39;.format(error)) else: self.log.debug(&#39;closing&#39;) super().connection_lost(error) 需要两步来启动这个服务器。首先，应用告诉事件循环创建使用 protocol 类和 hostname 以及 socket 监听的端口信息来创建一个新的 server 对象。 create_server() 方法是一个 coroutine, 所以它的结果必须通过事件循环来处理这样才能真正的启动服务器。这个 coroutine 完成的时候会返回一个 与事件循环相关联的 asyncio.Server 实例. factory = event_loop.create_server(EchoServer, *SERVER_ADDRESS) server = event_loop.run_until_complete(factory) log.debug(&#39;starting up on {} port {}&#39;.format(*SERVER_ADDRESS)) 然后这个事件循环需要被运行，以便接收客户端请求以及处理相关事件。 对于一个长时间运行的服务器程序来说， run_forever() 方法是最简便的实现这个功能的方法。 当事件循环被停止的时候，无论是通过应用程序代码还是通过进程信号停止的，server 都可以被关闭以便能够正确的清理 socket 资源 try: event_loop.run_forever() finally: log.debug(&#39;closing server&#39;) server.close() event_loop.run_until_complete(server.wait_closed()) log.debug(&#39;closing event loop&#39;) event_loop.close() echo 客户端¶ 使用 protocol 类实现一个客户端的代码跟实现一个服务器端非常的相似. # asyncio_echo_client_protocol.py import asyncio import functools import logging import sys MESSAGES = [ b&#39;This is the message. &#39;, b&#39;It will be sent &#39;, b&#39;in parts.&#39;, ] SERVER_ADDRESS = (&#39;localhost&#39;, 10000) logging.basicConfig( level=logging.DEBUG, format=&#39;%(name)s: %(message)s&#39;, stream=sys.stderr, ) log = logging.getLogger(&#39;main&#39;) event_loop = asyncio.get_event_loop() 客户端 protocol 类定义了跟服务器端相同的方法，但是是不同的实现。 future 参数是一个 Future 实例，用来作为客户端已经完成了一次接收来只服务端数据操作的信号。 class EchoClient(asyncio.Protocol): def __init__(self, messages, future): super().__init__() self.messages = messages self.log = logging.getLogger(&#39;EchoClient&#39;) self.f = future 当客户端成功连接到服务器时，会立即开始通信。客户端一次发送了一堆数据，因为网络等原因可能会把多个消息合并到一个消息中。当所有消息都送达的时候，将发送一个 EOF。 虽然看起你所有的数据都立即被发送了，事实上 transport 对象会缓冲发出去的数据并且会设置一个回调来传输最终的数据，当 socket 的缓冲区准备好可以发送的时候会调用这个回调。这些都是由 transport 来实现的，所以应用代码可以按照 I/O 操作就像看起来那么发生的样子来实现. def connection_made(self, transport): self.transport = transport self.address = transport.get_extra_info(&#39;peername&#39;) self.log.debug( &#39;connectiong to {} port {}&#39;.format(*self.address) ) # 也可以使用 transport.writelines() # 这里使用 transport.write() 是为了方便 # 记录发送的每一行内容 for msg in self.messages: transport.write(msg) self.log.debug(&#39;sending {!r}&#39;.format(msg)) if transport.can_write_eof(): transport.write_eof() 当接收到来着服务器端的响应时，将会把这个响应记录下来 def data_received(self, data): self.log.debug(&#39;received {!r}&#39;.format(data)) 无论是收到 end-of-file 标记还是服务器端断开了连接，本地 transport 对象都将关闭并且 future 对象都会被通过设置一个结果值的方式标记为已完成。 def eof_received(self): self.log.debug(&#39;received EOF&#39;) self.transport.close() if not self.f.done(): self.f.set_result(True) def connnection_lost(self, exc): self.log.debug(&#39;server closed connection&#39;) self.transport.close() if not self.f.done(): self.f.set_result(True) super().connectiong_lost(exc) 然后创建所需的 future, 以及客户端 coroutine client_completed = asyncio.Future() client_factory = functools.partial( EchoClient, messages=MESSAGES, future=client_completed ) factory_coroutine = event_loop.create_connection( client_factory, *SERVER_ADDRESS, ) 然后使用两次 wait 来处理客户端发送完成并退出的操作 log.debug(&#39;waiting for client to complete&#39;) try: event_loop.run_until_complete(factory_coroutine) event_loop.run_until_complete(client_completed) finally: log.debug(&#39;closing event loop&#39;) event_loop.close() 输出¶ 在一个窗口运行服务端程序，然后在另一个窗口中运行三次客户端程序，客户端程序的输出如下: $ python3.6 asyncio_echo_client_protocol.py asyncio: Using selector: KqueueSelector main: waiting for client to complete EchoClient: connectiong to ::1 port 10000 EchoClient: sending b&#39;This is the message. &#39; EchoClient: sending b&#39;It will be sent &#39; EchoClient: sending b&#39;in parts.&#39; EchoClient: received b&#39;This is the message. It will be sent in parts.&#39; EchoClient: received EOF main: closing event loop $ python3.6 asyncio_echo_client_protocol.py asyncio: Using selector: KqueueSelector main: waiting for client to complete EchoClient: connectiong to ::1 port 10000 EchoClient: sending b&#39;This is the message. &#39; EchoClient: sending b&#39;It will be sent &#39; EchoClient: sending b&#39;in parts.&#39; EchoClient: received b&#39;This is the message. It will be sent in parts.&#39; EchoClient: received EOF main: closing event loop $ python3.6 asyncio_echo_client_protocol.py asyncio: Using selector: KqueueSelector main: waiting for client to complete EchoClient: connectiong to ::1 port 10000 EchoClient: sending b&#39;This is the message. &#39; EchoClient: sending b&#39;It will be sent &#39; EchoClient: sending b&#39;in parts.&#39; EchoClient: received b&#39;This is the message. It will be sent &#39; EchoClient: received b&#39;in parts.&#39; EchoClient: received EOF main: closing event loop 尽管客户端是分批发送的数据，但是服务器端其实有时收到的其实是合并后的整个数据。 $ asyncio_echo_server_protocol.py asyncio: Using selector: KqueueSelector main: starting up on localhost port 10000 EchoServer_::1_56353: connection accepted EchoServer_::1_56353: received b&#39;This is the message. It will be sent in parts.&#39; EchoServer_::1_56353: sent b&#39;This is the message. It will be sent in parts.&#39; EchoServer_::1_56353: received EOF EchoServer_::1_56353: closing EchoServer_::1_56354: connection accepted EchoServer_::1_56354: received b&#39;This is the message. It will be sent in parts.&#39; EchoServer_::1_56354: sent b&#39;This is the message. It will be sent in parts.&#39; EchoServer_::1_56354: received EOF EchoServer_::1_56354: closing EchoServer_::1_56355: connection accepted EchoServer_::1_56355: received b&#39;This is the message. It will be sent &#39; EchoServer_::1_56355: sent b&#39;This is the message. It will be sent &#39; EchoServer_::1_56355: received b&#39;in parts.&#39; EchoServer_::1_56355: sent b&#39;in parts.&#39; EchoServer_::1_56355: received EOF EchoServer_::1_56355: closing 完整代码¶ 服务端代码¶ # asyncio_echo_server_protocol.py import asyncio import logging import sys SERVER_ADDRESS = (&#39;localhost&#39;, 10000) logging.basicConfig( level=logging.DEBUG, format=&#39;%(name)s: %(message)s&#39;, stream=sys.stderr, ) log = logging.getLogger(&#39;main&#39;) event_loop = asyncio.get_event_loop() class EchoServer(asyncio.Protocol): def connection_made(self, transport): self.transport = transport self.address = transport.get_extra_info(&#39;peername&#39;) self.log = logging.getLogger( &#39;EchoServer_{}_{}&#39;.format(*self.address) ) self.log.debug(&#39;connection accepted&#39;) def data_received(self, data): self.log.debug(&#39;received {!r}&#39;.format(data)) self.transport.write(data) self.log.debug(&#39;sent {!r}&#39;.format(data)) def eof_received(self): self.log.debug(&#39;received EOF&#39;) if self.transport.can_write_eof(): self.transport.write_eof() def connection_lost(self, error): if error: self.log.error(&#39;ERROR: {}&#39;.format(error)) else: self.log.debug(&#39;closing&#39;) super().connection_lost(error) factory = event_loop.create_server(EchoServer, *SERVER_ADDRESS) server = event_loop.run_until_complete(factory) log.debug(&#39;starting up on {} port {}&#39;.format(*SERVER_ADDRESS)) try: event_loop.run_forever() finally: log.debug(&#39;closing server&#39;) server.close() event_loop.run_until_complete(server.wait_closed()) log.debug(&#39;closing event loop&#39;) event_loop.close() 客户端代码¶ # asyncio_echo_client_protocol.py import asyncio import functools import logging import sys MESSAGES = [ b&#39;This is the message. &#39;, b&#39;It will be sent &#39;, b&#39;in parts.&#39;, ] SERVER_ADDRESS = (&#39;localhost&#39;, 10000) logging.basicConfig( level=logging.DEBUG, format=&#39;%(name)s: %(message)s&#39;, stream=sys.stderr, ) log = logging.getLogger(&#39;main&#39;) event_loop = asyncio.get_event_loop() class EchoClient(asyncio.Protocol): def __init__(self, messages, future): super().__init__() self.messages = messages self.log = logging.getLogger(&#39;EchoClient&#39;) self.f = future def connection_made(self, transport): self.transport = transport self.address = transport.get_extra_info(&#39;peername&#39;) self.log.debug( &#39;connectiong to {} port {}&#39;.format(*self.address) ) # 也可以使用 transport.writelines() # 这里使用 transport.write() 是为了方便 # 记录发送的每一行内容 for msg in self.messages: transport.write(msg) self.log.debug(&#39;sending {!r}&#39;.format(msg)) if transport.can_write_eof(): transport.write_eof() def data_received(self, data): self.log.debug(&#39;received {!r}&#39;.format(data)) def eof_received(self): self.log.debug(&#39;received EOF&#39;) self.transport.close() if not self.f.done(): self.f.set_result(True) def connnection_lost(self, exc): self.log.debug(&#39;server closed connection&#39;) self.transport.close() if not self.f.done(): self.f.set_result(True) super().connectiong_lost(exc) client_completed = asyncio.Future() client_factory = functools.partial( EchoClient, messages=MESSAGES, future=client_completed ) factory_coroutine = event_loop.create_connection( client_factory, *SERVER_ADDRESS, ) log.debug(&#39;waiting for client to complete&#39;) try: event_loop.run_until_complete(factory_coroutine) event_loop.run_until_complete(client_completed) finally: log.debug(&#39;closing event loop&#39;) event_loop.close() 参考资料¶ Asynchronous I/O with Protocol Class Abstractions — PyMOTW 3 18.5.4. Transports and protocols (callback based API) — Python 3.6.2 documentation"/>
        <meta property="article:published_time" content="2017-08-26" />
            <meta property="article:section" content="python" />
            <meta property="article:tag" content="python" />
            <meta property="article:tag" content="asyncio" />
            <meta property="article:author" content="mozillazg" />
            <meta property="og:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>


    <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@mozillazg">
        <meta name="twitter:creator" content="@mozillazg">
    <meta name="twitter:domain" content="https://mozillazg.com">
            <meta property="twitter:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/css/bootstrap.min.css" type="text/css"/>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link href="https://cdn.jsdelivr.net/npm/pygments-css@1.0.0/github.css" rel="stylesheet">
    <link rel="stylesheet" href="https://mozillazg.com/theme/css/style.css" type="text/css"/>
            <link href="https://mozillazg.com/static/custom.css" rel="stylesheet">

        <link href="https://mozillazg.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Huang Huang 的博客 ATOM Feed"/>

        <link href="https://mozillazg.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="Huang Huang 的博客 RSS Feed"/>


        <link href="https://mozillazg.com/feeds/python.atom.xml" type="application/atom+xml" rel="alternate"
              title="Huang Huang 的博客 python ATOM Feed"/>


    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "publisher": {
            "@type": "Person",
            "name": "mozillazg",
            "logo": "https://mozillazg.com/static/avatar.jpeg"
        },
        "author": {
            "@type": "Person",
            "name": "mozillazg",
            "image": "https://mozillazg.com/static/avatar.jpeg",
            "url": "https://mozillazg.com",
            "sameAs": []
        },
        "headline": "asyncio 学习笔记：使用抽象类 Protocol 实现异步 I/O",
        "url": "https://mozillazg.com/2017/08/python-asyncio-note-io-protocol.html",
        "image": [
            "https://mozillazg.com/static/avatar.jpeg"
         ],
        "keywords": "python, asyncio",
        "datePublished": "2017-08-26"
    }
    </script>

</head>
<body>

<div class="navbar" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://mozillazg.com/" class="navbar-brand">
Huang Huang 的博客            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="https://mozillazg.com/feeds/all.atom.xml">Feed</a></li>
                    <li><a href="/2014/10/pages/about-me.html">About</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://mozillazg.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content" class="yue">
        <article>
            <header class="text-center">
                <h1>
                    <a href="https://mozillazg.com/2017/08/python-asyncio-note-io-protocol.html"
                       rel="bookmark"
                       title="Permalink to asyncio 学习笔记：使用抽象类 Protocol 实现异步 I/O">
                        asyncio 学习笔记：使用抽象类 Protocol 实现异步 I/O
                    </a>
                </h1>
                <p class="published">
                    <time datetime="2017-08-26T00:00:00+00:00">
                    2017-08-26
                    </time>
                </p>
            </header>
            <div class="entry-content">
                <div class="well-sm article-info">
<footer class="post-info">
        <a href="https://mozillazg.com/category/python.html">python</a>


<span class="label label-default hide">Tags</span>
	<a href="https://mozillazg.com/tag/asyncio.html">asyncio</a>
    
</footer><!-- /.post-info -->                </div>
                <div class="js-toc"></div>
                <div>
                <p>本文是 <a class="reference external" href="https://pymotw.com/3/asyncio/io_protocol.html">https://pymotw.com/3/asyncio/io_protocol.html</a>
的学习笔记，强烈推荐直接阅读原文。</p>
<p>这次将用两个程序介绍使用 asyncio 实现一个简单的 echo 服务端和客户端程序</p>
<div class="section" id="echo">
<h2 id="hidecho">echo 服务端程序<a class="headerlink" href="#hidecho" title="Permalink to this headline">¶</a></h2>
<p>首先导入必需的一些模块，设置一下 asyncio 和
logging，然后再创建一个事件循环对象.</p>
<pre class="code python literal-block">
<span class="c1"># asyncio_echo_server_protocol.py</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="n">SERVER_ADDRESS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'localhost'</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">,</span>
    <span class="n">format</span><span class="o">=</span><span class="s1">'</span><span class="si">%(name)s</span><span class="s1">: </span><span class="si">%(message)s</span><span class="s1">'</span><span class="p">,</span>
    <span class="n">stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">'main'</span><span class="p">)</span>

<span class="n">event_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
</pre>
<div class="line-block">
<div class="line">然后定义一个继承 <tt class="docutils literal">asyncio.Protocol</tt> 的子类，用来处理与客户端的通信。</div>
<div class="line"><tt class="docutils literal">protocol</tt> 的方法是基于服务端 socket 事件来触发的。</div>
</div>
<pre class="code python literal-block">
<span class="k">class</span> <span class="nc">EchoServer</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
</pre>
<div class="line-block">
<div class="line">每当有一个新的客户端连接的时候，就会触发调用 <tt class="docutils literal">connection_made()</tt>
方法。 <tt class="docutils literal">transport</tt> 参数</div>
<div class="line">是一个 <tt class="docutils literal">asyncio.Transport</tt> 实例对象，这个对象抽象了一系列使用 socket
进行异步 I/O 操作的方法。不同的通信协议提供了不同的 transport
实现，但是它们都有同样的 API.</div>
<div class="line">比如，有一些 transport 类用来与 socket
通信，有些用来跟子进程通过管道通信。</div>
<div class="line">可以通过 <tt class="docutils literal">get_extra_info()</tt> 获取进来的客户端的地址信息。</div>
</div>
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">transport</span><span class="o">.</span><span class="n">get_extra_info</span><span class="p">(</span><span class="s1">'peername'</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span>
        <span class="s1">'EchoServer_{}_{}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'connection accepted'</span><span class="p">)</span>
</pre>
<p>连接建立以后，当有数据从客户端发到服务端的时候会使用传输过来的数据调用
<tt class="docutils literal">data_received()</tt>
方法。这里我们记录一下收到的数据，然后立即发收到的数据通过
<tt class="docutils literal">transport.write()</tt> 发回客户端。</p>
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'received {!r}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'sent {!r}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</pre>
<p>一些 transport 支持一个特殊的 end-of-file 标识符(<tt class="docutils literal">EOF</tt>)。当遇到一个
<tt class="docutils literal">EOF</tt> 的时候，<tt class="docutils literal">eof_received()</tt>
方法会被调用。在本次实现中，<tt class="docutils literal">EOF</tt>
会被发送会客户端，表示这个信号已经被收到。因为不是所有的 transport
都支持这个 <tt class="docutils literal">EOF</tt> ，这个协议会首先询问 transport 是否可以安全的发送
<tt class="docutils literal">EOF</tt> .</p>
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">eof_received</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'received EOF'</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">can_write_eof</span><span class="p">():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write_eof</span><span class="p">()</span>
</pre>
<p>当一个连接被关闭的时候，无论是正常关闭还是因为一个错误导致的关闭，协议的
<tt class="docutils literal">connection_lost()</tt>
方法都会被调用，如果是因为出错，参数中会包含一个相关的异常对象，否则这个对象就是
<tt class="docutils literal">None</tt>.</p>
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">connection_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">'ERROR: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'closing'</span><span class="p">)</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">connection_lost</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
</pre>
<p>需要两步来启动这个服务器。首先，应用告诉事件循环创建使用 protocol 类和
hostname 以及 socket 监听的端口信息来创建一个新的 server 对象。
<tt class="docutils literal">create_server()</tt> 方法是一个 coroutine,
所以它的结果必须通过事件循环来处理这样才能真正的启动服务器。这个
coroutine 完成的时候会返回一个 与事件循环相关联的 <tt class="docutils literal">asyncio.Server</tt>
实例.</p>
<pre class="code python literal-block">
<span class="n">factory</span> <span class="o">=</span> <span class="n">event_loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="n">EchoServer</span><span class="p">,</span> <span class="o">*</span><span class="n">SERVER_ADDRESS</span><span class="p">)</span>
<span class="n">server</span> <span class="o">=</span> <span class="n">event_loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">factory</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'starting up on {} port {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">SERVER_ADDRESS</span><span class="p">))</span>
</pre>
<div class="line-block">
<div class="line">然后这个事件循环需要被运行，以便接收客户端请求以及处理相关事件。</div>
<div class="line">对于一个长时间运行的服务器程序来说， <tt class="docutils literal">run_forever()</tt>
方法是最简便的实现这个功能的方法。</div>
<div class="line">当事件循环被停止的时候，无论是通过应用程序代码还是通过进程信号停止的，server
都可以被关闭以便能够正确的清理 socket 资源</div>
</div>
<pre class="code python literal-block">
<span class="k">try</span><span class="p">:</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'closing server'</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">server</span><span class="o">.</span><span class="n">wait_closed</span><span class="p">())</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'closing event loop'</span><span class="p">)</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre>
</div>
<div class="section" id="id1">
<h2 id="hidid1">echo 客户端<a class="headerlink" href="#hidid1" title="Permalink to this headline">¶</a></h2>
<p>使用 protocol 类实现一个客户端的代码跟实现一个服务器端非常的相似.</p>
<pre class="code python literal-block">
<span class="c1"># asyncio_echo_client_protocol.py</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">MESSAGES</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">b</span><span class="s1">'This is the message. '</span><span class="p">,</span>
    <span class="n">b</span><span class="s1">'It will be sent '</span><span class="p">,</span>
    <span class="n">b</span><span class="s1">'in parts.'</span><span class="p">,</span>
<span class="p">]</span>
<span class="n">SERVER_ADDRESS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'localhost'</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">,</span>
    <span class="n">format</span><span class="o">=</span><span class="s1">'</span><span class="si">%(name)s</span><span class="s1">: </span><span class="si">%(message)s</span><span class="s1">'</span><span class="p">,</span>
    <span class="n">stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">'main'</span><span class="p">)</span>

<span class="n">event_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>
</pre>
<div class="line-block">
<div class="line">客户端 protocol 类定义了跟服务器端相同的方法，但是是不同的实现。</div>
<div class="line"><tt class="docutils literal">future</tt> 参数是一个 <tt class="docutils literal">Future</tt>
实例，用来作为客户端已经完成了一次接收来只服务端数据操作的信号。</div>
</div>
<pre class="code python literal-block">
<span class="k">class</span> <span class="nc">EchoClient</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">messages</span><span class="p">,</span> <span class="n">future</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">messages</span> <span class="o">=</span> <span class="n">messages</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">'EchoClient'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">future</span>
</pre>
<p>当客户端成功连接到服务器时，会立即开始通信。客户端一次发送了一堆数据，因为网络等原因可能会把多个消息合并到一个消息中。当所有消息都送达的时候，将发送一个
<tt class="docutils literal">EOF</tt>。</p>
<p>虽然看起你所有的数据都立即被发送了，事实上 transport
对象会缓冲发出去的数据并且会设置一个回调来传输最终的数据，当 socket
的缓冲区准备好可以发送的时候会调用这个回调。这些都是由 transport
来实现的，所以应用代码可以按照 I/O 操作就像看起来那么发生的样子来实现.</p>
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">transport</span><span class="o">.</span><span class="n">get_extra_info</span><span class="p">(</span><span class="s1">'peername'</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
        <span class="s1">'connectiong to {} port {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># 也可以使用 transport.writelines()</span>
    <span class="c1"># 这里使用 transport.write() 是为了方便</span>
    <span class="c1"># 记录发送的每一行内容</span>
    <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">messages</span><span class="p">:</span>
        <span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'sending {!r}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">transport</span><span class="o">.</span><span class="n">can_write_eof</span><span class="p">():</span>
        <span class="n">transport</span><span class="o">.</span><span class="n">write_eof</span><span class="p">()</span>
</pre>
<p>当接收到来着服务器端的响应时，将会把这个响应记录下来</p>
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'received {!r}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
</pre>
<p>无论是收到 end-of-file 标记还是服务器端断开了连接，本地 transport
对象都将关闭并且 future 对象都会被通过设置一个结果值的方式标记为已完成。</p>
<pre class="code python literal-block">
<span class="k">def</span> <span class="nf">eof_received</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'received EOF'</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">connnection_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'server closed connection'</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">done</span><span class="p">():</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">set_result</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">connectiong_lost</span><span class="p">(</span><span class="n">exc</span><span class="p">)</span>
</pre>
<p>然后创建所需的 future, 以及客户端 coroutine</p>
<pre class="code python literal-block">
<span class="n">client_completed</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">Future</span><span class="p">()</span>
<span class="n">client_factory</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
    <span class="n">EchoClient</span><span class="p">,</span>
    <span class="n">messages</span><span class="o">=</span><span class="n">MESSAGES</span><span class="p">,</span>
    <span class="n">future</span><span class="o">=</span><span class="n">client_completed</span>
<span class="p">)</span>
<span class="n">factory_coroutine</span> <span class="o">=</span> <span class="n">event_loop</span><span class="o">.</span><span class="n">create_connection</span><span class="p">(</span>
    <span class="n">client_factory</span><span class="p">,</span>
    <span class="o">*</span><span class="n">SERVER_ADDRESS</span><span class="p">,</span>
<span class="p">)</span>
</pre>
<p>然后使用两次 wait 来处理客户端发送完成并退出的操作</p>
<pre class="code python literal-block">
<span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'waiting for client to complete'</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">factory_coroutine</span><span class="p">)</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">client_completed</span><span class="p">)</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'closing event loop'</span><span class="p">)</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre>
</div>
<div class="section" id="id2">
<h2 id="hidid2">输出<a class="headerlink" href="#hidid2" title="Permalink to this headline">¶</a></h2>
<p>在一个窗口运行服务端程序，然后在另一个窗口中运行三次客户端程序，客户端程序的输出如下:</p>
<pre class="literal-block">
$ python3.6 asyncio_echo_client_protocol.py
asyncio: Using selector: KqueueSelector
main: waiting for client to complete
EchoClient: connectiong to ::1 port 10000
EchoClient: sending b'This is the message. '
EchoClient: sending b'It will be sent '
EchoClient: sending b'in parts.'
EchoClient: received b'This is the message. It will be sent in parts.'
EchoClient: received EOF
main: closing event loop

$ python3.6 asyncio_echo_client_protocol.py
asyncio: Using selector: KqueueSelector
main: waiting for client to complete
EchoClient: connectiong to ::1 port 10000
EchoClient: sending b'This is the message. '
EchoClient: sending b'It will be sent '
EchoClient: sending b'in parts.'
EchoClient: received b'This is the message. It will be sent in parts.'
EchoClient: received EOF
main: closing event loop

$ python3.6 asyncio_echo_client_protocol.py
asyncio: Using selector: KqueueSelector
main: waiting for client to complete
EchoClient: connectiong to ::1 port 10000
EchoClient: sending b'This is the message. '
EchoClient: sending b'It will be sent '
EchoClient: sending b'in parts.'
EchoClient: received b'This is the message. It will be sent '
EchoClient: received b'in parts.'
EchoClient: received EOF
main: closing event loop
</pre>
<p>尽管客户端是分批发送的数据，但是服务器端其实有时收到的其实是合并后的整个数据。</p>
<pre class="literal-block">
$ asyncio_echo_server_protocol.py
asyncio: Using selector: KqueueSelector
main: starting up on localhost port 10000
EchoServer_::1_56353: connection accepted
EchoServer_::1_56353: received b'This is the message. It will be sent in parts.'
EchoServer_::1_56353: sent b'This is the message. It will be sent in parts.'
EchoServer_::1_56353: received EOF
EchoServer_::1_56353: closing

EchoServer_::1_56354: connection accepted
EchoServer_::1_56354: received b'This is the message. It will be sent in parts.'
EchoServer_::1_56354: sent b'This is the message. It will be sent in parts.'
EchoServer_::1_56354: received EOF
EchoServer_::1_56354: closing

EchoServer_::1_56355: connection accepted
EchoServer_::1_56355: received b'This is the message. It will be sent '
EchoServer_::1_56355: sent b'This is the message. It will be sent '
EchoServer_::1_56355: received b'in parts.'
EchoServer_::1_56355: sent b'in parts.'
EchoServer_::1_56355: received EOF
EchoServer_::1_56355: closing
</pre>
</div>
<div class="section" id="id3">
<h2 id="hidid3">完整代码<a class="headerlink" href="#hidid3" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id4">
<h3 id="hidid4">服务端代码<a class="headerlink" href="#hidid4" title="Permalink to this headline">¶</a></h3>
<pre class="code python literal-block">
<span class="c1"># asyncio_echo_server_protocol.py</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="n">SERVER_ADDRESS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'localhost'</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">,</span>
    <span class="n">format</span><span class="o">=</span><span class="s1">'</span><span class="si">%(name)s</span><span class="s1">: </span><span class="si">%(message)s</span><span class="s1">'</span><span class="p">,</span>
    <span class="n">stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">'main'</span><span class="p">)</span>

<span class="n">event_loop</span> <span class="o">=</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">get_event_loop</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">EchoServer</span><span class="p">(</span><span class="n">asyncio</span><span class="o">.</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">connection_made</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span> <span class="o">=</span> <span class="n">transport</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">address</span> <span class="o">=</span> <span class="n">transport</span><span class="o">.</span><span class="n">get_extra_info</span><span class="p">(</span><span class="s1">'peername'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span>
            <span class="s1">'EchoServer_{}_{}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'connection accepted'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">data_received</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'received {!r}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'sent {!r}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">eof_received</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'received EOF'</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">can_write_eof</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transport</span><span class="o">.</span><span class="n">write_eof</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">connection_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">'ERROR: {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'closing'</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">connection_lost</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>


<span class="n">factory</span> <span class="o">=</span> <span class="n">event_loop</span><span class="o">.</span><span class="n">create_server</span><span class="p">(</span><span class="n">EchoServer</span><span class="p">,</span> <span class="o">*</span><span class="n">SERVER_ADDRESS</span><span class="p">)</span>
<span class="n">server</span> <span class="o">=</span> <span class="n">event_loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">factory</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'starting up on {} port {}'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">SERVER_ADDRESS</span><span class="p">))</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">run_forever</span><span class="p">()</span>
<span class="k">finally</span><span class="p">:</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'closing server'</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">run_until_complete</span><span class="p">(</span><span class="n">server</span><span class="o">.</span><span class="n">wait_closed</span><span class="p">())</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">'closing event loop'</span><span class="p">)</span>
    <span class="n">event_loop</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre>
</div>
<div class="section" id="id5">
<h3 id="hidid5">客户端代码<a class="headerlink" href="#hidid5" title="Permalink to this headline">¶</a></h3>
<pre class="literal-block">
# asyncio_echo_client_protocol.py
import asyncio
import functools
import logging
import sys

MESSAGES = [
    b'This is the message. ',
    b'It will be sent ',
    b'in parts.',
]
SERVER_ADDRESS = ('localhost', 10000)

logging.basicConfig(
    level=logging.DEBUG,
    format='%(name)s: %(message)s',
    stream=sys.stderr,
)
log = logging.getLogger('main')

event_loop = asyncio.get_event_loop()


class EchoClient(asyncio.Protocol):
    def __init__(self, messages, future):
        super().__init__()
        self.messages = messages
        self.log = logging.getLogger('EchoClient')
        self.f = future

    def connection_made(self, transport):
        self.transport = transport
        self.address = transport.get_extra_info('peername')
        self.log.debug(
            'connectiong to {} port {}'.format(*self.address)
        )
        # 也可以使用 transport.writelines()
        # 这里使用 transport.write() 是为了方便
        # 记录发送的每一行内容
        for msg in self.messages:
            transport.write(msg)
            self.log.debug('sending {!r}'.format(msg))

        if transport.can_write_eof():
            transport.write_eof()

    def data_received(self, data):
        self.log.debug('received {!r}'.format(data))

    def eof_received(self):
        self.log.debug('received EOF')
        self.transport.close()
        if not self.f.done():
            self.f.set_result(True)

    def connnection_lost(self, exc):
        self.log.debug('server closed connection')
        self.transport.close()
        if not self.f.done():
            self.f.set_result(True)
        super().connectiong_lost(exc)


client_completed = asyncio.Future()
client_factory = functools.partial(
    EchoClient,
    messages=MESSAGES,
    future=client_completed
)
factory_coroutine = event_loop.create_connection(
    client_factory,
    *SERVER_ADDRESS,
)

log.debug('waiting for client to complete')
try:
    event_loop.run_until_complete(factory_coroutine)
    event_loop.run_until_complete(client_completed)
finally:
    log.debug('closing event loop')
    event_loop.close()
</pre>
</div>
</div>
<div class="section" id="id6">
<h2 id="hidid6">参考资料<a class="headerlink" href="#hidid6" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://pymotw.com/3/asyncio/io_protocol.html">Asynchronous I/O with Protocol Class Abstractions — PyMOTW
3</a></li>
<li><a class="reference external" href="https://docs.python.org/3.6/library/asyncio-protocol.html">18.5.4. Transports and protocols (callback based API) — Python 3.6.2
documentation</a></li>
</ul>
</div>

                </div>
            </div>
            <!-- /.entry-content -->
<section class="text-center">
  
<div id="donate"></div>

<div class="social-share"></div>
<div class="social-comment-note">
<p>有任何建议和想法欢迎在下方评论区留言或者加我<a href="/static/wechat.png">微信</a>交流</p>
</div>

</section>
<section class="well" id="related-posts">
    <p>Related Posts:</p>
    <ul>
        <li><a href="https://mozillazg.com/2017/08/python-asyncio-note-coroutines-base-usage.html">asyncio 学习笔记：基本用法</a></li>
        <li><a href="https://mozillazg.com/2017/08/python-asyncio-note-synchronization-primitives.html">asyncio 学习笔记：同步原语</a></li>
        <li><a href="https://mozillazg.com/2017/08/python-asyncio-note-task-usage.html">asyncio 学习笔记：并发执行 Task</a></li>
        <li><a href="https://mozillazg.com/2017/08/python-asyncio-note-coroutine-schedule.html">asyncio 学习笔记：调用定时函数</a></li>
        <li><a href="https://mozillazg.com/2017/08/python-asyncio-note-control-Coroutines.html">asyncio 学习笔记：控制组合式 Coroutines</a></li>
    </ul>
</section>
    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'my-github-blog'; // required: replace example with your forum shortname

                    var disqus_identifier = 'python-asyncio-note-io-protocol';
                var disqus_url = 'https://mozillazg.com/2017/08/python-asyncio-note-io-protocol.html';

            var disqus_config = function () {
                this.language = "zh";
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2022 mozillazg
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>
            &middot; <a href="/privacy-policy.html" target="_blank">Privacy</a>              <p><small>  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/static/images/by-sa-80x15.png" /></a>
    &quot;<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Huang Huang 的博客</span>&quot; by <a xmlns:cc="http://creativecommons.org/ns#" href="https://mozillazg.com" property="cc:attributionName" rel="cc:attributionURL">mozillazg</a> is
  licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="https://cdn.jsdelivr.net/npm/jquery@2.1.1/dist/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->

    <!-- Disqus -->
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'my-github-blog'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script');
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <!-- End Disqus Code -->
    <!-- Google Analytics Universal -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-77172981-1', 'auto');
        ga('send', 'pageview');
    </script>
    <!-- End Google Analytics Universal Code -->

<!-- share.js -->
<script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>



<script src="https://cdn.jsdelivr.net/npm/tocbot@3.0.2/dist/tocbot.min.js"></script>
<script>
$(document).ready(function(){
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.js-toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.entry-content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h2, h3, h4,h5',
    // Headings that match the ignoreSelector will be skipped.
    ignoreSelector: '.js-toc-ignore',
    // Main class to add to links.
    linkClass: 'toc-link',
    // Extra classes to add to links.
    extraLinkClasses: '',
    // Class to add to active links,
    // the link corresponding to the top most heading on the page.
    activeLinkClass: 'is-active-link',
    // Main class to add to lists.
    listClass: 'toc-list',
    // Extra classes to add to lists.
    extraListClasses: '',
    // Class that gets added when a list should be collapsed.
    isCollapsedClass: 'is-collapsed',
    // Class that gets added when a list should be able
    // to be collapsed but isn't necessarily collpased.
    collapsibleClass: 'is-collapsible',
    // Class to add to list items.
    listItemClass: 'toc-list-item',
    // How many heading levels should not be collpased.
    // For example, number 6 will show everything since
    // there are only 6 heading levels and number 0 will collpase them all.
    // The sections that are hidden will open
    // and close as you scroll to headings within them.
    collapseDepth: 6,
    // Smooth scrolling enabled.
    smoothScroll: true,
    // Smooth scroll duration.
    smoothScrollDuration: 420,
    // Callback for scroll end (requires: smoothScroll).
    scrollEndCallback: function (e) {},
    // Headings offset between the headings and the top of the document (this is meant for minor adjustments).
    headingsOffset: 0,
    // Timeout between events firing to make sure it's
    // not too rapid (for performance reasons).
    throttleTimeout: 50,
    // Element to add the positionFixedClass to.
    positionFixedSelector: null,
    // Fixed position class to add to make sidebar fixed after scrolling
    // down past the fixedSidebarOffset.
    positionFixedClass: 'is-position-fixed',
    // fixedSidebarOffset can be any number but by default is set
    // to auto which sets the fixedSidebarOffset to the sidebar
    // element's offsetTop from the top of the document on init.
    fixedSidebarOffset: 'auto',
    // includeHtml can be set to true to include the HTML markup from the
    // heading node instead of just including the textContent.
    includeHtml: false
  });
});
</script>
</body>
</html>