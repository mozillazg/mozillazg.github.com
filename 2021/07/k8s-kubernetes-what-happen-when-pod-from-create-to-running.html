<!DOCTYPE html>
<html lang="zh"  prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml" class="han-init">
<head>
    <title>Pod 从创建到 Running 背后发生了什么 - mozillazg's Blog</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- share.css -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">


    <link href="https://mozillazg.com/favicon.ico" rel="icon">

<link rel="canonical" href="https://mozillazg.com/2021/07/k8s-kubernetes-what-happen-when-pod-from-create-to-running.html">

        <meta name="author" content="mozillazg" />
        <meta name="keywords" content="k8s,kubernetes" />
    <meta name="description" content="前言 简单记录一下 Pod 从创建到最终 Running 背后发生的事情， 以便对 k8s 的一些工作机制有一个更深入一点的了解。 本文内容所针对的 Kubernetes 版本为 v1.21.3 从发送创建 Pod 的请求到 Pod 信息存入 etcd 先讲一下从客户端发送创建 Pod 的请求到 apiserver 然后 apiserver 把数据存入 etcd 过程中发生的事情： 客户端向 apiserver 发送创建 Pod 的请求: POST /api/v1/namespaces/{namespace}/pods apiserver 收到请求后 首先会对请求做 认证（authentication） ，解析请求所携带的认证信息得到 User 信息，然后将 User 信息写入请求的 Context 中。 支持的认证方法详见 官方文档 认证通过后，再对 User 做 鉴权（Authorization） ，检查当前 User 对这个请求所操作的资源是否有相应的操作权限。 支持的鉴权方法详见 官方文档 认证和鉴权都通过后，请求的 body 将会被反序列化为 runtime.Object 对象。 在 存入 etcd 之前 ， 反序列化后的对象会 先被 填充默认值 和进行 字段校验 然后这个请求和对象还会被 Admission Controllers 处理一遍。 Admission Controllers 即包括 kube-apiserver 内置的 admission controllers 也包括用户自行实现的 admission webhooks 。 Admission Controllers 既可以实现对请求做进一步的校验（比如按一定策略对请求校验，拦截未使用指定 docker registory 的 Pod）（ validating admission ）） 也可以实现修改请求创建/修改的对象的属性的需求（比如给 Pod 注入 sidecar 容器）（ mutating admission ））。 先处理 mutating admission 然后 再处理 validating admission ) 只要有一个 Admission Controller 返回失败，请求就会失败。 多个 Admission Controller 串行执行 ， 每个 Admission Controller 内部都有自己的逻辑，比如， ValidatingAdmissionWebhook Controller 内部会 并发执行 定义的多个 validating admission webhook ，执行完成后只返回 第一个错误 （未被忽略的那个错误，因为 webhook 可以配置忽略错误） MutatingAdmissionWebhook Controller 内部会 串行执行 定义的多个 mutating webhook ，出错（未被忽略的错误，因为 webhook 可以配置忽略错误）就 返回 Admission controllers 处理完以后， 对象被存入到 etcd 中 最后根据执行结果方法相应的 Response。 此时 Pod 就创建成功了，但是还没有被调度到某个节点并且状态是 Pending。 Pod 调度 kube-scheduler 组件负责 Pod 的调度工作，具体过程如下： kube-scheduler 通过 Informer 机制 监控 Pod 等资源的变更事件并注册相应的回调函数 当上面的 Pod 创建成功后， 触发了 Pod 的变更事件 ，因为此时这个 Pod 满足 nodeName 的值为空并且 schedulerName 中指定的是已知的 Scheduler Framework Name，所以这个 Pod 对象会被放入到 SchedulingQueue 队列中等待处理。 kube-scheduler 中 SchedulingQueue 中的待调度 Pod 会由 scheduleOne 函数进行处理，Pod 调度逻辑就在这个函数里: 根据 Pod 的 schedulerName 字段的值找到 Pod 指定要使用的 Scheduler Framework (fwk) 根据调度算法（内置的策略加 fwk 实现的策略）得出适合这个 Pod 的最佳节点（调度算法的详细说明以后再单独细说） 如果调度算法失败了： 执行 fwk.RunPostFilterPlugins 函数，获取可能的 nominatedNode 产生一个 FailedScheduling Event、 更新 Pod 的 status.conditions 字段增加一个 type 为 PodScheduled status 为 False 的 PodCondition 以及更新 status.nominatedNodeName 字段的值为前面获取的 nominatedNode 如果调度算法成功返回了节点信息，首先执行 fwk.RunReservePluginsReserve 如果失败了执行 fwk.RunReservePluginsUnreserve 然后按上面 3.2 的操作记录调度失败 然后再执行 fwk.RunPermitPlugins `` 如果失败了执行 ``fwk.RunReservePluginsUnreserve 然后按上面 3.2 的操作记录调度失败 最后执行 binding 操作 执行 fwk.WaitOnPermit 如果失败了执行 fwk.RunReservePluginsUnreserve 然后按上面 3.2 的操作记录调度失败 执行 fwk.RunPreBindPlugins 如果失败了执行 fwk.RunReservePluginsUnreserve 然后按上面 3.2 的操作记录调度失败 执行真正的 binding 操作 sched.bind ， 默认的 Bind 实现 会去 post 当前 Pod 的 binding 子资源 记录 Pod 被调度到哪个节点上了， 如果失败了执行 fwk.RunReservePluginsUnreserve 然后按上面 3.2 的操作记录调度失败 执行 fwk.RunPostBindPlugins 当 apiserver 收到对 Pod binding 子资源的 post 请求的时候，会触发 binding 的 create 逻辑， 更新 Pod 的 nodeName 字段为请求中包含的 NodeName 以及 更新 Pod 的 status.conditions 字段增加一个 type 为 PodScheduled status 为 True 的 pod condition 。 此时 Pod 就被调度到一个节点上了，但是 Pod 的还是 Pending 因为 Pod 内的容器还没有在被调度的节点上运行。 节点上运行 Pod 中的容器 kubelet 组件负责在节点上运行 Pod 中定义的容器，具体的过程如下： kubelet 组件启动后会 watch 所有 nodeName 字段的值是当前节点名称的 Pod 的 变更事件 当 Pod 经过调度后，它的 nodeName 字段会被设置为被选中的节点的名称，此时会触发 kubelet 中 pod ADD 事件（因为之前没在这个节点上处理过）: 触发 Pod 更新 的 处理 逻 辑 : 首先执行 canRunPod 检查（ 检查 AppArmor 、 NoNewPrivs 以及 ProcMount 这三个特性），如果检查不通过的话，不会进行后续的操作 如果网络插件未就绪并且当前 Pod 未使用 Host 网络的话，返回 network is not ready 的错误以及产生一个 NetworkNotReady 的 Event 如果启用了 cgroups-per-qos 功能，将为 Pod 创建 Cgroups 创建存放 Pod 容器数据的目录： Pod 目录，比如 /var/run/kubelet/pods/{PodUID} PodVolumes 目录，比如 {PodDir}/volumes PodPlugins 目录，比如 {PodDir}/plugins 通过 volumeManager.WaitForAttachAndMount 等待 Pod 中所有容器的 volumeMounts 和 volumeDevices 中使用的 volume 被成功 attatch 和 mount （关于 volumeManager 相关内容以后再单独细说）。 如果失败的话，返回 mount 失败的 event 和错误 获取 Pod 中指定的 imagePullSecrets 所使用的那些 secret 数据的内容。 容器运行时创建容器 : 执行 createPodSandbox 方法创建一个 pod sandbox 内部 会通过 gRPC 调用不同 CRI（Container Runtime Interface） 所实现的 RunPodSandbox 接口 不同 CRI 实现 RunPodSandbox 接口的方法可能会不尽相同。以 Docker 为例，dockershim 中实现的 RunPodSandbox 接口的 内部操作 如下： pull sandbox 容器（pause 容器）所用的镜像（默认是 k8s.gcr.io/pause:3.4.1 ，） 调用 docker client api 创建 sandbox 容器 创建 sandbox checkpoint 启动 sandbox 容器 更新容器内的 resolv.conf 文件的内容 如果 Pod 使用的是 Host 网络，直接返回, 如果不是用的 Host 网络的话，继续 通过 CNI 插件 配置容器网络 : 实际上是调用 CNI 插件的二进制可执行文件， 执行 一个 ADD 指令 如果网络配置失败 清理网络资源：执行 CNI 插件的 DEL 指令 停止前面启动的容器 然后再通过调用 CRI 的 PodSandboxStatus 接口查询一下创建的 pod sandbox 的状态，确保创建的 pod sandbox 无异常，同时获取 status 中包含的 pod IP 信息。 启动 ephemeral 容器， 启动容器 的步骤如下： 使用前面 6 获取的 secret 数据 pull image 调用 CRI 的 CreateContainer 接口创建容器 调用 CRI 的 StartContainer 接口启动容器 执行 container 中定义的 lifecycle.postStart hook 启动 init 容器 启动剩下的容器 容器启动完成后，将当前 Pod 注册 到 probeManager 中。 probeManager 负责异步执行容器中定义的 startupProbe 、 readinessProbe 以及 livenessProbe 操作。 这些 probe 操作的结果会发送到 startupManager 、 readinessManager 以及 livenessManager 中，从而触发响应的 事件响应逻辑 比如 readinessProbe 执行成功了会触发更新 statusManager 中记录的 Pod 的 status 信息，更新 ContainersReady 和 Ready 信息，以及 触发 Pod 信息同步操作（这里会有更新 statusManager 把 statusManager 中的Pod 状态 更新 为 Running 的 逻辑 ）。 statusManager 里有个 协程 会定期把待更新的 pod 状态通过 apiserver 进行 更新 。 经过 kubelet 中一些列的处理后，此时 Pod 的状态就变成 Running 了。 总结 简单记录了一下 Pod 从创建到最终 Running 背后发生的事情，其中有些细节没有展开， 后面再补充或者另写一些文章说一下那些没展开的内容。 参考资料 kubernetes/kubernetes at v1.21.3 Kubernetes Documentation | Kubernetes" />

    <style>
      .js-toc {
        margin-bottom: 20px;
      }
      .donate-modal {
        text-align: center;
      }
      #donate-modal-container .donate-image {
        max-height: 300px !important;
        min-height: inherit !important;
      }
    </style>

        <meta property="og:site_name" content="mozillazg's Blog" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Pod 从创建到 Running 背后发生了什么"/>
        <meta property="og:url" content="https://mozillazg.com/2021/07/k8s-kubernetes-what-happen-when-pod-from-create-to-running.html"/>
        <meta property="og:description" content="前言 简单记录一下 Pod 从创建到最终 Running 背后发生的事情， 以便对 k8s 的一些工作机制有一个更深入一点的了解。 本文内容所针对的 Kubernetes 版本为 v1.21.3 从发送创建 Pod 的请求到 Pod 信息存入 etcd 先讲一下从客户端发送创建 Pod 的请求到 apiserver 然后 apiserver 把数据存入 etcd 过程中发生的事情： 客户端向 apiserver 发送创建 Pod 的请求: POST /api/v1/namespaces/{namespace}/pods apiserver 收到请求后 首先会对请求做 认证（authentication） ，解析请求所携带的认证信息得到 User 信息，然后将 User 信息写入请求的 Context 中。 支持的认证方法详见 官方文档 认证通过后，再对 User 做 鉴权（Authorization） ，检查当前 User 对这个请求所操作的资源是否有相应的操作权限。 支持的鉴权方法详见 官方文档 认证和鉴权都通过后，请求的 body 将会被反序列化为 runtime.Object 对象。 在 存入 etcd 之前 ， 反序列化后的对象会 先被 填充默认值 和进行 字段校验 然后这个请求和对象还会被 Admission Controllers 处理一遍。 Admission Controllers 即包括 kube-apiserver 内置的 admission controllers 也包括用户自行实现的 admission webhooks 。 Admission Controllers 既可以实现对请求做进一步的校验（比如按一定策略对请求校验，拦截未使用指定 docker registory 的 Pod）（ validating admission ）） 也可以实现修改请求创建/修改的对象的属性的需求（比如给 Pod 注入 sidecar 容器）（ mutating admission ））。 先处理 mutating admission 然后 再处理 validating admission ) 只要有一个 Admission Controller 返回失败，请求就会失败。 多个 Admission Controller 串行执行 ， 每个 Admission Controller 内部都有自己的逻辑，比如， ValidatingAdmissionWebhook Controller 内部会 并发执行 定义的多个 validating admission webhook ，执行完成后只返回 第一个错误 （未被忽略的那个错误，因为 webhook 可以配置忽略错误） MutatingAdmissionWebhook Controller 内部会 串行执行 定义的多个 mutating webhook ，出错（未被忽略的错误，因为 webhook 可以配置忽略错误）就 返回 Admission controllers 处理完以后， 对象被存入到 etcd 中 最后根据执行结果方法相应的 Response。 此时 Pod 就创建成功了，但是还没有被调度到某个节点并且状态是 Pending。 Pod 调度 kube-scheduler 组件负责 Pod 的调度工作，具体过程如下： kube-scheduler 通过 Informer 机制 监控 Pod 等资源的变更事件并注册相应的回调函数 当上面的 Pod 创建成功后， 触发了 Pod 的变更事件 ，因为此时这个 Pod 满足 nodeName 的值为空并且 schedulerName 中指定的是已知的 Scheduler Framework Name，所以这个 Pod 对象会被放入到 SchedulingQueue 队列中等待处理。 kube-scheduler 中 SchedulingQueue 中的待调度 Pod 会由 scheduleOne 函数进行处理，Pod 调度逻辑就在这个函数里: 根据 Pod 的 schedulerName 字段的值找到 Pod 指定要使用的 Scheduler Framework (fwk) 根据调度算法（内置的策略加 fwk 实现的策略）得出适合这个 Pod 的最佳节点（调度算法的详细说明以后再单独细说） 如果调度算法失败了： 执行 fwk.RunPostFilterPlugins 函数，获取可能的 nominatedNode 产生一个 FailedScheduling Event、 更新 Pod 的 status.conditions 字段增加一个 type 为 PodScheduled status 为 False 的 PodCondition 以及更新 status.nominatedNodeName 字段的值为前面获取的 nominatedNode 如果调度算法成功返回了节点信息，首先执行 fwk.RunReservePluginsReserve 如果失败了执行 fwk.RunReservePluginsUnreserve 然后按上面 3.2 的操作记录调度失败 然后再执行 fwk.RunPermitPlugins `` 如果失败了执行 ``fwk.RunReservePluginsUnreserve 然后按上面 3.2 的操作记录调度失败 最后执行 binding 操作 执行 fwk.WaitOnPermit 如果失败了执行 fwk.RunReservePluginsUnreserve 然后按上面 3.2 的操作记录调度失败 执行 fwk.RunPreBindPlugins 如果失败了执行 fwk.RunReservePluginsUnreserve 然后按上面 3.2 的操作记录调度失败 执行真正的 binding 操作 sched.bind ， 默认的 Bind 实现 会去 post 当前 Pod 的 binding 子资源 记录 Pod 被调度到哪个节点上了， 如果失败了执行 fwk.RunReservePluginsUnreserve 然后按上面 3.2 的操作记录调度失败 执行 fwk.RunPostBindPlugins 当 apiserver 收到对 Pod binding 子资源的 post 请求的时候，会触发 binding 的 create 逻辑， 更新 Pod 的 nodeName 字段为请求中包含的 NodeName 以及 更新 Pod 的 status.conditions 字段增加一个 type 为 PodScheduled status 为 True 的 pod condition 。 此时 Pod 就被调度到一个节点上了，但是 Pod 的还是 Pending 因为 Pod 内的容器还没有在被调度的节点上运行。 节点上运行 Pod 中的容器 kubelet 组件负责在节点上运行 Pod 中定义的容器，具体的过程如下： kubelet 组件启动后会 watch 所有 nodeName 字段的值是当前节点名称的 Pod 的 变更事件 当 Pod 经过调度后，它的 nodeName 字段会被设置为被选中的节点的名称，此时会触发 kubelet 中 pod ADD 事件（因为之前没在这个节点上处理过）: 触发 Pod 更新 的 处理 逻 辑 : 首先执行 canRunPod 检查（ 检查 AppArmor 、 NoNewPrivs 以及 ProcMount 这三个特性），如果检查不通过的话，不会进行后续的操作 如果网络插件未就绪并且当前 Pod 未使用 Host 网络的话，返回 network is not ready 的错误以及产生一个 NetworkNotReady 的 Event 如果启用了 cgroups-per-qos 功能，将为 Pod 创建 Cgroups 创建存放 Pod 容器数据的目录： Pod 目录，比如 /var/run/kubelet/pods/{PodUID} PodVolumes 目录，比如 {PodDir}/volumes PodPlugins 目录，比如 {PodDir}/plugins 通过 volumeManager.WaitForAttachAndMount 等待 Pod 中所有容器的 volumeMounts 和 volumeDevices 中使用的 volume 被成功 attatch 和 mount （关于 volumeManager 相关内容以后再单独细说）。 如果失败的话，返回 mount 失败的 event 和错误 获取 Pod 中指定的 imagePullSecrets 所使用的那些 secret 数据的内容。 容器运行时创建容器 : 执行 createPodSandbox 方法创建一个 pod sandbox 内部 会通过 gRPC 调用不同 CRI（Container Runtime Interface） 所实现的 RunPodSandbox 接口 不同 CRI 实现 RunPodSandbox 接口的方法可能会不尽相同。以 Docker 为例，dockershim 中实现的 RunPodSandbox 接口的 内部操作 如下： pull sandbox 容器（pause 容器）所用的镜像（默认是 k8s.gcr.io/pause:3.4.1 ，） 调用 docker client api 创建 sandbox 容器 创建 sandbox checkpoint 启动 sandbox 容器 更新容器内的 resolv.conf 文件的内容 如果 Pod 使用的是 Host 网络，直接返回, 如果不是用的 Host 网络的话，继续 通过 CNI 插件 配置容器网络 : 实际上是调用 CNI 插件的二进制可执行文件， 执行 一个 ADD 指令 如果网络配置失败 清理网络资源：执行 CNI 插件的 DEL 指令 停止前面启动的容器 然后再通过调用 CRI 的 PodSandboxStatus 接口查询一下创建的 pod sandbox 的状态，确保创建的 pod sandbox 无异常，同时获取 status 中包含的 pod IP 信息。 启动 ephemeral 容器， 启动容器 的步骤如下： 使用前面 6 获取的 secret 数据 pull image 调用 CRI 的 CreateContainer 接口创建容器 调用 CRI 的 StartContainer 接口启动容器 执行 container 中定义的 lifecycle.postStart hook 启动 init 容器 启动剩下的容器 容器启动完成后，将当前 Pod 注册 到 probeManager 中。 probeManager 负责异步执行容器中定义的 startupProbe 、 readinessProbe 以及 livenessProbe 操作。 这些 probe 操作的结果会发送到 startupManager 、 readinessManager 以及 livenessManager 中，从而触发响应的 事件响应逻辑 比如 readinessProbe 执行成功了会触发更新 statusManager 中记录的 Pod 的 status 信息，更新 ContainersReady 和 Ready 信息，以及 触发 Pod 信息同步操作（这里会有更新 statusManager 把 statusManager 中的Pod 状态 更新 为 Running 的 逻辑 ）。 statusManager 里有个 协程 会定期把待更新的 pod 状态通过 apiserver 进行 更新 。 经过 kubelet 中一些列的处理后，此时 Pod 的状态就变成 Running 了。 总结 简单记录了一下 Pod 从创建到最终 Running 背后发生的事情，其中有些细节没有展开， 后面再补充或者另写一些文章说一下那些没展开的内容。 参考资料 kubernetes/kubernetes at v1.21.3 Kubernetes Documentation | Kubernetes"/>
        <meta property="article:published_time" content="2021-07-25" />
            <meta property="article:section" content="k8s" />
            <meta property="article:tag" content="k8s" />
            <meta property="article:tag" content="kubernetes" />
            <meta property="article:author" content="mozillazg" />
            <meta property="og:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>


    <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@mozillazg">
        <meta name="twitter:creator" content="@mozillazg">
    <meta name="twitter:domain" content="https://mozillazg.com">
            <meta property="twitter:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/css/bootstrap.min.css" type="text/css"/>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link href="https://cdn.jsdelivr.net/npm/pygments-css@1.0.0/github.css" rel="stylesheet">
    <link rel="stylesheet" href="https://mozillazg.com/theme/css/style.css" type="text/css"/>
            <link href="https://mozillazg.com/static/custom.css" rel="stylesheet">

        <link href="https://mozillazg.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog ATOM Feed"/>

        <link href="https://mozillazg.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="mozillazg's Blog RSS Feed"/>


        <link href="https://mozillazg.com/feeds/k8s.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog k8s ATOM Feed"/>


    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "publisher": {
            "@type": "Person",
            "name": "mozillazg",
            "logo": "https://mozillazg.com/static/avatar.jpeg"
        },
        "author": {
            "@type": "Person",
            "name": "mozillazg",
            "image": "https://mozillazg.com/static/avatar.jpeg",
            "url": "https://mozillazg.com",
            "sameAs": []
        },
        "headline": "Pod 从创建到 Running 背后发生了什么",
        "url": "https://mozillazg.com/2021/07/k8s-kubernetes-what-happen-when-pod-from-create-to-running.html",
        "image": [
            "https://mozillazg.com/static/avatar.jpeg"
         ],
        "keywords": "k8s, kubernetes",
        "description": "前言 简单记录一下 Pod 从创建到最终 Running 背后发生的事情， 以便对 k8s 的一些工作机制有一个更深入一点的了解。 本文内容所针对的 Kubernetes 版本为 v1.21.3 从发送创建 Pod 的请求到 Pod 信息存入 etcd 先讲一下从客户端发送创建 Pod 的请求到 apiserver 然后 apiserver 把数据存入 etcd 过程中发生的事情： 客户端向 apiserver 发送创建 Pod 的请求: POST /api/v1/namespaces/{namespace}/pods apiserver 收到请求后 首先会对请求做 认证（authentication） ，解析请求所携带的认证信息得到 User 信息，然后将 User 信息写入请求的 Context 中。 支持的认证方法详见 官方文档 认证通过后，再对 User 做 鉴权（Authorization） ，检查当前 User 对这个请求所操作的资源是否有相应的操作权限。 支持的鉴权方法详见 官方文档 认证和鉴权都通过后，请求的 body 将会被反序列化为 runtime.Object 对象。 在 存入 etcd 之前 ， 反序列化后的对象会 先被 填充默认值 和进行 字段校验 然后这个请求和对象还会被 Admission Controllers 处理一遍。 Admission Controllers 即包括 kube-apiserver 内置的 admission controllers 也包括用户自行实现的 admission webhooks 。 Admission Controllers 既可以实现对请求做进一步的校验（比如按一定策略对请求校验，拦截未使用指定 docker registory 的 Pod）（ validating admission ）） 也可以实现修改请求创建/修改的对象的属性的需求（比如给 Pod 注入 sidecar 容器）（ mutating admission ））。 先处理 mutating admission 然后 再处理 validating admission ) 只要有一个 Admission Controller 返回失败，请求就会失败。 多个 Admission Controller 串行执行 ， 每个 Admission Controller 内部都有自己的逻辑，比如， ValidatingAdmissionWebhook Controller 内部会 并发执行 定义的多个 validating admission webhook ，执行完成后只返回 第一个错误 （未被忽略的那个错误，因为 webhook 可以配置忽略错误） MutatingAdmissionWebhook Controller 内部会 串行执行 定义的多个 mutating webhook ，出错（未被忽略的错误，因为 webhook 可以配置忽略错误）就 返回 Admission controllers 处理完以后， 对象被存入到 etcd 中 最后根据执行结果方法相应的 Response。 此时 Pod 就创建成功了，但是还没有被调度到某个节点并且状态是 Pending。 Pod 调度 kube-scheduler 组件负责 Pod 的调度工作，具体过程如下： kube-scheduler 通过 Informer 机制 监控 Pod 等资源的变更事件并注册相应的回调函数 当上面的 Pod 创建成功后， 触发了 Pod 的变更事件 ，因为此时这个 Pod 满足 nodeName 的值为空并且 schedulerName 中指定的是已知的 Scheduler Framework Name，所以这个 Pod 对象会被放入到 SchedulingQueue 队列中等待处理。 kube-scheduler 中 SchedulingQueue 中的待调度 Pod 会由 scheduleOne 函数进行处理，Pod 调度逻辑就在这个函数里: 根据 Pod 的 schedulerName 字段的值找到 Pod 指定要使用的 Scheduler Framework (fwk) 根据调度算法（内置的策略加 fwk 实现的策略）得出适合这个 Pod 的最佳节点（调度算法的详细说明以后再单独细说） 如果调度算法失败了： 执行 fwk.RunPostFilterPlugins 函数，获取可能的 nominatedNode 产生一个 FailedScheduling Event、 更新 Pod 的 status.conditions 字段增加一个 type 为 PodScheduled status 为 False 的 PodCondition 以及更新 status.nominatedNodeName 字段的值为前面获取的 nominatedNode 如果调度算法成功返回了节点信息，首先执行 fwk.RunReservePluginsReserve 如果失败了执行 fwk.RunReservePluginsUnreserve 然后按上面 3.2 的操作记录调度失败 然后再执行 fwk.RunPermitPlugins `` 如果失败了执行 ``fwk.RunReservePluginsUnreserve 然后按上面 3.2 的操作记录调度失败 最后执行 binding 操作 执行 fwk.WaitOnPermit 如果失败了执行 fwk.RunReservePluginsUnreserve 然后按上面 3.2 的操作记录调度失败 执行 fwk.RunPreBindPlugins 如果失败了执行 fwk.RunReservePluginsUnreserve 然后按上面 3.2 的操作记录调度失败 执行真正的 binding 操作 sched.bind ， 默认的 Bind 实现 会去 post 当前 Pod 的 binding 子资源 记录 Pod 被调度到哪个节点上了， 如果失败了执行 fwk.RunReservePluginsUnreserve 然后按上面 3.2 的操作记录调度失败 执行 fwk.RunPostBindPlugins 当 apiserver 收到对 Pod binding 子资源的 post 请求的时候，会触发 binding 的 create 逻辑， 更新 Pod 的 nodeName 字段为请求中包含的 NodeName 以及 更新 Pod 的 status.conditions 字段增加一个 type 为 PodScheduled status 为 True 的 pod condition 。 此时 Pod 就被调度到一个节点上了，但是 Pod 的还是 Pending 因为 Pod 内的容器还没有在被调度的节点上运行。 节点上运行 Pod 中的容器 kubelet 组件负责在节点上运行 Pod 中定义的容器，具体的过程如下： kubelet 组件启动后会 watch 所有 nodeName 字段的值是当前节点名称的 Pod 的 变更事件 当 Pod 经过调度后，它的 nodeName 字段会被设置为被选中的节点的名称，此时会触发 kubelet 中 pod ADD 事件（因为之前没在这个节点上处理过）: 触发 Pod 更新 的 处理 逻 辑 : 首先执行 canRunPod 检查（ 检查 AppArmor 、 NoNewPrivs 以及 ProcMount 这三个特性），如果检查不通过的话，不会进行后续的操作 如果网络插件未就绪并且当前 Pod 未使用 Host 网络的话，返回 network is not ready 的错误以及产生一个 NetworkNotReady 的 Event 如果启用了 cgroups-per-qos 功能，将为 Pod 创建 Cgroups 创建存放 Pod 容器数据的目录： Pod 目录，比如 /var/run/kubelet/pods/{PodUID} PodVolumes 目录，比如 {PodDir}/volumes PodPlugins 目录，比如 {PodDir}/plugins 通过 volumeManager.WaitForAttachAndMount 等待 Pod 中所有容器的 volumeMounts 和 volumeDevices 中使用的 volume 被成功 attatch 和 mount （关于 volumeManager 相关内容以后再单独细说）。 如果失败的话，返回 mount 失败的 event 和错误 获取 Pod 中指定的 imagePullSecrets 所使用的那些 secret 数据的内容。 容器运行时创建容器 : 执行 createPodSandbox 方法创建一个 pod sandbox 内部 会通过 gRPC 调用不同 CRI（Container Runtime Interface） 所实现的 RunPodSandbox 接口 不同 CRI 实现 RunPodSandbox 接口的方法可能会不尽相同。以 Docker 为例，dockershim 中实现的 RunPodSandbox 接口的 内部操作 如下： pull sandbox 容器（pause 容器）所用的镜像（默认是 k8s.gcr.io/pause:3.4.1 ，） 调用 docker client api 创建 sandbox 容器 创建 sandbox checkpoint 启动 sandbox 容器 更新容器内的 resolv.conf 文件的内容 如果 Pod 使用的是 Host 网络，直接返回, 如果不是用的 Host 网络的话，继续 通过 CNI 插件 配置容器网络 : 实际上是调用 CNI 插件的二进制可执行文件， 执行 一个 ADD 指令 如果网络配置失败 清理网络资源：执行 CNI 插件的 DEL 指令 停止前面启动的容器 然后再通过调用 CRI 的 PodSandboxStatus 接口查询一下创建的 pod sandbox 的状态，确保创建的 pod sandbox 无异常，同时获取 status 中包含的 pod IP 信息。 启动 ephemeral 容器， 启动容器 的步骤如下： 使用前面 6 获取的 secret 数据 pull image 调用 CRI 的 CreateContainer 接口创建容器 调用 CRI 的 StartContainer 接口启动容器 执行 container 中定义的 lifecycle.postStart hook 启动 init 容器 启动剩下的容器 容器启动完成后，将当前 Pod 注册 到 probeManager 中。 probeManager 负责异步执行容器中定义的 startupProbe 、 readinessProbe 以及 livenessProbe 操作。 这些 probe 操作的结果会发送到 startupManager 、 readinessManager 以及 livenessManager 中，从而触发响应的 事件响应逻辑 比如 readinessProbe 执行成功了会触发更新 statusManager 中记录的 Pod 的 status 信息，更新 ContainersReady 和 Ready 信息，以及 触发 Pod 信息同步操作（这里会有更新 statusManager 把 statusManager 中的Pod 状态 更新 为 Running 的 逻辑 ）。 statusManager 里有个 协程 会定期把待更新的 pod 状态通过 apiserver 进行 更新 。 经过 kubelet 中一些列的处理后，此时 Pod 的状态就变成 Running 了。 总结 简单记录了一下 Pod 从创建到最终 Running 背后发生的事情，其中有些细节没有展开， 后面再补充或者另写一些文章说一下那些没展开的内容。 参考资料 kubernetes/kubernetes at v1.21.3 Kubernetes Documentation | Kubernetes",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "https://mozillazg.com/2021/07/k8s-kubernetes-what-happen-when-pod-from-create-to-running.html"
        },
        "datePublished": "2021-07-25"
    }
    </script>

</head>
<body>

<div class="navbar" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://mozillazg.com/" class="navbar-brand">
mozillazg's Blog            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="https://mozillazg.com/feeds/all.atom.xml">Feed</a></li>
                    <li><a href="/2014/10/pages/about-me.html">About</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://mozillazg.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content" class="yue">
        <article>
            <header class="text-center">
                <h1>
                    <a href="https://mozillazg.com/2021/07/k8s-kubernetes-what-happen-when-pod-from-create-to-running.html"
                       rel="bookmark"
                       title="Permalink to Pod 从创建到 Running 背后发生了什么">
                        Pod 从创建到 Running 背后发生了什么
                    </a>
                </h1>
                <p class="published">
                    <time datetime="2021-07-25T00:00:00+00:00">
                    2021-07-25
                    </time>
                </p>
            </header>
            <div class="entry-content">
                <div class="well-sm article-info">
<footer class="post-info">
        <a href="https://mozillazg.com/category/k8s.html">k8s</a>


<span class="label label-default hide">Tags</span>
	<a href="https://mozillazg.com/tag/kubernetes.html">kubernetes</a>
    
</footer><!-- /.post-info -->                </div>
                <div class="js-toc"></div>
                <div>
                <div class="section" id="id1">
<h2 id="hidid1">前言<a class="headerlink" href="#hidid1" title="Permalink to this headline">¶</a></h2>
<p>简单记录一下 Pod 从创建到最终 Running 背后发生的事情，
以便对 k8s 的一些工作机制有一个更深入一点的了解。</p>
<p>本文内容所针对的 Kubernetes 版本为 <a class="reference external" href="https://github.com/kubernetes/kubernetes/tree/v1.21.3">v1.21.3</a></p>
<div class="section" id="pod-pod-etcd">
<h3 id="hidpod-pod-etcd">从发送创建 Pod 的请求到 Pod 信息存入 etcd<a class="headerlink" href="#hidpod-pod-etcd" title="Permalink to this headline">¶</a></h3>
<p>先讲一下从客户端发送创建 Pod 的请求到 apiserver 然后 apiserver 把数据存入 etcd 过程中发生的事情：</p>
<ol class="arabic simple">
<li>客户端向 apiserver 发送创建 Pod 的请求: <tt class="docutils literal">POST <span class="pre">/api/v1/namespaces/{namespace}/pods</span></tt></li>
<li>apiserver 收到请求后<ol class="arabic">
<li>首先会对请求做 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/ca643a4d1f7bfe34773c74f79527be4afd95bf39/staging/src/k8s.io/apiserver/pkg/endpoints/filters/authentication.go#L45-L82">认证（authentication）</a> ，解析请求所携带的认证信息得到 User 信息，然后将 User 信息写入请求的 Context 中。
支持的认证方法详见 <a class="reference external" href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/">官方文档</a></li>
<li>认证通过后，再对 User 做 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/ca643a4d1f7bfe34773c74f79527be4afd95bf39/staging/src/k8s.io/apiserver/pkg/endpoints/filters/authorization.go#L45-L78">鉴权（Authorization）</a> ，检查当前 User 对这个请求所操作的资源是否有相应的操作权限。
支持的鉴权方法详见 <a class="reference external" href="https://kubernetes.io/docs/reference/access-authn-authz/authorization/">官方文档</a></li>
<li>认证和鉴权都通过后，请求的 body 将会被反序列化为 <tt class="docutils literal">runtime.Object</tt> 对象。</li>
<li>在 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/f86b59ab79227929e7f283b859b4c59317399807/staging/src/k8s.io/apiserver/pkg/endpoints/handlers/create.go#L50-L201">存入</a> <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/a1fac8cbd9289d95db4831a83239292ed56ce59d/staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go#L365-L377">etcd 之前</a> ，
反序列化后的对象会 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/34cab8f80a9104be7fe5d8a5a22c3207dab46268/staging/src/k8s.io/apiserver/pkg/registry/rest/create.go#L74-L119">先被</a> <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/a1fac8cbd9289d95db4831a83239292ed56ce59d/pkg/registry/core/pod/strategy.go#L82-L92">填充默认值</a> 和进行 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/a1fac8cbd9289d95db4831a83239292ed56ce59d/pkg/registry/core/pod/strategy.go#L104-L108">字段校验</a></li>
<li>然后这个请求和对象还会被 Admission Controllers 处理一遍。
Admission Controllers 即包括 kube-apiserver 内置的 <a class="reference external" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/">admission controllers</a> 也包括用户自行实现的 <a class="reference external" href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">admission webhooks</a> 。<ul>
<li>Admission Controllers 既可以实现对请求做进一步的校验（比如按一定策略对请求校验，拦截未使用指定 docker registory 的 Pod）（ validating admission ）） 也可以实现修改请求创建/修改的对象的属性的需求（比如给 Pod 注入 sidecar 容器）（ mutating admission ））。</li>
<li><a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/f86b59ab79227929e7f283b859b4c59317399807/staging/src/k8s.io/apiserver/pkg/endpoints/handlers/create.go#L169-L177">先处理 mutating admission</a> 然后 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/a1fac8cbd9289d95db4831a83239292ed56ce59d/staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go#L379-L385">再处理 validating admission</a> )</li>
<li>只要有一个 Admission Controller 返回失败，请求就会失败。</li>
<li>多个 Admission Controller <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/61774cd7176cae0c0324d23ab20e6c6b3038153f/staging/src/k8s.io/apiserver/pkg/admission/chain.go#L30-L60">串行执行</a> ，
每个 Admission Controller 内部都有自己的逻辑，比如，<ul>
<li>ValidatingAdmissionWebhook Controller 内部会 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/b3aeaa4ed7bf8d419a96b4456a97bdf4c29e4330/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/validating/dispatcher.go#L94-L147">并发执行</a> 定义的多个 validating admission webhook ，执行完成后只返回 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/b3aeaa4ed7bf8d419a96b4456a97bdf4c29e4330/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/validating/dispatcher.go#L149-L162">第一个错误</a> （未被忽略的那个错误，因为 webhook 可以配置忽略错误）</li>
<li>MutatingAdmissionWebhook Controller 内部会 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/b3aeaa4ed7bf8d419a96b4456a97bdf4c29e4330/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/mutating/dispatcher.go#L94-L189">串行执行</a> 定义的多个 mutating webhook ，出错（未被忽略的错误，因为 webhook 可以配置忽略错误）就 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/b3aeaa4ed7bf8d419a96b4456a97bdf4c29e4330/staging/src/k8s.io/apiserver/pkg/admission/plugin/webhook/mutating/dispatcher.go#L168-L184">返回</a></li>
</ul>
</li>
</ul>
</li>
<li>Admission controllers 处理完以后， <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/a1fac8cbd9289d95db4831a83239292ed56ce59d/staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go#L401-L419">对象被存入到 etcd 中</a></li>
<li>最后根据执行结果方法相应的 Response。</li>
</ol>
</li>
<li>此时 Pod 就创建成功了，但是还没有被调度到某个节点并且状态是 Pending。</li>
</ol>
</div>
<div class="section" id="pod">
<h3 id="hidpod">Pod 调度<a class="headerlink" href="#hidpod" title="Permalink to this headline">¶</a></h3>
<p>kube-scheduler 组件负责 Pod 的调度工作，具体过程如下：</p>
<ol class="arabic simple">
<li>kube-scheduler 通过 Informer 机制 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/22a8a9ab455e23a841952872bdc7e042c75a878f/pkg/scheduler/eventhandlers.go#L358-L461">监控 Pod 等资源的变更事件并注册相应的回调函数</a></li>
<li>当上面的 Pod 创建成功后， <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/22a8a9ab455e23a841952872bdc7e042c75a878f/pkg/scheduler/eventhandlers.go#L388-L411">触发了 Pod 的变更事件</a> ，因为此时这个 Pod 满足 <tt class="docutils literal">nodeName</tt> 的值为空并且 <tt class="docutils literal">schedulerName</tt> 中指定的是已知的 Scheduler Framework Name，所以这个 Pod 对象会被放入到 <tt class="docutils literal">SchedulingQueue</tt> 队列中等待处理。</li>
<li>kube-scheduler 中 <tt class="docutils literal">SchedulingQueue</tt> 中的待调度 Pod 会由 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/318677cc93e281f4c78e94c58562d1f1b2e34061/pkg/scheduler/scheduler.go#L441-L614">scheduleOne</a> 函数进行处理，Pod 调度逻辑就在这个函数里:<ol class="arabic">
<li>根据 Pod 的 <tt class="docutils literal">schedulerName</tt> 字段的值找到 Pod 指定要使用的 Scheduler Framework (fwk)</li>
<li>根据调度算法（内置的策略加 fwk 实现的策略）得出适合这个 Pod 的最佳节点（调度算法的详细说明以后再单独细说）</li>
<li>如果调度算法失败了：<ol class="arabic">
<li>执行 fwk.RunPostFilterPlugins 函数，获取可能的 nominatedNode</li>
<li>产生一个 <tt class="docutils literal">FailedScheduling</tt> Event、 更新 Pod 的 <tt class="docutils literal">status.conditions</tt> 字段增加一个 <tt class="docutils literal">type</tt> 为 <tt class="docutils literal">PodScheduled</tt> <tt class="docutils literal">status</tt> 为 <tt class="docutils literal">False</tt> 的 PodCondition 以及更新 <tt class="docutils literal">status.nominatedNodeName</tt> 字段的值为前面获取的 <tt class="docutils literal">nominatedNode</tt></li>
</ol>
</li>
<li>如果调度算法成功返回了节点信息，首先执行 <tt class="docutils literal">fwk.RunReservePluginsReserve</tt> 如果失败了执行 <tt class="docutils literal">fwk.RunReservePluginsUnreserve</tt> 然后按上面 3.2 的操作记录调度失败</li>
<li>然后再执行 <tt class="docutils literal">fwk.RunPermitPlugins `` 如果失败了执行 ``fwk.RunReservePluginsUnreserve</tt> 然后按上面 3.2 的操作记录调度失败</li>
<li>最后执行 binding 操作<ol class="arabic">
<li>执行 <tt class="docutils literal">fwk.WaitOnPermit</tt> 如果失败了执行 <tt class="docutils literal">fwk.RunReservePluginsUnreserve</tt> 然后按上面 3.2 的操作记录调度失败</li>
<li>执行 <tt class="docutils literal">fwk.RunPreBindPlugins</tt> 如果失败了执行 <tt class="docutils literal">fwk.RunReservePluginsUnreserve</tt> 然后按上面 3.2 的操作记录调度失败</li>
<li>执行真正的 binding 操作 <tt class="docutils literal">sched.bind</tt> ， <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/c03b4c78507be4e6d50a2549e2c337bbda1aa87e/pkg/scheduler/framework/plugins/defaultbinder/default_binder.go#L50-L61">默认的 Bind 实现</a> 会去 post 当前 Pod 的 <tt class="docutils literal">binding</tt> <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/72ab11193a419f0e0e66e86c4e6be9991c3682f2/staging/src/k8s.io/client-go/kubernetes/typed/core/v1/pod_expansion.go#L38-L41">子资源</a>  记录 Pod 被调度到哪个节点上了， 如果失败了执行 <tt class="docutils literal">fwk.RunReservePluginsUnreserve</tt> 然后按上面 3.2 的操作记录调度失败</li>
<li>执行 <tt class="docutils literal">fwk.RunPostBindPlugins</tt></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>当 apiserver 收到对 Pod <tt class="docutils literal">binding</tt> 子资源的 post 请求的时候，会触发 binding 的 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/a1fac8cbd9289d95db4831a83239292ed56ce59d/pkg/registry/core/pod/storage/storage.go#L161-L186">create</a> 逻辑， <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/a1fac8cbd9289d95db4831a83239292ed56ce59d/pkg/registry/core/pod/storage/storage.go#L188-L234">更新 Pod</a> 的 <tt class="docutils literal">nodeName</tt> 字段为请求中包含的 NodeName 以及 更新 Pod 的 <tt class="docutils literal">status.conditions</tt> 字段增加一个 type 为 <tt class="docutils literal">PodScheduled</tt> status 为 <tt class="docutils literal">True</tt> 的 pod condition 。</p>
<p>此时 Pod 就被调度到一个节点上了，但是 Pod 的还是 Pending 因为 Pod 内的容器还没有在被调度的节点上运行。</p>
</div>
<div class="section" id="id2">
<h3 id="hidid2">节点上运行 Pod 中的容器<a class="headerlink" href="#hidid2" title="Permalink to this headline">¶</a></h3>
<p>kubelet 组件负责在节点上运行 Pod 中定义的容器，具体的过程如下：</p>
<ol class="arabic simple">
<li>kubelet 组件启动后会 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/d10d7e8dc94dc58bb432039f99e902115e66d4cc/pkg/kubelet/config/apiserver.go#L36-L55">watch</a> 所有 <tt class="docutils literal">nodeName</tt> 字段的值是当前节点名称的 Pod 的 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/d10d7e8dc94dc58bb432039f99e902115e66d4cc/pkg/kubelet/kubelet.go#L1887-L2016">变更事件</a></li>
<li>当 Pod 经过调度后，它的 <tt class="docutils literal">nodeName</tt> 字段会被设置为被选中的节点的名称，此时会触发 kubelet 中 pod <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/d10d7e8dc94dc58bb432039f99e902115e66d4cc/pkg/kubelet/kubelet.go#L2075-L2111">ADD</a> 事件（因为之前没在这个节点上处理过）:<ol class="arabic">
<li>触发 Pod <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/d10d7e8dc94dc58bb432039f99e902115e66d4cc/pkg/kubelet/kubelet.go#L2030-L2063">更新</a> 的 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/01a4e4facebda8a643383625d3cece724efe2a66/pkg/kubelet/pod_workers.go#L196-L234">处理</a> <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/01a4e4facebda8a643383625d3cece724efe2a66/pkg/kubelet/pod_workers.go#L157-L194">逻</a> <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/d10d7e8dc94dc58bb432039f99e902115e66d4cc/pkg/kubelet/kubelet.go#L1463-L1726">辑</a> :<ol class="arabic">
<li>首先执行 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/d10d7e8dc94dc58bb432039f99e902115e66d4cc/pkg/kubelet/kubelet.go#L1826-L1838">canRunPod</a> 检查（ <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/d10d7e8dc94dc58bb432039f99e902115e66d4cc/pkg/kubelet/kubelet.go#L809-L815">检查</a>  AppArmor 、 NoNewPrivs  以及 ProcMount 这三个特性），如果检查不通过的话，不会进行后续的操作</li>
<li>如果网络插件未就绪并且当前 Pod 未使用 Host 网络的话，返回 <tt class="docutils literal">network is not ready</tt> 的错误以及产生一个 <tt class="docutils literal">NetworkNotReady</tt> 的 Event</li>
<li>如果启用了 <tt class="docutils literal"><span class="pre">cgroups-per-qos</span></tt> 功能，将为 Pod 创建 Cgroups</li>
<li>创建存放 Pod 容器数据的目录：<ul>
<li>Pod 目录，比如 <tt class="docutils literal"><span class="pre">/var/run/kubelet/pods/{PodUID}</span></tt></li>
<li>PodVolumes 目录，比如 <tt class="docutils literal"><span class="pre">{PodDir}/volumes</span></tt></li>
<li>PodPlugins 目录，比如 <tt class="docutils literal"><span class="pre">{PodDir}/plugins</span></tt></li>
</ul>
</li>
<li>通过 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/d10d7e8dc94dc58bb432039f99e902115e66d4cc/pkg/kubelet/kubelet.go#L1699-L1702">volumeManager.WaitForAttachAndMount</a> 等待 Pod 中所有容器的 <tt class="docutils literal">volumeMounts</tt> 和 <tt class="docutils literal">volumeDevices</tt> 中使用的 volume 被成功 attatch 和 mount （关于 volumeManager 相关内容以后再单独细说）。 如果失败的话，返回 mount 失败的 event 和错误</li>
<li>获取 Pod 中指定的 <tt class="docutils literal">imagePullSecrets</tt> 所使用的那些 secret 数据的内容。</li>
<li><a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/461c0c1656994cbf393ea6f0ca9cf2454db93e7b/pkg/kubelet/kuberuntime/kuberuntime_manager.go#L693-L899">容器运行时创建容器</a> :<ol class="arabic">
<li>执行 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/629d5ab21349021cf7d38236620785071ee541b4/pkg/kubelet/kuberuntime/kuberuntime_sandbox.go#L36-L73">createPodSandbox</a> 方法创建一个 pod sandbox<ul>
<li><a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/8d86470417a3641e1971364902d172ad3026bda3/pkg/kubelet/cri/remote/remote_runtime.go#L99-L130">内部</a> 会通过 gRPC 调用不同 CRI（Container Runtime Interface） 所实现的 <tt class="docutils literal">RunPodSandbox</tt> 接口</li>
<li>不同 CRI 实现 <tt class="docutils literal">RunPodSandbox</tt> 接口的方法可能会不尽相同。以 Docker 为例，dockershim 中实现的 <tt class="docutils literal">RunPodSandbox</tt> 接口的 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/7735cf7f2674627283db081d61a2c45f4b70ee8f/pkg/kubelet/dockershim/docker_sandbox.go#L84-L205">内部操作</a> 如下：<ol class="arabic">
<li>pull sandbox 容器（pause 容器）所用的镜像（默认是 <tt class="docutils literal">k8s.gcr.io/pause:3.4.1</tt> ，）</li>
<li>调用 docker client api 创建 sandbox 容器</li>
<li>创建 sandbox checkpoint</li>
<li>启动 sandbox 容器</li>
<li>更新容器内的 resolv.conf 文件的内容</li>
<li>如果 Pod 使用的是 Host 网络，直接返回, 如果不是用的 Host 网络的话，继续</li>
<li>通过 CNI 插件 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/7735cf7f2674627283db081d61a2c45f4b70ee8f/pkg/kubelet/dockershim/network/plugins.go#L410-L424">配置容器网络</a> :<ul>
<li>实际上是调用 CNI 插件的二进制可执行文件， <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/6f79600e73584bbf600b414f8a79846f30fdf457/vendor/github.com/containernetworking/cni/libcni/api.go#L400-L422">执行</a> 一个 <tt class="docutils literal">ADD</tt> 指令</li>
</ul>
</li>
<li>如果网络配置失败<ol class="arabic">
<li>清理网络资源：执行 CNI 插件的 <tt class="docutils literal">DEL</tt> 指令</li>
<li>停止前面启动的容器</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li>然后再通过调用 CRI 的 <tt class="docutils literal">PodSandboxStatus</tt> 接口查询一下创建的 pod sandbox 的状态，确保创建的 pod sandbox 无异常，同时获取 status 中包含的 pod IP 信息。</li>
<li>启动 ephemeral 容器， <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/e781d2a672f044d47e75f0ec7015666d06164410/pkg/kubelet/kuberuntime/kuberuntime_container.go#L130-L239">启动容器</a> 的步骤如下：<ol class="arabic">
<li>使用前面 6 获取的 secret 数据 pull image</li>
<li>调用 CRI 的 <tt class="docutils literal">CreateContainer</tt> 接口创建容器</li>
<li>调用 CRI 的 <tt class="docutils literal">StartContainer</tt> 接口启动容器</li>
<li>执行 container 中定义的 <tt class="docutils literal">lifecycle.postStart</tt> hook</li>
</ol>
</li>
<li>启动 init 容器</li>
<li>启动剩下的容器</li>
</ol>
</li>
</ol>
</li>
<li>容器启动完成后，将当前 Pod <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/d10d7e8dc94dc58bb432039f99e902115e66d4cc/pkg/kubelet/kubelet.go#L2109">注册</a> <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/6af7eb6d494d8f742e18a3b965053e3a518bf6d7/pkg/kubelet/prober/prober_manager.go#L153-L197">到</a>  probeManager 中。 probeManager 负责异步执行容器中定义的 <tt class="docutils literal">startupProbe</tt> 、 <tt class="docutils literal">readinessProbe</tt> 以及 <tt class="docutils literal">livenessProbe</tt> 操作。<ul>
<li>这些 probe 操作的结果会发送到 <tt class="docutils literal">startupManager</tt> 、 <tt class="docutils literal">readinessManager</tt> 以及 <tt class="docutils literal">livenessManager</tt> 中，从而触发响应的 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/d10d7e8dc94dc58bb432039f99e902115e66d4cc/pkg/kubelet/kubelet.go#L1991-L2002">事件响应逻辑</a></li>
<li>比如 readinessProbe 执行成功了会触发更新 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/6af7eb6d494d8f742e18a3b965053e3a518bf6d7/pkg/kubelet/status/status_manager.go#L61-L72">statusManager</a> 中记录的 Pod 的 status 信息，更新 ContainersReady 和 Ready 信息，以及 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/d10d7e8dc94dc58bb432039f99e902115e66d4cc/pkg/kubelet/kubelet.go#L1998">触发</a> Pod 信息同步操作（这里会有更新 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/d10d7e8dc94dc58bb432039f99e902115e66d4cc/pkg/kubelet/kubelet.go#L1585-L1586">statusManager</a> 把 statusManager 中的Pod 状态 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/6af7eb6d494d8f742e18a3b965053e3a518bf6d7/pkg/kubelet/kubelet_pods.go#L1517-L1576">更新</a> 为 Running 的 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/6af7eb6d494d8f742e18a3b965053e3a518bf6d7/pkg/kubelet/kubelet_pods.go#L1415-L1515">逻辑</a> ）。</li>
<li>statusManager 里有个 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/6af7eb6d494d8f742e18a3b965053e3a518bf6d7/pkg/kubelet/status/status_manager.go#L161-L179">协程</a> 会定期把待更新的 pod 状态通过 apiserver 进行 <a class="reference external" href="https://github.com/kubernetes/kubernetes/blob/6af7eb6d494d8f742e18a3b965053e3a518bf6d7/pkg/kubelet/status/status_manager.go#L548-L617">更新</a> 。</li>
</ul>
</li>
</ol>
</li>
</ol>
<p>经过 kubelet 中一些列的处理后，此时 Pod 的状态就变成 Running 了。</p>
</div>
</div>
<div class="section" id="id3">
<h2 id="hidid3">总结<a class="headerlink" href="#hidid3" title="Permalink to this headline">¶</a></h2>
<p>简单记录了一下 Pod 从创建到最终 Running 背后发生的事情，其中有些细节没有展开，
后面再补充或者另写一些文章说一下那些没展开的内容。</p>
</div>
<div class="section" id="id4">
<h2 id="hidid4">参考资料<a class="headerlink" href="#hidid4" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://github.com/kubernetes/kubernetes/tree/v1.21.3">kubernetes/kubernetes at v1.21.3</a></li>
<li><a class="reference external" href="https://kubernetes.io/docs/home/">Kubernetes Documentation | Kubernetes</a></li>
</ul>
</div>

                </div>
            </div>
            <!-- /.entry-content -->
<section class="text-center">
  
<div id="donate"></div>

<div class="social-share"></div>
<div class="social-comment-note">
<p>有任何建议和想法欢迎在下方评论区留言或者加我<a href="/static/wechat.png">微信</a>交流</p>
</div>

</section>
<section class="well" id="related-posts">
    <p>Related Posts:</p>
    <ul>
        <li><a href="https://mozillazg.com/2020/06/kubernetes-k8s-too-many-service-environment-variables-cause-pod-container-start-bash-too-slow.html">太多的 service 信息环境变量可能会导致容器中执行 bash 命令特别的慢</a></li>
        <li><a href="https://mozillazg.com/2021/06/k8s-kubernetes-rbac-rules-use-star-wildcard.html">在 Kubernetes RBAC Role/ClusterRole 规则中使用通配符 *</a></li>
        <li><a href="https://mozillazg.com/2020/05/k8s-kubernetes-use-which-psp-when-there-are-multiple-pod-security-policies.html">当有多个可用的 Pod Security Policy 时 k8s 的 PSP 选择策略</a></li>
        <li><a href="https://mozillazg.com/2020/06/k8s-kubernetes-kubectl-syntax-of-impersonate-as-user-or-serviceaccount-or-group.html">kubernetes 用户扮演 API</a></li>
        <li><a href="https://mozillazg.com/2021/07/introduce-echo-k8s-webhook-project.html">echo-k8s-webhook: 记录 k8s Admission Webhook 的请求内容</a></li>
    </ul>
</section>
    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'my-github-blog'; // required: replace example with your forum shortname

                    var disqus_identifier = 'k8s-kubernetes-what-happen-when-pod-from-create-to-running';
                var disqus_url = 'https://mozillazg.com/2021/07/k8s-kubernetes-what-happen-when-pod-from-create-to-running.html';

            var disqus_config = function () {
                this.language = "zh";
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2022 mozillazg
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>
            &middot; <a href="/privacy-policy.html" target="_blank">Privacy</a>              <p><small>  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/static/images/by-sa-80x15.png" /></a>
    &quot;<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">mozillazg's Blog</span>&quot; by <a xmlns:cc="http://creativecommons.org/ns#" href="https://mozillazg.com" property="cc:attributionName" rel="cc:attributionURL">mozillazg</a> is
  licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="https://cdn.jsdelivr.net/npm/jquery@2.1.1/dist/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->

    <!-- Disqus -->
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'my-github-blog'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script');
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <!-- End Disqus Code -->
    <!-- Google Analytics Universal -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-77172981-1', 'auto');
        ga('send', 'pageview');
    </script>
    <!-- End Google Analytics Universal Code -->

<!-- share.js -->
<script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>



<script src="https://cdn.jsdelivr.net/npm/tocbot@3.0.2/dist/tocbot.min.js"></script>
<script>
$(document).ready(function(){
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.js-toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.entry-content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h2, h3, h4,h5',
    // Headings that match the ignoreSelector will be skipped.
    ignoreSelector: '.js-toc-ignore',
    // Main class to add to links.
    linkClass: 'toc-link',
    // Extra classes to add to links.
    extraLinkClasses: '',
    // Class to add to active links,
    // the link corresponding to the top most heading on the page.
    activeLinkClass: 'is-active-link',
    // Main class to add to lists.
    listClass: 'toc-list',
    // Extra classes to add to lists.
    extraListClasses: '',
    // Class that gets added when a list should be collapsed.
    isCollapsedClass: 'is-collapsed',
    // Class that gets added when a list should be able
    // to be collapsed but isn't necessarily collpased.
    collapsibleClass: 'is-collapsible',
    // Class to add to list items.
    listItemClass: 'toc-list-item',
    // How many heading levels should not be collpased.
    // For example, number 6 will show everything since
    // there are only 6 heading levels and number 0 will collpase them all.
    // The sections that are hidden will open
    // and close as you scroll to headings within them.
    collapseDepth: 6,
    // Smooth scrolling enabled.
    smoothScroll: true,
    // Smooth scroll duration.
    smoothScrollDuration: 420,
    // Callback for scroll end (requires: smoothScroll).
    scrollEndCallback: function (e) {},
    // Headings offset between the headings and the top of the document (this is meant for minor adjustments).
    headingsOffset: 0,
    // Timeout between events firing to make sure it's
    // not too rapid (for performance reasons).
    throttleTimeout: 50,
    // Element to add the positionFixedClass to.
    positionFixedSelector: null,
    // Fixed position class to add to make sidebar fixed after scrolling
    // down past the fixedSidebarOffset.
    positionFixedClass: 'is-position-fixed',
    // fixedSidebarOffset can be any number but by default is set
    // to auto which sets the fixedSidebarOffset to the sidebar
    // element's offsetTop from the top of the document on init.
    fixedSidebarOffset: 'auto',
    // includeHtml can be set to true to include the HTML markup from the
    // heading node instead of just including the textContent.
    includeHtml: false
  });
});
</script>
</body>
</html>