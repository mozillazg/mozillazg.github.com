<!DOCTYPE html>
<html lang="en"  prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml" class="han-init">
<head>
    <title>The Difference Between Container Privileged Mode and Non-Privileged Mode - mozillazg's Blog</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- share.css -->
    <link rel="stylesheet" href="/theme/cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">


    <link href="https://mozillazg.com/favicon.ico" rel="icon">

<link rel="canonical" href="https://mozillazg.com/2021/11/docker-container-difference-between-privileged-mode-and-non-privileged-mode-en.html">

        <meta name="author" content="mozillazg" />
        <meta name="keywords" content="container,privileged,security,en-version" />
    <meta name="description" content="Introduction This article aims to explore the differences between privileged and non-privileged modes in containers, focusing on identifying scenarios where the privileged mode is essential for fulfilling specific business needs. Privileged Mode The description of privileged mode in the CRI(Container Runtime Interface) is outlined as follows: // If set, run container in privileged mode. // Privileged mode is incompatible with the following options. If // privileged is set, the following features MAY have no effect: // 1. capabilities // 2. selinux_options // 4. seccomp // 5. apparmor // // Privileged mode implies the following specific options are applied: // 1. All capabilities are added. // 2. Sensitive paths, such as kernel module paths within sysfs, are not masked. // 3. Any sysfs and procfs mounts are mounted RW. // 4. AppArmor confinement is not applied. // 5. Seccomp restrictions are not applied. // 6. The device cgroup does not restrict access to any devices. // 7. All devices from the host&#39;s /dev are available within the container. // 8. SELinux restrictions are not applied (e.g. label=disabled). Next, let&#39;s delve into each item&#39;s effect through illustrative examples. All capabilities are added In the standard mode, the processes inside a container are restricted to a limited set of Linux capabilities. $ docker run --rm -it r.j3ss.co/amicontained bash Capabilities: BOUNDING -&gt; chown dac_override fowner fsetid kill setgid setuid setpcap net_bind_service net_raw sys_chroot mknod audit_write setfcap On the other hand, processes inside containers operating in privileged mode have access to all Linux capabilities. $ docker run --privileged --rm -it r.j3ss.co/amicontained bash Capabilities: BOUNDING -&gt; chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read Similarly, in the standard mode, one can replicate these needs by manually adjusting the --cap-add parameter. $ docker run --cap-add=ALL --rm -it r.j3ss.co/amicontained bash Capabilities: BOUNDING -&gt; chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read By the way, while processes within a container in privileged mode have the ability to utilize all Linux capabilities, this doesn&#39;t automatically grant them permission for certain actions. For instance, if a container is initiated with a non-root user, even in privileged mode, it doesn&#39;t necessarily allow it to perform actions that are otherwise unauthorized. $ docker run --rm -it debian:buster chown 65534 /var/log/lastlog $ docker run -u 65534 --rm -it debian:buster chown 65534 /var/log/lastlog chown: changing ownership of &#39;/var/log/lastlog&#39;: Operation not permitted $ docker run --privileged -u 65534 --rm -it debian:buster chown 65534 /var/log/lastlog chown: changing ownership of &#39;/var/log/lastlog&#39;: Operation not permitted Sensitive paths, such as kernel module paths within sysfs, are not masked. In standard mode, access to certain kernel module paths, like specific directories under /proc, is selectively restricted. Some are write-protected, while others allow read and write operations. To address this, these directories are mounted into the container using the tmpfs filesystem, facilitating the implementation of directory masking. $ docker run --rm -it debian:buster mount |grep &#39;/proc.*tmpfs&#39; tmpfs on /proc/acpi type tmpfs (ro,relatime) tmpfs on /proc/kcore type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/keys type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/timer_list type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/sched_debug type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/scsi type tmpfs (ro,relatime) Under privileged mode, these directories are no longer mounted using the tmpfs filesystem approach. $ docker run --privileged --rm -it debian:buster mount |grep &#39;/proc.*tmpfs&#39; $ Any sysfs and procfs mounts are mounted RW. In standard mode, certain kernel file systems, such as sysfs and procfs, are mounted inside the container as read-only. This is to prevent processes within the container from making unauthorized changes to the system kernel. $ docker run --rm -it debian:buster mount |grep &#39;(ro&#39; sysfs on /sys type sysfs (ro,nosuid,nodev,noexec,relatime) cgroup on /sys/fs/cgroup/systemd type cgroup (ro,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd) cgroup on /sys/fs/cgroup/memory type cgroup (ro,nosuid,nodev,noexec,relatime,memory) cgroup on /sys/fs/cgroup/rdma type cgroup (ro,nosuid,nodev,noexec,relatime,rdma) cgroup on /sys/fs/cgroup/cpuset type cgroup (ro,nosuid,nodev,noexec,relatime,cpuset) cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (ro,nosuid,nodev,noexec,relatime,net_cls,net_prio) cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (ro,nosuid,nodev,noexec,relatime,cpu,cpuacct) cgroup on /sys/fs/cgroup/hugetlb type cgroup (ro,nosuid,nodev,noexec,relatime,hugetlb) cgroup on /sys/fs/cgroup/freezer type cgroup (ro,nosuid,nodev,noexec,relatime,freezer) cgroup on /sys/fs/cgroup/blkio type cgroup (ro,nosuid,nodev,noexec,relatime,blkio) cgroup on /sys/fs/cgroup/perf_event type cgroup (ro,nosuid,nodev,noexec,relatime,perf_event) cgroup on /sys/fs/cgroup/devices type cgroup (ro,nosuid,nodev,noexec,relatime,devices) cgroup on /sys/fs/cgroup/pids type cgroup (ro,nosuid,nodev,noexec,relatime,pids) proc on /proc/bus type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/fs type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/irq type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/sys type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/sysrq-trigger type proc (ro,nosuid,nodev,noexec,relatime) tmpfs on /proc/acpi type tmpfs (ro,relatime) tmpfs on /proc/scsi type tmpfs (ro,relatime) tmpfs on /sys/firmware type tmpfs (ro,relatime) In contrast, under privileged mode, these kernel file systems are not mounted as read-only. $ docker run --privileged --rm -it debian:buster mount |grep &#39;(ro&#39; $ AppArmor confinement is not applied. Seccomp restrictions are not applied. In standard mode, containers can be secured by setting up AppArmor or Seccomp security options. If these are not configured manually, the container engine typically activates certain default configurations for enhanced security. $ docker run --rm -it r.j3ss.co/amicontained bash AppArmor Profile: unconfined Seccomp: filtering Blocked Syscalls (63): MSGRCV SYSLOG SETPGID SETSID USELIB USTAT SYSFS VHANGUP PIVOT_ROOT _SYSCTL ACCT SETTIMEOFDAY MOUNT UMOUNT2 SWAPON SWAPOFF REBOOT SETHOSTNAME SETDOMAINNAME IOPL IOPERM CREATE_MODULE INIT_MODULE DELETE_MODULE GET_KERNEL_SYMS QUERY_MODULE QUOTACTL NFSSERVCTL GETPMSG PUTPMSG AFS_SYSCALL TUXCALL SECURITY LOOKUP_DCOOKIE CLOCK_SETTIME VSERVER MBIND SET_MEMPOLICY GET_MEMPOLICY KEXEC_LOAD ADD_KEY REQUEST_KEY KEYCTL MIGRATE_PAGES UNSHARE MOVE_PAGES PERF_EVENT_OPEN FANOTIFY_INIT NAME_TO_HANDLE_AT OPEN_BY_HANDLE_AT SETNS PROCESS_VM_READV PROCESS_VM_WRITEV KCMP FINIT_MODULE KEXEC_FILE_LOAD BPF USERFAULTFD PREADV2 PWRITEV2 PKEY_MPROTECT PKEY_ALLOC PKEY_FREE However, in privileged mode, these AppArmor or Seccomp configurations become ineffective. $ docker run --privileged --rm -it r.j3ss.co/amicontained bash AppArmor Profile: unconfined Seccomp: disabled Additionally, in standard mode, AppArmor or Seccomp features can be disabled using their respective security settings. The device cgroup does not restrict access to any devices. Under the default mode, operations on cgroup are limited to read-only access. $ docker run --rm -it debian:buster mount | grep &#39;cgroup&#39; tmpfs on /sys/fs/cgroup type tmpfs (rw,nosuid,nodev,noexec,relatime,mode=755) cgroup on /sys/fs/cgroup/systemd type cgroup (ro,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd) cgroup on /sys/fs/cgroup/memory type cgroup (ro,nosuid,nodev,noexec,relatime,memory) cgroup on /sys/fs/cgroup/rdma type cgroup (ro,nosuid,nodev,noexec,relatime,rdma) cgroup on /sys/fs/cgroup/cpuset type cgroup (ro,nosuid,nodev,noexec,relatime,cpuset) cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (ro,nosuid,nodev,noexec,relatime,net_cls,net_prio) cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (ro,nosuid,nodev,noexec,relatime,cpu,cpuacct) cgroup on /sys/fs/cgroup/hugetlb type cgroup (ro,nosuid,nodev,noexec,relatime,hugetlb) cgroup on /sys/fs/cgroup/freezer type cgroup (ro,nosuid,nodev,noexec,relatime,freezer) cgroup on /sys/fs/cgroup/blkio type cgroup (ro,nosuid,nodev,noexec,relatime,blkio) cgroup on /sys/fs/cgroup/perf_event type cgroup (ro,nosuid,nodev,noexec,relatime,perf_event) cgroup on /sys/fs/cgroup/devices type cgroup (ro,nosuid,nodev,noexec,relatime,devices) cgroup on /sys/fs/cgroup/pids type cgroup (ro,nosuid,nodev,noexec,relatime,pids) In contrast, privileged mode allows for both read and write operations on cgroup. $ docker run --privileged --rm -it debian:buster mount | grep &#39;cgroup&#39; tmpfs on /sys/fs/cgroup type tmpfs (rw,nosuid,nodev,noexec,relatime,mode=755) cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd) cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory) cgroup on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma) cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset) cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio) cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct) cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb) cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer) cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio) cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event) cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices) cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids) All devices from the host&#39;s /dev are available within the container. In standard mode, the device nodes unique to the /dev directory are not visible within the container&#39;s /dev directory. # docker run --rm -it debian:buster ls /dev console fd mqueue ptmx random stderr stdout urandom core full null pts shm stdin tty zero However, in privileged mode, the container&#39;s /dev directory includes these specific contents from the node&#39;s /dev directory. $ docker run --privileged --rm -it debian:buster ls /dev autofs mapper stdin tty25 tty44 tty63 vcsa1 btrfs-control mcelog stdout tty26 tty45 tty7 vcsa2 bus mem tty tty27 tty46 tty8 vcsa3 console memory_bandwidth tty0 tty28 tty47 tty9 vcsa4 core mqueue tty1 tty29 tty48 ttyS0 vcsa5 cpu net tty10 tty3 tty49 ttyS1 vcsa6 cpu_dma_latency network_latency tty11 tty30 tty5 ttyS2 vcsu cuse network_throughput tty12 tty31 tty50 ttyS3 vcsu1 dri null tty13 tty32 tty51 uhid vcsu2 fb0 nvram tty14 tty33 tty52 uinput vcsu3 fd port tty15 tty34 tty53 urandom vcsu4 full ppp tty16 tty35 tty54 usbmon0 vcsu5 fuse ptmx tty17 tty36 tty55 usbmon1 vcsu6 hidraw0 ptp0 tty18 tty37 tty56 vcs vda hpet pts tty19 tty38 tty57 vcs1 vda1 hwrng random tty2 tty39 tty58 vcs2 vfio infiniband raw tty20 tty4 tty59 vcs3 vga_arbiter input rtc0 tty21 tty40 tty6 vcs4 vhost-net kmsg shm tty22 tty41 tty60 vcs5 vhost-vsock lightnvm snapshot tty23 tty42 tty61 vcs6 zero loop-control stderr tty24 tty43 tty62 vcsa SELinux restrictions are not applied (e.g. label=disabled). In privileged mode, security hardening configurations related to SELinux are disabled. Similarly, in standard mode, SELinux features can be turned off using the appropriate security settings. References kubernetes/cri-api: Container Runtime Interface (CRI) – a plugin interface which enables kubelet to use a wide variety of container runtimes. capabilities(7) - Linux manual page Docker run reference | Docker Documentation" />

    <style>
      .js-toc {
        margin-bottom: 20px;
      }
      .donate-modal {
        text-align: center;
      }
      #donate-modal-container .donate-image {
        max-height: 300px !important;
        min-height: inherit !important;
      }
    </style>

        <meta property="og:site_name" content="mozillazg's Blog" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="The Difference Between Container Privileged Mode and Non-Privileged Mode"/>
        <meta property="og:url" content="https://mozillazg.com/2021/11/docker-container-difference-between-privileged-mode-and-non-privileged-mode-en.html"/>
        <meta property="og:description" content="Introduction This article aims to explore the differences between privileged and non-privileged modes in containers, focusing on identifying scenarios where the privileged mode is essential for fulfilling specific business needs. Privileged Mode The description of privileged mode in the CRI(Container Runtime Interface) is outlined as follows: // If set, run container in privileged mode. // Privileged mode is incompatible with the following options. If // privileged is set, the following features MAY have no effect: // 1. capabilities // 2. selinux_options // 4. seccomp // 5. apparmor // // Privileged mode implies the following specific options are applied: // 1. All capabilities are added. // 2. Sensitive paths, such as kernel module paths within sysfs, are not masked. // 3. Any sysfs and procfs mounts are mounted RW. // 4. AppArmor confinement is not applied. // 5. Seccomp restrictions are not applied. // 6. The device cgroup does not restrict access to any devices. // 7. All devices from the host&#39;s /dev are available within the container. // 8. SELinux restrictions are not applied (e.g. label=disabled). Next, let&#39;s delve into each item&#39;s effect through illustrative examples. All capabilities are added In the standard mode, the processes inside a container are restricted to a limited set of Linux capabilities. $ docker run --rm -it r.j3ss.co/amicontained bash Capabilities: BOUNDING -&gt; chown dac_override fowner fsetid kill setgid setuid setpcap net_bind_service net_raw sys_chroot mknod audit_write setfcap On the other hand, processes inside containers operating in privileged mode have access to all Linux capabilities. $ docker run --privileged --rm -it r.j3ss.co/amicontained bash Capabilities: BOUNDING -&gt; chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read Similarly, in the standard mode, one can replicate these needs by manually adjusting the --cap-add parameter. $ docker run --cap-add=ALL --rm -it r.j3ss.co/amicontained bash Capabilities: BOUNDING -&gt; chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read By the way, while processes within a container in privileged mode have the ability to utilize all Linux capabilities, this doesn&#39;t automatically grant them permission for certain actions. For instance, if a container is initiated with a non-root user, even in privileged mode, it doesn&#39;t necessarily allow it to perform actions that are otherwise unauthorized. $ docker run --rm -it debian:buster chown 65534 /var/log/lastlog $ docker run -u 65534 --rm -it debian:buster chown 65534 /var/log/lastlog chown: changing ownership of &#39;/var/log/lastlog&#39;: Operation not permitted $ docker run --privileged -u 65534 --rm -it debian:buster chown 65534 /var/log/lastlog chown: changing ownership of &#39;/var/log/lastlog&#39;: Operation not permitted Sensitive paths, such as kernel module paths within sysfs, are not masked. In standard mode, access to certain kernel module paths, like specific directories under /proc, is selectively restricted. Some are write-protected, while others allow read and write operations. To address this, these directories are mounted into the container using the tmpfs filesystem, facilitating the implementation of directory masking. $ docker run --rm -it debian:buster mount |grep &#39;/proc.*tmpfs&#39; tmpfs on /proc/acpi type tmpfs (ro,relatime) tmpfs on /proc/kcore type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/keys type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/timer_list type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/sched_debug type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/scsi type tmpfs (ro,relatime) Under privileged mode, these directories are no longer mounted using the tmpfs filesystem approach. $ docker run --privileged --rm -it debian:buster mount |grep &#39;/proc.*tmpfs&#39; $ Any sysfs and procfs mounts are mounted RW. In standard mode, certain kernel file systems, such as sysfs and procfs, are mounted inside the container as read-only. This is to prevent processes within the container from making unauthorized changes to the system kernel. $ docker run --rm -it debian:buster mount |grep &#39;(ro&#39; sysfs on /sys type sysfs (ro,nosuid,nodev,noexec,relatime) cgroup on /sys/fs/cgroup/systemd type cgroup (ro,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd) cgroup on /sys/fs/cgroup/memory type cgroup (ro,nosuid,nodev,noexec,relatime,memory) cgroup on /sys/fs/cgroup/rdma type cgroup (ro,nosuid,nodev,noexec,relatime,rdma) cgroup on /sys/fs/cgroup/cpuset type cgroup (ro,nosuid,nodev,noexec,relatime,cpuset) cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (ro,nosuid,nodev,noexec,relatime,net_cls,net_prio) cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (ro,nosuid,nodev,noexec,relatime,cpu,cpuacct) cgroup on /sys/fs/cgroup/hugetlb type cgroup (ro,nosuid,nodev,noexec,relatime,hugetlb) cgroup on /sys/fs/cgroup/freezer type cgroup (ro,nosuid,nodev,noexec,relatime,freezer) cgroup on /sys/fs/cgroup/blkio type cgroup (ro,nosuid,nodev,noexec,relatime,blkio) cgroup on /sys/fs/cgroup/perf_event type cgroup (ro,nosuid,nodev,noexec,relatime,perf_event) cgroup on /sys/fs/cgroup/devices type cgroup (ro,nosuid,nodev,noexec,relatime,devices) cgroup on /sys/fs/cgroup/pids type cgroup (ro,nosuid,nodev,noexec,relatime,pids) proc on /proc/bus type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/fs type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/irq type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/sys type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/sysrq-trigger type proc (ro,nosuid,nodev,noexec,relatime) tmpfs on /proc/acpi type tmpfs (ro,relatime) tmpfs on /proc/scsi type tmpfs (ro,relatime) tmpfs on /sys/firmware type tmpfs (ro,relatime) In contrast, under privileged mode, these kernel file systems are not mounted as read-only. $ docker run --privileged --rm -it debian:buster mount |grep &#39;(ro&#39; $ AppArmor confinement is not applied. Seccomp restrictions are not applied. In standard mode, containers can be secured by setting up AppArmor or Seccomp security options. If these are not configured manually, the container engine typically activates certain default configurations for enhanced security. $ docker run --rm -it r.j3ss.co/amicontained bash AppArmor Profile: unconfined Seccomp: filtering Blocked Syscalls (63): MSGRCV SYSLOG SETPGID SETSID USELIB USTAT SYSFS VHANGUP PIVOT_ROOT _SYSCTL ACCT SETTIMEOFDAY MOUNT UMOUNT2 SWAPON SWAPOFF REBOOT SETHOSTNAME SETDOMAINNAME IOPL IOPERM CREATE_MODULE INIT_MODULE DELETE_MODULE GET_KERNEL_SYMS QUERY_MODULE QUOTACTL NFSSERVCTL GETPMSG PUTPMSG AFS_SYSCALL TUXCALL SECURITY LOOKUP_DCOOKIE CLOCK_SETTIME VSERVER MBIND SET_MEMPOLICY GET_MEMPOLICY KEXEC_LOAD ADD_KEY REQUEST_KEY KEYCTL MIGRATE_PAGES UNSHARE MOVE_PAGES PERF_EVENT_OPEN FANOTIFY_INIT NAME_TO_HANDLE_AT OPEN_BY_HANDLE_AT SETNS PROCESS_VM_READV PROCESS_VM_WRITEV KCMP FINIT_MODULE KEXEC_FILE_LOAD BPF USERFAULTFD PREADV2 PWRITEV2 PKEY_MPROTECT PKEY_ALLOC PKEY_FREE However, in privileged mode, these AppArmor or Seccomp configurations become ineffective. $ docker run --privileged --rm -it r.j3ss.co/amicontained bash AppArmor Profile: unconfined Seccomp: disabled Additionally, in standard mode, AppArmor or Seccomp features can be disabled using their respective security settings. The device cgroup does not restrict access to any devices. Under the default mode, operations on cgroup are limited to read-only access. $ docker run --rm -it debian:buster mount | grep &#39;cgroup&#39; tmpfs on /sys/fs/cgroup type tmpfs (rw,nosuid,nodev,noexec,relatime,mode=755) cgroup on /sys/fs/cgroup/systemd type cgroup (ro,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd) cgroup on /sys/fs/cgroup/memory type cgroup (ro,nosuid,nodev,noexec,relatime,memory) cgroup on /sys/fs/cgroup/rdma type cgroup (ro,nosuid,nodev,noexec,relatime,rdma) cgroup on /sys/fs/cgroup/cpuset type cgroup (ro,nosuid,nodev,noexec,relatime,cpuset) cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (ro,nosuid,nodev,noexec,relatime,net_cls,net_prio) cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (ro,nosuid,nodev,noexec,relatime,cpu,cpuacct) cgroup on /sys/fs/cgroup/hugetlb type cgroup (ro,nosuid,nodev,noexec,relatime,hugetlb) cgroup on /sys/fs/cgroup/freezer type cgroup (ro,nosuid,nodev,noexec,relatime,freezer) cgroup on /sys/fs/cgroup/blkio type cgroup (ro,nosuid,nodev,noexec,relatime,blkio) cgroup on /sys/fs/cgroup/perf_event type cgroup (ro,nosuid,nodev,noexec,relatime,perf_event) cgroup on /sys/fs/cgroup/devices type cgroup (ro,nosuid,nodev,noexec,relatime,devices) cgroup on /sys/fs/cgroup/pids type cgroup (ro,nosuid,nodev,noexec,relatime,pids) In contrast, privileged mode allows for both read and write operations on cgroup. $ docker run --privileged --rm -it debian:buster mount | grep &#39;cgroup&#39; tmpfs on /sys/fs/cgroup type tmpfs (rw,nosuid,nodev,noexec,relatime,mode=755) cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd) cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory) cgroup on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma) cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset) cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio) cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct) cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb) cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer) cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio) cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event) cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices) cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids) All devices from the host&#39;s /dev are available within the container. In standard mode, the device nodes unique to the /dev directory are not visible within the container&#39;s /dev directory. # docker run --rm -it debian:buster ls /dev console fd mqueue ptmx random stderr stdout urandom core full null pts shm stdin tty zero However, in privileged mode, the container&#39;s /dev directory includes these specific contents from the node&#39;s /dev directory. $ docker run --privileged --rm -it debian:buster ls /dev autofs mapper stdin tty25 tty44 tty63 vcsa1 btrfs-control mcelog stdout tty26 tty45 tty7 vcsa2 bus mem tty tty27 tty46 tty8 vcsa3 console memory_bandwidth tty0 tty28 tty47 tty9 vcsa4 core mqueue tty1 tty29 tty48 ttyS0 vcsa5 cpu net tty10 tty3 tty49 ttyS1 vcsa6 cpu_dma_latency network_latency tty11 tty30 tty5 ttyS2 vcsu cuse network_throughput tty12 tty31 tty50 ttyS3 vcsu1 dri null tty13 tty32 tty51 uhid vcsu2 fb0 nvram tty14 tty33 tty52 uinput vcsu3 fd port tty15 tty34 tty53 urandom vcsu4 full ppp tty16 tty35 tty54 usbmon0 vcsu5 fuse ptmx tty17 tty36 tty55 usbmon1 vcsu6 hidraw0 ptp0 tty18 tty37 tty56 vcs vda hpet pts tty19 tty38 tty57 vcs1 vda1 hwrng random tty2 tty39 tty58 vcs2 vfio infiniband raw tty20 tty4 tty59 vcs3 vga_arbiter input rtc0 tty21 tty40 tty6 vcs4 vhost-net kmsg shm tty22 tty41 tty60 vcs5 vhost-vsock lightnvm snapshot tty23 tty42 tty61 vcs6 zero loop-control stderr tty24 tty43 tty62 vcsa SELinux restrictions are not applied (e.g. label=disabled). In privileged mode, security hardening configurations related to SELinux are disabled. Similarly, in standard mode, SELinux features can be turned off using the appropriate security settings. References kubernetes/cri-api: Container Runtime Interface (CRI) – a plugin interface which enables kubelet to use a wide variety of container runtimes. capabilities(7) - Linux manual page Docker run reference | Docker Documentation"/>
        <meta property="article:published_time" content="2021-11-21" />
            <meta property="article:section" content="container" />
            <meta property="article:tag" content="container" />
            <meta property="article:tag" content="privileged" />
            <meta property="article:tag" content="security" />
            <meta property="article:tag" content="en-version" />
            <meta property="article:author" content="mozillazg" />
            <meta property="og:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>


    <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@mozillazg">
        <meta name="twitter:creator" content="@mozillazg">
    <meta name="twitter:domain" content="https://mozillazg.com">
            <meta property="twitter:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="/theme/cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/css/bootstrap.min.css" type="text/css"/>
    <link href="/theme/cdn.jsdelivr.net/npm/font-awesome@4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link href="/theme/cdn.jsdelivr.net/npm/pygments-css@1.0.0/github.css" rel="stylesheet">
    <link rel="stylesheet" href="https://mozillazg.com/theme/css/style.css" type="text/css"/>
            <link href="/static/han.min.css" rel="stylesheet">
            <link href="/static/yue.css" rel="stylesheet">
            <link href="/static/custom.css" rel="stylesheet">

        <link href="https://mozillazg.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog ATOM Feed"/>

        <link href="https://mozillazg.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="mozillazg's Blog RSS Feed"/>


        <link href="https://mozillazg.com/feeds/container.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog container ATOM Feed"/>


    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "publisher": {
            "@type": "Person",
            "name": "mozillazg",
            "logo": "https://mozillazg.com/static/avatar.jpeg"
        },
        "author": {
            "@type": "Person",
            "name": "mozillazg",
            "image": "https://mozillazg.com/static/avatar.jpeg",
            "url": "https://mozillazg.com",
            "sameAs": []
        },
        "headline": "The Difference Between Container Privileged Mode and Non-Privileged Mode",
        "url": "https://mozillazg.com/2021/11/docker-container-difference-between-privileged-mode-and-non-privileged-mode-en.html",
        "image": [
            "https://mozillazg.com/static/avatar.jpeg"
         ],
        "keywords": "container, privileged, security, en-version",
        "description": "Introduction This article aims to explore the differences between privileged and non-privileged modes in containers, focusing on identifying scenarios where the privileged mode is essential for fulfilling specific business needs. Privileged Mode The description of privileged mode in the CRI(Container Runtime Interface) is outlined as follows: // If set, run container in privileged mode. // Privileged mode is incompatible with the following options. If // privileged is set, the following features MAY have no effect: // 1. capabilities // 2. selinux_options // 4. seccomp // 5. apparmor // // Privileged mode implies the following specific options are applied: // 1. All capabilities are added. // 2. Sensitive paths, such as kernel module paths within sysfs, are not masked. // 3. Any sysfs and procfs mounts are mounted RW. // 4. AppArmor confinement is not applied. // 5. Seccomp restrictions are not applied. // 6. The device cgroup does not restrict access to any devices. // 7. All devices from the host&#39;s /dev are available within the container. // 8. SELinux restrictions are not applied (e.g. label=disabled). Next, let&#39;s delve into each item&#39;s effect through illustrative examples. All capabilities are added In the standard mode, the processes inside a container are restricted to a limited set of Linux capabilities. $ docker run --rm -it r.j3ss.co/amicontained bash Capabilities: BOUNDING -&gt; chown dac_override fowner fsetid kill setgid setuid setpcap net_bind_service net_raw sys_chroot mknod audit_write setfcap On the other hand, processes inside containers operating in privileged mode have access to all Linux capabilities. $ docker run --privileged --rm -it r.j3ss.co/amicontained bash Capabilities: BOUNDING -&gt; chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read Similarly, in the standard mode, one can replicate these needs by manually adjusting the --cap-add parameter. $ docker run --cap-add=ALL --rm -it r.j3ss.co/amicontained bash Capabilities: BOUNDING -&gt; chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read By the way, while processes within a container in privileged mode have the ability to utilize all Linux capabilities, this doesn&#39;t automatically grant them permission for certain actions. For instance, if a container is initiated with a non-root user, even in privileged mode, it doesn&#39;t necessarily allow it to perform actions that are otherwise unauthorized. $ docker run --rm -it debian:buster chown 65534 /var/log/lastlog $ docker run -u 65534 --rm -it debian:buster chown 65534 /var/log/lastlog chown: changing ownership of &#39;/var/log/lastlog&#39;: Operation not permitted $ docker run --privileged -u 65534 --rm -it debian:buster chown 65534 /var/log/lastlog chown: changing ownership of &#39;/var/log/lastlog&#39;: Operation not permitted Sensitive paths, such as kernel module paths within sysfs, are not masked. In standard mode, access to certain kernel module paths, like specific directories under /proc, is selectively restricted. Some are write-protected, while others allow read and write operations. To address this, these directories are mounted into the container using the tmpfs filesystem, facilitating the implementation of directory masking. $ docker run --rm -it debian:buster mount |grep &#39;/proc.*tmpfs&#39; tmpfs on /proc/acpi type tmpfs (ro,relatime) tmpfs on /proc/kcore type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/keys type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/timer_list type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/sched_debug type tmpfs (rw,nosuid,size=65536k,mode=755) tmpfs on /proc/scsi type tmpfs (ro,relatime) Under privileged mode, these directories are no longer mounted using the tmpfs filesystem approach. $ docker run --privileged --rm -it debian:buster mount |grep &#39;/proc.*tmpfs&#39; $ Any sysfs and procfs mounts are mounted RW. In standard mode, certain kernel file systems, such as sysfs and procfs, are mounted inside the container as read-only. This is to prevent processes within the container from making unauthorized changes to the system kernel. $ docker run --rm -it debian:buster mount |grep &#39;(ro&#39; sysfs on /sys type sysfs (ro,nosuid,nodev,noexec,relatime) cgroup on /sys/fs/cgroup/systemd type cgroup (ro,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd) cgroup on /sys/fs/cgroup/memory type cgroup (ro,nosuid,nodev,noexec,relatime,memory) cgroup on /sys/fs/cgroup/rdma type cgroup (ro,nosuid,nodev,noexec,relatime,rdma) cgroup on /sys/fs/cgroup/cpuset type cgroup (ro,nosuid,nodev,noexec,relatime,cpuset) cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (ro,nosuid,nodev,noexec,relatime,net_cls,net_prio) cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (ro,nosuid,nodev,noexec,relatime,cpu,cpuacct) cgroup on /sys/fs/cgroup/hugetlb type cgroup (ro,nosuid,nodev,noexec,relatime,hugetlb) cgroup on /sys/fs/cgroup/freezer type cgroup (ro,nosuid,nodev,noexec,relatime,freezer) cgroup on /sys/fs/cgroup/blkio type cgroup (ro,nosuid,nodev,noexec,relatime,blkio) cgroup on /sys/fs/cgroup/perf_event type cgroup (ro,nosuid,nodev,noexec,relatime,perf_event) cgroup on /sys/fs/cgroup/devices type cgroup (ro,nosuid,nodev,noexec,relatime,devices) cgroup on /sys/fs/cgroup/pids type cgroup (ro,nosuid,nodev,noexec,relatime,pids) proc on /proc/bus type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/fs type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/irq type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/sys type proc (ro,nosuid,nodev,noexec,relatime) proc on /proc/sysrq-trigger type proc (ro,nosuid,nodev,noexec,relatime) tmpfs on /proc/acpi type tmpfs (ro,relatime) tmpfs on /proc/scsi type tmpfs (ro,relatime) tmpfs on /sys/firmware type tmpfs (ro,relatime) In contrast, under privileged mode, these kernel file systems are not mounted as read-only. $ docker run --privileged --rm -it debian:buster mount |grep &#39;(ro&#39; $ AppArmor confinement is not applied. Seccomp restrictions are not applied. In standard mode, containers can be secured by setting up AppArmor or Seccomp security options. If these are not configured manually, the container engine typically activates certain default configurations for enhanced security. $ docker run --rm -it r.j3ss.co/amicontained bash AppArmor Profile: unconfined Seccomp: filtering Blocked Syscalls (63): MSGRCV SYSLOG SETPGID SETSID USELIB USTAT SYSFS VHANGUP PIVOT_ROOT _SYSCTL ACCT SETTIMEOFDAY MOUNT UMOUNT2 SWAPON SWAPOFF REBOOT SETHOSTNAME SETDOMAINNAME IOPL IOPERM CREATE_MODULE INIT_MODULE DELETE_MODULE GET_KERNEL_SYMS QUERY_MODULE QUOTACTL NFSSERVCTL GETPMSG PUTPMSG AFS_SYSCALL TUXCALL SECURITY LOOKUP_DCOOKIE CLOCK_SETTIME VSERVER MBIND SET_MEMPOLICY GET_MEMPOLICY KEXEC_LOAD ADD_KEY REQUEST_KEY KEYCTL MIGRATE_PAGES UNSHARE MOVE_PAGES PERF_EVENT_OPEN FANOTIFY_INIT NAME_TO_HANDLE_AT OPEN_BY_HANDLE_AT SETNS PROCESS_VM_READV PROCESS_VM_WRITEV KCMP FINIT_MODULE KEXEC_FILE_LOAD BPF USERFAULTFD PREADV2 PWRITEV2 PKEY_MPROTECT PKEY_ALLOC PKEY_FREE However, in privileged mode, these AppArmor or Seccomp configurations become ineffective. $ docker run --privileged --rm -it r.j3ss.co/amicontained bash AppArmor Profile: unconfined Seccomp: disabled Additionally, in standard mode, AppArmor or Seccomp features can be disabled using their respective security settings. The device cgroup does not restrict access to any devices. Under the default mode, operations on cgroup are limited to read-only access. $ docker run --rm -it debian:buster mount | grep &#39;cgroup&#39; tmpfs on /sys/fs/cgroup type tmpfs (rw,nosuid,nodev,noexec,relatime,mode=755) cgroup on /sys/fs/cgroup/systemd type cgroup (ro,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd) cgroup on /sys/fs/cgroup/memory type cgroup (ro,nosuid,nodev,noexec,relatime,memory) cgroup on /sys/fs/cgroup/rdma type cgroup (ro,nosuid,nodev,noexec,relatime,rdma) cgroup on /sys/fs/cgroup/cpuset type cgroup (ro,nosuid,nodev,noexec,relatime,cpuset) cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (ro,nosuid,nodev,noexec,relatime,net_cls,net_prio) cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (ro,nosuid,nodev,noexec,relatime,cpu,cpuacct) cgroup on /sys/fs/cgroup/hugetlb type cgroup (ro,nosuid,nodev,noexec,relatime,hugetlb) cgroup on /sys/fs/cgroup/freezer type cgroup (ro,nosuid,nodev,noexec,relatime,freezer) cgroup on /sys/fs/cgroup/blkio type cgroup (ro,nosuid,nodev,noexec,relatime,blkio) cgroup on /sys/fs/cgroup/perf_event type cgroup (ro,nosuid,nodev,noexec,relatime,perf_event) cgroup on /sys/fs/cgroup/devices type cgroup (ro,nosuid,nodev,noexec,relatime,devices) cgroup on /sys/fs/cgroup/pids type cgroup (ro,nosuid,nodev,noexec,relatime,pids) In contrast, privileged mode allows for both read and write operations on cgroup. $ docker run --privileged --rm -it debian:buster mount | grep &#39;cgroup&#39; tmpfs on /sys/fs/cgroup type tmpfs (rw,nosuid,nodev,noexec,relatime,mode=755) cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd) cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory) cgroup on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma) cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset) cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio) cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct) cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb) cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer) cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio) cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event) cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices) cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids) All devices from the host&#39;s /dev are available within the container. In standard mode, the device nodes unique to the /dev directory are not visible within the container&#39;s /dev directory. # docker run --rm -it debian:buster ls /dev console fd mqueue ptmx random stderr stdout urandom core full null pts shm stdin tty zero However, in privileged mode, the container&#39;s /dev directory includes these specific contents from the node&#39;s /dev directory. $ docker run --privileged --rm -it debian:buster ls /dev autofs mapper stdin tty25 tty44 tty63 vcsa1 btrfs-control mcelog stdout tty26 tty45 tty7 vcsa2 bus mem tty tty27 tty46 tty8 vcsa3 console memory_bandwidth tty0 tty28 tty47 tty9 vcsa4 core mqueue tty1 tty29 tty48 ttyS0 vcsa5 cpu net tty10 tty3 tty49 ttyS1 vcsa6 cpu_dma_latency network_latency tty11 tty30 tty5 ttyS2 vcsu cuse network_throughput tty12 tty31 tty50 ttyS3 vcsu1 dri null tty13 tty32 tty51 uhid vcsu2 fb0 nvram tty14 tty33 tty52 uinput vcsu3 fd port tty15 tty34 tty53 urandom vcsu4 full ppp tty16 tty35 tty54 usbmon0 vcsu5 fuse ptmx tty17 tty36 tty55 usbmon1 vcsu6 hidraw0 ptp0 tty18 tty37 tty56 vcs vda hpet pts tty19 tty38 tty57 vcs1 vda1 hwrng random tty2 tty39 tty58 vcs2 vfio infiniband raw tty20 tty4 tty59 vcs3 vga_arbiter input rtc0 tty21 tty40 tty6 vcs4 vhost-net kmsg shm tty22 tty41 tty60 vcs5 vhost-vsock lightnvm snapshot tty23 tty42 tty61 vcs6 zero loop-control stderr tty24 tty43 tty62 vcsa SELinux restrictions are not applied (e.g. label=disabled). In privileged mode, security hardening configurations related to SELinux are disabled. Similarly, in standard mode, SELinux features can be turned off using the appropriate security settings. References kubernetes/cri-api: Container Runtime Interface (CRI) – a plugin interface which enables kubelet to use a wide variety of container runtimes. capabilities(7) - Linux manual page Docker run reference | Docker Documentation",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "https://mozillazg.com/2021/11/docker-container-difference-between-privileged-mode-and-non-privileged-mode-en.html"
        },
        "datePublished": "2021-11-21"
    }
    </script>

</head>
<body>

<div class="navbar" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://mozillazg.com/" class="navbar-brand">
mozillazg's Blog            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="https://mozillazg.com/feeds/all.atom.xml">Feed</a></li>
                    <li><a href="/2014/10/pages/about-me.html">About</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://mozillazg.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content" class="yue">
        <article>
            <header class="text-center">
                <h1>
                    <a href="https://mozillazg.com/2021/11/docker-container-difference-between-privileged-mode-and-non-privileged-mode-en.html"
                       rel="bookmark"
                       title="Permalink to The Difference Between Container Privileged Mode and Non-Privileged Mode">
                        The Difference Between Container Privileged Mode and Non-Privileged Mode
                    </a>
                </h1>
                <p class="published">
                    <time datetime="2021-11-21T00:00:00+00:00">
                    2021-11-21
                    </time>
                </p>
            </header>
            <div class="entry-content">
                <div class="well-sm article-info">
<footer class="post-info">
        <a href="https://mozillazg.com/category/container.html">container</a>


<span class="label label-default hide">Tags</span>
	<a href="https://mozillazg.com/tag/privileged.html">privileged</a>
        /
	<a href="https://mozillazg.com/tag/security.html">security</a>
        /
	<a href="https://mozillazg.com/tag/en-version.html">en-version</a>
    <span class="label label-default">Lang</span>
	<a href="https://mozillazg.com/2021/11/docker-container-difference-between-privileged-mode-and-non-privileged-mode.html">zh</a>

</footer><!-- /.post-info -->                </div>
                <div class="js-toc"></div>
                <div>
                <div class="section" id="introduction">
<h2 id="hidintroduction">Introduction<a class="headerlink" href="#hidintroduction" title="Permalink to this headline">¶</a></h2>
<p>This article aims to explore the differences between privileged and non-privileged modes in containers,
focusing on identifying scenarios where the privileged mode is essential for fulfilling specific business needs.</p>
</div>
<div class="section" id="privileged-mode">
<h2 id="hidprivileged-mode">Privileged Mode<a class="headerlink" href="#hidprivileged-mode" title="Permalink to this headline">¶</a></h2>
<p>The description of privileged mode in the <a class="reference external" href="https://github.com/kubernetes/cri-api">CRI(Container Runtime Interface)</a> is outlined as follows:</p>
<pre class="literal-block">
// If set, run container in privileged mode.
// Privileged mode is incompatible with the following options. If
// privileged is set, the following features MAY have no effect:
// 1. capabilities
// 2. selinux_options
// 4. seccomp
// 5. apparmor
//
// Privileged mode implies the following specific options are applied:
// 1. All capabilities are added.
// 2. Sensitive paths, such as kernel module paths within sysfs, are not masked.
// 3. Any sysfs and procfs mounts are mounted RW.
// 4. AppArmor confinement is not applied.
// 5. Seccomp restrictions are not applied.
// 6. The device cgroup does not restrict access to any devices.
// 7. All devices from the host's /dev are available within the container.
// 8. SELinux restrictions are not applied (e.g. label=disabled).
</pre>
<!-- 通过上面的说明，可以得出如下信息： -->
<!--  -->
<!-- * 开启特权模式后，linux capabilities、SELinux、Seccomp、AppArmor 等限制容器内进程权限的功能可能不会再生效。 -->
<!-- * 开启特权模式时，将： -->
<!--  -->
<!-- * 启用所有的 `linux capabilities <https://man7.org/linux/man-pages/man7/capabilities.7.html>`__ -->
<!-- * 将不再对容器内进程屏蔽主机上的敏感目录，比如 sysfs 下的内核模块文件 -->
<!-- * 任何的 sysfs 和 procfs 挂载目录将以 ``RW`` 读写模式进行挂载 -->
<!-- * 不再应用 AppArmor 安全配置 -->
<!-- * 不再应用 Seccomp 安全约束 -->
<!-- * cgroup 设备将不再禁止访问任何的设备 -->
<!-- * 容器将可以操作主机上的 /dev 下的设备 -->
<!-- * 不再应用 SELinux 安全约束 -->
<p>Next, let's delve into each item's effect through illustrative examples.</p>
<div class="section" id="all-capabilities-are-added">
<h3 id="hidall-capabilities-are-added">All capabilities are added<a class="headerlink" href="#hidall-capabilities-are-added" title="Permalink to this headline">¶</a></h3>
<p>In the standard mode, the processes inside a container are restricted to a limited set of Linux capabilities.</p>
<pre class="literal-block">
$ docker run --rm -it  r.j3ss.co/amicontained bash

Capabilities:
    BOUNDING -&gt; chown dac_override fowner fsetid kill setgid setuid setpcap net_bind_service net_raw sys_chroot mknod audit_write setfcap
</pre>
<p>On the other hand, processes inside containers operating in privileged mode have access to all Linux capabilities.</p>
<pre class="literal-block">
$ docker run --privileged --rm -it  r.j3ss.co/amicontained bash

Capabilities:
    BOUNDING -&gt; chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read
</pre>
<p>Similarly, in the standard mode, one can replicate these needs by manually adjusting the <tt class="docutils literal"><span class="pre">--cap-add</span></tt> parameter.</p>
<pre class="literal-block">
$ docker run --cap-add=ALL  --rm -it  r.j3ss.co/amicontained bash
Capabilities:
        BOUNDING -&gt; chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read
</pre>
<p>By the way, while processes within a container in privileged mode have the ability to utilize all Linux capabilities, this doesn't automatically grant them permission for certain actions. For instance, if a container is initiated with a non-root user, even in privileged mode, it doesn't necessarily allow it to perform actions that are otherwise unauthorized.</p>
<pre class="literal-block">
$ docker run --rm -it debian:buster chown 65534 /var/log/lastlog

$ docker run -u 65534 --rm -it debian:buster chown 65534 /var/log/lastlog
chown: changing ownership of '/var/log/lastlog': Operation not permitted

$ docker run --privileged -u 65534 --rm -it debian:buster chown 65534 /var/log/lastlog
chown: changing ownership of '/var/log/lastlog': Operation not permitted
</pre>
</div>
<div class="section" id="sensitive-paths-such-as-kernel-module-paths-within-sysfs-are-not-masked">
<h3 id="hidsensitive-paths-such-as-kernel-module-paths-within-sysfs-are-not-masked">Sensitive paths, such as kernel module paths within sysfs, are not masked.<a class="headerlink" href="#hidsensitive-paths-such-as-kernel-module-paths-within-sysfs-are-not-masked" title="Permalink to this headline">¶</a></h3>
<p>In standard mode, access to certain kernel module paths, like specific directories under /proc, is selectively restricted. Some are write-protected, while others allow read and write operations. To address this, these directories are mounted into the container using the tmpfs filesystem, facilitating the implementation of directory masking.</p>
<pre class="literal-block">
$ docker run --rm -it debian:buster mount |grep '/proc.*tmpfs'
tmpfs on /proc/acpi type tmpfs (ro,relatime)
tmpfs on /proc/kcore type tmpfs (rw,nosuid,size=65536k,mode=755)
tmpfs on /proc/keys type tmpfs (rw,nosuid,size=65536k,mode=755)
tmpfs on /proc/timer_list type tmpfs (rw,nosuid,size=65536k,mode=755)
tmpfs on /proc/sched_debug type tmpfs (rw,nosuid,size=65536k,mode=755)
tmpfs on /proc/scsi type tmpfs (ro,relatime)
</pre>
<p>Under privileged mode, these directories are no longer mounted using the tmpfs filesystem approach.</p>
<pre class="literal-block">
$ docker run --privileged --rm -it debian:buster mount |grep '/proc.*tmpfs'
$
</pre>
</div>
<div class="section" id="any-sysfs-and-procfs-mounts-are-mounted-rw">
<h3 id="hidany-sysfs-and-procfs-mounts-are-mounted-rw">Any sysfs and procfs mounts are mounted RW.<a class="headerlink" href="#hidany-sysfs-and-procfs-mounts-are-mounted-rw" title="Permalink to this headline">¶</a></h3>
<p>In standard mode, certain kernel file systems, such as sysfs and procfs, are mounted inside the container as read-only. This is to prevent processes within the container from making unauthorized changes to the system kernel.</p>
<pre class="literal-block">
$ docker run --rm -it debian:buster mount |grep '(ro'
sysfs on /sys type sysfs (ro,nosuid,nodev,noexec,relatime)
cgroup on /sys/fs/cgroup/systemd type cgroup (ro,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)
cgroup on /sys/fs/cgroup/memory type cgroup (ro,nosuid,nodev,noexec,relatime,memory)
cgroup on /sys/fs/cgroup/rdma type cgroup (ro,nosuid,nodev,noexec,relatime,rdma)
cgroup on /sys/fs/cgroup/cpuset type cgroup (ro,nosuid,nodev,noexec,relatime,cpuset)
cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (ro,nosuid,nodev,noexec,relatime,net_cls,net_prio)
cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (ro,nosuid,nodev,noexec,relatime,cpu,cpuacct)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (ro,nosuid,nodev,noexec,relatime,hugetlb)
cgroup on /sys/fs/cgroup/freezer type cgroup (ro,nosuid,nodev,noexec,relatime,freezer)
cgroup on /sys/fs/cgroup/blkio type cgroup (ro,nosuid,nodev,noexec,relatime,blkio)
cgroup on /sys/fs/cgroup/perf_event type cgroup (ro,nosuid,nodev,noexec,relatime,perf_event)
cgroup on /sys/fs/cgroup/devices type cgroup (ro,nosuid,nodev,noexec,relatime,devices)
cgroup on /sys/fs/cgroup/pids type cgroup (ro,nosuid,nodev,noexec,relatime,pids)
proc on /proc/bus type proc (ro,nosuid,nodev,noexec,relatime)
proc on /proc/fs type proc (ro,nosuid,nodev,noexec,relatime)
proc on /proc/irq type proc (ro,nosuid,nodev,noexec,relatime)
proc on /proc/sys type proc (ro,nosuid,nodev,noexec,relatime)
proc on /proc/sysrq-trigger type proc (ro,nosuid,nodev,noexec,relatime)
tmpfs on /proc/acpi type tmpfs (ro,relatime)
tmpfs on /proc/scsi type tmpfs (ro,relatime)
tmpfs on /sys/firmware type tmpfs (ro,relatime)
</pre>
<p>In contrast, under privileged mode, these kernel file systems are not mounted as read-only.</p>
<pre class="literal-block">
$ docker run --privileged --rm -it debian:buster mount |grep '(ro'
$
</pre>
</div>
<div class="section" id="apparmor-confinement-is-not-applied">
<h3 id="hidapparmor-confinement-is-not-applied">AppArmor confinement is not applied.<a class="headerlink" href="#hidapparmor-confinement-is-not-applied" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="seccomp-restrictions-are-not-applied">
<h3 id="hidseccomp-restrictions-are-not-applied">Seccomp restrictions are not applied.<a class="headerlink" href="#hidseccomp-restrictions-are-not-applied" title="Permalink to this headline">¶</a></h3>
<p>In standard mode, containers can be secured by setting up AppArmor or Seccomp security options. If these are not configured manually, the container engine typically activates certain default configurations for enhanced security.</p>
<pre class="literal-block">
$ docker run --rm -it  r.j3ss.co/amicontained bash
AppArmor Profile: unconfined
Seccomp: filtering
Blocked Syscalls (63):
        MSGRCV SYSLOG SETPGID SETSID USELIB USTAT SYSFS VHANGUP PIVOT_ROOT _SYSCTL ACCT SETTIMEOFDAY MOUNT UMOUNT2 SWAPON SWAPOFF REBOOT SETHOSTNAME SETDOMAINNAME IOPL IOPERM CREATE_MODULE INIT_MODULE DELETE_MODULE GET_KERNEL_SYMS QUERY_MODULE QUOTACTL NFSSERVCTL GETPMSG PUTPMSG AFS_SYSCALL TUXCALL SECURITY LOOKUP_DCOOKIE CLOCK_SETTIME VSERVER MBIND SET_MEMPOLICY GET_MEMPOLICY KEXEC_LOAD ADD_KEY REQUEST_KEY KEYCTL MIGRATE_PAGES UNSHARE MOVE_PAGES PERF_EVENT_OPEN FANOTIFY_INIT NAME_TO_HANDLE_AT OPEN_BY_HANDLE_AT SETNS PROCESS_VM_READV PROCESS_VM_WRITEV KCMP FINIT_MODULE KEXEC_FILE_LOAD BPF USERFAULTFD PREADV2 PWRITEV2 PKEY_MPROTECT PKEY_ALLOC PKEY_FREE
</pre>
<p>However, in privileged mode, these AppArmor or Seccomp configurations become ineffective.</p>
<pre class="literal-block">
$ docker run --privileged --rm -it  r.j3ss.co/amicontained bash
AppArmor Profile: unconfined
Seccomp: disabled
</pre>
<p>Additionally, in standard mode, AppArmor or Seccomp features can be disabled using their respective security settings.</p>
</div>
<div class="section" id="the-device-cgroup-does-not-restrict-access-to-any-devices">
<h3 id="hidthe-device-cgroup-does-not-restrict-access-to-any-devices">The device cgroup does not restrict access to any devices.<a class="headerlink" href="#hidthe-device-cgroup-does-not-restrict-access-to-any-devices" title="Permalink to this headline">¶</a></h3>
<p>Under the default mode, operations on cgroup are limited to read-only access.</p>
<pre class="literal-block">
$ docker run --rm -it debian:buster mount | grep 'cgroup'
tmpfs on /sys/fs/cgroup type tmpfs (rw,nosuid,nodev,noexec,relatime,mode=755)
cgroup on /sys/fs/cgroup/systemd type cgroup (ro,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)
cgroup on /sys/fs/cgroup/memory type cgroup (ro,nosuid,nodev,noexec,relatime,memory)
cgroup on /sys/fs/cgroup/rdma type cgroup (ro,nosuid,nodev,noexec,relatime,rdma)
cgroup on /sys/fs/cgroup/cpuset type cgroup (ro,nosuid,nodev,noexec,relatime,cpuset)
cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (ro,nosuid,nodev,noexec,relatime,net_cls,net_prio)
cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (ro,nosuid,nodev,noexec,relatime,cpu,cpuacct)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (ro,nosuid,nodev,noexec,relatime,hugetlb)
cgroup on /sys/fs/cgroup/freezer type cgroup (ro,nosuid,nodev,noexec,relatime,freezer)
cgroup on /sys/fs/cgroup/blkio type cgroup (ro,nosuid,nodev,noexec,relatime,blkio)
cgroup on /sys/fs/cgroup/perf_event type cgroup (ro,nosuid,nodev,noexec,relatime,perf_event)
cgroup on /sys/fs/cgroup/devices type cgroup (ro,nosuid,nodev,noexec,relatime,devices)
cgroup on /sys/fs/cgroup/pids type cgroup (ro,nosuid,nodev,noexec,relatime,pids)
</pre>
<p>In contrast, privileged mode allows for both read and write operations on cgroup.</p>
<pre class="literal-block">
$ docker run --privileged --rm -it debian:buster mount | grep 'cgroup'
tmpfs on /sys/fs/cgroup type tmpfs (rw,nosuid,nodev,noexec,relatime,mode=755)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)
cgroup on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma)
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)
cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)
cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)
cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)
</pre>
</div>
<div class="section" id="all-devices-from-the-host-s-dev-are-available-within-the-container">
<h3 id="hidall-devices-from-the-host-s-dev-are-available-within-the-container">All devices from the host's /dev are available within the container.<a class="headerlink" href="#hidall-devices-from-the-host-s-dev-are-available-within-the-container" title="Permalink to this headline">¶</a></h3>
<p>In standard mode, the device nodes unique to the /dev directory are not visible within the container's /dev directory.</p>
<pre class="literal-block">
# docker run --rm -it debian:buster ls /dev
console  fd    mqueue  ptmx  random  stderr  stdout  urandom
core     full  null    pts   shm     stdin   tty     zero
</pre>
<p>However, in privileged mode, the container's /dev directory includes these specific contents from the node's /dev directory.</p>
<pre class="literal-block">
$ docker run --privileged --rm -it debian:buster ls /dev
autofs           mapper              stdin   tty25  tty44  tty63    vcsa1
btrfs-control    mcelog              stdout  tty26  tty45  tty7     vcsa2
bus              mem                 tty     tty27  tty46  tty8     vcsa3
console          memory_bandwidth    tty0    tty28  tty47  tty9     vcsa4
core             mqueue              tty1    tty29  tty48  ttyS0    vcsa5
cpu              net                 tty10   tty3   tty49  ttyS1    vcsa6
cpu_dma_latency  network_latency     tty11   tty30  tty5   ttyS2    vcsu
cuse             network_throughput  tty12   tty31  tty50  ttyS3    vcsu1
dri              null                tty13   tty32  tty51  uhid     vcsu2
fb0              nvram               tty14   tty33  tty52  uinput   vcsu3
fd               port                tty15   tty34  tty53  urandom  vcsu4
full             ppp                 tty16   tty35  tty54  usbmon0  vcsu5
fuse             ptmx                tty17   tty36  tty55  usbmon1  vcsu6
hidraw0          ptp0                tty18   tty37  tty56  vcs      vda
hpet             pts                 tty19   tty38  tty57  vcs1     vda1
hwrng            random              tty2    tty39  tty58  vcs2     vfio
infiniband       raw                 tty20   tty4   tty59  vcs3     vga_arbiter
input            rtc0                tty21   tty40  tty6   vcs4     vhost-net
kmsg             shm                 tty22   tty41  tty60  vcs5     vhost-vsock
lightnvm         snapshot            tty23   tty42  tty61  vcs6     zero
loop-control     stderr              tty24   tty43  tty62  vcsa
</pre>
</div>
<div class="section" id="selinux-restrictions-are-not-applied-e-g-label-disabled">
<h3 id="hidselinux-restrictions-are-not-applied-e-g-label-disabled">SELinux restrictions are not applied (e.g. label=disabled).<a class="headerlink" href="#hidselinux-restrictions-are-not-applied-e-g-label-disabled" title="Permalink to this headline">¶</a></h3>
<p>In privileged mode, security hardening configurations related to SELinux are disabled.</p>
<p>Similarly, in standard mode, SELinux features can be turned off using the appropriate security settings.</p>
</div>
</div>
<div class="section" id="references">
<h2 id="hidreferences">References<a class="headerlink" href="#hidreferences" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://github.com/kubernetes/cri-api">kubernetes/cri-api: Container Runtime Interface (CRI) – a plugin interface which enables kubelet to use a wide variety of container runtimes.</a></li>
<li><a class="reference external" href="https://man7.org/linux/man-pages/man7/capabilities.7.html">capabilities(7) - Linux manual page</a></li>
<li><a class="reference external" href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities">Docker run reference | Docker Documentation</a></li>
</ul>
</div>

                </div>
            </div>
            <!-- /.entry-content -->
<section class="text-center">
  
<div id="donate"></div>

<div class="social-share"></div>
<div class="social-comment-note">
<p class="text-center">有任何建议和想法欢迎在下方评论区留言或者加我<a href="/static/wechat.png">微信</a>交流</p>
</div>

</section>
<section class="well" id="related-posts">
    <p>Related Posts:</p>
    <ul>
        <li><a href="https://mozillazg.com/2021/11/docker-container-difference-between-privileged-mode-and-non-privileged-mode.html">容器特权模式与非特权模式的区别</a></li>
        <li><a href="https://mozillazg.com/2022/06/ebpf-libbpf-btf-powered-enabled-raw-tracepoint-common-questions-en.html">Frequently asked questions about using btf raw tracepoint with ebpf/libbpf programs</a></li>
        <li><a href="https://mozillazg.com/2022/05/ebpf-libbpf-raw-tracepoint-common-questions-en.html">Frequently asked questions about using raw tracepoint with ebpf/libbpf programs</a></li>
        <li><a href="https://mozillazg.com/2022/05/ebpf-libbpf-tracepoint-common-questions-en.html">Frequently asked questions about using tracepoint with ebpf/libbpf programs</a></li>
        <li><a href="https://mozillazg.com/2022/10/ebpf-libbpf-verifier-fix-type-expected-issue-en.html">One way to solve the ebpf verifier alert type error problem</a></li>
    </ul>
</section>
<hr/>
<section class="comments" id="comments">
    <h2>Comments</h2>
    <script src="https://giscus.app/client.js"
            data-repo="mozillazg/mozillazg.github.com"
            data-repo-id="MDEwOlJlcG9zaXRvcnk3Njc4MTA2"
            data-category="Announcements"
            data-category-id="DIC_kwDOAHUoms4CckZl"
            data-mapping="pathname"
            data-strict="0"
            data-reactions-enabled="1"
            data-emit-metadata="0"
            data-input-position="bottom"
            data-theme="preferred_color_scheme"
            data-lang="en"
            data-loading="lazy"
            crossorigin="anonymous"
            async>
    </script>
</section>
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2024 mozillazg
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>
            &middot; <a href="/privacy-policy.html" target="_blank">Privacy</a>              <p><small>  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/static/images/by-sa-80x15.png" /></a>
    &quot;<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">mozillazg's Blog</span>&quot; by <a xmlns:cc="http://creativecommons.org/ns#" href="https://mozillazg.com" property="cc:attributionName" rel="cc:attributionURL">mozillazg</a> is
  licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="/theme/cdn.jsdelivr.net/npm/jquery@2.1.1/dist/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="/theme/cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->


<!-- share.js -->
<script src="/theme/cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>



<script src="/theme/cdn.jsdelivr.net/npm/tocbot@3.0.2/dist/tocbot.min.js"></script>
<script>
$(document).ready(function(){
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.js-toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.entry-content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h2, h3, h4,h5',
    // Headings that match the ignoreSelector will be skipped.
    ignoreSelector: '.js-toc-ignore',
    // Main class to add to links.
    linkClass: 'toc-link',
    // Extra classes to add to links.
    extraLinkClasses: '',
    // Class to add to active links,
    // the link corresponding to the top most heading on the page.
    activeLinkClass: 'is-active-link',
    // Main class to add to lists.
    listClass: 'toc-list',
    // Extra classes to add to lists.
    extraListClasses: '',
    // Class that gets added when a list should be collapsed.
    isCollapsedClass: 'is-collapsed',
    // Class that gets added when a list should be able
    // to be collapsed but isn't necessarily collpased.
    collapsibleClass: 'is-collapsible',
    // Class to add to list items.
    listItemClass: 'toc-list-item',
    // How many heading levels should not be collpased.
    // For example, number 6 will show everything since
    // there are only 6 heading levels and number 0 will collpase them all.
    // The sections that are hidden will open
    // and close as you scroll to headings within them.
    collapseDepth: 6,
    // Smooth scrolling enabled.
    smoothScroll: true,
    // Smooth scroll duration.
    smoothScrollDuration: 420,
    // Callback for scroll end (requires: smoothScroll).
    scrollEndCallback: function (e) {},
    // Headings offset between the headings and the top of the document (this is meant for minor adjustments).
    headingsOffset: 0,
    // Timeout between events firing to make sure it's
    // not too rapid (for performance reasons).
    throttleTimeout: 50,
    // Element to add the positionFixedClass to.
    positionFixedSelector: null,
    // Fixed position class to add to make sidebar fixed after scrolling
    // down past the fixedSidebarOffset.
    positionFixedClass: 'is-position-fixed',
    // fixedSidebarOffset can be any number but by default is set
    // to auto which sets the fixedSidebarOffset to the sidebar
    // element's offsetTop from the top of the document on init.
    fixedSidebarOffset: 'auto',
    // includeHtml can be set to true to include the HTML markup from the
    // heading node instead of just including the textContent.
    includeHtml: false
  });
});
</script>
</body>
</html>