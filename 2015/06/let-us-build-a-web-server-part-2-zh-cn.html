<!DOCTYPE html>
<html lang="zh-hans" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml" class="han-init">
<head>
    <title>让我们一起来构建一个 Web 服务器（二） - Huang Huang 的博客</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- share.css -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">


    <link href="https://mozillazg.com/favicon.ico" rel="icon">

<link rel="canonical" href="https://mozillazg.com/2015/06/let-us-build-a-web-server-part-2-zh-cn.html">

        <meta name="author" content="mozillazg" />
        <meta name="keywords" content="let-us-build,server,http,wsgi,lsbaws,让我们一起来构建一个 Web 服务器" />
    <meta name="description" content="本文译自：http://ruslanspivak.com/lsbaws-part2/ 还记得吗？在 第一部分 我向你问了一个问题：”如何在你新鲜出炉的 Web 服务器上不做任何修改的就运行 Django 应用，Flask 应用， Pyramid 应用?“ 往下读就可以找到答案。 在过去，当你选择的 Python Web 框架会限制你所能选择的 Web 服务器, 如果那个框架和服务器被设计的可以一起工作的话，那就皆大欢喜了： 但是，当你尝试把一个服务器和一个框架一起使用的时候可能会（可能你已经）面临它们被设计为不兼容的情况： 一般来说你必须使用能够一起工作的组件而不仅仅是你想使用的组件。 那么，你如何确保你能够在你的 Web 服务器上运行多个 Web 框架，并且不需要修改 Web 服务器或 Web 框架的现有的代码呢？ 解决这个问题的答案就是 Python Web Server Gateway Interface (或简称 WSGI , 读作 “wizgy”) WSGI 允许开发者自由选择 Web 框架和 Web 服务器。现在你可以任意混搭不同的 Web 服务器和 Web 框架，并选择一个你需要的合适的组合。 比如，你可以 用 Gunicorn or Nginx/uWSGI or Waitress 运行 Django, Flask, 或 Pyramid . 真正的随意混搭，感谢那些服务器和框架对 WSGI 的支持： 因此，WSGI 就是我在 第一部分 向你问的并在文章开头重复过的问题的答案。 你的 Web 服务器必须实现 WSGI 接口的服务器端部分， 所有的现代 Python Web 框架都已经实现了 WSGI 接口的框架端部分， 这部分允许你不需要修改你的服务器代码去适应某个特定的框架就可以使用这些框架。 现在你已经知道了被 Web 服务器和 Web 框架所支持的 WSGI 允许你选择适合你的组合， 它同样也对服务器和框架的开发者有益，因为他们可以专注于标准中他们各自的区域，不会出现因为越界而踩到对方的脚趾。 其他语言也有类似的接口：例如，Java 有 Servlet API，Ruby 有 Rack. 一切都很棒，但是我猜你会说”Show me the code!“，好吧，一起来看看下面这个非常简约的 WSGI 服务器实现吧： # Tested with Python 2.7.9, Linux &amp; Mac OS X import socket import StringIO import sys class WSGIServer(object): address_family = socket.AF_INET socket_type = socket.SOCK_STREAM request_queue_size = 1 def __init__(self, server_address): # Create a listening socket self.listen_socket = listen_socket = socket.socket( self.address_family, self.socket_type ) # Allow to reuse the same address listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # Bind listen_socket.bind(server_address) # Activate listen_socket.listen(self.request_queue_size) # Get server host name and port host, port = self.listen_socket.getsockname()[:2] self.server_name = socket.getfqdn(host) self.server_port = port # Return headers set by Web framework/Web application self.headers_set = [] def set_app(self, application): self.application = application def serve_forever(self): listen_socket = self.listen_socket while True: # New client connection self.client_connection, client_address = listen_socket.accept() # Handle one request and close the client connection. Then # loop over to wait for another client connection self.handle_one_request() def handle_one_request(self): self.request_data = request_data = self.client_connection.recv(1024) # Print formatted request data a la &#39;curl -v&#39; print(&#39;&#39;.join( &#39;&lt; {line}\n&#39;.format(line=line) for line in request_data.splitlines() )) self.parse_request(request_data) # Construct environment dictionary using request data env = self.get_environ() # It&#39;s time to call our application callable and get # back a result that will become HTTP response body result = self.application(env, self.start_response) # Construct a response and send it back to the client self.finish_response(result) def parse_request(self, text): request_line = text.splitlines()[0] request_line = request_line.rstrip(&#39;\r\n&#39;) # Break down the request line into components (self.request_method, # GET self.path, # /hello self.request_version # HTTP/1.1 ) = request_line.split() def get_environ(self): env = {} # The following code snippet does not follow PEP8 conventions # but it&#39;s formatted the way it is for demonstration purposes # to emphasize the required variables and their values # # Required WSGI variables env[&#39;wsgi.version&#39;] = (1, 0) env[&#39;wsgi.url_scheme&#39;] = &#39;http&#39; env[&#39;wsgi.input&#39;] = StringIO.StringIO(self.request_data) env[&#39;wsgi.errors&#39;] = sys.stderr env[&#39;wsgi.multithread&#39;] = False env[&#39;wsgi.multiprocess&#39;] = False env[&#39;wsgi.run_once&#39;] = False # Required CGI variables env[&#39;REQUEST_METHOD&#39;] = self.request_method # GET env[&#39;PATH_INFO&#39;] = self.path # /hello env[&#39;SERVER_NAME&#39;] = self.server_name # localhost env[&#39;SERVER_PORT&#39;] = str(self.server_port) # 8888 return env def start_response(self, status, response_headers, exc_info=None): # Add necessary server headers server_headers = [ (&#39;Date&#39;, &#39;Tue, 31 Mar 2015 12:54:48 GMT&#39;), (&#39;Server&#39;, &#39;WSGIServer 0.2&#39;), ] self.headers_set = [status, response_headers + server_headers] # To adhere to WSGI specification the start_response must return # a &#39;write&#39; callable. We simplicity&#39;s sake we&#39;ll ignore that detail # for now. # return self.finish_response def finish_response(self, result): try: status, response_headers = self.headers_set response = &#39;HTTP/1.1 {status}\r\n&#39;.format(status=status) for header in response_headers: response += &#39;{0}: {1}\r\n&#39;.format(*header) response += &#39;\r\n&#39; for data in result: response += data # Print formatted response data a la &#39;curl -v&#39; print(&#39;&#39;.join( &#39;&gt; {line}\n&#39;.format(line=line) for line in response.splitlines() )) self.client_connection.sendall(response) finally: self.client_connection.close() SERVER_ADDRESS = (HOST, PORT) = &#39;&#39;, 8888 def make_server(server_address, application): server = WSGIServer(server_address) server.set_app(application) return server if __name__ == &#39;__main__&#39;: if len(sys.argv) &lt; 2: sys.exit(&#39;Provide a WSGI application object as module:callable&#39;) app_path = sys.argv[1] module, application = app_path.split(&#39;:&#39;) module = __import__(module) application = getattr(module, application) httpd = make_server(SERVER_ADDRESS, application) print(&#39;WSGIServer: Serving HTTP on port {port} ...\n&#39;.format(port=PORT)) httpd.serve_forever() 上面的代码比 第一部分 的服务器代码更长，但是，为了让你能够理解而不至于陷入细节的泥潭中，它已经足够小了（只有不到 150 行）。 上面的服务器代码同样也能做更多的工作——它能运行用你上面所见的 Web 框架（Pyramid, Flask, Django, 或其他的 Python WSGI 框架）所写的基础 Web 应用， 不信？动手试一下吧。把上面的代码保存为 webserver2.py 或者直接从 GitHub 上下载下来。如果你不带任何参数就运行这个程序的话，它会向你抱怨，然后退出。 $ python webserver2.py Provide a WSGI application object as module:callable 它真的非常想要服务你的 Web 应用，这是个非常有趣的开始。 为了能够运行这个服务器你只需要安装 Python 就可以了。 但是，为了运行用 Pyramid, Flask, 或 Django 开发的应用，你需要首先安装这些框架。 让我们来安装这三个框架吧。 我喜欢使用 virtualenv. 只需按照下面的步骤去创建并激活一个虚拟环境，然后就可以安装这三个框架了。 $ [sudo] pip install virtualenv $ mkdir ~/envs $ virtualenv ~/envs/lsbaws/ $ cd ~/envs/lsbaws/ $ ls bin include lib $ source bin/activate (lsbaws) $ pip install pyramid (lsbaws) $ pip install flask (lsbaws) $ pip install django 到这一步的时候你需要创建一个 Web 应用。让我们先用 Pyramid 开始吧。把下面的代码保存为 pyramidapp.py 并放到你之前所保存的 webserver2.py 文件或直接从 GitHub 所下载的文件所在目录（即：把 pyramidapp.py 放在 webserver2.py 所在目录）： from pyramid.config import Configurator from pyramid.response import Response def hello_world(request): return Response( &#39;Hello world from Pyramid!\n&#39;, content_type=&#39;text/plain&#39;, ) config = Configurator() config.add_route(&#39;hello&#39;, &#39;/hello&#39;) config.add_view(hello_world, route_name=&#39;hello&#39;) app = config.make_wsgi_app() 现在，你可以准备用你自己的 Web 服务器来服务你的 Pyramid 应用了： (lsbaws) $ python webserver2.py pyramidapp:app WSGIServer: Serving HTTP on port 8888 ... 你只需告诉你的服务器从 python 模块 pyramidapp 中载入一个可调用的 app 对象，你的服务器现在已经准备好 接收请求并把它们转发给你的 Pyramid 应用了。 这个应用目前只处理了一个路由：/hello 路由。 在你的浏览器中输入 http://localhost:8888/hello 地址，然后按下回车键，注意返回的结果： 你也可以在命令行中使用 curl 命令来测试这个服务器： $ curl -v http://localhost:8888/hello ... 检查服务器以及 curl 打印到标准输出的内容。 现在轮到 Flask 了。让我们按照相同的步骤来操作。 from flask import Flask from flask import Response flask_app = Flask(&#39;flaskapp&#39;) @flask_app.route(&#39;/hello&#39;) def hello_world(): return Response( &#39;Hello world from Flask!\n&#39;, mimetype=&#39;text/plain&#39; ) app = flask_app.wsgi_app 把上面的代码保存为 flaskapp.py 或从 GitHub 上下载，然后用以下方式运行服务器: (lsbaws) $ python webserver2.py flaskapp:app WSGIServer: Serving HTTP on port 8888 ... 现在在你的浏览器中输入 http://localhost:8888/hello 然后按下回车键： 再一次，尝试 curl 命令，然后看一下服务器返回的由这个 Flask 应用所生成的信息： $ curl -v http://localhost:8888/hello ... 这个服务器能处理 Django 应用吗啊？试一下就知道了！ 这次涉及的东西有点复杂，我建议你克隆这个 仓库 然后使用 GitHub 仓库 中的 djangoapp.py 文件。 下面的源码主要是添加 Django helloworld 项目（预先使用 Django 的 django-admin.py startproject 命令）到当前 Python 路径 然后导入项目中的 WSGI 应用。 import sys sys.path.insert(0, &#39;./helloworld&#39;) from helloworld import wsgi app = wsgi.application 把上面的代码保存为 djangoapp.py 然后用你的 Web 服务器运行这个 Django 应用： (lsbaws) $ python webserver2.py djangoapp:app WSGIServer: Serving HTTP on port 8888 ... 输入如下地址并回车： 正如你之前做过的那几次一样，你也可以在命令行中进行测试。 确认这个 Django 应用处理了你这一次的请求： $ curl -v http://localhost:8888/hello ... 你试过了吗？你有确认过这个服务器可以与这三个框架一起工作吗？ 如果还没有的话，一定要试一下。 阅读很重要，但是这个系列讲的是关于重新构建，这意味着你需要手动进行这些尝试。 快去试试吧。别担心，我会等你的。 我是认真的，你必须去尝试，最好能够亲自一个字一个字的敲下所有的字符， 并确保它能达到预期的效果。 好了，你已经熟悉 WSGI 的威力了：它允许你混搭你的 Web 服务器和 Web 框架。 WSGI 规定了 Python Web 服务器和 Python Web 框架之间的一些接口。 它非常的简单，不管是在服务器还是框架端都非常容易实现。 下面的片段展示了服务器和框架端的接口： def run_application(application): &#34;&#34;&#34;Server code.&#34;&#34;&#34; # This is where an application/framework stores # an HTTP status and HTTP response headers for the server # to transmit to the client headers_set = [] # Environment dictionary with WSGI/CGI variables environ = {} def start_response(status, response_headers, exc_info=None): headers_set[:] = [status, response_headers] # Server invokes the ‘application&#39; callable and gets back the # response body result = application(environ, start_response) # Server builds an HTTP response and transmits it to the client … def app(environ, start_response): &#34;&#34;&#34;A barebones WSGI app.&#34;&#34;&#34; start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/plain&#39;)]) return [&#39;Hello world!&#39;] run_application(app) 它的工作原理是这样的： 框架提供了一个 application 可调用对象（WSGI 规范没有规定它应该如何被实现） 每当收到来自 HTTP 客户端的请求的时候，服务器就调用这个 application 可调用对象。 它把一个包含 WSGI/CGI 变量的字典 environ 和一个 start_response 可调用对象作为参数传递给了 application 可调用对象。 框架/应用生成一个 HTTP 状态信息和 HTTP 响应头信息，并把它们传递给了 start_response 可调用对象， 让服务器把它们存起来。框架/应用也返回了一个响应 body 信息。 服务器把状态信息，响应头信息以及响应 body 信息合并为一个 HTTP 响应，然后把它传输给客户端（这一步不是规范的一部分， 但是它是流程中的下一个逻辑步骤，为了清晰可见我把它列在了这里） 下面是这个接口的可视化图表： 到目前位置，你已经见过了 Pyramid, Flask 以及 Django Web 应用，你也见过了实现 WSGI 规范的服务器端代码。 你也见过不用任何框架所实现的极简 WSGI 应用的代码片段。 事实是，当你用这些框架中某个开发一个 Web 应用的时候，你是在高层面进行工作， 并没有直接与 WSGI 打交到，但是我知道非常好奇框架端的 WSGI 接口实现，也是因为你正在阅读这篇文章。 那么，让我们来创建一个不使用 Pyramid, Flask, Django 的微型 WSGI Web 应用/Web 框架， 并用你的服务器来运行它： def app(environ, start_response): &#34;&#34;&#34;A barebones WSGI application. This is a starting point for your own Web framework :) &#34;&#34;&#34; status = &#39;200 OK&#39; response_headers = [(&#39;Content-Type&#39;, &#39;text/plain&#39;)] start_response(status, response_headers) return [&#39;Hello world from a simple WSGI application!\n&#39;] 再一次的，把上面的代码保存为 wsgiapp.py 或直接从 GitHub 上下载它，然后用你的 Web 服务器像下面这样运行这个应用： (lsbaws) $ python webserver2.py wsgiapp:app WSGIServer: Serving HTTP on port 8888 ... 输入如下地址并按下回车键。你应该会看到这样的结果： 在学习如何创建一个 Web 服务器的同时，你刚刚又写了一个你自己的微型 WSGI WEB 框架！ 真是意外之喜！ 现在，让我们回到服务器都给客户端传输了什么东西。 下面是当你使用 HTTP 客户端调用你的 Pyramind 应用时，服务器生成的 HTTP 响应： 这个响应有一些你在 第一部分 看到过的东西，但是它也有一些新东西。比如说，它有四个你之前还没见过的 HTTP headers： Content-Type , Content-Length , Date 以及 Server . 这些包含在响应里的头信息是一个 Web 服务器应该要生成的信息。 虽然它们中没有一个是严格要求必须提供的。 这些头信息的目的是传输关于 HTTP 请求/响应的附加信息。 现在你已经了解了关于 WSGI 接口的更详细的信息了，下面是同一个 HTTP 响应部分是如何产生的更详细的信息： 我还没有说过任何有关 environ 字典相关的信息，但是，基本上就是它是一个 Python 字典，它必须包含某些由 WSGI 规范所规定的 WSGI 和 CGI 变量。 解析完请求信息后，服务器从 HTTP 请求中得到这个字典所需的一些值。 这个字典看起来像下面这样： Web 框架使用来自这个字典里的信息来决定那个 view 可以被用来服务，基于获得的路由，请求方法等信息, 决定可以从哪里读取请求的 body 信息以及哪里可以用来写入错误信息，如果有的话。 到目前为止，你已经创建了你自己的 WSGI Web 服务器，你也用不同的 Web 框架编写过 Web 应用了。同时，你也顺便创建过极其简陋的 Web 应用/Web 框架。 真是一个操蛋的旅程。让我们来重述一下为了服务一个针对 WSGI 应用的请求信息，你的 WSGI Web 框架需要做的事情： 首先，服务器启动并载入一个由你的 Web 框架/应用所定义的 application 可调用对象 然后，服务器读取一个请求 然后，服务器解析这个请求 然后，服务器用这个请求数据构建了一个 environ 字典 然后，服务器以 environ 字典和一个 start_response 可调用对象作为参数来调用 application 对象，并获得一个返回的响应 body 。 然后，服务器用通过调用 application 对象获得的 body 数据以及通过 start_reponse 可调用对象设置的状态信息和响应头信息一起构建了一个 HTTP 响应。 最后，服务器把 HTTP 响应传输回客户端 就这些了。你现在有了一个可以工作的 WSGI 服务器，它能够服务那些用 WSGI 兼容的 Web 框架（比如：Django, Flask, Pyramid 或者是你自己开发的 WSGI 框架) 开发的基础的 Web 应用。最棒的是不需要修改任何的服务器代码就可以与多个 Web 框架一起使用。目前看起来还不赖嘛。 在你离开前，这里有另一个问题需要你思考，”如何让你的服务器能够在同一时刻处理多个请求？“ 敬请期待，在 第三部分 我将向你展示一种方法。加油！" />

    <style>
      .js-toc {
        margin-bottom: 20px;
      }
      .donate-modal {
        text-align: center;
      }
      #donate-modal-container .donate-image {
        max-height: 300px !important;
        min-height: inherit !important;
      }
    </style>

        <meta property="og:site_name" content="Huang Huang 的博客" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="让我们一起来构建一个 Web 服务器（二）"/>
        <meta property="og:url" content="https://mozillazg.com/2015/06/let-us-build-a-web-server-part-2-zh-cn.html"/>
        <meta property="og:description" content="本文译自：http://ruslanspivak.com/lsbaws-part2/ 还记得吗？在 第一部分 我向你问了一个问题：”如何在你新鲜出炉的 Web 服务器上不做任何修改的就运行 Django 应用，Flask 应用， Pyramid 应用?“ 往下读就可以找到答案。 在过去，当你选择的 Python Web 框架会限制你所能选择的 Web 服务器, 如果那个框架和服务器被设计的可以一起工作的话，那就皆大欢喜了： 但是，当你尝试把一个服务器和一个框架一起使用的时候可能会（可能你已经）面临它们被设计为不兼容的情况： 一般来说你必须使用能够一起工作的组件而不仅仅是你想使用的组件。 那么，你如何确保你能够在你的 Web 服务器上运行多个 Web 框架，并且不需要修改 Web 服务器或 Web 框架的现有的代码呢？ 解决这个问题的答案就是 Python Web Server Gateway Interface (或简称 WSGI , 读作 “wizgy”) WSGI 允许开发者自由选择 Web 框架和 Web 服务器。现在你可以任意混搭不同的 Web 服务器和 Web 框架，并选择一个你需要的合适的组合。 比如，你可以 用 Gunicorn or Nginx/uWSGI or Waitress 运行 Django, Flask, 或 Pyramid . 真正的随意混搭，感谢那些服务器和框架对 WSGI 的支持： 因此，WSGI 就是我在 第一部分 向你问的并在文章开头重复过的问题的答案。 你的 Web 服务器必须实现 WSGI 接口的服务器端部分， 所有的现代 Python Web 框架都已经实现了 WSGI 接口的框架端部分， 这部分允许你不需要修改你的服务器代码去适应某个特定的框架就可以使用这些框架。 现在你已经知道了被 Web 服务器和 Web 框架所支持的 WSGI 允许你选择适合你的组合， 它同样也对服务器和框架的开发者有益，因为他们可以专注于标准中他们各自的区域，不会出现因为越界而踩到对方的脚趾。 其他语言也有类似的接口：例如，Java 有 Servlet API，Ruby 有 Rack. 一切都很棒，但是我猜你会说”Show me the code!“，好吧，一起来看看下面这个非常简约的 WSGI 服务器实现吧： # Tested with Python 2.7.9, Linux &amp; Mac OS X import socket import StringIO import sys class WSGIServer(object): address_family = socket.AF_INET socket_type = socket.SOCK_STREAM request_queue_size = 1 def __init__(self, server_address): # Create a listening socket self.listen_socket = listen_socket = socket.socket( self.address_family, self.socket_type ) # Allow to reuse the same address listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # Bind listen_socket.bind(server_address) # Activate listen_socket.listen(self.request_queue_size) # Get server host name and port host, port = self.listen_socket.getsockname()[:2] self.server_name = socket.getfqdn(host) self.server_port = port # Return headers set by Web framework/Web application self.headers_set = [] def set_app(self, application): self.application = application def serve_forever(self): listen_socket = self.listen_socket while True: # New client connection self.client_connection, client_address = listen_socket.accept() # Handle one request and close the client connection. Then # loop over to wait for another client connection self.handle_one_request() def handle_one_request(self): self.request_data = request_data = self.client_connection.recv(1024) # Print formatted request data a la &#39;curl -v&#39; print(&#39;&#39;.join( &#39;&lt; {line}\n&#39;.format(line=line) for line in request_data.splitlines() )) self.parse_request(request_data) # Construct environment dictionary using request data env = self.get_environ() # It&#39;s time to call our application callable and get # back a result that will become HTTP response body result = self.application(env, self.start_response) # Construct a response and send it back to the client self.finish_response(result) def parse_request(self, text): request_line = text.splitlines()[0] request_line = request_line.rstrip(&#39;\r\n&#39;) # Break down the request line into components (self.request_method, # GET self.path, # /hello self.request_version # HTTP/1.1 ) = request_line.split() def get_environ(self): env = {} # The following code snippet does not follow PEP8 conventions # but it&#39;s formatted the way it is for demonstration purposes # to emphasize the required variables and their values # # Required WSGI variables env[&#39;wsgi.version&#39;] = (1, 0) env[&#39;wsgi.url_scheme&#39;] = &#39;http&#39; env[&#39;wsgi.input&#39;] = StringIO.StringIO(self.request_data) env[&#39;wsgi.errors&#39;] = sys.stderr env[&#39;wsgi.multithread&#39;] = False env[&#39;wsgi.multiprocess&#39;] = False env[&#39;wsgi.run_once&#39;] = False # Required CGI variables env[&#39;REQUEST_METHOD&#39;] = self.request_method # GET env[&#39;PATH_INFO&#39;] = self.path # /hello env[&#39;SERVER_NAME&#39;] = self.server_name # localhost env[&#39;SERVER_PORT&#39;] = str(self.server_port) # 8888 return env def start_response(self, status, response_headers, exc_info=None): # Add necessary server headers server_headers = [ (&#39;Date&#39;, &#39;Tue, 31 Mar 2015 12:54:48 GMT&#39;), (&#39;Server&#39;, &#39;WSGIServer 0.2&#39;), ] self.headers_set = [status, response_headers + server_headers] # To adhere to WSGI specification the start_response must return # a &#39;write&#39; callable. We simplicity&#39;s sake we&#39;ll ignore that detail # for now. # return self.finish_response def finish_response(self, result): try: status, response_headers = self.headers_set response = &#39;HTTP/1.1 {status}\r\n&#39;.format(status=status) for header in response_headers: response += &#39;{0}: {1}\r\n&#39;.format(*header) response += &#39;\r\n&#39; for data in result: response += data # Print formatted response data a la &#39;curl -v&#39; print(&#39;&#39;.join( &#39;&gt; {line}\n&#39;.format(line=line) for line in response.splitlines() )) self.client_connection.sendall(response) finally: self.client_connection.close() SERVER_ADDRESS = (HOST, PORT) = &#39;&#39;, 8888 def make_server(server_address, application): server = WSGIServer(server_address) server.set_app(application) return server if __name__ == &#39;__main__&#39;: if len(sys.argv) &lt; 2: sys.exit(&#39;Provide a WSGI application object as module:callable&#39;) app_path = sys.argv[1] module, application = app_path.split(&#39;:&#39;) module = __import__(module) application = getattr(module, application) httpd = make_server(SERVER_ADDRESS, application) print(&#39;WSGIServer: Serving HTTP on port {port} ...\n&#39;.format(port=PORT)) httpd.serve_forever() 上面的代码比 第一部分 的服务器代码更长，但是，为了让你能够理解而不至于陷入细节的泥潭中，它已经足够小了（只有不到 150 行）。 上面的服务器代码同样也能做更多的工作——它能运行用你上面所见的 Web 框架（Pyramid, Flask, Django, 或其他的 Python WSGI 框架）所写的基础 Web 应用， 不信？动手试一下吧。把上面的代码保存为 webserver2.py 或者直接从 GitHub 上下载下来。如果你不带任何参数就运行这个程序的话，它会向你抱怨，然后退出。 $ python webserver2.py Provide a WSGI application object as module:callable 它真的非常想要服务你的 Web 应用，这是个非常有趣的开始。 为了能够运行这个服务器你只需要安装 Python 就可以了。 但是，为了运行用 Pyramid, Flask, 或 Django 开发的应用，你需要首先安装这些框架。 让我们来安装这三个框架吧。 我喜欢使用 virtualenv. 只需按照下面的步骤去创建并激活一个虚拟环境，然后就可以安装这三个框架了。 $ [sudo] pip install virtualenv $ mkdir ~/envs $ virtualenv ~/envs/lsbaws/ $ cd ~/envs/lsbaws/ $ ls bin include lib $ source bin/activate (lsbaws) $ pip install pyramid (lsbaws) $ pip install flask (lsbaws) $ pip install django 到这一步的时候你需要创建一个 Web 应用。让我们先用 Pyramid 开始吧。把下面的代码保存为 pyramidapp.py 并放到你之前所保存的 webserver2.py 文件或直接从 GitHub 所下载的文件所在目录（即：把 pyramidapp.py 放在 webserver2.py 所在目录）： from pyramid.config import Configurator from pyramid.response import Response def hello_world(request): return Response( &#39;Hello world from Pyramid!\n&#39;, content_type=&#39;text/plain&#39;, ) config = Configurator() config.add_route(&#39;hello&#39;, &#39;/hello&#39;) config.add_view(hello_world, route_name=&#39;hello&#39;) app = config.make_wsgi_app() 现在，你可以准备用你自己的 Web 服务器来服务你的 Pyramid 应用了： (lsbaws) $ python webserver2.py pyramidapp:app WSGIServer: Serving HTTP on port 8888 ... 你只需告诉你的服务器从 python 模块 pyramidapp 中载入一个可调用的 app 对象，你的服务器现在已经准备好 接收请求并把它们转发给你的 Pyramid 应用了。 这个应用目前只处理了一个路由：/hello 路由。 在你的浏览器中输入 http://localhost:8888/hello 地址，然后按下回车键，注意返回的结果： 你也可以在命令行中使用 curl 命令来测试这个服务器： $ curl -v http://localhost:8888/hello ... 检查服务器以及 curl 打印到标准输出的内容。 现在轮到 Flask 了。让我们按照相同的步骤来操作。 from flask import Flask from flask import Response flask_app = Flask(&#39;flaskapp&#39;) @flask_app.route(&#39;/hello&#39;) def hello_world(): return Response( &#39;Hello world from Flask!\n&#39;, mimetype=&#39;text/plain&#39; ) app = flask_app.wsgi_app 把上面的代码保存为 flaskapp.py 或从 GitHub 上下载，然后用以下方式运行服务器: (lsbaws) $ python webserver2.py flaskapp:app WSGIServer: Serving HTTP on port 8888 ... 现在在你的浏览器中输入 http://localhost:8888/hello 然后按下回车键： 再一次，尝试 curl 命令，然后看一下服务器返回的由这个 Flask 应用所生成的信息： $ curl -v http://localhost:8888/hello ... 这个服务器能处理 Django 应用吗啊？试一下就知道了！ 这次涉及的东西有点复杂，我建议你克隆这个 仓库 然后使用 GitHub 仓库 中的 djangoapp.py 文件。 下面的源码主要是添加 Django helloworld 项目（预先使用 Django 的 django-admin.py startproject 命令）到当前 Python 路径 然后导入项目中的 WSGI 应用。 import sys sys.path.insert(0, &#39;./helloworld&#39;) from helloworld import wsgi app = wsgi.application 把上面的代码保存为 djangoapp.py 然后用你的 Web 服务器运行这个 Django 应用： (lsbaws) $ python webserver2.py djangoapp:app WSGIServer: Serving HTTP on port 8888 ... 输入如下地址并回车： 正如你之前做过的那几次一样，你也可以在命令行中进行测试。 确认这个 Django 应用处理了你这一次的请求： $ curl -v http://localhost:8888/hello ... 你试过了吗？你有确认过这个服务器可以与这三个框架一起工作吗？ 如果还没有的话，一定要试一下。 阅读很重要，但是这个系列讲的是关于重新构建，这意味着你需要手动进行这些尝试。 快去试试吧。别担心，我会等你的。 我是认真的，你必须去尝试，最好能够亲自一个字一个字的敲下所有的字符， 并确保它能达到预期的效果。 好了，你已经熟悉 WSGI 的威力了：它允许你混搭你的 Web 服务器和 Web 框架。 WSGI 规定了 Python Web 服务器和 Python Web 框架之间的一些接口。 它非常的简单，不管是在服务器还是框架端都非常容易实现。 下面的片段展示了服务器和框架端的接口： def run_application(application): &#34;&#34;&#34;Server code.&#34;&#34;&#34; # This is where an application/framework stores # an HTTP status and HTTP response headers for the server # to transmit to the client headers_set = [] # Environment dictionary with WSGI/CGI variables environ = {} def start_response(status, response_headers, exc_info=None): headers_set[:] = [status, response_headers] # Server invokes the ‘application&#39; callable and gets back the # response body result = application(environ, start_response) # Server builds an HTTP response and transmits it to the client … def app(environ, start_response): &#34;&#34;&#34;A barebones WSGI app.&#34;&#34;&#34; start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/plain&#39;)]) return [&#39;Hello world!&#39;] run_application(app) 它的工作原理是这样的： 框架提供了一个 application 可调用对象（WSGI 规范没有规定它应该如何被实现） 每当收到来自 HTTP 客户端的请求的时候，服务器就调用这个 application 可调用对象。 它把一个包含 WSGI/CGI 变量的字典 environ 和一个 start_response 可调用对象作为参数传递给了 application 可调用对象。 框架/应用生成一个 HTTP 状态信息和 HTTP 响应头信息，并把它们传递给了 start_response 可调用对象， 让服务器把它们存起来。框架/应用也返回了一个响应 body 信息。 服务器把状态信息，响应头信息以及响应 body 信息合并为一个 HTTP 响应，然后把它传输给客户端（这一步不是规范的一部分， 但是它是流程中的下一个逻辑步骤，为了清晰可见我把它列在了这里） 下面是这个接口的可视化图表： 到目前位置，你已经见过了 Pyramid, Flask 以及 Django Web 应用，你也见过了实现 WSGI 规范的服务器端代码。 你也见过不用任何框架所实现的极简 WSGI 应用的代码片段。 事实是，当你用这些框架中某个开发一个 Web 应用的时候，你是在高层面进行工作， 并没有直接与 WSGI 打交到，但是我知道非常好奇框架端的 WSGI 接口实现，也是因为你正在阅读这篇文章。 那么，让我们来创建一个不使用 Pyramid, Flask, Django 的微型 WSGI Web 应用/Web 框架， 并用你的服务器来运行它： def app(environ, start_response): &#34;&#34;&#34;A barebones WSGI application. This is a starting point for your own Web framework :) &#34;&#34;&#34; status = &#39;200 OK&#39; response_headers = [(&#39;Content-Type&#39;, &#39;text/plain&#39;)] start_response(status, response_headers) return [&#39;Hello world from a simple WSGI application!\n&#39;] 再一次的，把上面的代码保存为 wsgiapp.py 或直接从 GitHub 上下载它，然后用你的 Web 服务器像下面这样运行这个应用： (lsbaws) $ python webserver2.py wsgiapp:app WSGIServer: Serving HTTP on port 8888 ... 输入如下地址并按下回车键。你应该会看到这样的结果： 在学习如何创建一个 Web 服务器的同时，你刚刚又写了一个你自己的微型 WSGI WEB 框架！ 真是意外之喜！ 现在，让我们回到服务器都给客户端传输了什么东西。 下面是当你使用 HTTP 客户端调用你的 Pyramind 应用时，服务器生成的 HTTP 响应： 这个响应有一些你在 第一部分 看到过的东西，但是它也有一些新东西。比如说，它有四个你之前还没见过的 HTTP headers： Content-Type , Content-Length , Date 以及 Server . 这些包含在响应里的头信息是一个 Web 服务器应该要生成的信息。 虽然它们中没有一个是严格要求必须提供的。 这些头信息的目的是传输关于 HTTP 请求/响应的附加信息。 现在你已经了解了关于 WSGI 接口的更详细的信息了，下面是同一个 HTTP 响应部分是如何产生的更详细的信息： 我还没有说过任何有关 environ 字典相关的信息，但是，基本上就是它是一个 Python 字典，它必须包含某些由 WSGI 规范所规定的 WSGI 和 CGI 变量。 解析完请求信息后，服务器从 HTTP 请求中得到这个字典所需的一些值。 这个字典看起来像下面这样： Web 框架使用来自这个字典里的信息来决定那个 view 可以被用来服务，基于获得的路由，请求方法等信息, 决定可以从哪里读取请求的 body 信息以及哪里可以用来写入错误信息，如果有的话。 到目前为止，你已经创建了你自己的 WSGI Web 服务器，你也用不同的 Web 框架编写过 Web 应用了。同时，你也顺便创建过极其简陋的 Web 应用/Web 框架。 真是一个操蛋的旅程。让我们来重述一下为了服务一个针对 WSGI 应用的请求信息，你的 WSGI Web 框架需要做的事情： 首先，服务器启动并载入一个由你的 Web 框架/应用所定义的 application 可调用对象 然后，服务器读取一个请求 然后，服务器解析这个请求 然后，服务器用这个请求数据构建了一个 environ 字典 然后，服务器以 environ 字典和一个 start_response 可调用对象作为参数来调用 application 对象，并获得一个返回的响应 body 。 然后，服务器用通过调用 application 对象获得的 body 数据以及通过 start_reponse 可调用对象设置的状态信息和响应头信息一起构建了一个 HTTP 响应。 最后，服务器把 HTTP 响应传输回客户端 就这些了。你现在有了一个可以工作的 WSGI 服务器，它能够服务那些用 WSGI 兼容的 Web 框架（比如：Django, Flask, Pyramid 或者是你自己开发的 WSGI 框架) 开发的基础的 Web 应用。最棒的是不需要修改任何的服务器代码就可以与多个 Web 框架一起使用。目前看起来还不赖嘛。 在你离开前，这里有另一个问题需要你思考，”如何让你的服务器能够在同一时刻处理多个请求？“ 敬请期待，在 第三部分 我将向你展示一种方法。加油！"/>
        <meta property="article:published_time" content="2015-06-06" />
            <meta property="article:section" content="python" />
            <meta property="article:tag" content="let-us-build" />
            <meta property="article:tag" content="server" />
            <meta property="article:tag" content="http" />
            <meta property="article:tag" content="wsgi" />
            <meta property="article:tag" content="lsbaws" />
            <meta property="article:tag" content="让我们一起来构建一个 Web 服务器" />
            <meta property="article:author" content="mozillazg" />
            <meta property="og:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>


    <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@mozillazg">
        <meta name="twitter:creator" content="@mozillazg">
    <meta name="twitter:domain" content="https://mozillazg.com">
            <meta property="twitter:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/css/bootstrap.min.css" type="text/css"/>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link href="https://cdn.jsdelivr.net/npm/pygments-css@1.0.0/github.css" rel="stylesheet">
    <link rel="stylesheet" href="https://mozillazg.com/theme/css/style.css" type="text/css"/>
            <link href="https://mozillazg.com/static/custom.css" rel="stylesheet">

        <link href="https://mozillazg.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Huang Huang 的博客 ATOM Feed"/>

        <link href="https://mozillazg.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="Huang Huang 的博客 RSS Feed"/>


        <link href="https://mozillazg.com/feeds/python.atom.xml" type="application/atom+xml" rel="alternate"
              title="Huang Huang 的博客 python ATOM Feed"/>


    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Website",
        "publisher": {
            "@type": "Person",
            "name": "mozillazg",
            "logo": "https://mozillazg.com/static/avatar.jpeg"
        },
        "author": {
            "@type": "Person",
            "name": "mozillazg",
            "image": "https://mozillazg.com/static/avatar.jpeg",
            "url": "https://mozillazg.com",
            "sameAs": []
        },
        // "headline": "",
        "url": "https://mozillazg.com/2015/06/let-us-build-a-web-server-part-2-zh-cn.html",
        "datePublished": "2015-06-06",
        // "dateModified": "",
        "image": "https://mozillazg.com/static/avatar.jpeg",
        "keywords": "let-us-build, server, http, wsgi, lsbaws, 让我们一起来构建一个 Web 服务器",
        "description": "本文译自：http://ruslanspivak.com/lsbaws-part2/ 还记得吗？在 第一部分 我向你问了一个问题：”如何在你新鲜出炉的 Web 服务器上不做任何修改的就运行 Django 应用，Flask 应用， Pyramid 应用?“ 往下读就可以找到答案。 在过去，当你选择的 Python Web 框架会限制你所能选择的 Web 服务器, 如果那个框架和服务器被设计的可以一起工作的话，那就皆大欢喜了： 但是，当你尝试把一个服务器和一个框架一起使用的时候可能会（可能你已经）面临它们被设计为不兼容的情况： 一般来说你必须使用能够一起工作的组件而不仅仅是你想使用的组件。 那么，你如何确保你能够在你的 Web 服务器上运行多个 Web 框架，并且不需要修改 Web 服务器或 Web 框架的现有的代码呢？ 解决这个问题的答案就是 Python Web Server Gateway Interface (或简称 WSGI , 读作 “wizgy”) WSGI 允许开发者自由选择 Web 框架和 Web 服务器。现在你可以任意混搭不同的 Web 服务器和 Web 框架，并选择一个你需要的合适的组合。 比如，你可以 用 Gunicorn or Nginx/uWSGI or Waitress 运行 Django, Flask, 或 Pyramid . 真正的随意混搭，感谢那些服务器和框架对 WSGI 的支持： 因此，WSGI 就是我在 第一部分 向你问的并在文章开头重复过的问题的答案。 你的 Web 服务器必须实现 WSGI 接口的服务器端部分， 所有的现代 Python Web 框架都已经实现了 WSGI 接口的框架端部分， 这部分允许你不需要修改你的服务器代码去适应某个特定的框架就可以使用这些框架。 现在你已经知道了被 Web 服务器和 Web 框架所支持的 WSGI 允许你选择适合你的组合， 它同样也对服务器和框架的开发者有益，因为他们可以专注于标准中他们各自的区域，不会出现因为越界而踩到对方的脚趾。 其他语言也有类似的接口：例如，Java 有 Servlet API，Ruby 有 Rack. 一切都很棒，但是我猜你会说”Show me the code!“，好吧，一起来看看下面这个非常简约的 WSGI 服务器实现吧： # Tested with Python 2.7.9, Linux &amp; Mac OS X import socket import StringIO import sys class WSGIServer(object): address_family = socket.AF_INET socket_type = socket.SOCK_STREAM request_queue_size = 1 def __init__(self, server_address): # Create a listening socket self.listen_socket = listen_socket = socket.socket( self.address_family, self.socket_type ) # Allow to reuse the same address listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # Bind listen_socket.bind(server_address) # Activate listen_socket.listen(self.request_queue_size) # Get server host name and port host, port = self.listen_socket.getsockname()[:2] self.server_name = socket.getfqdn(host) self.server_port = port # Return headers set by Web framework/Web application self.headers_set = [] def set_app(self, application): self.application = application def serve_forever(self): listen_socket = self.listen_socket while True: # New client connection self.client_connection, client_address = listen_socket.accept() # Handle one request and close the client connection. Then # loop over to wait for another client connection self.handle_one_request() def handle_one_request(self): self.request_data = request_data = self.client_connection.recv(1024) # Print formatted request data a la &#39;curl -v&#39; print(&#39;&#39;.join( &#39;&lt; {line}\n&#39;.format(line=line) for line in request_data.splitlines() )) self.parse_request(request_data) # Construct environment dictionary using request data env = self.get_environ() # It&#39;s time to call our application callable and get # back a result that will become HTTP response body result = self.application(env, self.start_response) # Construct a response and send it back to the client self.finish_response(result) def parse_request(self, text): request_line = text.splitlines()[0] request_line = request_line.rstrip(&#39;\r\n&#39;) # Break down the request line into components (self.request_method, # GET self.path, # /hello self.request_version # HTTP/1.1 ) = request_line.split() def get_environ(self): env = {} # The following code snippet does not follow PEP8 conventions # but it&#39;s formatted the way it is for demonstration purposes # to emphasize the required variables and their values # # Required WSGI variables env[&#39;wsgi.version&#39;] = (1, 0) env[&#39;wsgi.url_scheme&#39;] = &#39;http&#39; env[&#39;wsgi.input&#39;] = StringIO.StringIO(self.request_data) env[&#39;wsgi.errors&#39;] = sys.stderr env[&#39;wsgi.multithread&#39;] = False env[&#39;wsgi.multiprocess&#39;] = False env[&#39;wsgi.run_once&#39;] = False # Required CGI variables env[&#39;REQUEST_METHOD&#39;] = self.request_method # GET env[&#39;PATH_INFO&#39;] = self.path # /hello env[&#39;SERVER_NAME&#39;] = self.server_name # localhost env[&#39;SERVER_PORT&#39;] = str(self.server_port) # 8888 return env def start_response(self, status, response_headers, exc_info=None): # Add necessary server headers server_headers = [ (&#39;Date&#39;, &#39;Tue, 31 Mar 2015 12:54:48 GMT&#39;), (&#39;Server&#39;, &#39;WSGIServer 0.2&#39;), ] self.headers_set = [status, response_headers + server_headers] # To adhere to WSGI specification the start_response must return # a &#39;write&#39; callable. We simplicity&#39;s sake we&#39;ll ignore that detail # for now. # return self.finish_response def finish_response(self, result): try: status, response_headers = self.headers_set response = &#39;HTTP/1.1 {status}\r\n&#39;.format(status=status) for header in response_headers: response += &#39;{0}: {1}\r\n&#39;.format(*header) response += &#39;\r\n&#39; for data in result: response += data # Print formatted response data a la &#39;curl -v&#39; print(&#39;&#39;.join( &#39;&gt; {line}\n&#39;.format(line=line) for line in response.splitlines() )) self.client_connection.sendall(response) finally: self.client_connection.close() SERVER_ADDRESS = (HOST, PORT) = &#39;&#39;, 8888 def make_server(server_address, application): server = WSGIServer(server_address) server.set_app(application) return server if __name__ == &#39;__main__&#39;: if len(sys.argv) &lt; 2: sys.exit(&#39;Provide a WSGI application object as module:callable&#39;) app_path = sys.argv[1] module, application = app_path.split(&#39;:&#39;) module = __import__(module) application = getattr(module, application) httpd = make_server(SERVER_ADDRESS, application) print(&#39;WSGIServer: Serving HTTP on port {port} ...\n&#39;.format(port=PORT)) httpd.serve_forever() 上面的代码比 第一部分 的服务器代码更长，但是，为了让你能够理解而不至于陷入细节的泥潭中，它已经足够小了（只有不到 150 行）。 上面的服务器代码同样也能做更多的工作——它能运行用你上面所见的 Web 框架（Pyramid, Flask, Django, 或其他的 Python WSGI 框架）所写的基础 Web 应用， 不信？动手试一下吧。把上面的代码保存为 webserver2.py 或者直接从 GitHub 上下载下来。如果你不带任何参数就运行这个程序的话，它会向你抱怨，然后退出。 $ python webserver2.py Provide a WSGI application object as module:callable 它真的非常想要服务你的 Web 应用，这是个非常有趣的开始。 为了能够运行这个服务器你只需要安装 Python 就可以了。 但是，为了运行用 Pyramid, Flask, 或 Django 开发的应用，你需要首先安装这些框架。 让我们来安装这三个框架吧。 我喜欢使用 virtualenv. 只需按照下面的步骤去创建并激活一个虚拟环境，然后就可以安装这三个框架了。 $ [sudo] pip install virtualenv $ mkdir ~/envs $ virtualenv ~/envs/lsbaws/ $ cd ~/envs/lsbaws/ $ ls bin include lib $ source bin/activate (lsbaws) $ pip install pyramid (lsbaws) $ pip install flask (lsbaws) $ pip install django 到这一步的时候你需要创建一个 Web 应用。让我们先用 Pyramid 开始吧。把下面的代码保存为 pyramidapp.py 并放到你之前所保存的 webserver2.py 文件或直接从 GitHub 所下载的文件所在目录（即：把 pyramidapp.py 放在 webserver2.py 所在目录）： from pyramid.config import Configurator from pyramid.response import Response def hello_world(request): return Response( &#39;Hello world from Pyramid!\n&#39;, content_type=&#39;text/plain&#39;, ) config = Configurator() config.add_route(&#39;hello&#39;, &#39;/hello&#39;) config.add_view(hello_world, route_name=&#39;hello&#39;) app = config.make_wsgi_app() 现在，你可以准备用你自己的 Web 服务器来服务你的 Pyramid 应用了： (lsbaws) $ python webserver2.py pyramidapp:app WSGIServer: Serving HTTP on port 8888 ... 你只需告诉你的服务器从 python 模块 pyramidapp 中载入一个可调用的 app 对象，你的服务器现在已经准备好 接收请求并把它们转发给你的 Pyramid 应用了。 这个应用目前只处理了一个路由：/hello 路由。 在你的浏览器中输入 http://localhost:8888/hello 地址，然后按下回车键，注意返回的结果： 你也可以在命令行中使用 curl 命令来测试这个服务器： $ curl -v http://localhost:8888/hello ... 检查服务器以及 curl 打印到标准输出的内容。 现在轮到 Flask 了。让我们按照相同的步骤来操作。 from flask import Flask from flask import Response flask_app = Flask(&#39;flaskapp&#39;) @flask_app.route(&#39;/hello&#39;) def hello_world(): return Response( &#39;Hello world from Flask!\n&#39;, mimetype=&#39;text/plain&#39; ) app = flask_app.wsgi_app 把上面的代码保存为 flaskapp.py 或从 GitHub 上下载，然后用以下方式运行服务器: (lsbaws) $ python webserver2.py flaskapp:app WSGIServer: Serving HTTP on port 8888 ... 现在在你的浏览器中输入 http://localhost:8888/hello 然后按下回车键： 再一次，尝试 curl 命令，然后看一下服务器返回的由这个 Flask 应用所生成的信息： $ curl -v http://localhost:8888/hello ... 这个服务器能处理 Django 应用吗啊？试一下就知道了！ 这次涉及的东西有点复杂，我建议你克隆这个 仓库 然后使用 GitHub 仓库 中的 djangoapp.py 文件。 下面的源码主要是添加 Django helloworld 项目（预先使用 Django 的 django-admin.py startproject 命令）到当前 Python 路径 然后导入项目中的 WSGI 应用。 import sys sys.path.insert(0, &#39;./helloworld&#39;) from helloworld import wsgi app = wsgi.application 把上面的代码保存为 djangoapp.py 然后用你的 Web 服务器运行这个 Django 应用： (lsbaws) $ python webserver2.py djangoapp:app WSGIServer: Serving HTTP on port 8888 ... 输入如下地址并回车： 正如你之前做过的那几次一样，你也可以在命令行中进行测试。 确认这个 Django 应用处理了你这一次的请求： $ curl -v http://localhost:8888/hello ... 你试过了吗？你有确认过这个服务器可以与这三个框架一起工作吗？ 如果还没有的话，一定要试一下。 阅读很重要，但是这个系列讲的是关于重新构建，这意味着你需要手动进行这些尝试。 快去试试吧。别担心，我会等你的。 我是认真的，你必须去尝试，最好能够亲自一个字一个字的敲下所有的字符， 并确保它能达到预期的效果。 好了，你已经熟悉 WSGI 的威力了：它允许你混搭你的 Web 服务器和 Web 框架。 WSGI 规定了 Python Web 服务器和 Python Web 框架之间的一些接口。 它非常的简单，不管是在服务器还是框架端都非常容易实现。 下面的片段展示了服务器和框架端的接口： def run_application(application): &#34;&#34;&#34;Server code.&#34;&#34;&#34; # This is where an application/framework stores # an HTTP status and HTTP response headers for the server # to transmit to the client headers_set = [] # Environment dictionary with WSGI/CGI variables environ = {} def start_response(status, response_headers, exc_info=None): headers_set[:] = [status, response_headers] # Server invokes the ‘application&#39; callable and gets back the # response body result = application(environ, start_response) # Server builds an HTTP response and transmits it to the client … def app(environ, start_response): &#34;&#34;&#34;A barebones WSGI app.&#34;&#34;&#34; start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/plain&#39;)]) return [&#39;Hello world!&#39;] run_application(app) 它的工作原理是这样的： 框架提供了一个 application 可调用对象（WSGI 规范没有规定它应该如何被实现） 每当收到来自 HTTP 客户端的请求的时候，服务器就调用这个 application 可调用对象。 它把一个包含 WSGI/CGI 变量的字典 environ 和一个 start_response 可调用对象作为参数传递给了 application 可调用对象。 框架/应用生成一个 HTTP 状态信息和 HTTP 响应头信息，并把它们传递给了 start_response 可调用对象， 让服务器把它们存起来。框架/应用也返回了一个响应 body 信息。 服务器把状态信息，响应头信息以及响应 body 信息合并为一个 HTTP 响应，然后把它传输给客户端（这一步不是规范的一部分， 但是它是流程中的下一个逻辑步骤，为了清晰可见我把它列在了这里） 下面是这个接口的可视化图表： 到目前位置，你已经见过了 Pyramid, Flask 以及 Django Web 应用，你也见过了实现 WSGI 规范的服务器端代码。 你也见过不用任何框架所实现的极简 WSGI 应用的代码片段。 事实是，当你用这些框架中某个开发一个 Web 应用的时候，你是在高层面进行工作， 并没有直接与 WSGI 打交到，但是我知道非常好奇框架端的 WSGI 接口实现，也是因为你正在阅读这篇文章。 那么，让我们来创建一个不使用 Pyramid, Flask, Django 的微型 WSGI Web 应用/Web 框架， 并用你的服务器来运行它： def app(environ, start_response): &#34;&#34;&#34;A barebones WSGI application. This is a starting point for your own Web framework :) &#34;&#34;&#34; status = &#39;200 OK&#39; response_headers = [(&#39;Content-Type&#39;, &#39;text/plain&#39;)] start_response(status, response_headers) return [&#39;Hello world from a simple WSGI application!\n&#39;] 再一次的，把上面的代码保存为 wsgiapp.py 或直接从 GitHub 上下载它，然后用你的 Web 服务器像下面这样运行这个应用： (lsbaws) $ python webserver2.py wsgiapp:app WSGIServer: Serving HTTP on port 8888 ... 输入如下地址并按下回车键。你应该会看到这样的结果： 在学习如何创建一个 Web 服务器的同时，你刚刚又写了一个你自己的微型 WSGI WEB 框架！ 真是意外之喜！ 现在，让我们回到服务器都给客户端传输了什么东西。 下面是当你使用 HTTP 客户端调用你的 Pyramind 应用时，服务器生成的 HTTP 响应： 这个响应有一些你在 第一部分 看到过的东西，但是它也有一些新东西。比如说，它有四个你之前还没见过的 HTTP headers： Content-Type , Content-Length , Date 以及 Server . 这些包含在响应里的头信息是一个 Web 服务器应该要生成的信息。 虽然它们中没有一个是严格要求必须提供的。 这些头信息的目的是传输关于 HTTP 请求/响应的附加信息。 现在你已经了解了关于 WSGI 接口的更详细的信息了，下面是同一个 HTTP 响应部分是如何产生的更详细的信息： 我还没有说过任何有关 environ 字典相关的信息，但是，基本上就是它是一个 Python 字典，它必须包含某些由 WSGI 规范所规定的 WSGI 和 CGI 变量。 解析完请求信息后，服务器从 HTTP 请求中得到这个字典所需的一些值。 这个字典看起来像下面这样： Web 框架使用来自这个字典里的信息来决定那个 view 可以被用来服务，基于获得的路由，请求方法等信息, 决定可以从哪里读取请求的 body 信息以及哪里可以用来写入错误信息，如果有的话。 到目前为止，你已经创建了你自己的 WSGI Web 服务器，你也用不同的 Web 框架编写过 Web 应用了。同时，你也顺便创建过极其简陋的 Web 应用/Web 框架。 真是一个操蛋的旅程。让我们来重述一下为了服务一个针对 WSGI 应用的请求信息，你的 WSGI Web 框架需要做的事情： 首先，服务器启动并载入一个由你的 Web 框架/应用所定义的 application 可调用对象 然后，服务器读取一个请求 然后，服务器解析这个请求 然后，服务器用这个请求数据构建了一个 environ 字典 然后，服务器以 environ 字典和一个 start_response 可调用对象作为参数来调用 application 对象，并获得一个返回的响应 body 。 然后，服务器用通过调用 application 对象获得的 body 数据以及通过 start_reponse 可调用对象设置的状态信息和响应头信息一起构建了一个 HTTP 响应。 最后，服务器把 HTTP 响应传输回客户端 就这些了。你现在有了一个可以工作的 WSGI 服务器，它能够服务那些用 WSGI 兼容的 Web 框架（比如：Django, Flask, Pyramid 或者是你自己开发的 WSGI 框架) 开发的基础的 Web 应用。最棒的是不需要修改任何的服务器代码就可以与多个 Web 框架一起使用。目前看起来还不赖嘛。 在你离开前，这里有另一个问题需要你思考，”如何让你的服务器能够在同一时刻处理多个请求？“ 敬请期待，在 第三部分 我将向你展示一种方法。加油！",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://mozillazg.com"
        }
    }
    </script>

</head>
<body>

<div class="navbar" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://mozillazg.com/" class="navbar-brand">
Huang Huang 的博客            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="https://mozillazg.com/feeds/all.atom.xml">Feed</a></li>
                    <li><a href="/2014/10/pages/about-me.html">About</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://mozillazg.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content" class="yue">
        <article>
            <header class="text-center">
                <h1>
                    <a href="https://mozillazg.com/2015/06/let-us-build-a-web-server-part-2-zh-cn.html"
                       rel="bookmark"
                       title="Permalink to 让我们一起来构建一个 Web 服务器（二）">
                        让我们一起来构建一个 Web 服务器（二）
                    </a>
                </h1>
                <p class="published">
                    <time datetime="2015-06-06T00:00:00+00:00">
                    2015-06-06
                    </time>
                </p>
            </header>
            <div class="entry-content">
                <div class="well-sm article-info">
<footer class="post-info">
        <a href="https://mozillazg.com/category/python.html">python</a>


<span class="label label-default hide">Tags</span>
	<a href="https://mozillazg.com/tag/let-us-build.html">let-us-build</a>
        /
	<a href="https://mozillazg.com/tag/server.html">server</a>
        /
	<a href="https://mozillazg.com/tag/http.html">http</a>
        /
	<a href="https://mozillazg.com/tag/wsgi.html">wsgi</a>
        /
	<a href="https://mozillazg.com/tag/lsbaws.html">lsbaws</a>
        /
	<a href="https://mozillazg.com/tag/rang-wo-men-yi-qi-lai-gou-jian-yi-ge-web-fu-wu-qi.html">让我们一起来构建一个 Web 服务器</a>
    
</footer><!-- /.post-info -->                </div>
                <div class="js-toc"></div>
                <div>
                <p>本文译自：<a class="reference external" href="http://ruslanspivak.com/lsbaws-part2/">http://ruslanspivak.com/lsbaws-part2/</a></p>
<p>还记得吗？在 <a class="reference external" href="http://mozillazg.com/2015/06/let-us-build-a-web-server-part-1-zh-cn.html">第一部分</a> 我向你问了一个问题：”如何在你新鲜出炉的 Web 服务器上不做任何修改的就运行 Django 应用，Flask 应用， Pyramid 应用?“
往下读就可以找到答案。</p>
<p>在过去，当你选择的 Python Web 框架会限制你所能选择的 Web 服务器, 如果那个框架和服务器被设计的可以一起工作的话，那就皆大欢喜了：</p>
<p><img alt="Server Framework Fit" src="/static/images/lsbaws-part2/lsbaws_part2_before_wsgi.png" /></p>
<p>但是，当你尝试把一个服务器和一个框架一起使用的时候可能会（可能你已经）面临它们被设计为不兼容的情况：</p>
<p><img alt="Server Framework Clash" src="/static/images/lsbaws-part2/lsbaws_part2_after_wsgi.png" /></p>
<p>一般来说你必须使用能够一起工作的组件而不仅仅是你想使用的组件。</p>
<p>那么，你如何确保你能够在你的 Web 服务器上运行多个 Web 框架，并且不需要修改 Web 服务器或 Web 框架的现有的代码呢？
解决这个问题的答案就是 Python Web Server Gateway Interface (或简称 WSGI , 读作 “wizgy”)</p>
<p><img alt="WSGI Interface" src="/static/images/lsbaws-part2/lsbaws_part2_wsgi_idea.png" /></p>
<p><a class="reference external" href="https://www.python.org/dev/peps/pep-0333/">WSGI</a> 允许开发者自由选择 Web 框架和 Web 服务器。现在你可以任意混搭不同的 Web 服务器和 Web 框架，并选择一个你需要的合适的组合。
比如，你可以 用 <a class="reference external" href="http://gunicorn.org/">Gunicorn</a> or <a class="reference external" href="http://uwsgi-docs.readthedocs.org/">Nginx/uWSGI</a> or <a class="reference external" href="http://waitress.readthedocs.org/">Waitress</a> 运行 <a class="reference external" href="https://www.djangoproject.com/">Django</a>, <a class="reference external" href="http://flask.pocoo.org/">Flask</a>, 或 <a class="reference external" href="http://trypyramid.com/">Pyramid</a> .
真正的随意混搭，感谢那些服务器和框架对 WSGI 的支持：</p>
<p><img alt="Mix &amp; Match" src="/static/images/lsbaws-part2/lsbaws_part2_wsgi_interop.png" /></p>
<p>因此，<a class="reference external" href="https://www.python.org/dev/peps/pep-0333/">WSGI</a> 就是我在 <a class="reference external" href="http://mozillazg.com/2015/06/let-us-build-a-web-server-part-1-zh-cn.html">第一部分</a> 向你问的并在文章开头重复过的问题的答案。
你的 Web 服务器必须实现 WSGI 接口的服务器端部分，
所有的现代 Python Web 框架都已经实现了 WSGI 接口的框架端部分，
这部分允许你不需要修改你的服务器代码去适应某个特定的框架就可以使用这些框架。</p>
<p>现在你已经知道了被 Web 服务器和 Web 框架所支持的 WSGI 允许你选择适合你的组合，
它同样也对服务器和框架的开发者有益，因为他们可以专注于标准中他们各自的区域，不会出现因为越界而踩到对方的脚趾。
其他语言也有类似的接口：例如，Java 有 <a class="reference external" href="http://en.wikipedia.org/wiki/Java_servlet">Servlet API</a>，Ruby 有 <a class="reference external" href="http://en.wikipedia.org/wiki/Rack_%28web_server_interface%29">Rack</a>.</p>
<p>一切都很棒，但是我猜你会说”Show me the code!“，好吧，一起来看看下面这个非常简约的 WSGI 服务器实现吧：</p>
<div class="highlight"><pre><span></span><span class="c1"># Tested with Python 2.7.9, Linux &amp; Mac OS X</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">StringIO</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="k">class</span> <span class="nc">WSGIServer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">address_family</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span>
    <span class="n">socket_type</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span>
    <span class="n">request_queue_size</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">server_address</span><span class="p">):</span>
        <span class="c1"># Create a listening socket</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listen_socket</span> <span class="o">=</span> <span class="n">listen_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">address_family</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">socket_type</span>
        <span class="p">)</span>
        <span class="c1"># Allow to reuse the same address</span>
        <span class="n">listen_socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Bind</span>
        <span class="n">listen_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
        <span class="c1"># Activate</span>
        <span class="n">listen_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">request_queue_size</span><span class="p">)</span>
        <span class="c1"># Get server host name and port</span>
        <span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listen_socket</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server_name</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">getfqdn</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server_port</span> <span class="o">=</span> <span class="n">port</span>
        <span class="c1"># Return headers set by Web framework/Web application</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">headers_set</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">set_app</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">application</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">application</span> <span class="o">=</span> <span class="n">application</span>

    <span class="k">def</span> <span class="nf">serve_forever</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">listen_socket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listen_socket</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c1"># New client connection</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">client_connection</span><span class="p">,</span> <span class="n">client_address</span> <span class="o">=</span> <span class="n">listen_socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
            <span class="c1"># Handle one request and close the client connection. Then</span>
            <span class="c1"># loop over to wait for another client connection</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle_one_request</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">handle_one_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">request_data</span> <span class="o">=</span> <span class="n">request_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_connection</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
        <span class="c1"># Print formatted request data a la &#39;curl -v&#39;</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s1">&#39;&lt; {line}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">request_data</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parse_request</span><span class="p">(</span><span class="n">request_data</span><span class="p">)</span>

        <span class="c1"># Construct environment dictionary using request data</span>
        <span class="n">env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_environ</span><span class="p">()</span>

        <span class="c1"># It&#39;s time to call our application callable and get</span>
        <span class="c1"># back a result that will become HTTP response body</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">application</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_response</span><span class="p">)</span>

        <span class="c1"># Construct a response and send it back to the client</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finish_response</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">request_line</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">request_line</span> <span class="o">=</span> <span class="n">request_line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># Break down the request line into components</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">request_method</span><span class="p">,</span>  <span class="c1"># GET</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>            <span class="c1"># /hello</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">request_version</span>  <span class="c1"># HTTP/1.1</span>
         <span class="p">)</span> <span class="o">=</span> <span class="n">request_line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_environ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">env</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># The following code snippet does not follow PEP8 conventions</span>
        <span class="c1"># but it&#39;s formatted the way it is for demonstration purposes</span>
        <span class="c1"># to emphasize the required variables and their values</span>
        <span class="c1">#</span>
        <span class="c1"># Required WSGI variables</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;wsgi.version&#39;</span><span class="p">]</span>      <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;wsgi.url_scheme&#39;</span><span class="p">]</span>   <span class="o">=</span> <span class="s1">&#39;http&#39;</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;wsgi.input&#39;</span><span class="p">]</span>        <span class="o">=</span> <span class="n">StringIO</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">request_data</span><span class="p">)</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;wsgi.errors&#39;</span><span class="p">]</span>       <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;wsgi.multithread&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="bp">False</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;wsgi.multiprocess&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;wsgi.run_once&#39;</span><span class="p">]</span>     <span class="o">=</span> <span class="bp">False</span>
        <span class="c1"># Required CGI variables</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;REQUEST_METHOD&#39;</span><span class="p">]</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_method</span>    <span class="c1"># GET</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;PATH_INFO&#39;</span><span class="p">]</span>         <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>              <span class="c1"># /hello</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;SERVER_NAME&#39;</span><span class="p">]</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">server_name</span>       <span class="c1"># localhost</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;SERVER_PORT&#39;</span><span class="p">]</span>       <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">server_port</span><span class="p">)</span>  <span class="c1"># 8888</span>
        <span class="k">return</span> <span class="n">env</span>

    <span class="k">def</span> <span class="nf">start_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c1"># Add necessary server headers</span>
        <span class="n">server_headers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;Date&#39;</span><span class="p">,</span> <span class="s1">&#39;Tue, 31 Mar 2015 12:54:48 GMT&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Server&#39;</span><span class="p">,</span> <span class="s1">&#39;WSGIServer 0.2&#39;</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">headers_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span> <span class="o">+</span> <span class="n">server_headers</span><span class="p">]</span>
        <span class="c1"># To adhere to WSGI specification the start_response must return</span>
        <span class="c1"># a &#39;write&#39; callable. We simplicity&#39;s sake we&#39;ll ignore that detail</span>
        <span class="c1"># for now.</span>
        <span class="c1"># return self.finish_response</span>

    <span class="k">def</span> <span class="nf">finish_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers_set</span>
            <span class="n">response</span> <span class="o">=</span> <span class="s1">&#39;HTTP/1.1 {status}</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="n">status</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="n">response_headers</span><span class="p">:</span>
                <span class="n">response</span> <span class="o">+=</span> <span class="s1">&#39;{0}: {1}</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">header</span><span class="p">)</span>
            <span class="n">response</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span>
            <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">response</span> <span class="o">+=</span> <span class="n">data</span>
            <span class="c1"># Print formatted response data a la &#39;curl -v&#39;</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="s1">&#39;&gt; {line}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
            <span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">client_connection</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">client_connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="n">SERVER_ADDRESS</span> <span class="o">=</span> <span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">8888</span>


<span class="k">def</span> <span class="nf">make_server</span><span class="p">(</span><span class="n">server_address</span><span class="p">,</span> <span class="n">application</span><span class="p">):</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">WSGIServer</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">set_app</span><span class="p">(</span><span class="n">application</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">server</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Provide a WSGI application object as module:callable&#39;</span><span class="p">)</span>
    <span class="n">app_path</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">module</span><span class="p">,</span> <span class="n">application</span> <span class="o">=</span> <span class="n">app_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
    <span class="n">module</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="n">application</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">application</span><span class="p">)</span>
    <span class="n">httpd</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="n">SERVER_ADDRESS</span><span class="p">,</span> <span class="n">application</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;WSGIServer: Serving HTTP on port {port} ...</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">port</span><span class="o">=</span><span class="n">PORT</span><span class="p">))</span>
    <span class="n">httpd</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</pre></div>
<p>上面的代码比 <a class="reference external" href="http://mozillazg.com/2015/06/let-us-build-a-web-server-part-1-zh-cn.html">第一部分</a> 的服务器代码更长，但是，为了让你能够理解而不至于陷入细节的泥潭中，它已经足够小了（只有不到 150 行）。
上面的服务器代码同样也能做更多的工作——它能运行用你上面所见的 Web 框架（<a class="reference external" href="http://trypyramid.com/">Pyramid</a>, <a class="reference external" href="http://flask.pocoo.org/">Flask</a>, <a class="reference external" href="https://www.djangoproject.com/">Django</a>, 或其他的 Python WSGI 框架）所写的基础 Web 应用，</p>
<p>不信？动手试一下吧。把上面的代码保存为 <tt class="docutils literal">webserver2.py</tt> 或者直接从 <a class="reference external" href="https://github.com/rspivak/lsbaws/blob/master/part2/webserver2.py">GitHub</a> 上下载下来。如果你不带任何参数就运行这个程序的话，它会向你抱怨，然后退出。</p>
<pre class="literal-block">
$ python webserver2.py
Provide a WSGI application object as module:callable
</pre>
<p>它真的非常想要服务你的 Web 应用，这是个非常有趣的开始。
为了能够运行这个服务器你只需要安装 Python 就可以了。
但是，为了运行用 <a class="reference external" href="http://trypyramid.com/">Pyramid</a>, <a class="reference external" href="http://flask.pocoo.org/">Flask</a>, 或 <a class="reference external" href="https://www.djangoproject.com/">Django</a> 开发的应用，你需要首先安装这些框架。
让我们来安装这三个框架吧。
我喜欢使用 <a class="reference external" href="https://virtualenv.pypa.io/">virtualenv</a>. 只需按照下面的步骤去创建并激活一个虚拟环境，然后就可以安装这三个框架了。</p>
<pre class="literal-block">
$ [sudo] pip install virtualenv
$ mkdir ~/envs
$ virtualenv ~/envs/lsbaws/
$ cd ~/envs/lsbaws/
$ ls
bin  include  lib
$ source bin/activate
(lsbaws) $ pip install pyramid
(lsbaws) $ pip install flask
(lsbaws) $ pip install django
</pre>
<p>到这一步的时候你需要创建一个 Web 应用。让我们先用 <a class="reference external" href="http://trypyramid.com/">Pyramid</a> 开始吧。把下面的代码保存为 <tt class="docutils literal">pyramidapp.py</tt>  并放到你之前所保存的 <tt class="docutils literal">webserver2.py</tt> 文件或直接从 <a class="reference external" href="https://github.com/rspivak/lsbaws/blob/master/part2/pyramidapp.py">GitHub</a> 所下载的文件所在目录（即：把 <tt class="docutils literal">pyramidapp.py</tt> 放在 <tt class="docutils literal">webserver2.py</tt> 所在目录）：</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>


<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span>
        <span class="s1">&#39;Hello world from Pyramid!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="n">content_type</span><span class="o">=</span><span class="s1">&#39;text/plain&#39;</span><span class="p">,</span>
    <span class="p">)</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;/hello&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="n">hello_world</span><span class="p">,</span> <span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">make_wsgi_app</span><span class="p">()</span>
</pre></div>
<p>现在，你可以准备用你自己的 Web 服务器来服务你的 Pyramid 应用了：</p>
<pre class="literal-block">
(lsbaws) $ python webserver2.py pyramidapp:app
WSGIServer: Serving HTTP on port 8888 ...
</pre>
<p>你只需告诉你的服务器从 python 模块 <tt class="docutils literal">pyramidapp</tt> 中载入一个可调用的 <tt class="docutils literal">app</tt> 对象，你的服务器现在已经准备好
接收请求并把它们转发给你的 Pyramid 应用了。
这个应用目前只处理了一个路由：<tt class="docutils literal">/hello</tt> 路由。
在你的浏览器中输入 <a class="reference external" href="http://localhost:8888/hello">http://localhost:8888/hello</a> 地址，然后按下回车键，注意返回的结果：</p>
<p><img alt="Pyramid" src="/static/images/lsbaws-part2/lsbaws_part2_browser_pyramid.png" /></p>
<p>你也可以在命令行中使用 <tt class="docutils literal">curl</tt> 命令来测试这个服务器：</p>
<pre class="literal-block">
$ curl -v http://localhost:8888/hello
...
</pre>
<p>检查服务器以及 <tt class="docutils literal">curl</tt> 打印到标准输出的内容。</p>
<p>现在轮到 <a class="reference external" href="http://flask.pocoo.org/">Flask</a> 了。让我们按照相同的步骤来操作。</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Response</span>
<span class="n">flask_app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="s1">&#39;flaskapp&#39;</span><span class="p">)</span>


<span class="nd">@flask_app.route</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span>
        <span class="s1">&#39;Hello world from Flask!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="n">mimetype</span><span class="o">=</span><span class="s1">&#39;text/plain&#39;</span>
    <span class="p">)</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">flask_app</span><span class="o">.</span><span class="n">wsgi_app</span>
</pre></div>
<p>把上面的代码保存为 <tt class="docutils literal">flaskapp.py</tt>  或从 <a class="reference external" href="https://github.com/rspivak/lsbaws/blob/master/part2/flaskapp.py">GitHub</a> 上下载，然后用以下方式运行服务器:</p>
<pre class="literal-block">
(lsbaws) $ python webserver2.py flaskapp:app
WSGIServer: Serving HTTP on port 8888 ...
</pre>
<p>现在在你的浏览器中输入 <a class="reference external" href="http://localhost:8888/hello">http://localhost:8888/hello</a> 然后按下回车键：</p>
<p><img alt="Flask" src="/static/images/lsbaws-part2/lsbaws_part2_browser_flask.png" /></p>
<p>再一次，尝试 <tt class="docutils literal">curl</tt> 命令，然后看一下服务器返回的由这个 Flask 应用所生成的信息：</p>
<pre class="literal-block">
$ curl -v http://localhost:8888/hello
...
</pre>
<p>这个服务器能处理 <a class="reference external" href="https://www.djangoproject.com/">Django</a> 应用吗啊？试一下就知道了！
这次涉及的东西有点复杂，我建议你克隆这个 <a class="reference external" href="https://github.com/rspivak/lsbaws/">仓库</a> 然后使用  GitHub 仓库 中的 <a class="reference external" href="https://github.com/rspivak/lsbaws/blob/master/part2/djangoapp.py">djangoapp.py</a> 文件。
下面的源码主要是添加 Django <tt class="docutils literal">helloworld</tt> 项目（预先使用 Django 的 <tt class="docutils literal"><span class="pre">django-admin.py</span> startproject</tt> 命令）到当前 Python 路径
然后导入项目中的 WSGI 应用。</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;./helloworld&#39;</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">helloworld</span> <span class="kn">import</span> <span class="n">wsgi</span>


<span class="n">app</span> <span class="o">=</span> <span class="n">wsgi</span><span class="o">.</span><span class="n">application</span>
</pre></div>
<p>把上面的代码保存为 <tt class="docutils literal">djangoapp.py</tt>  然后用你的 Web 服务器运行这个 Django 应用：</p>
<pre class="literal-block">
(lsbaws) $ python webserver2.py djangoapp:app
WSGIServer: Serving HTTP on port 8888 ...
</pre>
<p>输入如下地址并回车：</p>
<p><img alt="Django" src="/static/images/lsbaws-part2/lsbaws_part2_browser_django.png" /></p>
<p>正如你之前做过的那几次一样，你也可以在命令行中进行测试。
确认这个 Django 应用处理了你这一次的请求：</p>
<pre class="literal-block">
$ curl -v http://localhost:8888/hello
...
</pre>
<p>你试过了吗？你有确认过这个服务器可以与这三个框架一起工作吗？
如果还没有的话，一定要试一下。
阅读很重要，但是这个系列讲的是关于重新构建，这意味着你需要手动进行这些尝试。
快去试试吧。别担心，我会等你的。
我是认真的，你必须去尝试，最好能够亲自一个字一个字的敲下所有的字符，
并确保它能达到预期的效果。</p>
<p>好了，你已经熟悉 WSGI 的威力了：它允许你混搭你的 Web 服务器和 Web 框架。
WSGI 规定了 Python Web 服务器和  Python Web 框架之间的一些接口。
它非常的简单，不管是在服务器还是框架端都非常容易实现。
下面的片段展示了服务器和框架端的接口：</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_application</span><span class="p">(</span><span class="n">application</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Server code.&quot;&quot;&quot;</span>
    <span class="c1"># This is where an application/framework stores</span>
    <span class="c1"># an HTTP status and HTTP response headers for the server</span>
    <span class="c1"># to transmit to the client</span>
    <span class="n">headers_set</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Environment dictionary with WSGI/CGI variables</span>
    <span class="n">environ</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">start_response</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">headers_set</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span><span class="p">]</span>

    <span class="c1"># Server invokes the ‘application&#39; callable and gets back the</span>
    <span class="c1"># response body</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">)</span>
    <span class="c1"># Server builds an HTTP response and transmits it to the client</span>
    <span class="err">…</span>

<span class="k">def</span> <span class="nf">app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A barebones WSGI app.&quot;&quot;&quot;</span>
    <span class="n">start_response</span><span class="p">(</span><span class="s1">&#39;200 OK&#39;</span><span class="p">,</span> <span class="p">[(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/plain&#39;</span><span class="p">)])</span>
    <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;Hello world!&#39;</span><span class="p">]</span>

<span class="n">run_application</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
</pre></div>
<p>它的工作原理是这样的：</p>
<ol class="arabic simple">
<li>框架提供了一个 <tt class="docutils literal">application</tt> 可调用对象（WSGI 规范没有规定它应该如何被实现）</li>
<li>每当收到来自 HTTP 客户端的请求的时候，服务器就调用这个 <tt class="docutils literal">application</tt> 可调用对象。
它把一个包含 WSGI/CGI 变量的字典 <tt class="docutils literal">environ</tt> 和一个 <tt class="docutils literal">start_response</tt> 可调用对象作为参数传递给了 <tt class="docutils literal">application</tt> 可调用对象。</li>
<li>框架/应用生成一个 HTTP 状态信息和 HTTP 响应头信息，并把它们传递给了 <tt class="docutils literal">start_response</tt> 可调用对象，
让服务器把它们存起来。框架/应用也返回了一个响应 body 信息。</li>
<li>服务器把状态信息，响应头信息以及响应 body 信息合并为一个 HTTP 响应，然后把它传输给客户端（这一步不是规范的一部分，
但是它是流程中的下一个逻辑步骤，为了清晰可见我把它列在了这里）</li>
</ol>
<p>下面是这个接口的可视化图表：</p>
<p><img alt="WSGI Interface Visual" src="/static/images/lsbaws-part2/lsbaws_part2_wsgi_interface.png" /></p>
<p>到目前位置，你已经见过了 <a class="reference external" href="http://trypyramid.com/">Pyramid</a>, <a class="reference external" href="http://flask.pocoo.org/">Flask</a> 以及 <a class="reference external" href="https://www.djangoproject.com/">Django</a> Web 应用，你也见过了实现 WSGI 规范的服务器端代码。
你也见过不用任何框架所实现的极简 WSGI 应用的代码片段。</p>
<p>事实是，当你用这些框架中某个开发一个 Web 应用的时候，你是在高层面进行工作，
并没有直接与 WSGI 打交到，但是我知道非常好奇框架端的 WSGI 接口实现，也是因为你正在阅读这篇文章。
那么，让我们来创建一个不使用 <a class="reference external" href="http://trypyramid.com/">Pyramid</a>, <a class="reference external" href="http://flask.pocoo.org/">Flask</a>, <a class="reference external" href="https://www.djangoproject.com/">Django</a> 的微型 WSGI Web 应用/Web 框架，
并用你的服务器来运行它：</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">app</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A barebones WSGI application.</span>

<span class="sd">    This is a starting point for your own Web framework :)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">status</span> <span class="o">=</span> <span class="s1">&#39;200 OK&#39;</span>
    <span class="n">response_headers</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;Content-Type&#39;</span><span class="p">,</span> <span class="s1">&#39;text/plain&#39;</span><span class="p">)]</span>
    <span class="n">start_response</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;Hello world from a simple WSGI application!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">]</span>
</pre></div>
<p>再一次的，把上面的代码保存为 <tt class="docutils literal">wsgiapp.py</tt> 或直接从 <a class="reference external" href="https://github.com/rspivak/lsbaws/blob/master/part2/wsgiapp.py">GitHub</a> 上下载它，然后用你的
Web 服务器像下面这样运行这个应用：</p>
<pre class="literal-block">
(lsbaws) $ python webserver2.py wsgiapp:app
WSGIServer: Serving HTTP on port 8888 ...
</pre>
<p>输入如下地址并按下回车键。你应该会看到这样的结果：</p>
<p><img alt="Simple WSGI Application" src="/static/images/lsbaws-part2/lsbaws_part2_browser_simple_wsgi_app.png" /></p>
<p>在学习如何创建一个 Web 服务器的同时，你刚刚又写了一个你自己的微型 WSGI WEB 框架！
真是意外之喜！</p>
<p>现在，让我们回到服务器都给客户端传输了什么东西。
下面是当你使用 HTTP 客户端调用你的 Pyramind 应用时，服务器生成的 HTTP 响应：</p>
<p><img alt="HTTP Response Part 1" src="/static/images/lsbaws-part2/lsbaws_part2_http_response.png" /></p>
<p>这个响应有一些你在 <a class="reference external" href="http://mozillazg.com/2015/06/let-us-build-a-web-server-part-1-zh-cn.html">第一部分</a> 看到过的东西，但是它也有一些新东西。比如说，它有四个你之前还没见过的 <a class="reference external" href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields">HTTP headers</a>：
<tt class="docutils literal"><span class="pre">Content-Type</span></tt> , <tt class="docutils literal"><span class="pre">Content-Length</span></tt> , <tt class="docutils literal">Date</tt> 以及 <tt class="docutils literal">Server</tt> .
这些包含在响应里的头信息是一个 Web 服务器应该要生成的信息。
虽然它们中没有一个是严格要求必须提供的。
这些头信息的目的是传输关于 HTTP 请求/响应的附加信息。</p>
<p>现在你已经了解了关于 WSGI 接口的更详细的信息了，下面是同一个 HTTP 响应部分是如何产生的更详细的信息：</p>
<p><img alt="HTTP Response Part 2" src="/static/images/lsbaws-part2/lsbaws_part2_http_response_explanation.png" /></p>
<p>我还没有说过任何有关 <tt class="docutils literal">environ</tt> 字典相关的信息，但是，基本上就是它是一个 Python 字典，它必须包含某些由 WSGI 规范所规定的 WSGI 和 CGI 变量。
解析完请求信息后，服务器从 HTTP 请求中得到这个字典所需的一些值。
这个字典看起来像下面这样：</p>
<p><img alt="Environ Python Dictionary" src="/static/images/lsbaws-part2/lsbaws_part2_environ.png" /></p>
<p>Web 框架使用来自这个字典里的信息来决定那个 view 可以被用来服务，基于获得的路由，请求方法等信息,
决定可以从哪里读取请求的 body 信息以及哪里可以用来写入错误信息，如果有的话。</p>
<p>到目前为止，你已经创建了你自己的 WSGI Web 服务器，你也用不同的 Web 框架编写过 Web 应用了。同时，你也顺便创建过极其简陋的 Web 应用/Web 框架。
真是一个操蛋的旅程。让我们来重述一下为了服务一个针对 WSGI 应用的请求信息，你的 WSGI Web 框架需要做的事情：</p>
<ol class="arabic simple">
<li>首先，服务器启动并载入一个由你的 Web 框架/应用所定义的 <tt class="docutils literal">application</tt> 可调用对象</li>
<li>然后，服务器读取一个请求</li>
<li>然后，服务器解析这个请求</li>
<li>然后，服务器用这个请求数据构建了一个 <tt class="docutils literal">environ</tt> 字典</li>
<li>然后，服务器以 <tt class="docutils literal">environ</tt> 字典和一个 <tt class="docutils literal">start_response</tt> 可调用对象作为参数来调用 <tt class="docutils literal">application</tt> 对象，并获得一个返回的响应 body 。</li>
<li>然后，服务器用通过调用 <tt class="docutils literal">application</tt> 对象获得的 body 数据以及通过 <tt class="docutils literal">start_reponse</tt> 可调用对象设置的状态信息和响应头信息一起构建了一个 HTTP 响应。</li>
<li>最后，服务器把 HTTP 响应传输回客户端</li>
</ol>
<p><img alt="Server Summary" src="/static/images/lsbaws-part2/lsbaws_part2_server_summary.png" /></p>
<p>就这些了。你现在有了一个可以工作的 WSGI 服务器，它能够服务那些用 WSGI 兼容的 Web 框架（比如：<a class="reference external" href="https://www.djangoproject.com/">Django</a>, <a class="reference external" href="http://flask.pocoo.org/">Flask</a>, <a class="reference external" href="http://trypyramid.com/">Pyramid</a> 或者是你自己开发的 WSGI 框架) 开发的基础的 Web 应用。最棒的是不需要修改任何的服务器代码就可以与多个 Web 框架一起使用。目前看起来还不赖嘛。</p>
<p>在你离开前，这里有另一个问题需要你思考，”如何让你的服务器能够在同一时刻处理多个请求？“</p>
<p>敬请期待，在 <a class="reference external" href="http://mozillazg.com/2015/08/let-us-build-a-web-server-part-3-zh-cn.html">第三部分</a> 我将向你展示一种方法。加油！</p>

                </div>
            </div>
            <!-- /.entry-content -->
<section class="text-center">
  
<div id="donate"></div>

<div class="social-share"></div>
<div class="social-comment-note">
<p>有任何建议和想法欢迎在下方评论区留言或者加我<a href="/static/wechat.png">微信</a>交流</p>
</div>

</section>
<section class="well" id="related-posts">
    <p>Related Posts:</p>
    <ul>
        <li><a href="https://mozillazg.com/2015/08/let-us-build-a-web-server-part-3-zh-cn.html">让我们一起来构建一个 Web 服务器（三）</a></li>
        <li><a href="https://mozillazg.com/2015/06/let-us-build-a-web-server-part-1-zh-cn.html">让我们一起来构建一个 Web 服务器（一）</a></li>
        <li><a href="https://mozillazg.com/2016/06/let-us-build-a-template-engine-part4.html">让我们一起来构建一个模板引擎（四）</a></li>
        <li><a href="https://mozillazg.com/2015/08/tujie-http-note.html">《图解 HTTP》阅读笔记</a></li>
        <li><a href="https://mozillazg.com/2016/03/let-us-build-a-template-engine-part1.html">让我们一起来构建一个模板引擎（一）</a></li>
    </ul>
</section>
    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'my-github-blog'; // required: replace example with your forum shortname

                    var disqus_identifier = 'let-us-build-a-web-server-part-2-zh-cn';
                var disqus_url = 'https://mozillazg.com/2015/06/let-us-build-a-web-server-part-2-zh-cn.html';

            var disqus_config = function () {
                this.language = "zh-hans";
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2021 mozillazg
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>              <p><small>  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/static/images/by-sa-80x15.png" /></a>
    &quot;<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Huang Huang 的博客</span>&quot; by <a xmlns:cc="http://creativecommons.org/ns#" href="https://mozillazg.com" property="cc:attributionName" rel="cc:attributionURL">mozillazg</a> is
  licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="https://cdn.jsdelivr.net/npm/jquery@2.1.1/dist/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->

    <!-- Disqus -->
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'my-github-blog'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script');
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <!-- End Disqus Code -->
    <!-- Google Analytics Universal -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-77172981-1', 'auto');
        ga('send', 'pageview');
    </script>
    <!-- End Google Analytics Universal Code -->

<!-- share.js -->
<script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>



<script src="https://cdn.jsdelivr.net/npm/tocbot@3.0.2/dist/tocbot.min.js"></script>
<script>
$(document).ready(function(){
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.js-toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.entry-content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h2, h3, h4,h5',
    // Headings that match the ignoreSelector will be skipped.
    ignoreSelector: '.js-toc-ignore',
    // Main class to add to links.
    linkClass: 'toc-link',
    // Extra classes to add to links.
    extraLinkClasses: '',
    // Class to add to active links,
    // the link corresponding to the top most heading on the page.
    activeLinkClass: 'is-active-link',
    // Main class to add to lists.
    listClass: 'toc-list',
    // Extra classes to add to lists.
    extraListClasses: '',
    // Class that gets added when a list should be collapsed.
    isCollapsedClass: 'is-collapsed',
    // Class that gets added when a list should be able
    // to be collapsed but isn't necessarily collpased.
    collapsibleClass: 'is-collapsible',
    // Class to add to list items.
    listItemClass: 'toc-list-item',
    // How many heading levels should not be collpased.
    // For example, number 6 will show everything since
    // there are only 6 heading levels and number 0 will collpase them all.
    // The sections that are hidden will open
    // and close as you scroll to headings within them.
    collapseDepth: 6,
    // Smooth scrolling enabled.
    smoothScroll: true,
    // Smooth scroll duration.
    smoothScrollDuration: 420,
    // Callback for scroll end (requires: smoothScroll).
    scrollEndCallback: function (e) {},
    // Headings offset between the headings and the top of the document (this is meant for minor adjustments).
    headingsOffset: 0,
    // Timeout between events firing to make sure it's
    // not too rapid (for performance reasons).
    throttleTimeout: 50,
    // Element to add the positionFixedClass to.
    positionFixedSelector: null,
    // Fixed position class to add to make sidebar fixed after scrolling
    // down past the fixedSidebarOffset.
    positionFixedClass: 'is-position-fixed',
    // fixedSidebarOffset can be any number but by default is set
    // to auto which sets the fixedSidebarOffset to the sidebar
    // element's offsetTop from the top of the document on init.
    fixedSidebarOffset: 'auto',
    // includeHtml can be set to true to include the HTML markup from the
    // heading node instead of just including the textContent.
    includeHtml: false
  });
});
</script>
</body>
</html>