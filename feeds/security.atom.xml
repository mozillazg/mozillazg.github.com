<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Huang Huang 的博客</title><link href="https://mozillazg.com/" rel="alternate"></link><link href="https://mozillazg.com/feeds/security.atom.xml" rel="self"></link><id>https://mozillazg.com/</id><updated>2021-12-12T00:00:00+00:00</updated><entry><title>Github Action 的 context 功能容易被攻击者利用实施脚本注入攻击</title><link href="https://mozillazg.com/2021/12/security-script-injection-attack-via-github-action-context.html" rel="alternate"></link><updated>2021-12-12T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2021-12-12:2021/12/security-script-injection-attack-via-github-action-context.html</id><summary type="html">&lt;p&gt;Github Action 提供了一个叫 &lt;a class="reference external" href="https://docs.github.com/en/actions/learn-github-actions/contexts"&gt;context&lt;/a&gt; 的功能，通过 context 可以在 workflow 中应用当前仓库、当前 job 等等
上下文 metadata 信息，其中通过 &lt;a class="reference external" href="https://docs.github.com/en/actions/learn-github-actions/contexts#github-context"&gt;github context&lt;/a&gt; 可以获取当前 workflow 的运行信息，比如分支名称、issue/PR 标题，
commit id, issue/PR message 等等。&lt;/p&gt;
&lt;p&gt;github context 获取到的很多信息其实是第三方控制的信息，
比如贡献者通过 PR 触发 CI 时，github context 中的很多信息就是贡献者提交 PR
的那个贡献者所控制的分支的相关信息。&lt;/p&gt;
&lt;p&gt;基于 github context 的这个特点，攻击者可以通过 PR 流程来实施脚本注入攻击。
比如，攻击者可以通过构造一个 shell 语句作为一个分支的名称，然后提交 PR 以触发 CI，
如果 CI 中 github action workflow 有直接在 shell 命令中使用分支名的逻辑话，
就会触发执行攻击者构造的 shell 语句的操作，攻击者就成功实施了脚本注入攻击。&lt;/p&gt;
&lt;p&gt;下面演示一个在 github action 中会存在脚本注入攻击问题的 workflow 语法的例子：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
- name: test
  run: |
    echo 'show branch name: '
    echo &amp;quot;${{ github.ref_name }}&amp;quot;
&lt;/pre&gt;
&lt;p&gt;上面这个 run 指令中，通过 echo 输出了执行当前 workflow 的分支名称，看起来没啥问题。
但是，但我创建一个名为 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;$(ls$IFS$(echo$IFS'UkVBRE1FLm1kCg=='|base64$IFS'-d'))&lt;/span&gt;&lt;/tt&gt; 的分支
然后在这个分支下触发 workflow 的时候， 结果就会跟预期的不一样了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/static/images/security/github-action-script-injection.png" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;参考资料&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#understanding-the-risk-of-script-injections"&gt;Security hardening for GitHub Actions - GitHub Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://python-security.readthedocs.io/pypi-vuln/index-2021-07-27-combine-prs-workflow.html"&gt;Vulnerability in GitHub Actions workflow for PyPI — Python Security 0.0 documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary></entry><entry><title>通过向 DNS 服务发送 SRV 查询请求获取 kubernetes 集群内所有 Service 信息</title><link href="https://mozillazg.com/2021/11/security-use-dns-srv-to-get-all-service-info.html" rel="alternate"></link><updated>2021-11-14T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2021-11-14:2021/11/security-use-dns-srv-to-get-all-service-info.html</id><summary type="html">&lt;p&gt;coredns 的 &lt;a class="reference external" href="https://github.com/coredns/coredns/blob/v1.8.6/plugin/kubernetes/README.md#wildcards"&gt;Wildcards&lt;/a&gt; 功能能够让我们通过一个简单的 SRV 查询就可以获取到整个 kubernetes 集群内的所有 service 信息。&lt;/p&gt;
&lt;p&gt;获取 service 和对应的 service ip 和端口信息（其中 &lt;tt class="docutils literal"&gt;*&lt;/tt&gt; 可以替换为 &lt;tt class="docutils literal"&gt;any&lt;/tt&gt; ）：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ dig srv *.*.svc.cluster.local

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.16.20 &amp;lt;&amp;lt;&amp;gt;&amp;gt; srv *.*.svc.cluster.local
;; global options: +cmd
;; Got answer:
;; WARNING: .local is reserved for Multicast DNS
;; You are currently testing what happens when an mDNS query is leaked to DNS
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 41570
;; flags: qr aa rd; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 4
;; WARNING: recursion requested but not available

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: 54380f3a1b0cb590 (echoed)
;; QUESTION SECTION:
;*.*.svc.cluster.local.             IN      SRV

;; ANSWER SECTION:
*.*.svc.cluster.local.      30      IN      SRV     0 20 443 kubernetes.default.svc.cluster.local.
*.*.svc.cluster.local.      30      IN      SRV     0 20 53 kube-dns.kube-system.svc.cluster.local.
*.*.svc.cluster.local.      30      IN      SRV     0 20 9153 kube-dns.kube-system.svc.cluster.local.
*.*.svc.cluster.local.      30      IN      SRV     0 20 80 my-service.ns-1.svc.cluster.local.

;; ADDITIONAL SECTION:
my-service.ns-1.svc.cluster.local. 30 IN A  10.96.146.96
kube-dns.kube-system.svc.cluster.local.     30 IN A 10.96.0.10
kubernetes.default.svc.cluster.local. 30 IN A       10.96.0.1

;; Query time: 2 msec
;; SERVER: 10.96.0.10#53(10.96.0.10)
;; WHEN: Sun Nov 14 07:08:27 UTC 2021
;; MSG SIZE  rcvd: 526
&lt;/pre&gt;
&lt;p&gt;上面的 &lt;tt class="docutils literal"&gt;0 20 53 &lt;span class="pre"&gt;kube-dns.kube-system.svc.cluster.local.&lt;/span&gt;&lt;/tt&gt; 记录中，
&lt;tt class="docutils literal"&gt;53&lt;/tt&gt; 是端口信息， &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;kube-dns.kube-system.svc.cluster.local&lt;/span&gt;&lt;/tt&gt; 是
service 的域名其中包含了 service 名称、namspace 等信息:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ kubectl -n kube-system get svc kube-dns
NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE
kube-dns   ClusterIP   10.96.0.10   &amp;lt;none&amp;gt;        53/UDP,53/TCP,9153/TCP   92m
&lt;/pre&gt;
&lt;p&gt;获取 service 以及对应的 endpoints 信息:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ dig srv *.*.*.svc.cluster.local

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.16.20 &amp;lt;&amp;lt;&amp;gt;&amp;gt; srv *.*.*.svc.cluster.local
;; global options: +cmd
;; Got answer:
;; WARNING: .local is reserved for Multicast DNS
;; You are currently testing what happens when an mDNS query is leaked to DNS
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 55650
;; flags: qr aa rd; QUERY: 1, ANSWER: 5, AUTHORITY: 0, ADDITIONAL: 4
;; WARNING: recursion requested but not available

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: 8d5836f2b43e3675 (echoed)
;; QUESTION SECTION:
;*.*.*.svc.cluster.local.   IN      SRV

;; ANSWER SECTION:
*.*.*.svc.cluster.local. 30 IN      SRV     0 14 6443 172-18-0-3.kubernetes.default.svc.cluster.local.
*.*.*.svc.cluster.local. 30 IN      SRV     0 14 53 10-244-0-3.kube-dns.kube-system.svc.cluster.local.
*.*.*.svc.cluster.local. 30 IN      SRV     0 14 9153 10-244-0-3.kube-dns.kube-system.svc.cluster.local.
*.*.*.svc.cluster.local. 30 IN      SRV     0 14 53 10-244-0-4.kube-dns.kube-system.svc.cluster.local.
*.*.*.svc.cluster.local. 30 IN      SRV     0 14 9153 10-244-0-4.kube-dns.kube-system.svc.cluster.local.

;; ADDITIONAL SECTION:
10-244-0-4.kube-dns.kube-system.svc.cluster.local. 30 IN A 10.244.0.4
10-244-0-3.kube-dns.kube-system.svc.cluster.local. 30 IN A 10.244.0.3
172-18-0-3.kubernetes.default.svc.cluster.local. 30 IN A 172.18.0.3

;; Query time: 2 msec
;; SERVER: 10.96.0.10#53(10.96.0.10)
;; WHEN: Sun Nov 14 07:09:38 UTC 2021
;; MSG SIZE  rcvd: 715
&lt;/pre&gt;
&lt;p&gt;上面的 &lt;tt class="docutils literal"&gt;0 14 53 &lt;span class="pre"&gt;10-244-0-3.kube-dns.kube-system.svc.cluster.local.&lt;/span&gt;&lt;/tt&gt; 记录中
&lt;tt class="docutils literal"&gt;53&lt;/tt&gt; 是其中一个 endpoint 的端口信息， &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;10-244-0-3&lt;/span&gt;&lt;/tt&gt; 是 endpoint 的 ip 地址:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ kubectl -n kube-system describe svc kube-dns
Name:              kube-dns
Namespace:         kube-system
...
IP:                10.96.0.10
Port:              dns  53/UDP
TargetPort:        53/UDP
Endpoints:         10.244.0.3:53,10.244.0.4:53
Port:              dns-tcp  53/TCP
TargetPort:        53/TCP
Endpoints:         10.244.0.3:53,10.244.0.4:53
Port:              metrics  9153/TCP
TargetPort:        9153/TCP
Endpoints:         10.244.0.3:9153,10.244.0.4:9153
...
&lt;/pre&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;参考资料&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/coredns/coredns/blob/v1.8.6/plugin/kubernetes/README.md#wildcards"&gt;coredns/README.md at v1.8.6 · coredns/coredns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/"&gt;DNS for Services and Pods | Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="kubernetes"></category><category term="coredns"></category><category term="dns"></category></entry><entry><title>IP 地址解析库的不同实现导致应用存在安全隐患</title><link href="https://mozillazg.com/2021/10/security-ipaddress-risk-with-leading-zeros.html" rel="alternate"></link><updated>2021-10-07T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2021-10-07:2021/10/security-ipaddress-risk-with-leading-zeros.html</id><summary type="html">&lt;p&gt;先来看一个例子，对于 &lt;tt class="docutils literal"&gt;0177.0.0.1&lt;/tt&gt; 这个 IP 地址不同的程序会解析出不同的结果：&lt;/p&gt;
&lt;p&gt;curl&lt;/p&gt;
&lt;pre class="literal-block"&gt;
curl 0177.0.0.1 -v
* Rebuilt URL to: 0177.0.0.1/
*   Trying 177.0.0.1...
* TCP_NODELAY set
&lt;/pre&gt;
&lt;p&gt;ping&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ping 0177.0.0.1
PING 0177.0.0.1 (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.059 ms
64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.084 ms
^C
&lt;/pre&gt;
&lt;p&gt;可以看到，对于 &lt;tt class="docutils literal"&gt;0177.0.0.1&lt;/tt&gt; 这个 IP 地址，
&lt;tt class="docutils literal"&gt;curl&lt;/tt&gt; 将它解析为 &lt;tt class="docutils literal"&gt;177.0.0.1&lt;/tt&gt; ，而 &lt;tt class="docutils literal"&gt;ping&lt;/tt&gt; 却解析为了 &lt;tt class="docutils literal"&gt;127.0.0.1&lt;/tt&gt; 。&lt;/p&gt;
&lt;p&gt;之所以会有这种不一样的结果，是因为对于应该如何解析 IP 地址中数字前面的 0 并没有一个统一的标准，
有的程序将这种情况标记为无效 IP ，有些程序将 &lt;tt class="docutils literal"&gt;0xx&lt;/tt&gt; 解析为 8 进制数字，有些程序将它解析为 10 进制数字。&lt;/p&gt;
&lt;p&gt;正因为存在这种不统一的情况，也就导致应用程序对 IP 地址的校验逻辑存在安全隐患。&lt;/p&gt;
&lt;p&gt;假设有一个服务的功能是访问用户输入的地址然后返回相应的响应信息，处于安全上的考虑，
会校验用户的输入，拦截访问服务内部 IP 的地址：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;用户输入 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;http://0177.0.0.1:8080/path/to/secret&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;服务端的校验程序使用的 IP 解析库将地址中包含的 IP 地址解析为 &lt;tt class="docutils literal"&gt;177.0.0.1&lt;/tt&gt; ，然后放行了该请求&lt;/li&gt;
&lt;li&gt;实际执行这个请求用户输入的服务，在请求这个地址时，使用的 IP 地址相关库将它解析为了 &lt;tt class="docutils literal"&gt;127.0.0.1&lt;/tt&gt; ，
此时就会存在安全隐患，导致出现了非预期的结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于 IP 黑名单的 ACL 或者过滤逻辑都有潜在的受这个问题影响的安全隐患， 这一问题的相关 CVE 可以参考【参考资料】中列出的部分 CVE 。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;参考资料&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://sick.codes/sick-2021-014/"&gt;CVE-2021-29921 - python stdlib &amp;quot;ipaddress&amp;quot; - Improper Input Validation of octal literals in python 3.8.0 thru v3.10 results in indeterminate SSRF &amp;amp; RFI vulnerabilities. - &amp;quot;ipaddress leading zeros in IPv4 address&amp;quot; - Sick Codes - Security Research, Hardware &amp;amp; Software Hacking, Consulting, Linux, IoT, Cloud, Embedded, Arch, Tweaks &amp;amp; Tips!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://sick.codes/sick-2021-015/"&gt;CVE-2021-29922 - rust standard library &amp;quot;net&amp;quot; - Improper Input Validation of octal literals in rust 1.52.0 std::net and below results in indeterminate SSRF &amp;amp; RFI vulnerabilities. - Sick Codes - Security Research, Hardware &amp;amp; Software Hacking, Consulting, Linux, IoT, Cloud, Embedded, Arch, Tweaks &amp;amp; Tips!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://sick.codes/sick-2021-016/"&gt;CVE-2021-29923 - golang standard library &amp;quot;net&amp;quot; - Improper Input Validation of octal literals in golang 1.16.2 and below standard library &amp;quot;net&amp;quot; results in indeterminate SSRF &amp;amp; RFI vulnerabilities. - Sick Codes - Security Research, Hardware &amp;amp; Software Hacking, Consulting, Linux, IoT, Cloud, Embedded, Arch, Tweaks &amp;amp; Tips!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-33571"&gt;CVE-2021-33571 – In Django 2.2 before 2.2.24, 3.x before 3.1.12, and 3.2 before 3.2.4, URLValidator, validate_ipv4_address, and validate_ipv46_address do not prohibit leading zero characters in octal literals. This may allow a bypass of access control that is based on IP addresses. (validate_ipv4_address and validate_ipv46_address are unaffected with Python 3.9.5+..) .&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12161"&gt;CVE-2019-12161 – CVE-2019-12161 WPO WebPageTest 19.04 allows SSRF because ValidateURL in www/runtest.php does not consider octal encoding of IP addresses (such as 0300.0250 as a replacement for 192.168).&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-4029"&gt;CVE-2016-4029 – WordPress before 4.5 does not consider octal and hexadecimal IP address formats when determining an intranet address, which allows remote attackers to bypass an intended SSRF protection mechanism via a crafted address.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://bugs.python.org/issue36384"&gt;Issue 36384: [security] CVE-2021-29921: ipaddress Should not reject IPv4 addresses with leading zeroes as ambiguously octal - Python tracker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/golang/go/issues/30999"&gt;net: reject leading zeros in IP address parsers [freeze exception] · Issue #30999 · golang/go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://johnjhacking.com/blog/cve-2020-28360/"&gt;cve-2020-28360 - John J Hacking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://sick.codes/universal-netmask-npm-package-used-by-270000-projects-vulnerable-to-octal-input-data-server-side-request-forgery-remote-file-inclusion-local-file-inclusion-and-more-cve-2021-28918/"&gt;Universal &amp;quot;netmask&amp;quot; npm package, used by 270,000+ projects, vulnerable to octal input data: server-side request forgery, remote file inclusion, local file inclusion, and more (CVE-2021-28918) - Sick Codes - Security Research, Hardware &amp;amp; Software Hacking, Consulting, Linux, IoT, Cloud, Embedded, Arch, Tweaks &amp;amp; Tips!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="安全"></category></entry><entry><title>通过给开源项目提交 PR 然后触发 CI 流程的方式获取敏感信息</title><link href="https://mozillazg.com/2021/10/security-the-way-of-sofeware-supply-chain-attack-via-pull-request.html" rel="alternate"></link><updated>2021-10-06T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2021-10-06:2021/10/security-the-way-of-sofeware-supply-chain-attack-via-pull-request.html</id><summary type="html">&lt;p&gt;开源项目的使用越来越广泛，各大公司和个人也积极的参与和开发了不同的开源项目。
同时开源项目的安全问题也越来越受到广泛的关注，其中即有开源项目代码方面的安全问题，
也有开源项目使用的第三方服务、开发流程导致的安全问题。&lt;/p&gt;
&lt;p&gt;这篇文章介绍的是 CI 流程中可能会出现的安全问题：攻击者可以通过给开源项目提交 PR 的方式获取项目开发流程中涉及的 CI 系统中的敏感信息。&lt;/p&gt;
&lt;p&gt;整个流程如下：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;攻击者 fork 目标开源项目仓库，修改仓库代码增加可以获取 CI 环境中敏感信息代码或者可以在 CI 环境中运行恶意脚本和软件的代码&lt;/li&gt;
&lt;li&gt;然后工具者将修改后的代码通过 Pull Request 的方式提交到上游项目中（不需要合并代码）&lt;/li&gt;
&lt;li&gt;一般上游项目在 PR 提交时都会触发项目中设置的 CI 流程，此时 CI 流程中就会运行攻击者修改好的恶意代码&lt;/li&gt;
&lt;li&gt;如果 CI 环境设置不当或者 CI 服务有安全隐患的话，攻击者就可以通过 CI job 窃取环境中的敏感信息（比如密码、token、ak、证书等信息）、 入侵整个 CI job 所在节点、整个 CI 服务甚至整个公司所有资产。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;相关案例可以阅读参考资料中最近爆出的几个安全事项。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;参考资料&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arstechnica.com/information-technology/2021/09/travis-ci-flaw-exposed-secrets-for-thousands-of-open-source-projects/"&gt;Travis CI flaw exposed secrets of thousands of open source projects | Ars Technica&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://goteleport.com/blog/hack-via-pull-request/"&gt;How to attack cloud infrastructure via a malicious pull request | Teleport&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="软件供应链安全"></category><category term="supply-chain-security"></category></entry><entry><title>binaryless 容器基础镜像</title><link href="https://mozillazg.com/2021/08/security-binaryless-base-image.html" rel="alternate"></link><updated>2021-08-01T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2021-08-01:2021/08/security-binaryless-base-image.html</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="https://mozillazg.com/2021/05/security-use-shell-less-and-binary-less-distroless-container-with-root-less-container.html"&gt;前面&lt;/a&gt; 说过会维护一个 binaryless 容器基础镜像的项目，这个基础镜像的项目今天正式发布第一个版本。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/mozillazg/binaryless"&gt;https://github.com/mozillazg/binaryless&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前提供如下基础镜像:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
* binaryless/alpine:3.13
* binaryless/debian:10
&lt;/pre&gt;
&lt;p&gt;每个基础镜像都是多架构镜像，支持如下架构&lt;/p&gt;
&lt;pre class="literal-block"&gt;
linux/amd64, linux/arm, linux/arm64, linux/ppc64le, linux/s390x
&lt;/pre&gt;
&lt;p&gt;更多信息详见项目 README，欢迎大家试用。&lt;/p&gt;
</summary><category term="container"></category><category term="容器"></category><category term="容器安全"></category></entry><entry><title>shellless 容器、binaryless 容器以及 distroless 容器</title><link href="https://mozillazg.com/2021/05/security-use-shell-less-and-binary-less-distroless-container-with-root-less-container.html" rel="alternate"></link><updated>2021-05-30T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2021-05-30:2021/05/security-use-shell-less-and-binary-less-distroless-container-with-root-less-container.html</id><summary type="html">&lt;p&gt;大家可能对 rootless 容器有一定的了解，rootless 容器说的是不要以 root 用户启动容器，以便简单 限制一下容器内进程的权限，一方面更符合安全上对权限控制的要求，
另一方面也可以抵御部分容器逃逸问题。&lt;/p&gt;
&lt;p&gt;这里要介绍另一个容器安全方面的建议，那就是，应当尽可能的使用 shellless/shell-less 容器，
或使用 binaryless/binary-less 容器，甚至是使用 distroless 容器。&lt;/p&gt;
&lt;div class="section" id="shellless-shell-less"&gt;
&lt;h2 id="hidshellless-shell-less"&gt;shellless/shell-less 容器&lt;a class="headerlink" href="#hidshellless-shell-less" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;shellless 或者说 shell-less 容器， 顾名思义指的是 &lt;strong&gt;容器内不包含 shell&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;因为容器内不包含 shell，所以 shellless 容器可以免疫部分的 get shell 攻击和
部分利用任意命令执行漏洞进行的攻击以及其他依赖 shell 的攻击
（依赖 shell 的渗透攻击以及后渗透攻击）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="binaryless-binary-less"&gt;
&lt;h2 id="hidbinaryless-binary-less"&gt;binaryless/binary-less 容器&lt;a class="headerlink" href="#hidbinaryless-binary-less" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;binaryless 或者说 binary-less 容器，在 shellless 容器的基础上更进一步，
&lt;strong&gt;容器内不包含除用户业务程序外的任何其他二进制可执行文件和脚本&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;因为不包含任何额外的二进制可执行文件，所以 binaryless 容器比 shellless
容器能够免疫更多的利用任意命令执行漏洞进行的攻击以及其他依赖容器内有二进制执行文件的攻击。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="distroless"&gt;
&lt;h2 id="hiddistroless"&gt;distroless 容器&lt;a class="headerlink" href="#hiddistroless" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;distroless 容器在 binaryless 容器的基础上又跟进了一步，
&lt;strong&gt;容器内不包含除用户业务程序及业务程序的运行时依赖外的任何其他程序、库以及非必须的系统文件&lt;/strong&gt; ，&lt;/p&gt;
&lt;p&gt;因为只包含业务程序及其依赖，所以 distroless 容器又比 binaryless 容器能进一步提升容器安全性。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;实现方案&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;目前社区使用的一些容器方案可以实现 shellless 、 binaryless 或 distroless 容器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;一个是使用 &lt;tt class="docutils literal"&gt;scratch&lt;/tt&gt; 作为基础镜像，并且通过多阶段构建的方式 &lt;tt class="docutils literal"&gt;COPY&lt;/tt&gt; 业务所需的内容，类似下面这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; golang:1.16 as builder&lt;/span&gt;
&lt;span class="c"&gt;# ...&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; go build xxx

&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; scratch&lt;/span&gt;
COPY --from&lt;span class="o"&gt;=&lt;/span&gt;builder /path/to/buld-files  /path/to/save
&lt;span class="c"&gt;# ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;一个是使用 &lt;a class="reference external" href="https://github.com/GoogleContainerTools/distroless"&gt;https://github.com/GoogleContainerTools/distroless&lt;/a&gt; 项目提供的镜像作为基础镜像，并且通过多阶段构建的方式 &lt;tt class="docutils literal"&gt;COPY&lt;/tt&gt; 业务所需的内容，类似下面这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; golang:1.16 as builder&lt;/span&gt;
&lt;span class="c"&gt;# ...&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; go build xxx

&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; gcr.io/distroless/base-debian10&lt;/span&gt;
COPY --from&lt;span class="o"&gt;=&lt;/span&gt;builder /path/to/buld-files  /path/to/save
&lt;span class="c"&gt;# ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;还有就是使用 &lt;a class="reference external" href="https://github.com/docker-slim/docker-slim"&gt;docker-slim&lt;/a&gt; 工具对镜像做二次精简，删除不需要的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，也可以其他方法实现类似 &lt;tt class="docutils literal"&gt;scratch&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;gcr.io/distroless&lt;/tt&gt; 这样的 shellless 、 binaryless 或 distroless 的基础镜像，
然后按照类似上面的方法使用这些基础镜像来构建相应的业务镜像。&lt;/p&gt;
&lt;p&gt;大家下次构建镜像的时候，推荐构建一个 shellless 或 binaryless 的镜像，也可以尝试 distroless 镜像或者使用 docker-slim 工具对镜像进行二次精简。&lt;/p&gt;
&lt;p&gt;我后面也会根据自己的实践维护一个类似 &lt;a class="reference external" href="https://github.com/GoogleContainerTools/distroless"&gt;https://github.com/GoogleContainerTools/distroless&lt;/a&gt; 的项目，
提供一些 binaryless 的基础镜像，以及相应的各个场景下使用 binaryless 可能会面临的一些问题的可行的解决方法。&lt;/p&gt;
&lt;p&gt;更新：&lt;/p&gt;
&lt;p&gt;我维护的 binaryless 基础镜像项目地址： &lt;a class="reference external" href="https://github.com/mozillazg/binaryless"&gt;https://github.com/mozillazg/binaryless&lt;/a&gt;&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3 id="hidid2"&gt;参考资料&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://hub.docker.com/_/scratch"&gt;https://hub.docker.com/_/scratch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/GoogleContainerTools/distroless"&gt;https://github.com/GoogleContainerTools/distroless&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="container"></category><category term="容器"></category><category term="容器安全"></category></entry><entry><title>《浅析软件供应链攻击之包抢注低成本钓鱼》阅读笔记</title><link href="https://mozillazg.com/2021/04/security-the-way-of-sofeware-supply-chain-attack-notes-01.html" rel="alternate"></link><updated>2021-04-03T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2021-04-03:2021/04/security-the-way-of-sofeware-supply-chain-attack-notes-01.html</id><summary type="html">&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;前言&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文是 &lt;a class="reference external" href="https://mp.weixin.qq.com/s/JWSjKZWyuSvXdzYhU0INmQ"&gt;浅析软件供应链攻击之包抢注低成本钓鱼&lt;/a&gt;
这篇文章的阅读笔记。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;软件供应链攻击方法&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3 id="hidid4"&gt;产品开发阶段&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;源代码编译遭攻击污染：IDE 污染、日常开发和运维工具被入侵置入病毒和后门&lt;/li&gt;
&lt;li&gt;供应商预留后门：vpn、笔记本、chrome 插件等日常工具预置后门&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3 id="hidid5"&gt;产品分发阶段&lt;a class="headerlink" href="#hidid5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;捆绑下载，正常软件被捆绑了恶意代码&lt;/li&gt;
&lt;li&gt;下载劫持，包括官网下载链接遭替换、HTTP流量/域名劫持等中间人劫持、P2P缓存毒化劫持等&lt;/li&gt;
&lt;li&gt;依赖包抢注：抢注相似包名、抢注企业内部包名&lt;ul&gt;
&lt;li&gt;开发者没有及时到官方源注册包名，造成攻击者可以抢先注册&lt;/li&gt;
&lt;li&gt;开发者生成依赖配置文件引用了官方源不存在的包&lt;/li&gt;
&lt;li&gt;开发者包命名不够规范，造成使用者容易被误导&lt;/li&gt;
&lt;li&gt;使用者安装知名软件时，根据直觉直接敲打广为人知的名称，但实际上官方包另有其名&lt;/li&gt;
&lt;li&gt;使用者在使用命令行手敲安装包名时，漏敲或多敲或错敲个别字符，或不经意粘贴其他内容，造成安装恶意软件包&lt;/li&gt;
&lt;li&gt;开发者错误指引或使用者错误使用不安全的安装选项&lt;/li&gt;
&lt;li&gt;攻击者抢注包名的一些手段:&lt;ul&gt;
&lt;li&gt;分析官方源库全部包名称&lt;/li&gt;
&lt;li&gt;分析软件包的引用方式&lt;/li&gt;
&lt;li&gt;分析GitHub开源项目的名称、README.md、依赖关系文件&lt;/li&gt;
&lt;li&gt;挖掘网站泄露信息&lt;/li&gt;
&lt;li&gt;直接抢注知名软件名称、常见名词&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;物流链劫持，硬件产品（比如服务器、笔记本、U盘等）在物理运输过程中被调包或加料植入木马后门&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h3 id="hidid6"&gt;产品使用阶段&lt;a class="headerlink" href="#hidid6" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;升级更新劫持，包括官网升级程序被替换，HTTP流量/域名劫持等中间人劫持&lt;/li&gt;
&lt;li&gt;官方云控作恶，官方下发命令操控用户主机&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2 id="hidid7"&gt;软件供应链攻击应对防范措施&lt;a class="headerlink" href="#hidid7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3 id="hidid8"&gt;安全人员&lt;a class="headerlink" href="#hidid8" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;企业内部维护可信软件仓库，尽量减少企业人员从各种未知渠道下载软件。&lt;/li&gt;
&lt;li&gt;监测服务器和PC运行软件的异常操作和流量，甚至提前对软件进行沙盒检测，主动发现潜在隐患。&lt;/li&gt;
&lt;li&gt;全面梳理和维护企业在用软硬件信息，在供应链攻击曝光时做到快速止损定损。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h3 id="hidid9"&gt;开发人员&lt;a class="headerlink" href="#hidid9" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;使用官方渠道下载的IDE；软件分发及升级采用HTTPS等加密传输；避免内置远程控制能力；定期自检官网代码和执行程序是否存在恶意篡改。&lt;/li&gt;
&lt;li&gt;关于防范包抢注攻击：对于企业内部包，可以及时到PyPI/NPM/RubyGems等官方源注册包名（可以上传空包占位以免内部代码泄露），防止企业自身遭遇抢注攻击；对于开源包，也及时到官方源注册并上传最新代码，既方便用户也能防止用户遭遇攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h3 id="hidid10"&gt;使用人员&lt;a class="headerlink" href="#hidid10" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;始终保持任何外来软件都不是完全安全可信的态度，优先选择知名有口碑有安全意识的软件。&lt;/li&gt;
&lt;li&gt;关于防范包抢注攻击：安装软件时务必谨慎，按照官方指引确保安装方式正确，如命令行手敲命令时注意拼写准确，以防一不小心机器就成肉鸡。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="软件供应链安全"></category><category term="supply-chain-security"></category></entry><entry><title>软件供应链安全之软件依赖替代攻击</title><link href="https://mozillazg.com/2021/03/security-the-way-of-sofeware-supply-chain-attack-about-dependencies-substitution-attack.html" rel="alternate"></link><updated>2021-03-21T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2021-03-21:2021/03/security-the-way-of-sofeware-supply-chain-attack-about-dependencies-substitution-attack.html</id><summary type="html">&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;前言&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;记录一下软件供应链攻击中软件依赖的替代攻击方法。&lt;/p&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3 id="hidid3"&gt;替代攻击&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一般公司内都会开发一些内部依赖包，即项目的依赖中会即包括外部依赖包也包括内部依赖包。
公司内部的软件包索引系统一般会回源到上游系统（
公共包索引系统，比如 PyPI、npm，可能会使用多个上游，比如同时使用多个 mirror 和官方的索引系统）。&lt;/p&gt;
&lt;p&gt;替代攻击指的是攻击者在公共包索引系统中注册一个跟内部包同名/拼写相似的软件包，然后等待有人安装这个同名/拼写相似的软件包：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;比如恶意包版本特别高，如果项目中依赖的内部包未指定特定版本，在安装依赖时可能会出现回源/上翻从而安装了恶意包&lt;/li&gt;
&lt;li&gt;内部索引系统或上游系统删了某个软件包/版本，但是实际上还有项目在用，这些项目可能会因此安装上恶意包&lt;/li&gt;
&lt;li&gt;内部索引系统异常，出现了非预期的内部包回源现象&lt;/li&gt;
&lt;li&gt;有些包的名字非常容易出现拼写错误，安装时如果不注意的话，就容易安装上非预期的恶意包&lt;/li&gt;
&lt;li&gt;有些软件在索引系统中使用的包名字跟代码里实际使用的名字不一样，攻击者注册了这个代码里的这个名字&lt;/li&gt;
&lt;li&gt;回源到某个上游系统时，上游系统在某一时间段出现过域名过期，然后被攻击者抢注了域名&lt;/li&gt;
&lt;li&gt;恶意包虽然被上游系统删除了，但是内部系统中有缓存&lt;/li&gt;
&lt;li&gt;使用的上游系统被入侵，攻击者替换了系统中的软件包&lt;/li&gt;
&lt;li&gt;依赖包的所有者的帐号被攻击者盗号，攻击者使用该帐号发布了恶意包&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;参考资料&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.blog/2021-02-12-avoiding-npm-substitution-attacks/"&gt;Avoiding npm substitution attacks - The GitHub Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://azure.microsoft.com/zh-cn/resources/3-ways-to-mitigate-risk-using-private-package-feeds/"&gt;azure.microsoft.com/en-us/resources/3-ways-to-mitigate-risk-using-private-package-feeds/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://medium.com/&amp;#64;alex.birsan/dependency-confusion-4a5d60fec610"&gt;Dependency Confusion: How I Hacked Into Apple, Microsoft and Dozens of Other Companies | by Alex Birsan | Feb, 2021 | Medium&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="软件供应链安全"></category><category term="supply-chain-security"></category></entry></feed>