<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Huang Huang 的博客</title><link href="https://mozillazg.com/" rel="alternate"></link><link href="https://mozillazg.com/feeds/reading.atom.xml" rel="self"></link><id>https://mozillazg.com/</id><updated>2019-06-26T00:00:00+00:00</updated><entry><title>《Release It! Second Edition》阅读笔记（二）</title><link href="https://mozillazg.com/2019/06/Release-It-Design-and-Deploy-Production-Ready-Software-Second-Edition-2th-read-note-2.html" rel="alternate"></link><updated>2019-06-26T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2019-06-26:2019/06/Release-It-Design-and-Deploy-Production-Ready-Software-Second-Edition-2th-read-note-2.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;前言&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文是 &lt;a class="reference external" href="https://pragprog.com/book/mnee2/release-it-second-edition"&gt;《Release It! Second Edition》&lt;/a&gt; 这本书的流水账式阅读笔记。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="stability-patterns"&gt;
&lt;h2 id="hidstability-patterns"&gt;Stability Patterns&lt;a class="headerlink" href="#hidstability-patterns" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这章将介绍一些提高系统稳定性的模式，当然不要觉得系统中应用的模式越多稳定性就越高。&lt;/p&gt;
&lt;div class="section" id="timeouts"&gt;
&lt;h3 id="hidtimeouts"&gt;Timeouts&lt;a class="headerlink" href="#hidtimeouts" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;对外部依赖、阻塞线程以及慢响应使用超时技术。&lt;/li&gt;
&lt;li&gt;使用超时技术从非预期的故障中恢复。&lt;/li&gt;
&lt;li&gt;考虑延迟重试。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="circuit-breaker"&gt;
&lt;h3 id="hidcircuit-breaker"&gt;Circuit Breaker&lt;a class="headerlink" href="#hidcircuit-breaker" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;与重试不同，熔断器用于阻止操作而不是重复执行操作。
软件中应用熔断器的方法是使用一个组件包装危险的操作，这个组件可以在系统不健康时避开对其的调用，一旦系统恢复健康重新恢复对其的调用。&lt;/p&gt;
&lt;p&gt;当熔断器处于【closed】状态的时候，它会执行常规的操作，如果操作失败的话，熔断器会记录失败情况。
一旦失败次数（或者是失败频率）达到了阈值，熔断器触发熔断，进入【open】状态。&lt;/p&gt;
&lt;p&gt;[图]&lt;/p&gt;
&lt;p&gt;当熔断处于【open】状态的时候，所有经过熔断器的调用都将立即失败，不会去执行真正的操作。
一段时间后，熔断器进入【half-open】状态，这个状态下，下一次的调用将执行真正的操作，如果调用成功了，
熔断器会被重置并进入【closed】状态，如果调用失败了，熔断器将进入【open】状态直到触发超时（不会一直保持 open 会有个超时期限）。&lt;/p&gt;
&lt;p&gt;当熔断器开启时，必须对进来的调用进行处理。 最简单的答案是调用立即失败，
也许可以抛出一个异常(最好是一个不同于普通超时的异常，这样调用者可以提供有用的反馈)。
熔断器也可能有一个 fallback 策略。 也许它会返回最后一个好的响应或者一个缓存的值。
它可能返回一个通用的答案，而不是一个个性化的答案。
或者它甚至可以在主服务不可用时调用备用服务。&lt;/p&gt;
&lt;p&gt;熔断器是在系统受到压力时实现自动降级的一种方法。
无论采用何种 fallbak 策略，都会对系统业务产生影响。
因此，在决定如何处理熔断打开发出的调用时，必须让系统的利益相关者参与进来，也就是要根据对应的业务场景来处理。&lt;/p&gt;
&lt;p&gt;有一些有趣的实现细节需要考虑。 首先，什么是&amp;quot;太多的失败&amp;quot;？
一个简单的记录所有错误的计数器可能并不那么有趣，
观察在五小时内均匀分布的五个错误和在最后三十秒内发生的五个错误之间有着天壤之别。
我们通常对故障密度比总计数更感兴趣。我喜欢漏桶模式（Leaky Bucket）。
这是一个简单的计数器，可以在每次发现错误时递增。
在后台，一个线程或计时器周期性地递减计数器(当然是递减到零) 如果计数超过一个阈值，那么你就知道错误到来的非常的快。&lt;/p&gt;
&lt;p&gt;系统中熔断器的状态对另一些利益相关的人员来说非常的重要：运维/操作人员。
应该始终记录熔断器状态的更改事件，并且应该公开当前状态以便查询和监控。
事实上，状态变更的频率是一个随时间变化的有用指标; 它是发现企业其他部门问题的先行指标。
同样，运维/操作人员需要一些方法来直接跳闸或复位熔断器。
熔断器器也是一个方便收集调用量和响应时间指标的好地方。&lt;/p&gt;
&lt;p&gt;一个熔断器应该建立在单进程的范围内。 也就是说，
相同的熔断器状态会影响进程中的每个线程，但不会跨多个进程共享。
这确实意味着，当调用方的多个实例各自独立地发现提供方程序宕机时，效率会有所下降。
然而，共享熔断器状态引入了另一种进程外通信机制。 这意味着安全机制将引入一个新的故障模式！&lt;/p&gt;
&lt;p&gt;即便只在一个进程中共享，熔断器也受制于多线程编程的各种陷阱。 确保不会意外出现一个线程处理所有对外部系统的调用的情况！
每种语言和框架都有对应的开源熔断器库，最好是从中选一个来使用。&lt;/p&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;如果会带来坏的影响就别做。如果外部依赖有严重的问题，那就暂时别调用它。&lt;/li&gt;
&lt;li&gt;结合超时机制一起使用&lt;/li&gt;
&lt;li&gt;公开，追踪，报告状态变更事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="bulkheads"&gt;
&lt;h3 id="hidbulkheads"&gt;Bulkheads&lt;a class="headerlink" href="#hidbulkheads" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;舱壁模式指的是对操作或服务做隔离，来实现类似故障隔离的功能，减轻故障对整个系统的影响。&lt;/p&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;拯救船上其他部分。当故障发生的时候，通过舱壁模式提供的隔离功能来保护部分功能。&lt;/li&gt;
&lt;li&gt;选择一个合适的隔离粒度。可以隔离应用中的不同线程池、服务器上的不同 CPU 或者是集群里的不同服务器。&lt;/li&gt;
&lt;li&gt;考虑使用舱壁模式，尤其是共享服务模式下。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="steady-state"&gt;
&lt;h3 id="hidsteady-state"&gt;Steady State&lt;a class="headerlink" href="#hidsteady-state" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;稳态模式认为，对于每一个积累资源的机制，都必须有一些其他的机制来回收这些资源。
让我们来看看几种可以积累的污泥，以及如何避免搅拌的需要。&lt;/p&gt;
&lt;p&gt;Data Purging&lt;/p&gt;
&lt;p&gt;Log Files&lt;/p&gt;
&lt;p&gt;In-Memory Caching&lt;/p&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Avoid fiddling. 人为干预会导致问题。 消除重复人工干预的必要性。 你的系统应该至少运行一个典型的部署周期，而不需要手动清理磁盘或每晚重新启动。&lt;/li&gt;
&lt;li&gt;使用应用本身的逻辑来清理数据。&lt;/li&gt;
&lt;li&gt;限制缓存。&lt;/li&gt;
&lt;li&gt;滚动切割日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="fail-fast"&gt;
&lt;h3 id="hidfail-fast"&gt;Fail Fast&lt;a class="headerlink" href="#hidfail-fast" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;阻止慢响应，尽量快速失败。如果你的系统无法满足 SLA 标准，那就快速告诉调用方，不要让调用方一直等待，一直等到超时，那样只是把你的问题传递到了他们那里。&lt;/li&gt;
&lt;li&gt;谨慎对待资源，尽早验证依赖。不要做无用的工作。&lt;/li&gt;
&lt;li&gt;使用输入校验。在请求资源前先对用户输入做基本的校验，不要出现获取了数据库连接，查询并获取了结果，最后给出少了个必选参数的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="let-it-crash"&gt;
&lt;h3 id="hidlet-it-crash"&gt;Let It Crash&lt;a class="headerlink" href="#hidlet-it-crash" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有时创建系统级稳定性的最佳方法是放弃组件级稳定性。在 Erlang 中，这被称为&amp;quot;Let It Crash&amp;quot;的哲学。&lt;/p&gt;
&lt;p&gt;程序最干净的状态是在启动之后。 &amp;quot;Let It Crash&amp;quot;的方法表明错误恢复是困难的和不可靠的，所以我们的目标应该是尽快回到干净的启动状态。&lt;/p&gt;
&lt;p&gt;为了让&amp;quot;Let It Crash&amp;quot;起作用，我们的系统中有几件事必须是确定的。&lt;/p&gt;
&lt;p&gt;Limited Granularity&lt;/p&gt;
&lt;p&gt;崩溃必须有一个边界。我们想崩溃的是一个隔离的组件。系统的剩余部分必须要能够在一个级联故障中保护自己。&lt;/p&gt;
&lt;p&gt;Fast Replacement&lt;/p&gt;
&lt;p&gt;我们必须能够回到干净状态，并尽快恢复正常运行。 否则，当太多的实例在同时重启时，我们将看到性能下降。 极限情况下，由于所有实例都在忙于重启，我们的服务可能会无法对外提供服务。&lt;/p&gt;
&lt;p&gt;服务实例更加棘手。 这取决于需要启动多少&amp;quot;堆栈&amp;quot;。 下面有几个例子:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;我们在一个容器中运行 Go 二进制文件。 新容器和其中的进程的启动时间以毫秒为单位。 可以让整个容器崩溃。&lt;/li&gt;
&lt;li&gt;这是一个在 AWS 长期运行的虚拟机上运行的 NodeJS 服务。 启动 NodeJS 进程需要毫秒级别，但启动一个新的虚拟机需要几分钟。 在这种情况下，只崩溃 NodeJS 进程。&lt;/li&gt;
&lt;li&gt;一个带有 API 的老旧 JavaEE 应用程序，在一个数据中心的虚拟机上运行。 启动时间以分钟为单位。 &amp;quot;Let It Crash&amp;quot;不是正确的策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Supervision&lt;/p&gt;
&lt;p&gt;需要有相应的守护程序或系统来重启崩溃的进程或实例。&lt;/p&gt;
&lt;p&gt;Reintegration&lt;/p&gt;
&lt;p&gt;进程/实例从崩溃中恢复后，需要有一种机制能让这个恢复后的服务能够重新对外提供服务，恢复处理外部请求。比如：当负载均衡器的健康检查发现实例恢复健康后，实例应当能够重新被加入负载均衡器中并开始接受外部请求。&lt;/p&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;通过崩溃某个/些组件来维持整个系统的整体稳定性&lt;/li&gt;
&lt;li&gt;快速重启然后自动重新提供服务&lt;/li&gt;
&lt;li&gt;隔离组件以便可以独立的崩溃。使用熔断器（Circuit Breakers）帮助调用方从崩溃的组件中脱离出来。使用守护程序/系统（supervisors）来确定那部分需要快速重启，并保证崩溃不会影响不相关的功能。&lt;/li&gt;
&lt;li&gt;不要崩溃单体/巨大的应用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="handshaking"&gt;
&lt;h3 id="hidhandshaking"&gt;Handshaking&lt;a class="headerlink" href="#hidhandshaking" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;握手（Handshaking）就是让服务器通过控制自己的工作负载来保护自己。 服务器应该有一种拒绝传入工作的方法，而不是成为对它提出的任何要求的牺牲品。&lt;/p&gt;
&lt;p&gt;比如服务提供一个健康检查接口供负载均衡器使用，以便在异常/过载时拒绝外部请求。
健康检查这种方式只是一个粗糙的方法，最好的方法是在你实现的任何自定义协议中实现握手机制（handshaking）。&lt;/p&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Create cooperative demand control。&lt;/li&gt;
&lt;li&gt;考虑健康检查。&lt;/li&gt;
&lt;li&gt;在你自己的底层协议中实现握手机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="test-harnesses"&gt;
&lt;h3 id="hidtest-harnesses"&gt;Test Harnesses&lt;a class="headerlink" href="#hidtest-harnesses" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;开发环境、QA 环境以及集成测试环境中都无法测试部分分布式系统的失败模型，我们需要有一个测试套件（test harness）来帮助我们测试这些失败模型。&lt;/p&gt;
&lt;p&gt;考虑构建一个测试套件，它可以代替每个 web 服务都会调用的远端服务。因为远程调用需要使用网络，基于 socket 的连接容易出现下面的故障：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;连接可能被拒绝。&lt;/li&gt;
&lt;li&gt;可能会待在 listen 队列中，直到调用方超时。&lt;/li&gt;
&lt;li&gt;远端在回复了 SYN/ACK 后就不再发送任何数据了。&lt;/li&gt;
&lt;li&gt;远端只发送 RESET 包。&lt;/li&gt;
&lt;li&gt;远端反馈接收窗口满了，但是却不消费数据。&lt;/li&gt;
&lt;li&gt;连接可以建立，但是远端不发送任何数据。&lt;/li&gt;
&lt;li&gt;连接可以建立，但是丢包导致延迟重传。&lt;/li&gt;
&lt;li&gt;连接可以建立，但是远端不发送确认收到的回复，导致无限重传。&lt;/li&gt;
&lt;li&gt;服务可以接受请求，发送响应 header, 但是一直不发送响应 body。&lt;/li&gt;
&lt;li&gt;服务每 30 秒发送一个字节的响应。&lt;/li&gt;
&lt;li&gt;服务发送了一个 HTML 响应而不是预期的 XML。&lt;/li&gt;
&lt;li&gt;服务发送了 MB 级别的数据而不是预期的 KB 级别。&lt;/li&gt;
&lt;li&gt;服务拒绝所有身份验证凭据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些故障可以分为不同的类别: 网络传输问题、网络协议问题、应用协议问题和应用逻辑问题。&lt;/p&gt;
&lt;p&gt;这种类似的测试套件其实是类似 &amp;quot;chaos engineering&amp;quot; 的思路。这个后面会讲到。&lt;/p&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;模拟不合规的故障。&lt;/li&gt;
&lt;li&gt;对调用方施加压力。测试工具可以产生缓慢的响应、无响应或垃圾响应。 然后可以可以观察你的应用程序是如何处理这些情况的。&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="decoupling-middleware"&gt;
&lt;h3 id="hiddecoupling-middleware"&gt;Decoupling Middleware&lt;a class="headerlink" href="#hiddecoupling-middleware" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Decide at the last responsible moment. 其他稳定性模式可以在不对设计或架构进行大规模更改的情况下实现。 解耦中间件是一个架构决策。 它会波及到系统的每一个部分。 这是几乎不可逆转的决定之一，应尽早而不是推迟作出。&lt;/li&gt;
&lt;li&gt;通过完全解耦来避免多个故障模式。解耦单个服务、层和应用程序越完全，外部依赖、级联故障、慢响应和线程阻塞的问题就越少。 你会发现，解耦的应用程序也具有更强的适应性，因为你可以在不依赖其他参与者的情况下变更依赖。&lt;/li&gt;
&lt;li&gt;学习多种架构，并在其中进行选择。不是每个系统都需要成为一个带有关系数据库的三层应用程序。 学习多种架构风格，为手头的问题选择最好的架构。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="shed-load"&gt;
&lt;h3 id="hidshed-load"&gt;Shed Load&lt;a class="headerlink" href="#hidshed-load" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;服务、微服务、网站和开放 api 都有一个共同特征: 它们没法控制外部请求。在任何时候，超过10亿台设备都可以发出请求。 无论你的负载均衡器有多强大，或者你的扩容速度有多快，这个世界总是会产生超出你能力的负载。&lt;/p&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;你无法超越整个世界。如果你的服务暴露于无法控制的环境，那么你需要能够在全世界为你疯狂时甩掉/消减负载。&lt;/li&gt;
&lt;li&gt;使用 Shed Load（消减负载）来阻止慢响应。&lt;/li&gt;
&lt;li&gt;使用负载均衡器作为减震器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="create-back-pressure"&gt;
&lt;h3 id="hidcreate-back-pressure"&gt;Create Back Pressure&lt;a class="headerlink" href="#hidcreate-back-pressure" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;每个性能问题都开始于某个地方的队列开始阻塞了。可能是 socket 的 listen 队列，也可能是操作系统的运行队列或者是数据库的 I/O 队列。&lt;/p&gt;
&lt;p&gt;无限队列基本是不可接受的，因为它们会吃掉所有可用的内存。如果队列是有限的的，我们就需要决定在队列阻塞时做啥操作，只有少量的选项：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;假装接受新条目，但是实际上会直接把它丢弃。&lt;/li&gt;
&lt;li&gt;真的接受新条目，然后把队列中的一些数据给丢弃。&lt;/li&gt;
&lt;li&gt;拒绝新条目。&lt;/li&gt;
&lt;li&gt;阻塞生产者，直到队列有空位。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于某些用例，丢弃新条目可能是最好的选择。 对于价值随年龄(age)迅速下降的数据，删除队列中最老的条目可能是最佳选择。&lt;/p&gt;
&lt;p&gt;阻塞生产者是一种流量控制手段。 它允许队列向上游施加&amp;quot;反压力/背压(back pressure)&amp;quot;。 据推测，背压(back pressure)会一直传递到最终的客户端，在队列释放新的空间前，客户端的速度会被降低。&lt;/p&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;背压（Back Pressure）通过降低（服务）消费方的消费速度来创造安全性。（服务）消费方将经历减速。 唯一的替代选择是让他们崩溃（服务）提供方。&lt;/li&gt;
&lt;li&gt;在一个系统的边界应用背压（Back Pressure）模式。跨越界限，转而关注负载的减少。尤其是当互联网是你的用户基础的时候。&lt;/li&gt;
&lt;li&gt;为了让响应时间有限，队列必须是有限的。当队列满的时候，你只有有限的几个选择。 所有这些选择都是令人不快的: 丢失数据、拒绝工作或阻塞。（服务）消费方必须小心，不要永远阻塞在那。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="governor"&gt;
&lt;h3 id="hidgovernor"&gt;Governor&lt;a class="headerlink" href="#hidgovernor" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;自动化没有判断力。 当它出错的时候，往往很快就会出错。 当一个人察觉到问题的时候，它就是一个恢复而不是干预的问题。 我们怎么能允许人为干预而不让人参与其中呢？ 我们应该使用自动化来处理人类不擅长的事情: 重复性任务和快速响应。 我们应该用人来做自动化不擅长的事情: 在更高的层次上感知整个状况。&lt;/p&gt;
&lt;p&gt;我们可以创建调节器（Governor）来降低操作的速度。 Reddit 通过为他们的自动扩容装置添加一次只能关闭一定百分比的实例的逻辑来实现这一特性。&lt;/p&gt;
&lt;p&gt;调节器（Governor）是有状态和时间意识的。 它知道在一段时间内做了什么操作。 它也应该是不对称的。 大多数材质都有一个&amp;quot;安全&amp;quot;方向和一个&amp;quot;不安全&amp;quot;方向。 关闭实例是不安全的。 删除数据是不安全的。 阻止客户端 IP 地址是不安全的。&lt;/p&gt;
&lt;p&gt;你经常会在&amp;quot;安全&amp;quot;的定义之间找到对立。 关闭实例对于可用性是不安全的，而拉起实例对于成本是不安全的。 这些对立并不互相抵消。 相反，他们定义了一个 u 型曲线，在这个曲线上，向任何一个方向走得太远都是不好的。 这意味着操作在规定的范围内是安全的，在范围外是不安全的。
你的 AWS 预算可能允许一千个 EC2 实例，但是如果自动扩容程序开始朝着扩容两千个实例的方向前进的话，那么它需要放慢速度。&lt;/p&gt;
&lt;p&gt;你可以将这个 u 型曲线看作是定义调节器（Governor）的响应曲线。 在安全区内行动迅速。 在范围之外调节器（Governor）增加阻力。&lt;/p&gt;
&lt;p&gt;调节器（Governor）的全部意义就是让事情慢下来，足以让人类参与进来。 当然，这意味着连接监控系统以便警告人类有异常情况，并给他们足够的可见性来了解正在发生的事情。&lt;/p&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;让事情慢下来，以便可以人工介入。当事情即将偏离轨道时，我们常常发现自动化工具会将其推向极限。 人类更善于基于场景的思考，所以我们需要创造机会让自己能够介入其中。&lt;/li&gt;
&lt;li&gt;在不安全的方向施加阻力。 有些动作本身就是不安全的。 关闭，删除，阻塞... 这些都有可能中断服务。 自动化将使它们运行得更快，因此你应该应用调节器（Governor）来为人工介入预留时间。&lt;/li&gt;
&lt;li&gt;考虑响应曲线。考虑一个响应曲线。在规定的范围内，操作可能是安全的。 在这个范围之外，它们应该遇到越来越大的&amp;quot;阻力&amp;quot;（通过减慢它们发生的速度）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="stability"></category></entry><entry><title>《Release It! Second Edition》阅读笔记（一）</title><link href="https://mozillazg.com/2019/06/Release-It-Design-and-Deploy-Production-Ready-Software-Second-Edition-2th-read-note-1.html" rel="alternate"></link><updated>2019-06-16T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2019-06-16:2019/06/Release-It-Design-and-Deploy-Production-Ready-Software-Second-Edition-2th-read-note-1.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;前言&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文是 &lt;a class="reference external" href="https://pragprog.com/book/mnee2/release-it-second-edition"&gt;《Release It! Second Edition》&lt;/a&gt; 这本书的流水账式阅读笔记。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="living-in-production"&gt;
&lt;h2 id="hidliving-in-production"&gt;Living in Production&lt;a class="headerlink" href="#hidliving-in-production" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;软件只有在线上（上线）才能体现它的价值。上线之前的开发、测试、计划等等都是上线前的前奏。这本书讲的是围绕上线以及线上稳定性的各方面的知识。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="create-stability"&gt;
&lt;h2 id="hidcreate-stability"&gt;Create Stability&lt;a class="headerlink" href="#hidcreate-stability" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="case-study-the-exception-that-grounded-an-airline"&gt;
&lt;h3 id="hidcase-study-the-exception-that-grounded-an-airline"&gt;Case Study: The Exception That Grounded an Airline&lt;a class="headerlink" href="#hidcase-study-the-exception-that-grounded-an-airline" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;举了一个航空公司的系统故障的例子，在这个例子中因为一个未捕获的 SQLException 异常导致整个航空系统瘫痪了数小时。&lt;/p&gt;
&lt;p&gt;讲了一下用到的方法：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;通过 jvm 的 thread dumps 找到各个服务 block 的地方&lt;/li&gt;
&lt;li&gt;通过反编译的方式拿到了关键问题的 java 代码，从而最终确定了 bug 是哪段代码导致的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;bug 总是不可避免的，谁也不能保证再也不会出现 bug。这个例子中最糟糕的问题不是这个 bug 本身，而是这个 bug 瘫痪了整个系统：
一个系统中的 bug 所产生的影响传递到了所有相关的系统。我们要解决的问题是：如何阻止一个系统中的 bug 影响其他所有的系统。
后面的章节会讲如何组织这类问题的一些设计模式。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="stabilize-your-system"&gt;
&lt;h3 id="hidstabilize-your-system"&gt;Stabilize Your System&lt;a class="headerlink" href="#hidstabilize-your-system" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="extending-your-life-span"&gt;
&lt;h4 id="hidextending-your-life-span"&gt;Extending Your Life Span&lt;a class="headerlink" href="#hidextending-your-life-span" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;测试可以发现很多问题，一切没有通过测试发现的问题最终都将会发生：如果你没有测试一下在七天后会发生的内存泄露问题，那么七天后就会发生内存泄露。&lt;/p&gt;
&lt;p&gt;问题是，大部分测试运行的时间都太短了，测试环境、开发环境的服务都会频繁的重启，并没有像生产环境一样一个服务持续运行很长一段时间，
这样就会导致很多问题无法在测试和开发的过程中发现，直到到了生产环境才在某天触发。&lt;/p&gt;
&lt;p&gt;如何应对这类需要长时间运行才能发现的问题，并在生产环境之前提前发现这类问题？你需要准备一个类似的长时间运行的环境，如果条件不允许的话，
简单的一台机器上运行长时间的服务，然后负载测试的时候不要只跑一会儿，试试持续跑几个小时甚至几天。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="failure-modes"&gt;
&lt;h4 id="hidfailure-modes"&gt;Failure Modes&lt;a class="headerlink" href="#hidfailure-modes" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;为你的系统设计故障方法，你可以设计一些安全的故障方法，在出现故障的时候保护系统的其他部分不受故障的影响。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="stopping-crack-propagation"&gt;
&lt;h4 id="hidstopping-crack-propagation"&gt;Stopping Crack Propagation&lt;a class="headerlink" href="#hidstopping-crack-propagation" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;不要让故障持续传递&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="chain-of-failure"&gt;
&lt;h4 id="hidchain-of-failure"&gt;Chain of Failure&lt;a class="headerlink" href="#hidchain-of-failure" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;故障链上的每一个步故障可能都会导致后面系统的故障，导致出现雪崩效应，出现一个小 bug 导致链路上的所有系统都故障的问题。&lt;/p&gt;
&lt;p&gt;一种为每个可能故障的做准备的方法是，检查所有外部调用、所有 I/O 调用、所有资源使用以及所有预期的结果，自问一下：『所有的这些操作可能会出现哪些异常情况？』：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;无法完成初始化连接会咋样？&lt;/li&gt;
&lt;li&gt;如果建立一个连接需要 10 分钟会咋样？&lt;/li&gt;
&lt;li&gt;连接建立了然后又被断开了呢？&lt;/li&gt;
&lt;li&gt;可以建立连接但是无法获取的响应信息？&lt;/li&gt;
&lt;li&gt;如果我的查询需要 2 分钟才能获得响应呢？&lt;/li&gt;
&lt;li&gt;当尝试写一个关键的错误日志（比如前面的 SQLException）的时候磁盘满了呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每一次线上故障都是唯一的，但是我们可以从这些故障中找到一些故障模型，通过分析这些故障模型就可以找到一些通用的解决办法。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="stability-antipatterns"&gt;
&lt;h2 id="hidstability-antipatterns"&gt;Stability Antipatterns&lt;a class="headerlink" href="#hidstability-antipatterns" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本章讲一些可能会摧毁你的系统的反模式。&lt;/p&gt;
&lt;div class="section" id="integration-points"&gt;
&lt;h3 id="hidintegration-points"&gt;Integration Points&lt;a class="headerlink" href="#hidintegration-points" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;现在大部分系统的结构已经从之前的单体架构变成了集成多个服务的类似网状的结构，网状结构中的各个依赖链路是摧毁你系统的一个关键点，
下面看看这些依赖链路是怎么在各种场景下成为毁灭者的，以及你可以如何应对。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="socket-based-protocols"&gt;
&lt;h3 id="hidsocket-based-protocols"&gt;Socket-Based Protocols&lt;a class="headerlink" href="#hidsocket-based-protocols" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;大多数高级协议都是基于 socket 实现的。虽然这些高级协议都有自己的故障模型，但是它们都会受 socket 层故障的影响。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;connection refused 是最容易处理、一般也不会被忽略的一种异常情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;TCP 三次握手（SYN、SYN/ACK、ACK）期间的异常情况：
* 如果远程服务没有监听指定的端口，客户端会收到 RST 报，这个过程的响应特别快，调用方会得到一个异常/错误返回码
* 远程服务监听了指定端口，监控端口的同时会有一个 listen queue（在队列内的连接处于发送了 SYN，但是还没收到 SYN/ACK 回复的 pending 状态）:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;队列满了：新进来的连接会被拒绝（不放到 listen queue 中，不回复 SYN/ACK），客户端会反复重传 SYN 包&lt;/li&gt;
&lt;li&gt;队列没满，但是没有 accept 回复 SYN/ACK 的话，客户端会反复重传 SYN 包&lt;/li&gt;
&lt;li&gt;open() 调用在三次握手没完成的时候都会阻塞在那里，直到连接成功或超时（connection timeout）。
连接超时的阻塞时间一般都是分钟级别的，甚至十几分钟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;客户端连接成功了并且发送了一个请求，但是服务端可能会花很长时间才会完成读取请求并返回一个响应的操作。
在服务端返回响应前， read() 调用会一直阻塞在那里，通常这个阻塞是没有时间限制的，如果你想唤醒这个阻塞调用的话，必须得设置 socket 超时时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络故障通常有两种方式：快速或者缓慢。类似 connection refused 的快速故障调用者可以在几毫秒内就获知这个结果，
类似 ACK 包被丢弃的缓慢故障会导致分钟级别的线程阻塞问题，阻塞的线程无法处理其他事物，如果所有线程都阻塞的话，可能会导致整个系统宕机。&lt;/p&gt;
&lt;p&gt;所以，缓慢的响应比没有响应（快速得到结果）更糟。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-5-a-m-problem"&gt;
&lt;h3 id="hidthe-5-a-m-problem"&gt;The 5 A.M. Problem&lt;a class="headerlink" href="#hidthe-5-a-m-problem" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过抓包工具（tcpdump、Wireshark）来调查 socket 相关的问题。&lt;/p&gt;
&lt;p&gt;作者讲了一个因为链路中的一个防火墙频繁丢弃了 ACK 包导致服务 hang 住最终导致整条链路都挂了的案例
（有个连接池，连接池中每个空闲连接的超时时间是一个小时，因为丢包问题导致无法及时剔除有问题的连接，然后使用连接的时候用了有问题的连接出现服务 block）。&lt;/p&gt;
&lt;p&gt;一般需要二十分钟 socket 库才能感知到重传导致的超时问题（tcp_retries2），上面案例中他们用的系统需要三十分钟才能感知到超时，
也就是说他们服务中的 write socket 操作会出现长达三十分钟的 block 问题，read socket 操作会 block forever!&lt;/p&gt;
&lt;p&gt;这个例子想说的是，有时候故障不一定是应用层面导致的问题，有时可能是上层或下层导致的问题，你需要知道如何深挖至少两层来找到真正的问题所在。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="http-protocols"&gt;
&lt;h3 id="hidhttp-protocols"&gt;HTTP Protocols&lt;a class="headerlink" href="#hidhttp-protocols" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;HTTP 协议也是基于 socket 的，所以它有上面提到 socket 相关的所有问题，同时它也有自己特殊的问题：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;服务端可能接受了 TCP 连接，但是不响应 HTTP 请求&lt;/li&gt;
&lt;li&gt;服务端可能接受连接，但是不读取请求。如果请求的 body 特别大的话，可能会超出服务的的 TCP 窗口大小，这会导致
调用方的 TCP buffer 被填满，这将导致 write socket 操作 block 住。这种情况下正在发送的请求永远都不会完成&lt;/li&gt;
&lt;li&gt;服务端可能会返回一个调用方无法处理的响应，比如 &amp;quot;418 I’m a teapot.&amp;quot; 或者 &amp;quot;451 Resource censored.&amp;quot;&lt;/li&gt;
&lt;li&gt;服务端可能会返回一个调用方非预期的或者无法处理的内容类型，比如，返回一个 404 的 Html 页面而不是预期的 JSON 响应。（比如，有些 ISP 在 dns 查询失败的时候会返回一个 html 的错误页面）&lt;/li&gt;
&lt;li&gt;服务端声明会返回一个 JSON 数据，但是实际上是个普通的纯文本数据或者二进制数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;推荐使用那种可以详细控制超时（包括连接超时和读取超时）以及如何处理响应的客户端库，不要用那种直接把响应映射为对象的库，应该在确认获取到了预期的数据后再把响应作为合法数据进行处理。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="vendor-api-libraries"&gt;
&lt;h3 id="hidvendor-api-libraries"&gt;Vendor API Libraries&lt;a class="headerlink" href="#hidvendor-api-libraries" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;供应商提供的 API 库通常意味着：代码质量差、bug 多、bug 修复周期长、有些甚至看不到源代码无法自助修复 bug。&lt;/p&gt;
&lt;p&gt;供应商 API 库主要的稳定性杀手是其中的 block 操作：内部连接池/资源池、socket read 调用、HTTP 连接或者是不安全的序列化操作。
供应商 API 库布满了大量不安全的代码实践。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="countering-integration-point-problems"&gt;
&lt;h3 id="hidcountering-integration-point-problems"&gt;Countering Integration Point Problems&lt;a class="headerlink" href="#hidcountering-integration-point-problems" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如何防范集成链路中各个依赖的问题，下面有一些建议：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;警惕必然会出现的问题：链路上的每个依赖必然会出现某种故障，你需要为这些故障做预案和准备。&lt;/li&gt;
&lt;li&gt;为多种形式的故障准备预案。&lt;/li&gt;
&lt;li&gt;故障会快速传递：远程系统中的故障会快速成为你的系统中的问题，如果你的代码防御性不够的话，这个问题通常会演变成瀑布式故障（故障风暴）。&lt;/li&gt;
&lt;li&gt;应用一些模式来抵御链路中的问题：通过熔断（Circuit Breaker）、超时（ Timeouts）、解耦中间件 （Decoupling Middleware）、握手（Handshaking）这些防御式编程方法来帮助你抵御链路上的危险问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="chain-reactions"&gt;
&lt;h3 id="hidchain-reactions"&gt;Chain Reactions&lt;a class="headerlink" href="#hidchain-reactions" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;目前的架构风格一般分为水平扩展和垂直扩展，然后大部分服务都是水平扩展架构的。&lt;/p&gt;
&lt;p&gt;水平扩展的模式一下，一般都有类似负载均衡或集群的模式。
水平扩展虽然不容易受单点故障问题的影响，但是仍旧有负载相关的失败模式。
比如，有一个节点因为内存泄露导致服务异常了，此时这个节点上的流量通过负载均衡器会分摊到剩下的健康节点上，
但是剩下的节点可能也会因为这些新的流量也导致出现异常（因为这些节点也有内存泄露问题，只是暂时还未达到临界点）。
解决这种连锁反（chain reaction）应的唯一办法是修复导致问题的 bug。&lt;/p&gt;
&lt;p&gt;把一层分隔为多个池的舱壁模式（Bulkhead）可以减轻连锁反应说带来的影响。&lt;/p&gt;
&lt;p&gt;连锁反应有时是因为一些阻塞的线程而导致的问题，比如一个节点中所有处理请求的线程都阻塞了，这会导致服务无法响应请求，
新进来的连接会分散到同一层的其他节点上，加大其他节点出现问题的几率。&lt;/p&gt;
&lt;p&gt;Remember This:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;意识到，有时一个服务宕机会危及剩下的服务，导致它们也出现宕机的问题。连锁反应可能会导致整个层的服务都宕机， 其他依赖这层的服务必须保护自己，否则它们可能会因为失败风暴导致宕机。&lt;/li&gt;
&lt;li&gt;追杀资源泄露问题。大部分连锁反应都是内存泄露导致的问题。&lt;/li&gt;
&lt;li&gt;追杀令人费解的时间相关的 bug。如果一个节点出现死锁问题，很有可能会导致其他节点也出现死锁问题。&lt;/li&gt;
&lt;li&gt;使用自动扩容功能。随着时间的推移，自动扩容的速度将超过连锁反应的传递速度，最终终止连锁反应。&lt;/li&gt;
&lt;li&gt;使用舱壁(Bulkheads)模式进行防御：在服务端使用舱壁模式阻止连锁反应危及整个服务， 在客户端使用熔断器（Circuit Breaker）模式来处理一部分服务宕机的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="cascading-failures"&gt;
&lt;h3 id="hidcascading-failures"&gt;Cascading Failures&lt;a class="headerlink" href="#hidcascading-failures" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;瀑布式故障，故障雪崩，指的是某一层的服务的故障导致调用方那一层也出现故障。&lt;/p&gt;
&lt;p&gt;瀑布式故障通常是低层次的故障导致资源池异常的结果，比如请求依赖的外部服务时没有设置超时。&lt;/p&gt;
&lt;p&gt;下游服务的故障会导致上游服务触发重试逻辑，然后随着下游服务故障的加重最后触发了重试风暴，最终打挂下游服务。
针对这种重试风暴的情况，调用方需要应用熔断器（Circuit Breaker）模式。&lt;/p&gt;
&lt;p&gt;最高效的对付瀑布式故障的模式是熔断器（Circuit Breaker）和超时。&lt;/p&gt;
&lt;p&gt;Remember This:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;确保你的服务在外部依赖异常时不会受牵连导致宕机。&lt;/li&gt;
&lt;li&gt;仔细检查各种资源池。资源池异常通常会导致瀑布式故障。比如，长时间无法获取到需要的资源的连接池，获取连接的线程会一直阻塞，其他等待连接的线程也会阻塞。 安全的资源池应该限制一个线程获取资源的等待时间。&lt;/li&gt;
&lt;li&gt;通过超时和熔断器（Circuit Breaker）模式来防御瀑布式故障问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="users"&gt;
&lt;h3 id="hidusers"&gt;Users&lt;a class="headerlink" href="#hidusers" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;用户太少是个问题，用户太多其实也会成为问题。比如未准备好的促销活动或者网红转发导致的用户量暴增，这些个的用户增长可能都会打垮服务。&lt;/p&gt;
&lt;div class="section" id="traffic"&gt;
&lt;h4 id="hidtraffic"&gt;Traffic&lt;a class="headerlink" href="#hidtraffic" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;流量同样也有类似的问题，一般服务都有自己的预估容量，如果超出了可支撑的容量就会导致问题。
如果你的服务是跑在云上的话，云服务的自动扩容功能是好手段，不过有可能会出现因为自动扩容导致巨额账单的问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="heap-memory"&gt;
&lt;h4 id="hidheap-memory"&gt;Heap Memory&lt;a class="headerlink" href="#hidheap-memory" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;基于内存的 session 中应该保存尽可能少的数据。可以通过各个语言提供的弱引用（weak references）相关的技术来保证及时释放内存。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="off-heap-memory-off-host-memory"&gt;
&lt;h4 id="hidoff-heap-memory-off-host-memory"&gt;Off-Heap Memory, Off-Host Memory&lt;a class="headerlink" href="#hidoff-heap-memory-off-host-memory" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;善用把数据存放到外部进程的方式来代替进程内的用户数据内存，比如 Memcached、Redis&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sockets"&gt;
&lt;h4 id="hidsockets"&gt;Sockets&lt;a class="headerlink" href="#hidsockets" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;一个服务器所能处理的接入连接数是有限制的，主要是端口数限制，解决的办法是虚拟 ip 地址，服务通过监听网卡上的多个虚拟 ip 的方式来突破端口数量限制。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="closed-sockets"&gt;
&lt;h4 id="hidclosed-sockets"&gt;Closed Sockets&lt;a class="headerlink" href="#hidclosed-sockets" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;关闭 socket 有时也可能会触发问题。比如记得留意一下 TIME_WAIT 状态的连接。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="expensive-to-serve"&gt;
&lt;h4 id="hidexpensive-to-serve"&gt;Expensive to Serve&lt;a class="headerlink" href="#hidexpensive-to-serve" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;有些用户可能比其他用户更难服务，比如大部分用户可能只是浏览一下商品页面，这些页面的内容通常可以使用缓存，
还有一部分用户会下单、付款，这些功能对服务的要求更高，可能会触发一些问题。&lt;/p&gt;
&lt;p&gt;对于这类问题的发现方法是压力测试，比如你预期的转化率是 2% 那你在做压力测试的时候就可以考虑测试 4%、6%、10% 的转化率。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="unwanted-users"&gt;
&lt;h4 id="hidunwanted-users"&gt;Unwanted Users&lt;a class="headerlink" href="#hidunwanted-users" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;不是所有的用户/请求都是服务想要的，比如不恰当的客户端导致的 DDoS 攻击、不遵守规范的网络爬虫等等。
你的服务需要考虑如何应对这些不想要的用户，让他们处于你们的控制下否则害虫就会大量滋生。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="malicious-users"&gt;
&lt;h4 id="hidmalicious-users"&gt;Malicious Users&lt;a class="headerlink" href="#hidmalicious-users" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;同样也不乏怀有恶意的用户，比如各种脚本小子、攻击者等等，比如最常见的 DDoS 攻击、各种安全漏洞攻击之类的，需要对这些恶意用户保持警惕。&lt;/p&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;用户会消耗内存：每个用户 session 都需要一点内存，最小化内存使用可以提高服务的容量。&lt;/li&gt;
&lt;li&gt;用户会做古怪的、随机的事情：真实世界的用户会做你无法预测的事情。测试脚本对这种情况可能不是特别有用，可以考虑看看fuzzing toolkits, property- based testing, or simulation testing。&lt;/li&gt;
&lt;li&gt;恶意用户无处不在：确保你的系统可以方便的进行各类漏洞的修补工作，及时更新使用的框架、持续学习。&lt;/li&gt;
&lt;li&gt;用户有时会像暴徒一样涌进来，比如有网红推荐了你的网站，大量涌入的用户可能会触发 hang 住、死锁等问题，需要对这些情况有所预案，比如对热链进行压力测试等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="blocked-threads"&gt;
&lt;h3 id="hidblocked-threads"&gt;Blocked Threads&lt;a class="headerlink" href="#hidblocked-threads" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;很多时候服务故障的时候并不会崩溃而是所有线程都阻塞在那等待着一些不能完成的事情。&lt;/p&gt;
&lt;p&gt;所以建议不只是要有内部监控（日志抓取、进程监控、端口监控等）也可以有个外部监控，比如一个模拟真实用户操作的客户端，如果这个客户端无法得到预期的结果的话，肯定是哪里有问题了，即便服务还在运行。&lt;/p&gt;
&lt;p&gt;metric 监控同样也可以帮助快速发现问题，比如登录成功数、支付失败数等计数类 metric 监控。&lt;/p&gt;
&lt;p&gt;线程阻塞可能发生在任何时候：从连接池中获取一个连接、处理缓存或对象登记、或者是进行一次外部调用。&lt;/p&gt;
&lt;p&gt;不安全的多线程代码通常有四种情况：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;错误情况和异常的组合数太多了，导致测试无法完全覆盖&lt;/li&gt;
&lt;li&gt;非预期的交互会把问题引入到前面安全的代码中&lt;/li&gt;
&lt;li&gt;时间非常重要，应用可能会同时 hang 住多个并发请求&lt;/li&gt;
&lt;li&gt;开发者从来没测试过应用处理 1 万个并发请求的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在开发环境很难发现 hang 住的情况。不要总想着自己实现连接池，实现一个可靠、安全、高性能的连接池比你想象的要更困难。&lt;/p&gt;
&lt;p&gt;尽量不要在同步方法里修改共享对象，建议是把这些共享对象实现为不可变的或者在同步方法里使用一个原对象的副本。&lt;/p&gt;
&lt;div class="section" id="spot-the-blocking"&gt;
&lt;h4 id="hidspot-the-blocking"&gt;Spot the Blocking&lt;a class="headerlink" href="#hidspot-the-blocking" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Use Caching, Carefully:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;所有应用级别的缓存都需要配置最大内存使用&lt;/li&gt;
&lt;li&gt;需要监控缓存命中率&lt;/li&gt;
&lt;li&gt;不要缓存没意义或者可以很快生成不需要放入缓存的数据&lt;/li&gt;
&lt;li&gt;缓存数据自身应该使用弱引用（weak reference）来帮助 gc 释放内存&lt;/li&gt;
&lt;li&gt;缓存要适时更新或过期，不要出现旧数据导致出问题的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="libraries"&gt;
&lt;h4 id="hidlibraries"&gt;Libraries&lt;a class="headerlink" href="#hidlibraries" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;第三方库是万恶之源，大部分阻塞的线程都来自第三方库。很多作为一个服务的客户端的库都有一个内置的资源池，它们通常会在出问题时永久阻塞发送请求的线程。
以及它们通常不能配置失败模型，比如如何处理所有连接都在等待那些永远都不会返回的响应的情况。&lt;/p&gt;
&lt;p&gt;如果是个开源库，你还可以通过各种方法快速的修复相关问题，如果是供应商提供的库的话，你可能需要自己包装一下这个库，使用自己可控的方式来处理请求。&lt;/p&gt;
&lt;p&gt;Remember This：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;消除阻塞线程相关的反模式可以解决大部分的故障问题&lt;/li&gt;
&lt;li&gt;仔细检查资源池&lt;/li&gt;
&lt;li&gt;使用久经考验的原语。任何并发相关的库都比你现造的生产者/消费者队列的轮子要经过更多的测试。&lt;/li&gt;
&lt;li&gt;使用超时机制进行防御&lt;/li&gt;
&lt;li&gt;小心那些没法看到源码的库&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="self-denial-attacks"&gt;
&lt;h3 id="hidself-denial-attacks"&gt;Self-Denial Attacks&lt;a class="headerlink" href="#hidself-denial-attacks" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;市场部门的营销活动可能会导致自我拒绝的攻击，一些全局共享的资源也会导致类似的问题，比如分布式全局锁服务。&lt;/p&gt;
&lt;div class="section" id="avoiding-self-denial"&gt;
&lt;h4 id="hidavoiding-self-denial"&gt;Avoiding Self-Denial&lt;a class="headerlink" href="#hidavoiding-self-denial" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;可以通过构建一个 shared-nothing 的架构（服务间不共享任何资源，不依赖其他服务的正常运行）来阻止机器相关的自我拒绝问题。
如果没法做到的话，可以考虑实现 fall back 机制，当一个依赖的服务异常时使用另一个服务或机制来实现类似的功能。&lt;/p&gt;
&lt;p&gt;也可以搭配硬件负载均衡器来进行流量管理、基础设施分区、使用新的云服务资源来处理营销活动或流量陡增的场景。&lt;/p&gt;
&lt;p&gt;自动扩容也是一个方法，不过要考虑到扩容的速度问题，如果都是虚拟机的话扩容可能会比较慢，可以考虑使用预扩容的方式来应对即将到来的营销活动。&lt;/p&gt;
&lt;p&gt;对于人为导致的攻击问题，解决方法是：培训、教育、交流。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="scaling-effects"&gt;
&lt;h3 id="hidscaling-effects"&gt;Scaling Effects&lt;a class="headerlink" href="#hidscaling-effects" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;任何时候你有一个多对一或多对少关系，当一端增长时候，你都可能会遇到尺度效应（scaling effects）的问题。&lt;/p&gt;
&lt;p&gt;比如，一个数据库服务在只有 10 台机器作为调用方的时候可以正常工作，但是当你又新加了 50 台机器的时候，这个数据服务就崩溃了。&lt;/p&gt;
&lt;p&gt;开发环境和测试环境中因为使用的机器数量太少，基本上很难发现尺度效应相关的问题。&lt;/p&gt;
&lt;div class="section" id="point-to-point-communications"&gt;
&lt;h4 id="hidpoint-to-point-communications"&gt;Point-to-Point Communications&lt;a class="headerlink" href="#hidpoint-to-point-communications" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;尺度效应问题的一个多发地是点对点通信的场景：服务内部实例之间需要点对点的互相通信。
当需要点对点通信的节点数量增加到数以千计的时候基本上都会成为很大问题，
然而除非你们是 google 或微软否则没法在测试环境搭建与生产等量的机器信息，所以测试一般都覆盖不了这种 case。&lt;/p&gt;
&lt;p&gt;如果机器数量比较少点对点通信可能没啥大问题，随着机器数量的增加，可以考虑使用下面的方式替换点对点通信：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;UDP 广播&lt;/li&gt;
&lt;li&gt;TCP 或 UDP 多播&lt;/li&gt;
&lt;li&gt;发布/订阅消息&lt;/li&gt;
&lt;li&gt;消息队列&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="shared-resources"&gt;
&lt;h4 id="hidshared-resources"&gt;Shared Resources&lt;a class="headerlink" href="#hidshared-resources" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;另一个危及稳定性的尺度效应问题是共享资源（Shared Resources）问题。
当这种共享资源过载的时候，它就会成为其他依赖这个共享资源的服务的容量瓶颈。&lt;/p&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;检查生产环境和 QA 环境的区别，找到上了生产环境后可能会因为尺度效应导致问题的风险点。&lt;/li&gt;
&lt;li&gt;小心点对点通信，点对点通信的方式会导致非常的难以扩容。&lt;/li&gt;
&lt;li&gt;小心共享资源。如果一定要依赖一些共享资源的话，记得做压力测试，以及要确保它们的客户端在共享资源变慢或者锁住的时候仍旧能够工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="unbalanced-capacities"&gt;
&lt;h3 id="hidunbalanced-capacities"&gt;Unbalanced Capacities&lt;a class="headerlink" href="#hidunbalanced-capacities" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;链路中各个系统的容量不一样，尤其是前端部分一般容量都比后端部分大，在突然出现的流量高峰的时候容量不够的部分就会成为瓶颈，
但是让所有系统的容量都预留的特别足只为了应对某一天的突发流量也不是特别现实。&lt;/p&gt;
&lt;p&gt;但是也还是要应对偶然的突发流量的，调用方可以在下游异常时应用熔断器模式来减轻下游服务的压力，
服务提供方可以使用 Handshaking 和 Backpressure 来告诉调用方请求限流了，同时也可以考虑使用 Bulkheads 模式来为高优先级的调用方保留容量。&lt;/p&gt;
&lt;div class="section" id="drive-out-through-testing"&gt;
&lt;h4 id="hiddrive-out-through-testing"&gt;Drive Out Through Testing&lt;a class="headerlink" href="#hiddrive-out-through-testing" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;不均衡的容量是另一个无法在 QA 环境发现的稳定性问题。&lt;/p&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;检查服务器和线程数量，防止在生产环境出现容量不均衡导致的问题，这个情况一般在测试环境中发现不了，因为测试环境中一把就一两台服务器。&lt;/li&gt;
&lt;li&gt;留意尺度效应和突增用户。&lt;/li&gt;
&lt;li&gt;虚拟化 QA 环境，扩容 QA 环境。尝试测试调用方和被调方非等比扩容下的 case 。&lt;/li&gt;
&lt;li&gt;压力测试接口的两端。既要测试后端服务（突然涌入10倍的流量会咋样？）也要测试前端流量（如果后端异常了会咋样？）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="dogpile"&gt;
&lt;h3 id="hiddogpile"&gt;Dogpile&lt;a class="headerlink" href="#hiddogpile" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;当一群服务同时施加这种瞬时负载的时候，这种情况就叫做叠罗汉（Dogpile）。 dogpile 可能发生的场景：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;多个服务启动的时候，比如代码升级或服务重启&lt;/li&gt;
&lt;li&gt;在半夜触发的定时任务（或者每小时触发）&lt;/li&gt;
&lt;li&gt;配置管理系统推送一个变更&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有些配置管理工具允许配置一个随机因子（这样推送事件就不会集中在某一点）来打散短时间内的 dogpile 问题。&lt;/p&gt;
&lt;p&gt;dogpile 也可能会发生在因为外部因素导致出现了同步触发的流量。
需要小心那些多个线程等待一个线程完成的情况，当那个线程完成的时候，那些等待的线程就会对下游服务产生 dogpile 现象。&lt;/p&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Dogpile 需要你花费更多的容量来处理它产生的波峰问题。&lt;/li&gt;
&lt;li&gt;使用随机时钟来打散波峰，不要把所有定时任务都放在半夜执行或者每小时执行，混合使用来打散负载。&lt;/li&gt;
&lt;li&gt;通过增加 backoff 次数来规避脉冲现象。固定周期的重试间隔会产生周期性的脉冲，应该使用 backoff 算法这样不同的调用者会因为不同的周期而产生不同的流量点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="force-multiplier"&gt;
&lt;h3 id="hidforce-multiplier"&gt;Force Multiplier&lt;a class="headerlink" href="#hidforce-multiplier" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;自动化赋予了管理员以少量工作完成大规模迁移的能力，这个就是 Force Multiplier&lt;/p&gt;
&lt;div class="section" id="outage-amplification"&gt;
&lt;h4 id="hidoutage-amplification"&gt;Outage Amplification&lt;a class="headerlink" href="#hidoutage-amplification" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;自动化系统或策略所产生的结果可能不一定是符合预期的结果，比如 reddit 有次故障就是跟自动化系统有关：&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.reddit.com/r/announcements/comments/4y0m56/why_reddit_was_down_on_aug_11"&gt;http://www.reddit.com/r/announcements/comments/4y0m56/why_reddit_was_down_on_aug_11&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="controls-and-safeguards"&gt;
&lt;h4 id="hidcontrols-and-safeguards"&gt;Controls and Safeguards&lt;a class="headerlink" href="#hidcontrols-and-safeguards" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;我们可以在我们的控制面板软件中实现一些保护措施（safeguards）来预防自动化可能产生的非预期结果：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;如果观察者报告有 80% 以上的系统不可用了，这个情况很有可能是观察者有问题而不是系统出问题了。&lt;/li&gt;
&lt;li&gt;应用迟滞现象（Hysteresis），快速启动机器，但是关闭的时候要慢一点。启动一台新的机器要比下掉一台旧机器更安全。&lt;/li&gt;
&lt;li&gt;当预期的状态跟观察到的状态有很大差异的时候，需要增加确认信号。&lt;/li&gt;
&lt;li&gt;消费资源的系统需要有足够的状态以便在他们尝试启动无限的实例的时候检测到这一异常情况。&lt;/li&gt;
&lt;li&gt;建立减速带来控制动力。假设你的控制面板每秒检测一次过量的负载，但启动一个虚拟机来处理负载需要五分钟。 确保它不会因为持续存在的负载而启动 300 台虚拟机。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;在做大破坏的前寻求帮助。基础设施管理工具可以在很短的时间内产生大量的破坏力，为它们构建限制器和保护措施这样它们就不会一次性把整个系统都摧毁。&lt;/li&gt;
&lt;li&gt;小心滞后的时间和动量。自动化启动的操作需要时间。 这个时间通常比监控时间间隔更长，因此要确保系统对动作的响应有一定的延迟（不要重复触发大量多余的自动化动作，比如前面提到的扩容问题）。&lt;/li&gt;
&lt;li&gt;提防错觉和迷信。控制系统可以感知环境，但是它们也可能被愚弄。 它们会计算出一个预期的状态和一个当前状态的『信念』，这两个任何一个都可能出错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="slow-responses"&gt;
&lt;h3 id="hidslow-responses"&gt;Slow Responses&lt;a class="headerlink" href="#hidslow-responses" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;通常一个慢响应要比一个拒绝连接或返回错误要更糟糕。&lt;/p&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;慢响应会触发级联故障。&lt;/li&gt;
&lt;li&gt;对于网站来说，慢响应会导致更多的流量。&lt;/li&gt;
&lt;li&gt;考虑快速失败。&lt;/li&gt;
&lt;li&gt;查找内存泄露和资源竞争。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="unbounded-result-sets"&gt;
&lt;h3 id="hidunbounded-result-sets"&gt;Unbounded Result Sets&lt;a class="headerlink" href="#hidunbounded-result-sets" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;设计的时候要对外部系统持怀疑态度，时常考虑：系统 X 的啥操作会影响我系统的稳定性。&lt;/p&gt;
&lt;p&gt;无限的结果集在某天可能会对你的系统找出特别大的伤害，
比如一个查询操作，因为没有限制返回的结果，平时数据量少看不出影响，突然有一天返回了上百万行的数据，此时可能就好影响你的系统的稳定性。&lt;/p&gt;
&lt;div class="section" id="black-monday"&gt;
&lt;h4 id="hidblack-monday"&gt;Black Monday&lt;a class="headerlink" href="#hidblack-monday" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Remember This&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;使用合理的数据容量&lt;/li&gt;
&lt;li&gt;分页&lt;/li&gt;
&lt;li&gt;不要依赖数据提供方。不要期望数据提供方会按照预期的提供有限的结果集，万一有一天他们把整个表的数据都返回给你了呢？&lt;/li&gt;
&lt;li&gt;在应用级别的协议中增加限制。服务调用，RMI, DCOM, XML-RPC 以及其他类型的请求/响应调用都非常的脆弱，非常容易然后大量的数据导致占用太多的内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="wrapping-up"&gt;
&lt;h3 id="hidwrapping-up"&gt;Wrapping Up&lt;a class="headerlink" href="#hidwrapping-up" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
</summary><category term="stability"></category></entry><entry><title>《Web 全栈工程师的自我修养》读书笔记</title><link href="https://mozillazg.com/2015/10/web-full-stack-engineer-note-1.html" rel="alternate"></link><updated>2015-10-29T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2015-10-29:2015/10/web-full-stack-engineer-note-1.html</id><summary type="html">&lt;p&gt;&lt;a href="http://book.douban.com/subject/26598045/"&gt;&lt;img alt="Web 全栈工程师的自我修养" src="/static/images/reading/web-full-stack-programmer.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;什么是全栈工程师&lt;/h2&gt;
&lt;p&gt;关于全栈工程师的定义，Quora 上得票最高的回答是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;全栈工程师是指，一个能处理数据库、服务器、系统工程和客户端的所有工作的工程师。根据项目的不同，客户需要的可能是移动栈、Web 栈、或者原生应用程序栈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;流水线开发流程“各司其职”的弊端&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工程师职责不清导致效率低下&lt;/li&gt;
&lt;li&gt;工程师缺乏主人感导致产品质量差&lt;/li&gt;
&lt;li&gt;工程师缺乏全局的视野影响个人成长&lt;/li&gt;
&lt;li&gt;更多角色导致项目效率低下&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;全栈工程师首先要“一专多长”。一专多长的意思是，工程师首先有一个专精的方向，在这个方向上足够精通后（高级工程师级别），以此为突破点去学习更多的知识，增加自己的长处。如果还没有获得某个方向上足够深入的理解，就不要囫囵吞枣地去学习其他领域的知识。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;勿在浮沙筑高台，“全栈”是一个长期积累的过程，是专精型工程师
在不断解决问题的过程中积累知识和经验所形成的能力，而不是一蹴而就的过程。&lt;/p&gt;
&lt;p&gt;解决问题，而不是醉心技术。如果新计划不是你擅长的，怎么办？您应该马上开始学习新的技术，这就是我说的关注问题，而不是醉心技术。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《黑客与画家》&lt;/li&gt;
&lt;li&gt;《专业主义》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;如何成为全栈工程师&lt;/h2&gt;
&lt;h3&gt;“先精后广，一专多长”&lt;/h3&gt;
&lt;p&gt;建议初学者学习全栈技能的时候，先在一个特定的方向上有比较深入的钻研，然后再将学习目标逐渐推广开来。&lt;/p&gt;
&lt;p&gt;作为一个求职者，无论是毕业生还是社会招聘，仅仅满足招聘要求是不够的。您需要在招聘要求的方向上 200% 的能力来得到这个职位。&lt;/p&gt;
&lt;h3&gt;围绕商业目标&lt;/h3&gt;
&lt;p&gt;老板雇用一个员工，不是因为他能写程序，而是因为他能帮助自己赚钱。
一切都要围绕商业目标来进行，包括您做的项目、您的汇报方式，以及您在学习新技能时进行的取舍。&lt;/p&gt;
&lt;p&gt;记住，当您只有一把锤子，您看什么都是钉子。
而如果您痴迷于工具，反而看不到问题的所在。因此，要先看看
有哪些问题需要解决，然后再补充您的工具箱。
永远从商业目标的角度来决定学习哪个东西，而不是纯粹为了锻炼
技术能力而去学习。&lt;/p&gt;
&lt;h3&gt;关注用户体验&lt;/h3&gt;
&lt;p&gt;老板雇用您不是因为您能写代码（或者做工具），而是因为您能帮他赚钱。所以您要用一切办法，去优化流程解决痛点，
做工具是一个可选的方法，但不应该是您的第一个想法，更不是唯一的方法。假使真的是做一个工具，最终汇报邮件的时候，不要以
“我做了一个工具。。。”开头，而应该以“我发现了一个问题。。。”开始。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《重来：更为简单有效的商业思维》&lt;/li&gt;
&lt;li&gt;《精益创业》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;从学生到工程师&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《编程之美：微软技术面试心得》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;野生程序员的故事&lt;/h2&gt;
&lt;p&gt;野生程序员容易陷入样样不精通的窘境。&lt;/p&gt;
&lt;h3&gt;大公司还是创业公司&lt;/h3&gt;
&lt;p&gt;大公司能给您的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;较小的风险&lt;/li&gt;
&lt;li&gt;技术最佳实践&lt;/li&gt;
&lt;li&gt;垂直专精的技能&lt;/li&gt;
&lt;li&gt;服务海量用户的经验&lt;/li&gt;
&lt;li&gt;软技能&lt;/li&gt;
&lt;li&gt;人脉&lt;/li&gt;
&lt;li&gt;心态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作者个人建议是，从毕业生自己前途发展的角度来看，
先加入一家上市大公司是个不错的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《打造 Facebook》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;工程师事业指南&lt;/h2&gt;
&lt;h3&gt;那个什么都懂的家伙&lt;/h3&gt;
&lt;p&gt;软件工程师事业指南告诉您，最核心的 3 个词就是技术、成长和声望。
技术是您的武器，成长就是好好打磨武器，而声望是
您一生的积累。&lt;/p&gt;
&lt;h3&gt;积累作品集&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《您就是极客：软件开发人员生存指南》&lt;/li&gt;
&lt;li&gt;《代码整洁之道》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;全栈工程师眼中的 HTTP&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;尽量减少同一域下的 HTTP 请求数&lt;/strong&gt;
浏览器常常限定了对同一域名发起的并发连接数的上限。
IE 6/7 和 Firefox 2 的设计规则是，同时只能对一个
域名发起两个并发连接。新版本的各种浏览器普遍把这一上限
设定为 4 至 8 个。&lt;/p&gt;
&lt;p&gt;把静态资源放在非主域名下，这种做法除了可以增加浏览器并发，
还有一个好处是，减少 HTTP 请求中携带的不必要的 cookie 数据。&lt;/p&gt;
&lt;p&gt;除此之外，前端工程师经常做的优化是合并同一域名下
的资源，比如把多个 css 合并为一个 css, 或者将图片组合成 css 拼图。&lt;/p&gt;
&lt;p&gt;还有一些优化建议是省掉不必要的 HTTP 请求，比如内嵌小型 css, 内嵌小型 javascript,
设置缓存，以及减少重定向。&lt;/p&gt;
&lt;h2&gt;高性能网站的关键：缓存&lt;/h2&gt;
&lt;p&gt;服务器缓存&lt;/p&gt;
&lt;p&gt;浏览器缓存&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《网站性能监测与优化》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;大前端&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;知识体系&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对浏览器兼容性的了解&lt;/li&gt;
&lt;li&gt;对 HTML/CSS/JavaScript 语法和原理的理解&lt;/li&gt;
&lt;li&gt;对编辑器和插件的熟悉程度&lt;/li&gt;
&lt;li&gt;对调试工具的了解程度&lt;/li&gt;
&lt;li&gt;对版本管理软件的熟悉和应用经验&lt;/li&gt;
&lt;li&gt;对前端库/框架的使用。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标准/规范&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对代码质量，代码规范的理解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;对 JavaSript 单元测试的熟悉。&lt;/li&gt;
&lt;li&gt;对性能优化的应用和理解。&lt;/li&gt;
&lt;li&gt;对 SEO 的应用和理解。&lt;/li&gt;
&lt;li&gt;代码部署。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移动 Web。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码架构&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;安全&lt;/li&gt;
&lt;li&gt;对自动化测试的理解&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;向移动端转型&lt;/h2&gt;
&lt;h3&gt;有哪些方向&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;iOS 原生 App&lt;/li&gt;
&lt;li&gt;Android 原生 App&lt;/li&gt;
&lt;li&gt;Windows Phone 原生 App&lt;/li&gt;
&lt;li&gt;Web App&lt;/li&gt;
&lt;li&gt;混合模式 App(Hybrid App)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Getting Real》&lt;/li&gt;
&lt;li&gt;《从 0 到 1：开启商业与未来的秘密》&lt;/li&gt;
&lt;li&gt;《Building iPhone Apps with HTML, CSS, and JavaScript》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;持续集成&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;版本控制最佳实践&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;鼓励频繁地提交&lt;/li&gt;
&lt;li&gt;确定分支流程&lt;/li&gt;
&lt;li&gt;定义主干原则，并且坚守它&lt;/li&gt;
&lt;li&gt;不要把逻辑的修改和代码格式化操作混在一起&lt;/li&gt;
&lt;li&gt;不相干的代码分开提交&lt;/li&gt;
&lt;li&gt;保持工作代码库的“干净”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;包管理&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;npm&lt;/li&gt;
&lt;li&gt;bower&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《Pro Git book》&lt;/li&gt;
&lt;li&gt;《Git 版本控制管理》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;理解编程语言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;通用用途语言 VS 特定领域语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;特定领域语言（Domain Specific Language, DSL）。
DSL 的目的是解决特定领域的问题。&lt;/p&gt;
&lt;p&gt;如果您是一个以解决问题为目标的全栈工程师，我建议您在考虑
发明一个 DSL 之前先考虑以下方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽量使用您熟悉的通用语言来解决问题，比如 Python, Java 或 C++.&lt;/li&gt;
&lt;li&gt;优化您的方案，提炼出一种真正精简、优雅的扩展库。&lt;/li&gt;
&lt;li&gt;开源您的扩展库，根据其他人的贡献来继续优化解决方案。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《代码大全》&lt;/li&gt;
&lt;li&gt;《代码的未来》&lt;/li&gt;
&lt;li&gt;《禅与摩托车维修的艺术》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;全栈游乐场&lt;/h2&gt;
&lt;p&gt;就是说了需要有一个自己的 VPS, VPS 可以让你对网站的全貌有所了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《鸟哥的 Linux 私房菜：基础学习篇》&lt;/li&gt;
&lt;li&gt;《只是为了好玩：Linux 之父林纳斯自传》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;软件设计方法&lt;/h2&gt;
&lt;h3&gt;设计模式&lt;/h3&gt;
&lt;p&gt;设计模式的关注点在于以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高效编写代码&lt;/li&gt;
&lt;li&gt;高可复用性&lt;/li&gt;
&lt;li&gt;抽象带来的可读性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;《设计模式》一书中作者列出了 23 种软件设计模式，分为三大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建型模式，就是用来创建对象的模式，它对实例化的过程进行了抽象。创建型模式帮助一个系统独立于如何创建、组合和表示它的那些对象。&lt;ul&gt;
&lt;li&gt;单例模式&lt;/li&gt;
&lt;li&gt;工厂方法&lt;/li&gt;
&lt;li&gt;抽象工厂&lt;/li&gt;
&lt;li&gt;建造模型&lt;/li&gt;
&lt;li&gt;原型模式&lt;/li&gt;
&lt;li&gt;对象池模式&lt;/li&gt;
&lt;li&gt;多例模式等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;结构型模式，主要解决类、对象、模块之间的耦合关系。&lt;ul&gt;
&lt;li&gt;适配器模式(Adapter)&lt;/li&gt;
&lt;li&gt;桥接模式&lt;/li&gt;
&lt;li&gt;组合模式&lt;/li&gt;
&lt;li&gt;装饰模式&lt;/li&gt;
&lt;li&gt;外观模式&lt;/li&gt;
&lt;li&gt;享元模式&lt;/li&gt;
&lt;li&gt;代理模式等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;行为模式，用来识别对象之间的常用交流模式并加以实现。&lt;ul&gt;
&lt;li&gt;观察者模式（发布订阅模式）&lt;/li&gt;
&lt;li&gt;黑板&lt;/li&gt;
&lt;li&gt;责任链&lt;/li&gt;
&lt;li&gt;命令&lt;/li&gt;
&lt;li&gt;解释器&lt;/li&gt;
&lt;li&gt;迭代器&lt;/li&gt;
&lt;li&gt;中介者&lt;/li&gt;
&lt;li&gt;备忘录&lt;/li&gt;
&lt;li&gt;空对象&lt;/li&gt;
&lt;li&gt;模板方法&lt;/li&gt;
&lt;li&gt;访问者等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;架构模式&lt;/h3&gt;
&lt;p&gt;比如：MVC&lt;/p&gt;
&lt;h3&gt;设计原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DRY，是 "Don't Repeat Yourself" 的缩写，在一个系统里，对于任何数据或变量，都应该配置在有且只有一个地方，其他地方都应该引用这里的数据。&lt;/li&gt;
&lt;li&gt;惯例优于设置，开发人员仅需要规定应用中不符合约定的部分。&lt;/li&gt;
&lt;li&gt;KISS 原则，是 "Keep it simple, stupid" 的缩写，意思是说软件设计当中应该注重简约的原则。&lt;/li&gt;
&lt;li&gt;最少知道原则，它是“松耦合原则”的一个具体实例，是指在面向对象编程中，每一个软件单元应该尽可能少地与其他单元发生作用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《设计模式：可复用面向对象软件的基础》&lt;/li&gt;
&lt;li&gt;《JavaScript 设计模式》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;高效工程师&lt;/h2&gt;
&lt;h3&gt;提速 100 倍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;阅读英文资料&lt;/li&gt;
&lt;li&gt;时间管理四象限&lt;ul&gt;
&lt;li&gt;既紧急又重要的（立即执行）&lt;/li&gt;
&lt;li&gt;紧急不重要（他人代劳）&lt;/li&gt;
&lt;li&gt;重要不紧急（制定计划，建议工程师把 80% 的工作投入到该象限中，避免“瞎忙”）&lt;/li&gt;
&lt;li&gt;不紧急不重要（对它所不）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消除重复工作&lt;/li&gt;
&lt;li&gt;给自己留出不被打扰的时间&lt;/li&gt;
&lt;li&gt;番茄工作法&lt;/li&gt;
&lt;li&gt;跨界思考&lt;/li&gt;
&lt;li&gt;纸上头脑风暴&lt;/li&gt;
&lt;li&gt;使用版本控制工具和构建系统&lt;/li&gt;
&lt;li&gt;不要加班&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《软件随想录：程序员部落酋长 Joel 谈软件》&lt;/li&gt;
&lt;li&gt;《卓有成效的程序员》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;学习设计&lt;/h2&gt;
&lt;h3&gt;设计基础&lt;/h3&gt;
&lt;p&gt;设计的四大基本理论是：亲密性，对齐，重复，对比。&lt;/p&gt;
&lt;p&gt;设计工具：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Axure&lt;/li&gt;
&lt;li&gt;Sketch&lt;/li&gt;
&lt;li&gt;Quartz Composer&lt;/li&gt;
&lt;li&gt;代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《响应式 Web 设计全流程解析》&lt;/li&gt;
&lt;li&gt;《写给大家看的设计书（第 3 版）》&lt;/li&gt;
&lt;li&gt;《写给大家看的设计书：实例与创意》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;全栈思维&lt;/h2&gt;
&lt;h3&gt;有兴趣就够了吗？&lt;/h3&gt;
&lt;p&gt;扯一些理由（特别是私人的理由）根本就是不专业的态度。
不要给自己没能完成的事情找任何理由，而要以诚恳的态度说明当前进度，以及未来是否能如期完成目标，如果不能，就直接说出来。&lt;/p&gt;
&lt;p&gt;在职场中，我们评估一个人并不是根据他的能力，而是他能
承担的责任。同样，我们最终评估一个人是否应该升职加薪，
不是看他的能力，也不是看他投入的时间，更不是看兴趣，
只是看他的责任。&lt;/p&gt;
&lt;h3&gt;学一点管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;好的管理者能让平凡的员工做不平凡的事&lt;/li&gt;
&lt;li&gt;根据员工特质来授权&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;沟通： 被忽视的竞争力&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《卓有成效的管理者》&lt;/li&gt;
&lt;li&gt;《麦肯锡教我的写作武器》&lt;/li&gt;
&lt;li&gt;《金字塔原理》&lt;/li&gt;
&lt;li&gt;《安静：内向性格的竞争力》&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Web 全栈工程师的自我修养"></category></entry><entry><title>《High Performance Django》阅读笔记（三）</title><link href="https://mozillazg.com/2015/09/high-performance-django-note-3.html" rel="alternate"></link><updated>2015-09-28T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2015-09-28:2015/09/high-performance-django-note-3.html</id><summary type="html">&lt;p&gt;&lt;a href="http://book.douban.com/subject/26359018/"&gt;&lt;img alt="" src="/static/images/reading/s28041145.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;第四章：预备&lt;/h2&gt;
&lt;h3&gt;使用 Jmeter 进行负载测试&lt;/h3&gt;
&lt;p&gt;这一部分主要讲解了 Jmeter 的各种是否方法及配置。&lt;/p&gt;
&lt;h3&gt;启动计划&lt;/h3&gt;
&lt;p&gt;启动的时候有些东西需要考虑&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用负载均衡器在新的和旧的之间分流&lt;/li&gt;
&lt;li&gt;使用“dark launch”，这样用户就不会感觉到他们访问的是新的服务器&lt;/li&gt;
&lt;li&gt;使用代理功能分一部分流量到新的服务器&lt;/li&gt;
&lt;li&gt;使用特性标志来发布一个新的特性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发送流量到一个新的没有缓存的服务器可能会导致临时的高负载
从而在缓存热和起来前击垮你的服务器。预热你的缓存可以解决这个问题。一个比较简单的办法是使用一个脚本在有真实请求前去抓取你的网站上的热门 URLs。&lt;/p&gt;
&lt;p&gt;不要在一天的最后时间段或周五的时候升启动，除非你想让你的
整个团队在晚上或周末加班。
你应该在大家都在并且有几个小时或几天的时间来处理
启动过程中出现的问题时候启动，同时也要确保你的成员有时间休息。
如果你的网站访问量比较高的话，尝试在访问量比较低的时间段进行升级操作。&lt;/p&gt;
&lt;h3&gt;启动前的检查事项&lt;/h3&gt;
&lt;h4&gt;Django 配置项&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DEBUG&lt;/code&gt; 和 &lt;code&gt;TEMPLATE_DEBUG&lt;/code&gt; 都设为 &lt;code&gt;False&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECRET_KEY&lt;/code&gt; 是个非常大的随机字符串并且保密&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ALLOWED_HOSTS&lt;/code&gt; 包含了访问者可能会使用的有效域名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TEMPLATE_LOADERS&lt;/code&gt;: Cached template loader 已启用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SESSION_ENGINE&lt;/code&gt; 比默认设置更快&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CACHES&lt;/code&gt;: 使用 Memcached 或 Redis 后端&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MEDIA_ROOT&lt;/code&gt; 和 &lt;code&gt;MEDIA_URL&lt;/code&gt; 接受并显示文件上传&lt;/li&gt;
&lt;li&gt;管理员账户被限制并且有一个强壮的密码&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;部署&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;通过点击各种页面和链接的方式来确认网站是否按预期的结果
  工作（没有挂掉的图片和链接）&lt;/li&gt;
&lt;li&gt;Django 日志是否正常工作&lt;/li&gt;
&lt;li&gt;监控平台是否接收到数据。确保你能看到整个技术栈中各级
  的错误信息。&lt;/li&gt;
&lt;li&gt;错误被汇报并且触发了通知&lt;/li&gt;
&lt;li&gt;第三方服务能够接收到数据（支付，分析等等）&lt;/li&gt;
&lt;li&gt;从你的应用服务和 Celery workers 中发出邮件的功能
  能够正常运行&lt;/li&gt;
&lt;li&gt;自定义的错误页面（400，500）已经在各个级别中被设置（负载均衡器，web 加速器，Django）&lt;/li&gt;
&lt;li&gt;Django admin 没法通过 /admin/ 公开访问&lt;/li&gt;
&lt;li&gt;SSL 证书有效并且设置是安全的。&lt;/li&gt;
&lt;li&gt;Django-secure 的 &lt;code&gt;manage.py checksecure&lt;/code&gt; 运行起来没有错误输出&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;基础设施&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;服务器和服务是安全的，已经锁好了大门&lt;/li&gt;
&lt;li&gt;有个简单，正式的程序用来部署新的代码&lt;/li&gt;
&lt;li&gt;你有一个可以在需要的时候快速水平扩展服务的计划&lt;/li&gt;
&lt;li&gt;DNS TTL 可以被修改为 5 分钟或更短的时间在需要更改的时候&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;第五章 The Launch&lt;/h2&gt;
&lt;h3&gt;监控整个 Launch&lt;/h3&gt;
&lt;h4&gt;服务器资源&lt;/h4&gt;
&lt;p&gt;可以使用如下工具参考服务器资源使用情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;htop&lt;/li&gt;
&lt;li&gt;varnishstat&lt;/li&gt;
&lt;li&gt;varnishhist&lt;/li&gt;
&lt;li&gt;varnishtop&lt;/li&gt;
&lt;li&gt;varnishlop&lt;/li&gt;
&lt;li&gt;uwsgitop&lt;/li&gt;
&lt;li&gt;celery inspect&lt;/li&gt;
&lt;li&gt;celery events&lt;/li&gt;
&lt;li&gt;flower&lt;/li&gt;
&lt;li&gt;memcache-top&lt;/li&gt;
&lt;li&gt;pg_top&lt;/li&gt;
&lt;li&gt;pg_stat_statements&lt;/li&gt;
&lt;li&gt;pt-query-digest&lt;/li&gt;
&lt;li&gt;mytop&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;当灾难来临的时候&lt;/h3&gt;
&lt;h4&gt;应用服务器过载&lt;/h4&gt;
&lt;p&gt;最简单的办法就是通过增加服务器的方式进行水平扩展。
不过你需要注意这将导致你的数据库承受更大的压力，
可能会把数据库搞挂。&lt;/p&gt;
&lt;p&gt;当你通过增加服务器的方式把负载降低到可以接受的级别后，
你就需要使用你的低级别的工具来查看为什么会出现负载过高的
情况。你的 web 加速器端缓存命中率过低是一个需要考虑的因素。&lt;/p&gt;
&lt;h4&gt;数据库服务器过载&lt;/h4&gt;
&lt;p&gt;如果你的网站是 读多写少的话，可以通过增加 replica 的方式来简单解决响应时间问题。
同时也看看是否在数据库优化时遗漏某些可以优化的项。&lt;/p&gt;
&lt;h4&gt;应用和数据库服务器过载&lt;/h4&gt;
&lt;p&gt;你可以从自底向上优化你的数据库，减轻数据库的压力可以让你的应用拥有更高的性能。
你也可以通过优化你的 web 加速器从而减轻应用服务器的压力，进而减轻数据库服务器的压力。&lt;/p&gt;
&lt;h2&gt;前方的路&lt;/h2&gt;
&lt;p&gt;恭喜你的网站已经启动了！现在你需要确保它能够持续稳定的运行。在这个战争中你需要与下列事物做斗争：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你的用户（流量增长）&lt;/li&gt;
&lt;li&gt;你的软件（一点点腐烂）&lt;/li&gt;
&lt;li&gt;你（错误的决定）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第一个没啥好惊讶的，最后两个可能会让你惊讶同时也是让你网站宕机的一些因素。&lt;/p&gt;
&lt;h3&gt;流量增长&lt;/h3&gt;
&lt;p&gt;正常情况下你的网站不应该在技术栈的任何层次占用 100% 的资源，一旦出现超过 70%（CPU,内存，磁盘等等）
的资源占用，那就说明某些地方需要优化了或者增加更多的资源。当流量突增的时候如果你有额外的资源的话就可以很好
的应对。&lt;/p&gt;
&lt;p&gt;有些时候的流量激增可能是商业上进行了某些吸引用户的活动，确保开发者知道这些商业活动，以便应对激增的流量。
一个好的主意是像刚启动时那样，大家在桌子上一起讨论分享这些商业信息。&lt;/p&gt;
&lt;h3&gt;一点点腐烂&lt;/h3&gt;
&lt;p&gt;由于高性能网站使用了很多不同的服务，所以需要保持这些服务打上了最新的安全补丁。
“如果没出现问题，就不要去修复它”是个非常危险的准则。&lt;/p&gt;
&lt;p&gt;跳过几个小版本是没什么问题的，但是不要落下太远，不然的话到时就会失去升级动力。
定期小步升级你的依赖（你的操作系统，主要的服务以及 Python 库）。&lt;/p&gt;
&lt;p&gt;作者的小贴士：&lt;/p&gt;
&lt;p&gt;当 review 升级的时候，我们通常不会使用最新的版本，一般最新版本也意味着有新的 bug ，我想
你不希望当小白鼠吧。给新版本几个月的成熟期。
升级到第一个稳定的版本或者你已经确保这个版本没什么大的问题了。&lt;/p&gt;
&lt;h3&gt;错误的决定&lt;/h3&gt;
&lt;h4&gt;意外的刷新了缓存&lt;/h4&gt;
&lt;p&gt;在流量特别高的时候重启缓存或 web 加速器可能会击垮你的网站。这个问题叫做 &lt;a href="http://en.wikipedia.org/wiki/Cache_stampede"&gt;dog-piling/cache stampede&lt;/a&gt;
所以尽量使用 reload 的方式来更新服务。对于使用 memcached/redis 的缓存可以通过给不同的缓存定义不同的 &lt;code&gt;KEY_PREFIX&lt;/code&gt;
的方式来实现逐个清理缓存（通过 &lt;code&gt;VERSION&lt;/code&gt;）而不是一下子删除所有缓存的功能。
如果一定要重启的话，进行选择在流量低的时候重启服务。&lt;/p&gt;
&lt;h4&gt;数据库锁表&lt;/h4&gt;
&lt;p&gt;数据库锁会临时阻塞主写操作，如果这个操作特别长的话就会成为一个问题。两个比较常见的长时间锁表的场景是： schema migration 和备份。&lt;/p&gt;
&lt;p&gt;在开发的时候， South 和内置的 migration 可以很方便的应用 Model 更改，
但是在生成环境下， migrate 操作可能会导致长时间的锁表现象，这个对你的用户来说就是个糟糕的消息了。
对于 &lt;code&gt;ADD COLUMN&lt;/code&gt; 操作，如果你使用的是 MySQL 数据库的话你需要留意一下这个，但是 PostgreSQL 很少会出现这个问题。&lt;/p&gt;
&lt;p&gt;无论你使用哪种数据库，migrations 都需要被 review 并且使用最近的线上数据的副本数据测试过后才能在生产环境使用。&lt;/p&gt;
&lt;p&gt;备份是另一个会导致长时间锁住数据库的操作。最好是在一个只读的 replica 上进行备份操作。&lt;/p&gt;
&lt;h4&gt;大量的缓存过期&lt;/h4&gt;
&lt;p&gt;跟刷新缓存差不多糟糕的事情就是有大量的缓存过期，这将导致数据库压力倍增。
如果你不是很确定的话，应该选择在流量比较低的时候进行部署操作，避免击垮你的站点。&lt;/p&gt;
&lt;h4&gt;昂贵的 admin 视图&lt;/h4&gt;
&lt;p&gt;构建一个未优化的 admin 视图会导致上千的数据库查询。
如果你正在使用一个查询缓存比如 johnny-cache, 每一次在 admin 中保存都将
导致与所在表相关的缓存都将失效。所以 admin 视图也需要像普通视图那样进行优化。&lt;/p&gt;
&lt;h4&gt;昂贵的后台任务&lt;/h4&gt;
&lt;p&gt;未优化，数据库依赖的任务会导致非预期的负载负担。所有应该像优化视图一样优化你的后台任务。&lt;/p&gt;
&lt;h4&gt;逐渐恶化&lt;/h4&gt;
&lt;p&gt;随着新功能的增加，网站的性能也在接受不同的考验，你需要随时关注性能问题。&lt;/p&gt;
&lt;p&gt;每次发布新版本的时候都关注一下性能的变化，如果响应时间变长了或者负载变高了，
立马去解决它。这样就不会出现在几个月的提交过去后再去查找问题所在的情况。&lt;/p&gt;
&lt;h4&gt;complexity creep&lt;/h4&gt;
&lt;p&gt;如果你按照前面所说的步骤做了的话，你已经做的非常好了。
随着你的网站的成长你可能会遇到各种各样的新问题，你可以很容易的就构建自己
独有的解决方法。
构建你自己的工具是件很有乐趣的事情，但是 &lt;a href="http://en.wikipedia.org/wiki/Not_invented_here"&gt;not invented here&lt;/a&gt; 对于长时间运行
的站点是非常危险的。你最好去学习如何让 Varnish 更高效而不是丢弃它转而使用你自己的工具。
这个决定衍生的代价是非常巨大的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;训练新的开发者需要更高的花费。你可以找到一名拥有使用一个比如 Varnish 这种服务经验的开发者，
  但是如果使用你自定义的方案的话，你需要训练每一位在门外徘徊的开发者。&lt;/li&gt;
&lt;li&gt;开发低级别的基础设施工具将会导致开发时间远离了你的核心产品。使用一个支持良好的开源服务，
  你的团队的开发者的效率会很高效。&lt;/li&gt;
&lt;li&gt;写你自己的软件代码不是一锤子买卖。所有的软件都需要不断的开发，测试，文档，等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;最后的想法&lt;/h2&gt;
&lt;p&gt;现在你可以在看看那个老问题“Django doesn't scale”，你是怎么认为的呢？
如果只用 &lt;code&gt;manage.py runserver&lt;/code&gt;，使用 SQLite 在一个非常小的云服务器上跑
当然不会很快。&lt;/p&gt;
&lt;p&gt;让我们回到 2012 年，当 Instagram 只有3个的 Django 团队却支撑起了 1千4百多万的用户的时候，
他们在博客上是 &lt;a href="http://instagram-engineering.tumblr.com/post/13649370142/what-powers-instagram-hundreds-ofinstances-dozens-of"&gt;这么说的&lt;/a&gt; ：&lt;/p&gt;
&lt;p&gt;我们选择一个系统的核心宗旨是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持非常简单&lt;/li&gt;
&lt;li&gt;不要重复造轮子&lt;/li&gt;
&lt;li&gt;可能的话，使用久经考验的成熟的技术&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们非常同意。因此，在你继续你的 Django 旅程的时候，不要忘了你在这里学到的东西。
简单是指导原则。&lt;/p&gt;</summary><category term="High Performance Django"></category><category term="Django"></category></entry><entry><title>《High Performance Django》阅读笔记（二）</title><link href="https://mozillazg.com/2015/09/high-performance-django-note-2.html" rel="alternate"></link><updated>2015-09-27T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2015-09-27:2015/09/high-performance-django-note-2.html</id><summary type="html">&lt;p&gt;&lt;a href="http://book.douban.com/subject/26359018/"&gt;&lt;img alt="" src="/static/images/reading/s28041145.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;第三章：The Deployment&lt;/h2&gt;
&lt;h3&gt;先决条件&lt;/h3&gt;
&lt;h4&gt;操作系统&lt;/h4&gt;
&lt;p&gt;作者推荐使用 Ubuntu。同时作者给出了选择其他操作系统时，需要考虑的事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够很容易的就使用 Python 2.7+ 。有些操作系统要安装 2.7+ 版本的 Python 非常的麻烦，如果是这样的话你就要慎重考虑了。&lt;/li&gt;
&lt;li&gt;有长久的安全更新支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;配置管理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Chef, Puppet, Ansible, Salt 都是比较好的配置管理工具&lt;/li&gt;
&lt;li&gt;Fabric 不是配置管理工具，如果你把它当作配置管理工具的话，会有你头疼的时候。你可以在 Fabric 的基础上
  构建你自己的配置管理工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;进程管理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;系统默认的工具：upstart, systemd&lt;/li&gt;
&lt;li&gt;第三方软件：deamontools, supervisord, circus&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;更新代码&lt;/h4&gt;
&lt;p&gt;更新代码一般需要进行下面几步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从版本控制服务器上拉取最新的代码&lt;/li&gt;
&lt;li&gt;更新依赖&lt;/li&gt;
&lt;li&gt;合并数据库更改(migrate)&lt;/li&gt;
&lt;li&gt;收集，压缩，推送静态文件到 CDN&lt;/li&gt;
&lt;li&gt;reload WSGI 服务器&lt;/li&gt;
&lt;li&gt;重启后台 workers&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;推荐写个脚本自动执行这些操作，这样不容易出错。如果要更新多台服务器的话，可以使用远程执行
框架来做这种事情，比如： Salt, Fabric。&lt;/p&gt;
&lt;p&gt;有一点特别要注意的是，一旦服务上线就应该尽可能的使用平滑 reload 的方式来代替重启进程的暴力方式。&lt;/p&gt;
&lt;h4&gt;多个远程环境&lt;/h4&gt;
&lt;p&gt;至少要有两个环境吧：打包/开发环境，生产环境。
同时多个环境尽量保证一致性，尤其是多个生产环境之间（设置，软件，系统，等等）。
不过有些东西还行要区分的，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第三方服务配置。比如，你肯定不希望在开发环境下触发支付操作或发送文件到生产环境下的 CDN 上。&lt;/li&gt;
&lt;li&gt;获取数据的问题。经常看到某些人在开发环境下使用线上数据库的副本，但是这里有几个问题要考虑：&lt;ul&gt;
&lt;li&gt;你的开发环境更生产环境一样安全吗？监控松散的开发机器是黑帽黑客经常会攻击的目标。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有可能会从你的应用中发送邮件或通知吗？从你的开发环境下向你的用户发送数千封邮件不仅是非常
  尴尬的事情，同时也会影响你们的商业。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;避免单点故障&lt;/h4&gt;
&lt;p&gt;要经常备份，确保你知道所有存储的数据（数据库，用户上传的数据，等等）都有备份。这样出现故障的时候
其他其他机器的时候丢失的数据会少一点。&lt;/p&gt;
&lt;p&gt;高可用是一个可以考虑的方法，如果对你的商业来说他是非常重要的话。 HA 可以保证在出现服务挂掉
的情况下能够无缝自动切换到备用服务或者说不用手动切换。不过需要注意的是通常构建高可用
的花费比服务当掉的花费还高。&lt;/p&gt;
&lt;p&gt;在考虑架构的时候要考虑到如何解决单点故障的问题。举个例子，当使用第三方的 Amazon EC2 的时候，
你是否能够接受某些区域的设备宕机，整个地区呢？如果服务商 Amazone 当了怎么办？
越早考虑这些问题就能在灾难实际发生的时候更好的应对。&lt;/p&gt;
&lt;h3&gt;服务器布局&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;负载均衡器： 可以使用云服务商提供的负载均衡服务或者使用 nginx, Haproxy。对于负载均衡器网络
  带宽是个非常重要的注意点。&lt;/li&gt;
&lt;li&gt;Web 加速器：网络带宽和内存是值得关注的点&lt;/li&gt;
&lt;li&gt;应用：CPU 和内存值得关注。&lt;/li&gt;
&lt;li&gt;后台运行的 workers：后台运行的任务通常都是 CPU 密集型的任务并且运行在独立的服务器上。一个服务器上可以运行
  多个 workers。&lt;/li&gt;
&lt;li&gt;缓存：你的缓存服务器需要更多的内存。另一个需要注意就是网络带宽，它可能会在内存之前成为瓶颈。如果网络开始
  拥堵的时候， Django 可以配置多个缓存服务器。&lt;/li&gt;
&lt;li&gt;数据库：足够的内存非常重要，最用是足够把你的数据都装载在内存里。
  如果你预期会有 64GB 的数据，那么至少要有 64GB 的内存。
  磁盘速度也非常重要。购买你能够负担得起的最快的磁盘。
  如果你用的是虚拟机的话，你需要留意你其实是在跟你的邻居共享一个物理磁盘，常规的实践是尽可能的买最大的虚拟机。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;优化技术栈&lt;/h3&gt;
&lt;h4&gt;优化数据库&lt;/h4&gt;
&lt;h4&gt;优化 uWSGI&lt;/h4&gt;
&lt;h4&gt;优化 Django&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;CACHES&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你使用 Memcached，使用 pylibmc 这个库会有更高的性能。
redis 的话可以使用 &lt;a href="http://niwibe.github.io/django-redis"&gt;django-redis&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;缓存过期是第一个需要面临的问题，一个缓存 key 过期或者被刷新都有可能摧毁你的数据库。
幸运的是有个简单包可以解决这个问题： &lt;a href="https://github.com/joshourisman/django-newcache"&gt;django-newcache&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还有一个问题就是如果缓存服务器宕机了会到期用户收到 “500 Server Error”的响应。
将使用一个缓存服务器改为三个可以降低出错的几率。
你需要考虑当缓存服务器宕机的时候，你是需要你的网站也跟着宕机，还是希望你的应用继续
运行良好只是把它当作缓存未命中来处理？作者创建了一个 &lt;a href="https://github.com/lincolnloop/django-ft-cache"&gt;django-ft-cache&lt;/a&gt; 包用来
解决这个问题，它会将任何的 memcached 操作用 try/except 包裹，捕获这里的异常，
这样缓存服务器当掉时请求依然可以被正确处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SESSION_ENGINE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把 session 保存在数据库中非常影响性能，一个好的办法是保存在缓存中。如果用 redis 的话
可以使用 cache backend, 用 memcached 的话 cached_db backend 也还行。
另一个办法就是使用 signed_cookies backend, 让客户端存储 session 数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DATABASES&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过 &lt;code&gt;DATABASES&lt;/code&gt; 设置增加 &lt;code&gt;CNN_MAX_AG&lt;/code&gt; key 选项来定义重用数据库连接。
比如 300, 这将告诉 Django 保持打开和重用数据库连接 5 分钟。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LOGGING&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不要定义 LOGGING 将日志保存到文件中，而是应该输出到 &lt;code&gt;STDERR&lt;/code&gt; ，让进程管理器来处理日志。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MIDDLEWARE_CLASSES&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不要轻易自定义中间件，因为中间件会在每个请求中执行。所以确保你知道每个中间件都做了什么，
以及尽可能的不要在中间件中执行数据库查询操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常规安全问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要注意 clickjacking 和 XSS(Cross Site Scripting)。最简单的方法是使用
&lt;a href="https://github.com/carljm/django-secure#readme"&gt;django-secure&lt;/a&gt; 项目来检查安全问题。
另一个安全问题是，确保你的 admin 后台处于保护中，如果你把它开放出去了，确保使用了非常
复杂的管理员密码。最好是把它变成一个内网服务，让它不能从外部互联网访问。&lt;/p&gt;
&lt;h3&gt;配置你的服务器&lt;/h3&gt;
&lt;h4&gt;安全&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;调整 SSH 配置：禁用 &lt;code&gt;root&lt;/code&gt; 登录，禁用密码登录，更改默认端口。&lt;/li&gt;
&lt;li&gt;应用安全补丁：关注一下系统安全问题，及时更新 zer-day 补丁（比如，Hearbleed）&lt;/li&gt;
&lt;li&gt;使用私有网络：大多数云服务器都提供私有网络服务，只允许访问你帐号下的服务。在私有网络
  中访问你的服务器可以加大被人攻击你的难度。&lt;/li&gt;
&lt;li&gt;保护内网服务：内网服务包括控制台，开发服务器，持续集成系统。它们会成为你安全网络的一道暗门。
  将它们用 VPN 或认证代理锁起来，如果你没有使用 VPN 的话，确保传输数据以及登录时总是使用 SSL/HTTPS。
  锁住你的开发环境可以确保 google 不会抓取它从而伤害你的 SEO）&lt;/li&gt;
&lt;li&gt;防火墙：只允许指定端口和 IP 访问你的服务器。硬件防火墙很棒，软件防火墙比如 iptables 也不错。&lt;/li&gt;
&lt;li&gt;不要在 root 下运行：不在 root 下运行可以防止某些人运用 RCE(remote code execution)获取你服务器的
  root 访问权限。使用标准用户登录服务器，只在必要时使用 sudo。&lt;/li&gt;
&lt;li&gt;保护你的第三方服务的账户：使用强壮的密码，尽可能的开启两步验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;备份&lt;/h4&gt;
&lt;p&gt;对于数据库，有一个运行的 replica 可以很方便的执行全备份。推荐在半夜执行全备份。
进行备份的时候有几个问题需要问一下你自己：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果有人黑进了你的服务器，他们能够删掉或破坏你的备份吗？
  基于这个原因拉取到备份服务器比推送要更好。&lt;/li&gt;
&lt;li&gt;如果有人拿到了你的备份会有多糟糕？加密备份文件并且确保黑客没法在同一个服务器上找到解密的方法（注：比如可以使用公钥进行加密，同时服务器上不要存有私钥，这样就不会被黑客在服务器上找到解密的方法）。&lt;/li&gt;
&lt;li&gt;你有测试过备份是否可用吗？定期测试你的备份，验证它们是否真的有效。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;监控&lt;/h3&gt;
&lt;p&gt;没有监控的话，线上网站就会成为一个大黑盒。你没法知道实际情况是怎样的，也就没法进行性能优化了。&lt;/p&gt;
&lt;h4&gt;instrumentation&lt;/h4&gt;
&lt;p&gt;对于应用，你需要知道下面这个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我的系统中最慢的部分是什么？&lt;/li&gt;
&lt;li&gt;Django 处理响应的平均耗时是多少？&lt;/li&gt;
&lt;li&gt;哪个视图是最慢的？或者花费最多的时间？&lt;/li&gt;
&lt;li&gt;哪个数据库查询是最慢的？或者花费最多的时间？&lt;/li&gt;
&lt;li&gt;这些数据一段时间内是如何变化的？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="http://newrelic.com/"&gt;NewRelic&lt;/a&gt; 是个探测这些问题的比较好的服务，它可以很方便的安装。
然而， NewRelic 是闭源的，专有的系统，同时也非常的贵。有一些开源产品可以替代它。
比如：Graphite&lt;/p&gt;
&lt;h4&gt;服务器资源&lt;/h4&gt;
&lt;p&gt;关于服务器资源需要监控如下数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平均负载&lt;/li&gt;
&lt;li&gt;CPU 负载&lt;/li&gt;
&lt;li&gt;物理内存使用情况&lt;/li&gt;
&lt;li&gt;磁盘相关数据&lt;/li&gt;
&lt;li&gt;网络 I/O&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;告警&lt;/h4&gt;
&lt;p&gt;下列情况需要发送告警：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超过 X% 的请求出现错误&lt;/li&gt;
&lt;li&gt;服务器宕机&lt;/li&gt;
&lt;li&gt;服务器资源占用过高：负载，虚拟内存，磁盘等等&lt;/li&gt;
&lt;li&gt;服务未响应&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;日志&lt;/h4&gt;
&lt;p&gt;需要收集如下日志：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从你的负载均衡器都应用的 Apache 风格的日志&lt;/li&gt;
&lt;li&gt;任何应用内的日志&lt;/li&gt;
&lt;li&gt;相关服务的 syslog 日志&lt;/li&gt;
&lt;li&gt;数据库慢查询日志，以及在不会导致数据库连接的 I/O 问题（尤其是磁盘或网络）的前提下收集所有数据库查询的日志。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;错误汇报&lt;/h4&gt;
&lt;p&gt;在生成环境下 Django 默认会在出现异常时给网站管理员发送异常邮件。这个功能有时也会导致一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Email 不利于追踪错误&lt;/li&gt;
&lt;li&gt;如果你的错误发生在一个高访问的页面的话，你实际上是在 DoS 你的邮件服务器，
  可能导致被加入黑名单，或者你的邮件服务商会关掉你的服务（他们不想在几秒内发送超过 10K 的邮件）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;幸运的是，更好的错误汇报方式已经存在了，开源的 &lt;a href="https://www.getsentry.com/"&gt;Sentry&lt;/a&gt; 项目是个非常好的解决方案。
Sentry 并不会发送 10K 的邮件，它之后在第一次出现错误时邮件通知你，之后收集并在 Web 页面上
暂时其他时候的错误用于分析问题。&lt;/p&gt;
&lt;p&gt;还有一个关于错误的主题就是确保有一个漂亮的不引来应用服务的 500.html 文件，并且已经在服务器上配置好了出错是使用
这个页面。&lt;/p&gt;</summary><category term="High Performance Django"></category><category term="Django"></category></entry><entry><title>《High Performance Django》阅读笔记（一）</title><link href="https://mozillazg.com/2015/09/high-performance-django-note-1.html" rel="alternate"></link><updated>2015-09-26T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2015-09-26:2015/09/high-performance-django-note-1.html</id><summary type="html">&lt;p&gt;&lt;a href="http://book.douban.com/subject/26359018/"&gt;&lt;img alt="" src="/static/images/reading/s28041145.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一句话点评：老司机的经验之谈，物有所值。&lt;/p&gt;
&lt;h2&gt;第一章：The Big Picture&lt;/h2&gt;
&lt;p&gt;作者开篇就提到大家总说 Django 性能不行，但是实际上
有很多高性能的站点是使用 Django 开发的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Django’s scaling success stories are almost too numerous to list at this point. It backs Disqus,
Instagram, and Pinterest. Want some more proof? Instagram was able to sustain over 30
million users on Django with only 3 engineers (2 of which had no back-end development
experience). Disqus serves over 8 billion page views per month. Those are some huge
numbers. These teams have proven Django most certainly does scale. Our experience here
at Lincoln Loop backs it up. We’ve built big Django sites capable of spending the day on
the Reddit homepage without breaking a sweat.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在作者的公司，他们开发高性能 Django 站点的准则就是 &lt;strong&gt;simplicity&lt;/strong&gt; :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Using as few moving parts as possible to make it all work. “Moving parts” may be
servers, services or third-party software.&lt;/li&gt;
&lt;li&gt;Choosing proven and dependable moving parts instead of the new hotness.&lt;/li&gt;
&lt;li&gt;Using a proven and dependable architecture instead of blazing your own trail.&lt;/li&gt;
&lt;li&gt;Deflecting traffic away from complex parts and toward fast, scalable, and simple parts .&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Simple systems are easier to scale, easier to understand, and easier to develop. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;构建高性能 Web 应用通常需要关注一下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库。关系型数据库通常是整个技术栈中最慢最复杂的部分，一个办法是改用 NoSQL 数据库，不过
  大多数情况下都可以通过缓存解决。&lt;/li&gt;
&lt;li&gt;模板。我们可以用一个更快的模板引擎替换 Django 自带的模板引擎，不过即便是这样模板仍旧是
  整个技术栈中第二慢的部分。我们仍然可以通过缓存解决这个问题。&lt;/li&gt;
&lt;li&gt;Python。Python 在通常情况下已经足够快了。我们可以使用 Web 加速器（比如：Varnish）缓存服务器响应，
  在请求进入到 Python 那一层之前就返回相应。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这章作者一直在强调缓存，"CACHE ALL THE THINGS"。无论你怎么优化你的技术栈，没有比缓存更快的优化方案。
说到缓存可能大家可能会顾虑缓存过期的问题，作者说了现在先别关心这个问题，之后会给出解决方案。&lt;/p&gt;
&lt;p&gt;作者提到一般的网站都保护这几层：负载均衡器，Web 加速器，APP 服务器，缓存，数据库。&lt;/p&gt;
&lt;p&gt;顺便提了一个 HTTPS 的负载均衡配置方法：客户端与负载均衡器之间使用 HTTPS，负载均衡器与后端服务之间使用 HTTP。这样既保证了安全又可以减少 HTTPS 对性能的影响。&lt;/p&gt;
&lt;h2&gt;第二章 The Build&lt;/h2&gt;
&lt;h3&gt;小技巧&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;本地开发环境应该尽可能的与线上环境一致：相同的数据库，相同的操作系统以及相同的软件版本。。。&lt;/li&gt;
&lt;li&gt;组织 settings 文件，创建一个基础的配置文件 settings/base.py ，然后再为开发，测试，部署分别创建一个配置文件，一些重要的配置信息可以通过环境变量获取&lt;ul&gt;
&lt;li&gt;settings/base.py&lt;/li&gt;
&lt;li&gt;settings/dev.py&lt;/li&gt;
&lt;li&gt;settings/deploy.py&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里作者有提到一个小技巧，那就是环境变量的值都是字符串，那么如果将值转换为布尔值，元组甚至字典呢？答案就是可以使用 ast 模块:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &amp;gt;&amp;gt;&amp;gt; ast.literal_eval(&amp;#39;True&amp;#39;)
     True

    &amp;gt;&amp;gt;&amp;gt; ast.literal_eval(&amp;#39;1, 2, 3&amp;#39;)
     (1, 2, 3)

    &amp;gt;&amp;gt;&amp;gt; ast.literal_eval(&amp;#39;{&amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;}&amp;#39;)
     {&amp;#39;foo&amp;#39;: &amp;#39;bar&amp;#39;}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;小心第三方 APP&lt;/h3&gt;
&lt;p&gt;在决定使用某个第三方 APP 之前，先回答下面几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它真的符合你的需求吗？还是只是有点相近？&lt;/li&gt;
&lt;li&gt;它是个健康的项目吗？&lt;ul&gt;
&lt;li&gt;维护者有一个好的追踪记录吗？&lt;/li&gt;
&lt;li&gt;文档写的好吗？&lt;/li&gt;
&lt;li&gt;测试覆盖率够吗？&lt;/li&gt;
&lt;li&gt;社区怎样（贡献者，pull requests 等等）？&lt;/li&gt;
&lt;li&gt;还在处于活跃开发吗？&lt;/li&gt;
&lt;li&gt;有很多旧的 issues 和 pull requests 吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能咋样？&lt;ul&gt;
&lt;li&gt;它会产生多少数据库查询？&lt;/li&gt;
&lt;li&gt;易于缓存吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;跟你项目的其他部分有冲突吗？&lt;/li&gt;
&lt;li&gt;它的授权协议跟你的项目兼容吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不再维护以及不稳定的第三方应用很快就会成为你的项目的负债。
可以尝试阅读源代码，然后从中找出你的项目需要的代码然后应用到项目中。&lt;/p&gt;
&lt;h3&gt;找出性能问题&lt;/h3&gt;
&lt;p&gt;可以使用下面这些工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://django-debug-toolbar.readthedocs.org/"&gt;Django Debug Toolbar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/recamshak/django-debug-panel"&gt;django-debug-panel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dcramer/django-devserver"&gt;django-devserver&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;观察页面性能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行了多少条 SQL 语句？&lt;/li&gt;
&lt;li&gt;有多少时间花费在数据库上？&lt;/li&gt;
&lt;li&gt;执行了什么特殊的查询操作，每次查询花费多长时间？&lt;/li&gt;
&lt;li&gt;这些查询是有什么代码生成的？&lt;/li&gt;
&lt;li&gt;渲染页面都用到了哪些模板？&lt;/li&gt;
&lt;li&gt;冷/热缓存是如果影响性能的？（提示：可以使用 settings 来切换缓存）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;哪里需要优化&lt;/h3&gt;
&lt;h4&gt;数据库优化&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;减少查询次数&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;select_related&lt;/code&gt;, &lt;code&gt;prefetch_related&lt;/code&gt;, (提示：&lt;code&gt;prefetch_related&lt;/code&gt; 要放在查询的最后，不然会没有效果。)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;减少查询时间&lt;ul&gt;
&lt;li&gt;不要忘记加索引（索引也是有代价的，每次对数据库进行写操作都需要更新索引）&lt;/li&gt;
&lt;li&gt;某些情况下 join 查询性能很差，在这种情况下两条查询语句比一条 join 耗时更少。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;限制结果数&lt;ul&gt;
&lt;li&gt;留意 &lt;code&gt;.all()&lt;/code&gt; 只取需要的结果数, &lt;code&gt;queryset[:20]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;count 查询很慢。可以的话，不要使用 count。比如使用 &lt;code&gt;.exists()&lt;/code&gt; 代替 count 进行判断记录是否存在。&lt;/li&gt;
&lt;li&gt;generic 外键。generic 外键是个很 cool 的功能，但是它会生成一些特别复杂的查询，所以可能的话，不要使用它。如果你一定要用的话，记得这是个需要缓存的地方。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优化 model 方法。如果某个 model 方法在一个请求内会多次被调用，可以使用 &lt;code&gt;cache_property&lt;/code&gt; 缓存方法解决（缓存只在该请求内有效）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;django.utils.functional&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;cached_property&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TheModel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;models&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Model&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="nd"&gt;@cached_property&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;expensive&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
       &lt;span class="c1"&gt;# ...&lt;/span&gt;
       &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果太大了，包含了不需要的字段。使用 &lt;code&gt;defer&lt;/code&gt;, &lt;code&gt;only&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;, &lt;code&gt;values_list&lt;/code&gt; 限制结果大小:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;posts = Post.objects.all().defer(&amp;#39;body&amp;#39;)
posts = Post.objects.all().only(&amp;#39;title&amp;#39;)
posts = Post.objects.all().values(&amp;#39;id&amp;#39;)
posts = Post.objects.all().values_list(&amp;#39;id&amp;#39;)
posts = Post.objects.all().values_list(&amp;#39;id&amp;#39;, flat=True)
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓存查询结果。这里提到两个库: &lt;a href="https://johnny-cache.readthedocs.org/en/latest/"&gt;Johnny Cache&lt;/a&gt; 和 &lt;a href="https://cache-machine.readthedocs.org/en/latest/"&gt;Cache Machine&lt;/a&gt; 这两个库的原理都是在 ORM 和数据库中间加了一个缓存层，将 ORM 生成的 SQL 作为 key 来缓存查询结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;只读 replicas。对那些读远远大于写的站点，可以考虑从 只读 replicas 中读取数据，实现读写分离。减少主库的负担优化性能。&lt;/li&gt;
&lt;li&gt;raw 查询。如果感觉 ORM 有点慢话，可以考虑使用 &lt;code&gt;raw&lt;/code&gt; 方法执行原生的 SQL 语句。&lt;/li&gt;
&lt;li&gt;反范式。这种方法有个问题就是每次更新的时候都需要同时更新其他表中相关的冗余字段。&lt;/li&gt;
&lt;li&gt;使用其他数据存储方式。比如： Postgres, redis, mongodb，使用 Elasticsearch 进行全文检索等。
  需要注意的是，在生产环境下新增一个服务并无法没有代价的。作为开发者我们可以不太在意这个，但是系统需要
  支持，配置，监控，备份等。新增服务的时候要考虑到这些代价以及你的系统管理员的意见。&lt;/li&gt;
&lt;li&gt;sharding。99.9% 的网站都不需要用到数据库的 sharding 功能，所以只有在你确信你遇到了那 0.1% 的时候
  再使用 sharding 功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;模板优化&lt;/h3&gt;
&lt;p&gt;应该缓存模板中一切可以缓存的东西。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;俄罗斯套娃式缓存。在一个模板里缓存嵌套缓存，就像俄罗斯套娃一样，一层套一层。比如:&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;{% cache MIDDLE_TTL &amp;quot;post_list&amp;quot; request.GET.page %}
    {% include &amp;quot;inc/post/header.html&amp;quot; %}
    &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;post-list&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    {% for post in post_list %}
        {% cache LONG_TTL &amp;quot;post_teaser_&amp;quot; post.id post.last_modified %}
            {% include &amp;quot;inc/post/teaser.html&amp;quot; %}
        {% endcache %}
    {% endfor %}
    &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{% endcache %}
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;自定义一个支持通过 url 参数刷新模板缓存的 cache 标签，这样就可以随时刷新缓存了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;随后处理耗时的任务&lt;/h3&gt;
&lt;p&gt;可以把耗时的，不需要同步知道结果的任务放到类似 celery 的任务队列中异步执行，
从而减少请求——响应的处理时间。下面这些任务可以考虑放到 celery 中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第三方 API 的调用&lt;/li&gt;
&lt;li&gt;发邮件&lt;/li&gt;
&lt;li&gt;非常复杂的计算（视频处理，大量的数字处理等）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于使用 celery 作者提到了一下小提示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要将 model 实例作为任务的参数，可以改用传主键的方式。因为在这期间 model 的数据可能已经发生改变了，
  还有就是那个 model 实例可能不支持序列化。&lt;/li&gt;
&lt;li&gt;保持任务小，不要再一个任务中执行太多的工作。把一个任务分割成多个任务，一方面可以使用多核或多 worker 的
  方式加速任务执行，另一方面，单个任务可以很快的执行完方便安全快速的重启 worker，因为一个 worker 重启时
  会等待正在执行的问题完成，保持任务小巧的话，可以加快部署时间。&lt;/li&gt;
&lt;li&gt;可以考虑使用 celery 的 beat 功能去自习定时任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;前段优化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;压缩 css 和 javascript（min, gzip, 版本化静态文件）。（个人建议：版本化文件应该类似这样 foo-xxyy.js 而不是这样 foo.js?v=xxyy ，主要是方便使用 CDN，防止出现缓存未过期的情况。）&lt;/li&gt;
&lt;li&gt;压缩图片。&lt;/li&gt;
&lt;li&gt;使用 CDN 服务静态文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;文件上传&lt;/h3&gt;
&lt;p&gt;可以考虑使用分布式文件系统或者云存储来存储上传的文件。使用云存储的时候要考虑备用方案，万一服务不可用怎么办。&lt;/p&gt;
&lt;h3&gt;测试&lt;/h3&gt;
&lt;p&gt;好的测试用例是健康代码的强有力的基石。测试应该覆盖到你代码中最复杂，最重要，最容易出问题的地方。&lt;/p&gt;
&lt;h4&gt;自动化测试以及持续集成&lt;/h4&gt;
&lt;p&gt;一个持续集成系统可以让开发者在开发进度的早期就发现问题，通过持续集成系统来执行
自动化测试以及检查你的代码的健康度。作者提到了他们的检查点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单元测试&lt;/li&gt;
&lt;li&gt;代码覆盖率&lt;/li&gt;
&lt;li&gt;PEP8/linting&lt;/li&gt;
&lt;li&gt;使用 Selenium 进行功能测试&lt;/li&gt;
&lt;li&gt;所以 Jmeter 进行性能测试&lt;/li&gt;
&lt;/ul&gt;</summary><category term="High Performance Django"></category><category term="Django"></category></entry><entry><title>《图解 HTTP》阅读笔记</title><link href="https://mozillazg.com/2015/08/tujie-http-note.html" rel="alternate"></link><updated>2015-08-28T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2015-08-28:2015/08/tujie-http-note.html</id><summary type="html">&lt;p&gt;&lt;a href="http://book.douban.com/subject/25863515/"&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/s27283822.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文记录了我阅读 《图解 HTTP》这本书时觉得重要的或之前不知道的内容。&lt;/p&gt;
&lt;h2&gt;了解 Web 及网络基础&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;TCP/IP 四层模型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层：HTTP, FTP, DNS 协议之类的处于这一层&lt;/li&gt;
&lt;li&gt;传输层：提供两台计算机之间的数据传输，TCP, UDP 协议处于这一层&lt;/li&gt;
&lt;li&gt;网络层：处理在网络上流动的数据包，IP 协议处于这一层&lt;/li&gt;
&lt;li&gt;链路层（数据链路层）：处理网络的硬件部分：网卡，光纤等物理可见的部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/1.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/2.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IP 协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 ARP 协议凭借 MAC 地址进行通信&lt;/p&gt;
&lt;p&gt;ip -&amp;gt; mac1 -&amp;gt; mac2 -&amp;gt; mac3 -&amp;gt; mac&lt;/p&gt;
&lt;p&gt;ARP 协议（Address Resolution Protocol）是一种用以解析地址的协议，
根据通信方的 IP 地址就可以反查出对应的 MAC 地址。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/3.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP 三次握手&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我要给你发数据了 SYN (发送端） -&amp;gt; 回应一个收到 SYN + ACK（接收端） -&amp;gt; 回应一个 OK ACK （发送端）&lt;/p&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/4.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各协议与 HTTP 协议的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/5.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URI 和 URL&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URI：统一资源标识符（Uniform Resource Identifier），比如：&lt;ul&gt;
&lt;li&gt;http://abc.com/a.txt&lt;/li&gt;
&lt;li&gt;redis://127.0.0.1/0&lt;/li&gt;
&lt;li&gt;mailto:foo@bar.com&lt;/li&gt;
&lt;li&gt;tel:+86123455&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;URL：统一资源定位符（Uniform Resource Locator）即我们熟悉的网址，比如：&lt;ul&gt;
&lt;li&gt;http://abc.com/a.txt&lt;/li&gt;
&lt;li&gt;https://foo.bar.com/foobar.txt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。
&lt;strong&gt;可见 URL 是 URI 的子集&lt;/strong&gt; 。&lt;/p&gt;
&lt;!--
## 简单的 HTTP 协议

## HTTP 报文内的 HTTP 信息

## 返回结果中的 HTTP 状态码
--&gt;

&lt;h2&gt;与 HTTP 协作的 Web 服务器&lt;/h2&gt;
&lt;p&gt;HTTP 通信时，处客户端和服务器外，还有一些用于通信数据转发的应用程序，例如：代理，网关和隧道。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;代理：代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的
  请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。&lt;ul&gt;
&lt;li&gt;缓存代理：代理转发响应时，缓存代理会预先将资源的副本（缓存）保存在代理服务器上。&lt;/li&gt;
&lt;li&gt;透明代理：转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理。反之，对
  报文内容进行加工的代理被成为非透明代理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网关：网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源
  的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。
  网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。&lt;/li&gt;
&lt;li&gt;隧道：隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;HTTP 首部&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;no-cache&lt;/code&gt;: 使用 no-cache 指令的目的是为了防止从缓存总返回过期的资源。
  事实上， no-cache 代表不缓存过期的资源，缓存会向源服务器进行有效期确认，然后再处理资源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;no-store&lt;/code&gt;: 该指令规定缓存不能在本地存储请求或响应的任一部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Pragma&lt;/code&gt; 是 HTTP/1.1 之前版本的历史遗留字段。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Pargma: no-cache&lt;/code&gt;: 只能用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。
  但要整体掌握全部中间服务器使用 HTTP 协议版本确实不现实的。因此，发送的请求会同时含有
  &lt;code&gt;Cache-Control: no-cache&lt;/code&gt;和 &lt;code&gt;Pragma: no-cache&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;X-Frame-Options: 作用于 HTTP 响应，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。
  其主要目的是为了防止点击劫持（clickjacking）攻击。&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DENY&lt;/code&gt;: 拒绝&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SAMEORIGINE&lt;/code&gt;: 仅同源域名下的页面可以加载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;X-XSS-Protection: 用于控制浏览器 XSS 防护机制的开关&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt;: 将 XSS 过滤设置为无效状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt;: 将 XSS 过滤设置为有效状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DNT: 拒绝个人信息被收集&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt;: 同意被追踪&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt;: 拒绝被追踪&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;协议中对 X- 前缀的废除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 HTTP 等多种协议中，通过给非标准参数加上前缀 X-, 来区分标准参数，并使
那些非标准的参数作为扩展变成可能。但是这种简单粗暴的做法有百害而无一益，
因此在 "RFC 6648 - Deprecating the "X-" Prefix and Similar
Constructs in Application Protocols" 中提议停止该做法。&lt;/p&gt;
&lt;p&gt;然而，对已经在使用中的 X- 前缀来说，不应该要求其变更。&lt;/p&gt;
&lt;h2&gt;确保 HTTP 安全的 HTTPS&lt;/h2&gt;
&lt;p&gt;HTTP 协议的实现本是非常简单，不论是谁发送过来的请求都会返回响应，
因此不确认通信方，会存在以下各种隐患。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。
  有可能是已伪装的 Web 服务器。&lt;/li&gt;
&lt;li&gt;无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。&lt;/li&gt;
&lt;li&gt;无法确定正在通信的对方是否具有访问权限。因为某些 Web 服务器上保存着重要的信息，
  只想发给特定用户通信的权限。&lt;/li&gt;
&lt;li&gt;无法判定请求是来自何方、出自谁手。&lt;/li&gt;
&lt;li&gt;即时是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service, 拒绝服务器攻击）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;HTTP + 加密 + 认证 + 完整性包含 = HTTPS&lt;/p&gt;
&lt;p&gt;HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL(Secure Socket Layer) 和
TLS(Transport Layer Security)协议代替而已。&lt;/p&gt;
&lt;p&gt;通常， HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和
SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。
所以 HTTPS 又叫 HTTP over SSL, HTTP over TLS&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对称密钥加密&lt;/strong&gt;: 加密和解密同用一个密钥的方式称为共享密钥加密(Common key crypto system)，
也被叫做对称密钥加密。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非对称加密&lt;/strong&gt;：公开密钥加密方式很好地解决了共享密钥加密的困难。公开密钥加密使用一对非对称密钥。一把叫做私有密钥
(private key)，另一把叫做公开密钥（public key）。顾名思义，私有密钥
不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTPS 通信步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/6.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/7.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/8.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不一直使用 HTTPS&lt;/strong&gt; 既然 HTTPS 那么安全可靠，那为何所有的 Web 网站不一直使用 HTTPS？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗
  相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。&lt;/li&gt;
&lt;li&gt;除此之外，想要节约购买证书的开销也是原因之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基于 HTTP 的功能追加协议&lt;/h2&gt;
&lt;p&gt;HTTP 的瓶颈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一条连接只可发送一个请求&lt;/li&gt;
&lt;li&gt;请求只能从客户端开始。客户端不可以接收除响应以外的指令&lt;/li&gt;
&lt;li&gt;请求/响应首部(header)未经压缩就发送。首部信息越多延迟越大。&lt;/li&gt;
&lt;li&gt;发送冗长的首部(header)。每次互相发送相同的首部造成的浪费较多。&lt;/li&gt;
&lt;li&gt;可任意选择数据压缩格式。非强制压缩发送。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;SPDY&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。
使用 SPDY 后，HTTP 协议额外获得以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多路复用流：通过单一的 TCP 请求，可以无限制处理多个 HTTP 请求。所有请求的处理
  都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。&lt;/li&gt;
&lt;li&gt;赋予请求优先级&lt;/li&gt;
&lt;li&gt;压缩 HTTP 首部(header)&lt;/li&gt;
&lt;li&gt;推送功能：支持服务器主动向客户端推送数据。&lt;/li&gt;
&lt;li&gt;服务器提示功能：服务器可以主动提示客户端请求所需的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/9.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用浏览器进行全双工的 WebSocket&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有
的通信都依靠这个专用协议进行。 WebSocket 协议的主要特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;推送功能&lt;/li&gt;
&lt;li&gt;减少通信量：只要建立起 WebSocket 连接，就希望一直保持连接状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="图解 HTTP" src="/static/images/reading/tujie-http-note/10.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;期盼已久的 HTTP/2.0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下摘自： https://http2.github.io/faq/&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What are the key differences to HTTP/1.x?&lt;/p&gt;
&lt;p&gt;At a high level, HTTP/2:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;is binary, instead of textual&lt;/li&gt;
&lt;li&gt;is fully multiplexed, instead of ordered and blocking&lt;/li&gt;
&lt;li&gt;can therefore use one connection for parallelism&lt;/li&gt;
&lt;li&gt;uses header compression to reduce overhead&lt;/li&gt;
&lt;li&gt;allows servers to “push” responses proactively into client caches&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Web 的攻击技术&lt;/h2&gt;
&lt;p&gt;因输出值转义不完全引发的安全漏洞：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;跨站脚本攻击（Cross-Site Scripting, XSS）&lt;/strong&gt; 主要是指在用户浏览器内运行了非法的 HTML 标签或 JavaScript 
  脚本。比如富文本编辑器，如果不过滤用户输入的数据直接显示用户输入的 HTML 内容的话，就会有可能运行恶意的 
  JavaScript 脚本，导致页面结构错乱，Cookies 信息被窃取等问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SQL 注入攻击（SQL Injection）&lt;/strong&gt; 是指针对 Web 应用使用的数据库，通过运行非法
  的 SQL 而产生的攻击。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OS 命令注入攻击（OS Command Injection）&lt;/strong&gt; 是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。
  只要在能调用 Shell 函数的地方就有存在被攻击的风险。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP 首部注入攻击（HTTP Header Injection）&lt;/strong&gt; 是指攻击者通过在响应首部字段内插入换行，添加任意响应首部
  或主体的一种攻击。属于被动工具模式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP 响应截断攻击&lt;/strong&gt; 是用在 HTTP 首部注入的一种攻击。攻击顺序相同，但是要将两个 %0D%0A%0D%0A 并排插入字符串后
  发送。利用两个连续的换行就可作出 HTTP 首部与主体分隔所需的空行了，这样
  就能显示伪造的主体，达到攻击的目的。这样的攻击叫做 HTTP 响应截断攻击。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;邮件首部注入攻击（Mail Header Injection）&lt;/strong&gt; 是指 Web 应用中的邮件发送功能，攻击者通过向邮件首部
  To 或 Subject 内任意添加非法内容发起的攻击。利用存在安全漏洞的 Web 网站，可对任意邮件地址发送广告邮件或
  病毒邮件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目录遍历攻击（Directory Traversal）&lt;/strong&gt; 是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问
  目的的一种攻击。比如，通过 ../ 等相对路径定位到 /etc/passwd 等绝对路径上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;远程文件包含漏洞（Remote File Inclusion）&lt;/strong&gt; 是指当部分脚本内容需要从其他文件读入是，攻击者利用指定外部服务器
  的 URL 充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因设置或设计上的缺陷引发的安全漏洞：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;强制浏览（Forced Browsing）安全漏洞&lt;/strong&gt; 是指，从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开
  的文件。比如，没有对那些需要保护的静态资源增加权限控制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不正确的错误消息处理（Error Handling Vulerability）的安全漏洞&lt;/strong&gt; 是指，Web 应用的错误信息内包含对攻击者有用
  的信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开放重定向（Open Redirect）&lt;/strong&gt; 是一种对指定的任意 URL 作重定向跳转的功能。而于此功能相关联的安全漏洞是指，
  假如指定的重定向 URL 到某个具有恶意的 Web 网站，那么用户就会被诱导至那个 Web 网站。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因会话管理疏忽引发的安全漏洞：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;会话劫持（Session Hijiack）&lt;/strong&gt; 是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成
  用户，达到攻击的目的。&lt;/li&gt;
&lt;li&gt;对以窃取目标会话 ID 为主动攻击手段的会话劫持而言， &lt;strong&gt;会话固定攻击（Session Fixation）&lt;/strong&gt; 会强制用户使用攻击者指定
  的会话 ID，属于被动攻击。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨站请求伪造（Cross-Site Request Forgeries, CSRF）攻击&lt;/strong&gt; 是指攻击者通过设置好陷阱，
  强制对已完成认证的用户进行非预期的个人信息或设定等某些状态更新，属于被动攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他安全漏洞：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;密码破解&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;点击劫持（Clickjacking）&lt;/strong&gt; 是指利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下，
  单击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UI Redressing）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DoS 攻击（Denial of Service attack）&lt;/strong&gt; 是一种让运行中的服务呈停止状态的攻击。
  有时也叫做服务停止攻击或拒绝服务攻击。多台计算机发起的 Dos 攻击称为
  &lt;strong&gt;DDoS 攻击（Distributed Denial of Service attach）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后门程序（Backdoor）&lt;/strong&gt; 是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限的功能。&lt;/li&gt;
&lt;/ul&gt;</summary><category term="HTTP"></category><category term="图解 HTTP"></category></entry></feed>