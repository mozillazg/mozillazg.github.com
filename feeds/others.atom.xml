<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Huang Huang 的博客</title><link href="https://mozillazg.com/" rel="alternate"></link><link href="https://mozillazg.com/feeds/others.atom.xml" rel="self"></link><id>https://mozillazg.com/</id><updated>2019-09-13T00:00:00+00:00</updated><entry><title>一份大但不全的配置中心知识备忘</title><link href="https://mozillazg.com/2019/09/production-ready-distributed-configuration-service-configuration-center.html" rel="alternate"></link><updated>2019-09-13T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2019-09-13:2019/09/production-ready-distributed-configuration-service-configuration-center.html</id><summary type="html">&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;前言&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;简单记录一下关于配置中心各方面（主要是功能方面）的一些思考和备忘知识。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;基本功能&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;作为配置中心需要具备如下基本的核心功能:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;配置的增删改查&lt;/li&gt;
&lt;li&gt;支持静态配置和动态配置（或者说所有配置都是动态配置，取决于用户程序中怎么去使用它）&lt;/li&gt;
&lt;li&gt;动态配置的变更推送功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;高级功能&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一般还会具有下面的高级功能：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;权限控制&lt;/li&gt;
&lt;li&gt;相同配置项在不同环境下（不同机房、不同单元、不同集群等）配置不同的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他功能在下面的多个主题下中穿插说明。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="web"&gt;
&lt;h2 id="hidweb"&gt;面向用户的 Web 面板&lt;a class="headerlink" href="#hidweb" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;现在哪个系统还没个 Web 面板呢，配置中心也不例外。
至少需要一个面向用户的 Web 面板，不然用户体验也太差了。&lt;/p&gt;
&lt;p&gt;这个 Web 面板一般有下面的功能：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;帐号体系，基本的用户管理和用户权限控制、配置的访问控制&lt;/li&gt;
&lt;li&gt;用户增删改查有权限的不同服务的配置&lt;/li&gt;
&lt;li&gt;版本控制：显式配置项值的不同版本，方便实现回退功能以及查看历史值&lt;/li&gt;
&lt;li&gt;回退：把配置项的值回退到过去某个版本&lt;/li&gt;
&lt;li&gt;变更记录(变更审计)：显式配置项增删改的所有变更记录，方便追溯&lt;/li&gt;
&lt;li&gt;配置项导入、导出功能&lt;/li&gt;
&lt;li&gt;变更审批功能：某些场景下修改配置项需要接入多人 double check + 审批的流程&lt;/li&gt;
&lt;li&gt;敏感配置加密功能：面板上接入第三方敏感信息加解密系统，配置中心只存储加密后的配置，配置的加解密由第三方敏感信息加解密系统来实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其他 Web 面板功能会在下面的主题中穿插说明。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2 id="hidid5"&gt;开关&lt;a class="headerlink" href="#hidid5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;开关其实可以作为一种特殊的配置项来实现，比如业务系统中的功能/特性开关可以通过动态配置来实现，
只不过是约定了一个特定规范用于实现开关配置项（比如，值只能是 true 或 false 或者只能是 0~100, 配置项必须以 &lt;tt class="docutils literal"&gt;switch:&lt;/tt&gt; 开头）， 这个约定需要 SDK 和 Web 面板一起协作来完成，通过 SDK 和面板的协作对用户屏蔽这一内部实现细节（API 端需要校验值的合法性）。&lt;/p&gt;
&lt;p&gt;开关配置既可以用来实现新功能的灰度/开启开关，
也可以用于实现系统故障场景下的功能降级/关闭开关、fallback 启用开关等各类动态切换的场景。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2 id="hidid6"&gt;配置灰度&lt;a class="headerlink" href="#hidid6" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;微服务场景下功能灰度是个非常重要的功能，功能灰度既可以通过金丝雀发布的方式实现，特定场景下也可以通过功能开关的方式实现。比如前面所说的开关配置，如果约定开关配置的值是 0~100.00 的话，可以通过不同的值控制功能打开的概率从而实现功能灰度。&lt;/p&gt;
&lt;p&gt;不只是功能需要灰度，配置也需要灰度，毕竟配置的变更对系统的影响也是非常大的，不亚于功能的变更。&lt;/p&gt;
&lt;p&gt;一般可以考虑支持如下其中一个、几个或全部的配置项变更灰度纬度:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;机房&lt;/li&gt;
&lt;li&gt;单元&lt;/li&gt;
&lt;li&gt;集群&lt;/li&gt;
&lt;li&gt;某些特定客户端IP/hostname&lt;/li&gt;
&lt;li&gt;一定比例的业务系统实例&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2 id="hidid7"&gt;稳定性&lt;a class="headerlink" href="#hidid7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;没有一个系统能够保证 100% 不出问题，配置中心也不例外。所以在设计客户端和服务端的时候需要应用一些面向失败设计的模式。&lt;/p&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3 id="hidid8"&gt;客户端&lt;a class="headerlink" href="#hidid8" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;客户端一定要实现的一个功能就是：本地缓存。
用于在无法连接服务端或者服务端异常时客户端有个本地兜底，不会因为配置中心异常导致用户服务异常。&lt;/p&gt;
&lt;p&gt;本地缓存一般包括内存缓存和本地文件缓存，可以考虑实现其中一个或两个都实现。&lt;/p&gt;
&lt;p&gt;以及需要注意之前 &lt;a class="reference external" href="https://mozillazg.com/2018/08/call-remote-service-checklist.html"&gt;调用远程服务的一些备忘录&lt;/a&gt; 和 &lt;a class="reference external" href="https://mozillazg.com/2019/03/safe-client-behaviour-notes-retry-jitter-back-off-more.html#hidsafer-clients-expose-information-to-server"&gt;安全友好的客户端行为&lt;/a&gt;  中提到的那些超时、重试等注意事项，毕竟这个也是调用远程服务的一个场景。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h3 id="hidid9"&gt;服务端&lt;a class="headerlink" href="#hidid9" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;服务端主要需要考虑如下方案：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;熔断: 在特定场景下通过熔断对外部依赖的请求或来自客户端的请求来保障服务端的稳定性&lt;/li&gt;
&lt;li&gt;降级: 在特定场景下通过降级某些功能或某些外部依赖来保障核心功能的稳定性&lt;/li&gt;
&lt;li&gt;限流/限速: 根据需要对用户、服务、IP 或者推送进行限流或限速，
至少要有一个宽松的默认限流策略，防止被异常的突发流量打垮系统。&lt;/li&gt;
&lt;li&gt;隔离（舱壁模式）：通过隔离技术来保护大部分用户不受少部分异常用户的影响或者核心组件受次要组件故障所影响。
常见的隔离技术有线程池隔离、进程隔离（比如剥离增删改查功能和推送功能独立部署或者在流量入口处按功能划分不同节点，比如部署单独的节点只提供推送服务）、集群隔离（为特定用户群体部署专享的独立集群，防止受主集群影响）等等。&lt;/li&gt;
&lt;li&gt;日志、监控、告警：根据实际情况来记录有用的日志、指标数据、以及配置必要的告警&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以进一步参考 &lt;a class="reference external" href="https://mozillazg.com/2019/06/release-it-design-and-deploy-production-ready-software-second-edition-2th-read-note-1"&gt;《Release It! Second Edition》阅读笔记（一）&lt;/a&gt; 和 &lt;a class="reference external" href="https://mozillazg.com/2019/06/release-it-design-and-deploy-production-ready-software-second-edition-2th-read-note-2"&gt;《Release It! Second Edition》阅读笔记（二）&lt;/a&gt; 中的内容。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h2 id="hidid10"&gt;治理&lt;a class="headerlink" href="#hidid10" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;配置中心不仅仅只是一个存放配置的地方，同样还应该承担起配置治理和收口的职责，
同时，没有考虑各方面治理的中间件只能说是一个软件或服务，而不能说是一个成熟的产品。&lt;/p&gt;
&lt;p&gt;下面简单记录一些常见的治理场景。&lt;/p&gt;
&lt;div class="section" id="id11"&gt;
&lt;h3 id="hidid11"&gt;通用配置治理&lt;a class="headerlink" href="#hidid11" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;所谓的通用配置指的是各个服务都会去配置的一些配置项，如果不治理的话，一方面配置项的名称会五花八门不利于用户服务的后续交接和维护，另一方面因为没有统一治理规范化，导致无法快速的根据需要调整或统计公司内部所有业务服务所使用的通用配置。&lt;/p&gt;
&lt;p&gt;希望通过治理后能够规范化通用配置，实现统一约定通用配置项名称方便业务系统的日常维护以及赋予平台统一管控的能力。&lt;/p&gt;
&lt;p&gt;下面举一些通用配置的例子：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;业务系统所使用的微服务框架本身包含了各种各样的配置，可以对这些配置项的名称和取值作统一规范化，用户按照规范在配置中心配置相应的配置，框架按照规范从配置中心去获取对应的配置。&lt;/li&gt;
&lt;li&gt;框架内置的各组件的功能特性的降级和开启开关&lt;/li&gt;
&lt;li&gt;基于框架实现的服务间调用的服务级别和接口级别的降级和开启开关&lt;/li&gt;
&lt;li&gt;服务启动时的启动参数控制、jvm 参数控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h3 id="hidid12"&gt;基础服务配置治理&lt;a class="headerlink" href="#hidid12" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;同样，基础服务配置治理也是为了规范化业务系统对基础服务依赖的相关配置，方便业务系统的日常维护以及赋予平台统一管控的能力。&lt;/p&gt;
&lt;p&gt;下面举几个基础服务配置的例子：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;数据库连接信息和连接参数&lt;/li&gt;
&lt;li&gt;消息队列连接信息&lt;/li&gt;
&lt;li&gt;限流/限速组件的配置信息&lt;/li&gt;
&lt;li&gt;其他基础服务（redis、es、oss等基础服务）的客户端所需的配置信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id13"&gt;
&lt;h3 id="hidid13"&gt;遗留配置治理&lt;a class="headerlink" href="#hidid13" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;随着时间的推移，配置中心上会存在很多遗留的不再使用的旧配置，为了避免成为配置坟场，需要对配置的使用情况进行治理。&lt;/p&gt;
&lt;p&gt;需要客户端/框架和服务端一起来实现配置使用的治理，客户端/框架中收集和上报用户系统真正在使用的配置项，
如果服务端能够感知到的话也可以在服务端主动记录。&lt;/p&gt;
&lt;p&gt;收集到真正在使用的配置项后，需要 Web 面板配置在页面上展示配置项的使用情况，方便用户清理不再使用的配置（可以主动提示用户某些配置项很久没使用了，是否是已废弃配置，请及时清理）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id14"&gt;
&lt;h3 id="hidid14"&gt;用户使用姿势治理&lt;a class="headerlink" href="#hidid14" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;没有哪个系统和服务是万能的，每个服务都有它预设的使用场景限制/约定，配置中心也不例外。&lt;/p&gt;
&lt;p&gt;所以在设计和开发配置中心的时候需要要定下它服务的场景和使用约束，提前发现或及时发现不合理的使用姿势，甚至直接拒绝不合理的使用姿势从源头就扼杀而不是等到后面再来治理。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id15"&gt;
&lt;h3 id="hidid15"&gt;客户端治理&lt;a class="headerlink" href="#hidid15" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;还有一个就是客户端的治理。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;版本治理:无论是官方实现的客户端还是第三方实现的客户端，随着时间的推移都需要治理，比如统计旧版及关键版本的使用情况，
根据使用情况废弃旧版或推动旧版业务方升级改造。
所以所有客户端的请求信息中必须包含符合规范的客户端名称和版本号（比如 http 协议的话可以考虑放在 User-Agent 里），方便服务端记录和统计客户端信息&lt;/li&gt;
&lt;li&gt;实现方式治理：如果是官方实现的客户端的话，可以很好的把控客户端的实现方式，但是第三方实现的客户端可能会包含各种影响服务端稳定性的不正确实现姿势或使用姿势。一方面服务端需要防范和应对会来自客户端的异常请求，另一方面也要实现能够帮助配置中心开发人员及时或提前发现可能的或已存在的异常请求，进而调整官方客户端的实现以及协调第三方客户端改进实现，比如应用上面【稳定性-客户端】那里提到的本地缓存以及各种客户端实现注意事项。再通过上面的版本治理来推进用户升级客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id16"&gt;
&lt;h2 id="hidid16"&gt;故障排查&lt;a class="headerlink" href="#hidid16" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;配置中心作为一个所有业务系统都会使用的一个中间件，为了减轻开发的排障压力需要主动收集关键信息或提供排障工具用于快速排障或自证清白。&lt;/p&gt;
&lt;p&gt;可以考虑收集如下信息:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;配置使用追踪（何时哪个客户端获取(使用)了哪个配置项）&lt;/li&gt;
&lt;li&gt;变更推送追踪（何时推送了哪个配置项的啥变更给哪个客户端）&lt;/li&gt;
&lt;li&gt;客户端异常情况（日志或打点）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并提供工具、手段或页面方便用户快速自行 debug：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;一份包含常见问题的答疑和 debug 步骤文档&lt;/li&gt;
&lt;li&gt;以某种方式在 Web 面板页面展示上面收集的信息&lt;/li&gt;
&lt;li&gt;API 或 SDK 的错误或异常信息中包含对应问题 case 的原因说明或解决办法的文档 URL 地址&lt;/li&gt;
&lt;li&gt;提供工具用于用户在他们出现异常的机器上进行简单的自动诊断，比如自动检测与服务端的网络连接情况、分析客户端的错误日志、根据已知的各种常见问题 case 的异常原因和检查步骤自动分析并给出相应的建议&lt;/li&gt;
&lt;li&gt;提供工具分析用户的代码检测出不符合规范的代码用法给予提示、改进建议甚至是自动重新源代码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要根据日常答疑和 debug 经验丰富上面的手段和方法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id17"&gt;
&lt;h2 id="hidid17"&gt;控制面板&lt;a class="headerlink" href="#hidid17" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个控制面板是一个面向配置中心开发人员和运维人员的 Web 面板（不一定是一个面板，也可能指的是包含公司内部各基础服务系统的一组面板集合），
用于观测配置中心运行过程中的各种状态信息（观测方面的需求也可以通过接入监控系统来实现）
以及在不重启配置中心不同组件服务的前提下动态控制配置中心的各种内部功能和细节。&lt;/p&gt;
&lt;p&gt;动态控制方面，常见的有如下需求：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;变更特定服务配置的访问控制信息&lt;/li&gt;
&lt;li&gt;变更对用户/客户端的限速、优先级、黑白名单等配置&lt;/li&gt;
&lt;li&gt;drop 或屏蔽一些请求&lt;/li&gt;
&lt;li&gt;后端服务节点的控制，比如上下线变更&lt;/li&gt;
&lt;li&gt;内部功能的开启和关闭、配置的变更（也可以直接通过面向用户的 Web 面板控制，即配置中心本身也通过配置中心来托管配置）&lt;/li&gt;
&lt;li&gt;SDK 特定功能的开启和关闭&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;观测方面的需求一般通过接入监控系统来实现，详见下面的监控告警主题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id18"&gt;
&lt;h2 id="hidid18"&gt;监控告警&lt;a class="headerlink" href="#hidid18" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;接入监控告警可以帮助配置中心开发人员和运维人员观测系统的运行状况，提前或及时发现异常情况，提高系统的稳定性以及故障处理速度。&lt;/p&gt;
&lt;p&gt;客户端和服务端可以考虑上报/提供如下指标数据，用于监控和告警。同样只是一些简单的例子，需要考虑实际场景添加合适的指标。&lt;/p&gt;
&lt;div class="section" id="id19"&gt;
&lt;h3 id="hidid19"&gt;服务端&lt;a class="headerlink" href="#hidid19" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;客户端请求情况：基本的请求信息(请求方、api、响应情况（成功、失败、响应时间等）&lt;/li&gt;
&lt;li&gt;配置变更&lt;/li&gt;
&lt;li&gt;变更推送&lt;/li&gt;
&lt;li&gt;限速、黑白名单触发&lt;/li&gt;
&lt;li&gt;其他内部关注的点&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id20"&gt;
&lt;h3 id="hidid20"&gt;客户端&lt;a class="headerlink" href="#hidid20" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;API 调用：api、成功、失败（失败原因）、响应时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id21"&gt;
&lt;h2 id="hidid21"&gt;周边生态&lt;a class="headerlink" href="#hidid21" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;目标是希望围绕配置中心形成一个生态，而不是所有需求都由配置中心来实现。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;微服务调用方或被调用方的限流功能，可能是由专门的组件或服务来实现限流功能，
但是每个服务的限流配置可以规范化存放在配置中心，帮助限流组件省去重复实现配置管理和变更推送的功能。&lt;/li&gt;
&lt;li&gt;基于各服务方使用配置中心实现功能开关来控制调用降级的前提，可以实现一个在不同故障场景下批量切换多个调用链上下游的降级开关，实现故障时上下游快速降级的需求（一键降级）。这个需求虽然可以在配置中心上实现，但是会给配置中心增加不必要的复杂度，可以考虑实现一个单独的系统，这个系统会调用配置中心的 api 来实现相应的开关切换，在那个系统中实现这个需求所需的各种繁琐的业务流程。&lt;/li&gt;
&lt;li&gt;其他需要实现配置管理和配置变更推送的场景，都可以把配置规范化存放在配置中心，围绕配置中心形成一个庞大的生态系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id22"&gt;
&lt;h2 id="hidid22"&gt;文档&lt;a class="headerlink" href="#hidid22" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;如果没有文档的话，用户可能都不知道怎么用你的产品，你的产品做的再好也没有用。&lt;/p&gt;
&lt;p&gt;文档主要包括面向用户的文档和面向内部开发和运维人员的文档。&lt;/p&gt;
&lt;p&gt;面向用户的文档：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;使用文档，包括 Web 面板的使用文档、API 文档、SDK 使用文档、debug 工具使用文档等等&lt;/li&gt;
&lt;li&gt;答疑文档，包括常见问题解答、常见异常 debug 步骤和解决方法等等&lt;/li&gt;
&lt;li&gt;介绍文档，包括适用的场景、解决的问题、不适用的场景、使用约束等等&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面向开发和运维的文档：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;开发文档&lt;/li&gt;
&lt;li&gt;部署和运维文档&lt;/li&gt;
&lt;li&gt;监控和告警&lt;/li&gt;
&lt;li&gt;常见故障恢复方法和步骤&lt;/li&gt;
&lt;li&gt;常见问题 debug 步骤和解决方法（包括用户遇到的问题以及内部问题）&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id23"&gt;
&lt;h2 id="hidid23"&gt;其他&lt;a class="headerlink" href="#hidid23" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;# TODO&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id24"&gt;
&lt;h2 id="hidid24"&gt;总结&lt;a class="headerlink" href="#hidid24" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;简单记录了一下配置中心的一些备忘知识，后面有空的时候再补充更新。&lt;/p&gt;
&lt;p&gt;BTW，开发一个配置中心或配置管理平台的时候不一定需要实现上面的所有的内容，可以是它的超集也可以是它的子集，同时也不要想着一次性就实现最终产品，可以考虑通过小步试错，快速迭代的方式一步步的实现和落地各种功能和方案（通过一个个的阶段性迭代和目标来实现最终目的，不要想着一蹴而就或者在一个大的迭代中完成目标）。
重要的是要考虑实际场景，组织架构风格，组织或团队的短期和长期目标（&amp;lt;del&amp;gt;比如某些团队或个人会把项目作为升职加薪的跳板，这样的话就需要取舍，哪些功能/需求是可以快速做出闪亮成绩的，哪些是需要时间才能证明其价值。不是时常会听说某个公司内某个/些项目在晋升季一过就没人维护甚至直接就黄了嘛[1]&amp;lt;/del&amp;gt;）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id25"&gt;
&lt;h2 id="hidid25"&gt;参考资料&lt;a class="headerlink" href="#hidid25" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pragprog.com/book/mnee2/release-it-second-edition"&gt;《Release It! Second Edition》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mozillazg.com/2018/08/call-remote-service-checklist.html"&gt;调用远程服务的一些备忘录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mozillazg.com/2019/03/safe-client-behaviour-notes-retry-jitter-back-off-more.html#hidsafer-clients-expose-information-to-server"&gt;安全友好的客户端行为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mozillazg.com/2019/06/Release-It-Design-and-Deploy-Production-Ready-Software-Second-Edition-2th-read-note-1.html"&gt;《Release It! Second Edition》阅读笔记（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mozillazg.com/2019/06/Release-It-Design-and-Deploy-Production-Ready-Software-Second-Edition-2th-read-note-2.html"&gt;《Release It! Second Edition》阅读笔记（二）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- [1]: https://twitter.com/laixintao/status/1163356711769427973 --&gt;
&lt;/div&gt;
</summary><category term="configuration-service"></category><category term="configuration-center"></category></entry><entry><title>负载均衡策略之有限负载一致性哈希</title><link href="https://mozillazg.com/2019/04/load-balancing-strategy-algorithm-Consistent-Hashing-with-Bounded-Loads.html" rel="alternate"></link><updated>2019-04-21T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2019-04-21:2019/04/load-balancing-strategy-algorithm-Consistent-Hashing-with-Bounded-Loads.html</id><summary type="html">&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;前言&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文简单介绍一下有限负载一致性哈希（Consistent Hashing with Bounded Loads）（或者叫有界负载一致性哈希、有负载界限/上限的一致性哈希）这个负载均衡策略。&lt;/p&gt;
&lt;p&gt;之前介绍的 &lt;a class="reference external" href="https://mozillazg.com/2019/03/load-balancing-strategy-algorithm-Consistent-hashing.html"&gt;一致性哈希策略&lt;/a&gt; 有一个缺陷，那就是没有解决热点问题：当有部分资源是热点资源或者部分用户请求量比较大的时候，会出现部分节点需要处理大量请求（这些请求根据一致性哈希策略都选中了固定的部分节点），出现负载非常不均的情况，因为是一致性哈希所以这些请求没法分摊到其他节点上，导致出现持续的负载不均和热点问题。下面要介绍的 Consistent Hashing with Bounded Loads 就是一种解决这个问题的方法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="consistent-hashing-with-bounded-loads"&gt;
&lt;h2 id="hidconsistent-hashing-with-bounded-loads"&gt;有限负载一致性哈希（Consistent Hashing with Bounded Loads）&lt;a class="headerlink" href="#hidconsistent-hashing-with-bounded-loads" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;有限负载一致性哈希（Consistent Hashing with Bounded Loads） 出自论文 &lt;a class="reference external" href="https://arxiv.org/abs/1608.01350"&gt;Consistent Hashing with Bounded Loads&lt;/a&gt; ，主要思路是，根据当前负载情况对所有节点限制一个最大负载，在一致性哈希中对 hash 环进行查找时将跳过达到最大负载限制的节点，通过把过载的请求转移到其他节点上来解决热点和不均衡问题：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;R&lt;/tt&gt;: 当前所有节点的总负载（正在处理的总请求数）&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;T&lt;/tt&gt;: 节点总个数&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;L&lt;/tt&gt;: 当前所有节点的平均负载&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;L = R/T&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;ε&lt;/tt&gt;: 一个参数用于表示在平均负载的基础上能够承受的额外负载上限，可以按照实际需求进行设置（根据 vimeo 分享的 &lt;a class="reference external" href="https://medium.com/vimeo-engineering-blog/improving-load-balancing-with-a-new-consistent-hashing-algorithm-9f1bd75709ed"&gt;经验&lt;/a&gt; 这个值推荐设置为 0.25~1）&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;M&lt;/tt&gt;: 节点的最大负载上限&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;M = &lt;span class="pre"&gt;L*(1+ε)&lt;/span&gt; = &lt;span class="pre"&gt;R*(1+ε)/T&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;一致性哈希中进行节点查找时，增加检查匹配的节点的负载（正在处理的请求数）是否达到负载上限 &lt;tt class="docutils literal"&gt;M&lt;/tt&gt; 的操作，如果达到了上限则跳过当前节点继续往后查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过上面可以发现 Consistent Hashing with Bounded Loads 结合了 &lt;a class="reference external" href="https://mozillazg.com/2019/02/load-balancing-strategy-algorithm-weighted-least-connection.html"&gt;最少连接策略&lt;/a&gt; 和一致性哈希 策略各自的优点，即平衡了负载又兼顾了一致性哈希，并且还可以通过调整转化为最少请求策略或一致性哈希策略：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;当 &lt;tt class="docutils literal"&gt;ε&lt;/tt&gt; 的值是 0 的时候，就实现了最少连接策略的效果&lt;/li&gt;
&lt;li&gt;当 &lt;tt class="docutils literal"&gt;ε&lt;/tt&gt; 的值是无穷大的时候，就是传统的一致性哈希策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;权重问题&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上面的方法是没有区分节点权重的，如果要支持节点权重的话，需要做一点改动:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;R&lt;/tt&gt;: 当前所有节点的总负载（正在处理的总请求数）&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;T&lt;/tt&gt;: 所有节点的权重总和&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;L&lt;/tt&gt;: 当前所有节点的平均负载（基于权重的平均负载）&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;L = R/T&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;W&lt;/tt&gt;: 当前节点的权重值&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;ε&lt;/tt&gt;: 一个参数用于表示在平均负载的基础上能够承受的额外负载上限。&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;M&lt;/tt&gt;: 节点的最大负载上限&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;M = &lt;span class="pre"&gt;W*L*(1+ε)&lt;/span&gt; = &lt;span class="pre"&gt;W*R*(1+ε)/T&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;一致性哈希中进行节点查找时，增加检查匹配的节点的负载（正在处理的请求数）是否达到负载上限 &lt;tt class="docutils literal"&gt;M&lt;/tt&gt; 的操作，如果达到了上限则跳过当前节点继续往后查找。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到主要区别是算平均负载的时候是基于节点的权重和来计算的，算负载上限的时候是按权重比来计算的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;总结&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;简单介绍了一下 Consistent Hashing with Bounded Loads ，更详细的内容请参考参考资料。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2 id="hidid5"&gt;参考资料&lt;a class="headerlink" href="#hidid5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://ai.googleblog.com/2017/04/consistent-hashing-with-bounded-loads.html"&gt;Google AI Blog: Consistent Hashing with Bounded Loads&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arxiv.org/abs/1608.01350"&gt;[1608.01350] Consistent Hashing with Bounded Loads&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://medium.com/vimeo-engineering-blog/improving-load-balancing-with-a-new-consistent-hashing-algorithm-9f1bd75709ed"&gt;Improving load balancing with a new consistent-hashing algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/haproxy/haproxy/commit/4f88c636097bf5f7651c790700a8bf3fb82e5f67"&gt;MEDIUM: server: Implement bounded-load hash algorithm · haproxy/haproxy&amp;#64;4f88c63&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/haproxy/haproxy/blob/d0e095c2aa54f020de8fc50db867eff1ef73350e/doc/configuration.txt#L3776"&gt;haproxy/configuration.txt at master · haproxy/haproxy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://blog.laisky.com/p/consistent-hashing/#CHBL"&gt;laisky-blog: 一致性哈希&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mozillazg.com/2019/02/load-balancing-strategy-algorithm-weighted-least-connection.html"&gt;负载均衡策略之最少连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mozillazg.com/2019/03/load-balancing-strategy-algorithm-consistent-hashing#comment-4389770157"&gt;负载均衡策略之一致性哈希&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="load-balancing"></category><category term="load-balancer"></category></entry><entry><title>rate limiting 之 leaky bucket</title><link href="https://mozillazg.com/2019/04/rate-limiting-intro-leaky-bucket.html" rel="alternate"></link><updated>2019-04-14T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2019-04-14:2019/04/rate-limiting-intro-leaky-bucket.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;前言&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;简单介绍一下 leaky bucket 算法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;版本&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;leaky bucket 有两个版本：一个是 as a meter 、另一个是 as a queue 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="as-a-meter"&gt;
&lt;h2 id="hidas-a-meter"&gt;as a meter&lt;a class="headerlink" href="#hidas-a-meter" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Leaky_bucket_image1" src="/static/images/leaky-bucket/Leaky_bucket_analogy.JPG" /&gt;&lt;/p&gt;
&lt;p&gt;(图片来自 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Leaky_bucket"&gt;https://en.wikipedia.org/wiki/Leaky_bucket&lt;/a&gt; )&lt;/p&gt;
&lt;p&gt;在 as a meter 版本中，一般用下面的方法来描述（来自 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Leaky_bucket"&gt;wikipedia&lt;/a&gt; ）：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A fixed capacity bucket, associated with each virtual connection or user, leaks at a fixed rate.
一个固定容量的 bucket ，用来处理每个连接或用户，这个 bucket 以一个固定的速率往下漏东西。&lt;/li&gt;
&lt;li&gt;If the bucket is empty, it stops leaking.
如果 bucket 为空，将不再漏东西。&lt;/li&gt;
&lt;li&gt;For a packet to conform, it has to be possible to add a specific amount of water to the bucket: The specific amount added by a conforming packet can be the same for all packets, or can be proportional to the length of the packet.
当需要确认一个数据包的时候，把它当做一定数量的水加到 bucket 中：这个添加的水量可以跟所有的包一样，也可以按包的实际长度以一定比例来添加。&lt;/li&gt;
&lt;li&gt;If this amount of water would cause the bucket to exceed its capacity then the packet does not conform and the water in the bucket is left unchanged.
如果 bucket 中水的总量达到了 bucket 的容量限制，那么新的包就不被接受并且 bucket 中的水不会有啥变化。&lt;/li&gt;
&lt;li&gt;不被接受的包可以被丢弃( &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Traffic_police"&gt;Traffic policing&lt;/a&gt; )，也可以被排队( &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Traffic_shaping"&gt;Traffic shaping&lt;/a&gt; )，看具体的需求来做。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过上面可以发现，as a meter 的 leaky bucket 其实跟前面说过的 &lt;a class="reference external" href="https://mozillazg.com/2019/01/rate-limiting-intro-token-bucket.html"&gt;token bucket&lt;/a&gt; 是类似的，只是实现上不一样而已，实际的效果其实是一样的：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;bucket 都有容量限制。&lt;/li&gt;
&lt;li&gt;都允许存在波峰/尖刺，考虑一个极端情况：在 token bucket 中当 bucket 满的时候是可以一次性拿出所有 token 的，此时就是个波峰/尖刺了，在 leaky bucket 中当 bucket 空的时候是可以一次性倒入达到 bucket 容量限制的水的，此时也会有个波峰/尖刺。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="as-a-queue"&gt;
&lt;h2 id="hidas-a-queue"&gt;as a queue&lt;a class="headerlink" href="#hidas-a-queue" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Leaky_bucket_image2" src="/static/images/leaky-bucket/LeakyBucket.png" /&gt;&lt;/p&gt;
&lt;p&gt;(图片来自 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Leaky_bucket"&gt;https://en.wikipedia.org/wiki/Leaky_bucket&lt;/a&gt; )&lt;/p&gt;
&lt;p&gt;在 as a queue 版本中，可以把它作为一个先进先出的队列，流量涌入到 bucket 中，但是只能以恒定的速率流出，可以用来平滑流量或消峰：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;流量涌入到 bucket 中，当超出 bucket 容量限制时，排队或者被丢弃&lt;/li&gt;
&lt;li&gt;bucket 中的流量被以一个恒定的速率流出（当然，如果 bucket 中的数据太少的话流出就会断断续续，主要是不会超过指定的速率）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过上面的介绍，可以看出来其实 as a queue 的 leaky bucket 可以看做是 as a meter 的 leaky bucket 的一个特例：
只要 as a meter 的 leaky bucket 的 bucket 容量被设置为在一个 ticket 周期内将流出的水量就可以达到类似 as a queue 的平滑流量/消峰的效果了。比如 rate 是 10kb/s ，ticket 是 1s，那么把 as a meter 的 bucket 容量限制为 10kb 即可达到类似效果。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;总结&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;简单介绍了一下 leaky bucket 算法，基本都是 wikipedia 上的知识，
建议直接查看参考资料中的 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Leaky_bucket"&gt;wikipedia&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;参考资料&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Leaky_bucket"&gt;Leaky bucket - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Token_bucket"&gt;Token bucket - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="rate-limiting"></category><category term="leaky-bucket"></category></entry><entry><title>安全友好的客户端行为</title><link href="https://mozillazg.com/2019/03/safe-client-behaviour-notes-retry-jitter-back-off-more.html" rel="alternate"></link><updated>2019-03-24T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2019-03-24:2019/03/safe-client-behaviour-notes-retry-jitter-back-off-more.html</id><summary type="html">&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;前言&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文是 &lt;a class="reference external" href="https://www.usenix.org/conference/srecon18asia/presentation/goh"&gt;Safe Client Behaviour | USENIX&lt;/a&gt; 这个视频的简单总结，可以当做是 &lt;a class="reference external" href="https://mozillazg.com/2018/08/call-remote-service-checklist.html"&gt;调用远程服务的一些备忘录&lt;/a&gt; 的延伸/补充内容。强烈建议直接查看 &lt;a class="reference external" href="https://www.usenix.org/conference/srecon18asia/presentation/goh"&gt;Safe Client Behaviour | USENIX&lt;/a&gt; 这个原始视频，本文只是个简单的笔记没啥可看的，原视频才是精华。&lt;/p&gt;
&lt;p&gt;不安全的客户端行为最直观的表现就是会在出现异常情况时 DDoS 服务端，所以安全的客户端行为就是要避免发生 DDoS 服务端的情况。视频里已一个 app 需要每 5 分钟从服务端获取一次信息为例，讲了几个原则，下面简单记录一下。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;period&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;300&lt;/span&gt; &lt;span class="c1"&gt;// Once every 5 minutes&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="nx"&gt;send_rpc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="nx"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;period&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="jitter-everything"&gt;
&lt;h2 id="hidjitter-everything"&gt;Jitter Everything!&lt;a class="headerlink" href="#hidjitter-everything" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;所谓的 Jitter 指的是给周期性的操作增加随机因子，不要固定操作周期平滑一下客户端的请求，让服务端的负载也平滑一下。
这里举了几个怎么加 jitter 的例子。&lt;/p&gt;
&lt;p&gt;首先容易想到的是在 wait 的时候加 jitter:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;period&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;300&lt;/span&gt; &lt;span class="c1"&gt;// Once every 5 minutes&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="nx"&gt;send_rpc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="nx"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;period&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nx"&gt;random&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种方法虽然确实平滑了后面周期性的请求，但是还有一个瑕疵，那就是第一次请求的时候多个客户端会产生一个尖峰，因为有可能发生大量客户端都在那个时候启动触发第一次请求，所以就有了第二方法：在第一次的时候就加 jitter，当然后面 wait 的时候也还是要继续加 jitter 的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;period&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;300&lt;/span&gt; &lt;span class="c1"&gt;// Once every 5 minutes&lt;/span&gt;
&lt;span class="nx"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;period&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nx"&gt;random&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="nx"&gt;send_rpc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="nx"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;period&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nx"&gt;random&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过在第一次请求前和后面 wait 的时候加 jitter 就可以尽可能的平滑请求，做一个不 DDoS 为服务端着想的好宝宝。&lt;/p&gt;
&lt;p&gt;作者还说了一个不对周期时间做 jitter 而是对执行时间做 jitter 的方法，视频中说这种方法可以完全平滑请求曲线 ，达到一种完美的状态(但是我并没有搞懂这个方法中 truncate 函数是怎么实现的究竟包含了什么魔法，视频中也没说细节，大家如果知道的话可以留言告知我一下，谢谢了):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="nx"&gt;period&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;300&lt;/span&gt; &lt;span class="c1"&gt;// Once every 5 minutes&lt;/span&gt;
  &lt;span class="nx"&gt;next_execution&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;now&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="nx"&gt;next_execution&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;truncate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;next_execution&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;period&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nx"&gt;next_execution&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nx"&gt;random&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nx"&gt;period&lt;/span&gt;
  &lt;span class="nx"&gt;wait_until&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;next_execution&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nx"&gt;send_rpc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="dont-retry-if-you-retry-back-off"&gt;
&lt;h2 id="hiddont-retry-if-you-retry-back-off"&gt;Don’t Retry! &amp;amp;&amp;amp; If you retry, back off!&lt;a class="headerlink" href="#hiddont-retry-if-you-retry-back-off" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个主要说的是如果要重试的话记得给重试增加 back-off(重试间隔指数递增) 和 jitter，例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="nx"&gt;period&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;delay&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
  &lt;span class="nx"&gt;success&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;send_rpc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nx"&gt;not&lt;/span&gt; &lt;span class="nx"&gt;success&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;delay&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nx"&gt;random&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="nx"&gt;success&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;send_rpc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="nx"&gt;delay&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;delay&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
  &lt;span class="nx"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;period&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nx"&gt;random&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一个重试时比上面效率更高更平滑的方法是限制重试次数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="nx"&gt;period&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;300&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;delay&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
  &lt;span class="nx"&gt;success&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;send_rpc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nx"&gt;not&lt;/span&gt; &lt;span class="nx"&gt;success&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;delay&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="nx"&gt;period&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;delay&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nx"&gt;random&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="nx"&gt;success&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;send_rpc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="nx"&gt;delay&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;delay&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
  &lt;span class="nx"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;period&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nx"&gt;random&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还提到了关于重试的其他 tips:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;默认不要重试。&lt;/li&gt;
&lt;li&gt;重试时增加 back-off 指数递增的重试间隔。&lt;/li&gt;
&lt;li&gt;同时也别忘了增加 jitter 随机因子。&lt;/li&gt;
&lt;li&gt;不同场景下的重试策略：&lt;ul&gt;
&lt;li&gt;不要重试客户端错误（比如 HTTP 404 错误）。&lt;/li&gt;
&lt;li&gt;在服务端错误时重试（比如 HTTP 500 错误）。&lt;/li&gt;
&lt;li&gt;在发生网络错误时重试。&lt;/li&gt;
&lt;li&gt;在发生超时的时候小心重试。&lt;/li&gt;
&lt;li&gt;在配额超限的时候不要重试！&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="safer-clients-move-control-to-the-server"&gt;
&lt;h2 id="hidsafer-clients-move-control-to-the-server"&gt;Safer clients: Move control to the server!&lt;a class="headerlink" href="#hidsafer-clients-move-control-to-the-server" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;可以实现一些功能让服务端拥有控制客户端的能力：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;在客户端和服务端都实现 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;Retry-After&lt;/span&gt;&lt;/tt&gt; 这个 HTTP Header，双方通过这个 Header 来约定下次重试的时机。&lt;/li&gt;
&lt;li&gt;服务端在实现这个重试周期的时候别忘了增加 jitter 随机因子。&lt;/li&gt;
&lt;li&gt;远程控制客户端的能力（比如远程把客户端的请求给临时停了，或者临时拉大重试基础间隔）。&lt;/li&gt;
&lt;li&gt;远程配置调用周期。&lt;/li&gt;
&lt;li&gt;维护一个可远程控制的客户端特性黑名单。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="safer-clients-expose-information-to-server"&gt;
&lt;h2 id="hidsafer-clients-expose-information-to-server"&gt;Safer clients: Expose information to server&lt;a class="headerlink" href="#hidsafer-clients-expose-information-to-server" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;客户端暴露越多的信息给服务端，就可以得到更精细的响应:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;给请求打标签&lt;ul&gt;
&lt;li&gt;客户端名称和版本号&lt;/li&gt;
&lt;li&gt;什么特性触发了当前请求&lt;/li&gt;
&lt;li&gt;失败请求的严重程度（比如短期内失败了多少次）&lt;/li&gt;
&lt;li&gt;当前请求是第一次请求还是重试发起的请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可能得到的服务端响应&lt;ul&gt;
&lt;li&gt;给请求赋予不同的优先级&lt;/li&gt;
&lt;li&gt;drop 一些后台请求&lt;/li&gt;
&lt;li&gt;防止 drop 了一些可能会触发重连风暴的请求&lt;/li&gt;
&lt;li&gt;为客户端的 bug 做一些 workaround （比如旧版本的客户端 bug）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="safer-microservices"&gt;
&lt;h2 id="hidsafer-microservices"&gt;Safer Microservices&lt;a class="headerlink" href="#hidsafer-microservices" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;微服务环境下可以做的更多。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;重试预算&lt;ul&gt;
&lt;li&gt;限制只有多少百分比的重试可以正常发出，其他的重试直接取消。比如只允许发出 10% 的重试。&lt;/li&gt;
&lt;li&gt;阻止重连请求影响其他正常请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;适当的限流
* 基于失败率直接在客户端取消掉新的请求，通过这种方式来减轻服务端的负载。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;总结&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;强烈建议直接查看 &lt;a class="reference external" href="https://www.usenix.org/conference/srecon18asia/presentation/goh"&gt;Safe Client Behaviour | USENIX&lt;/a&gt; 这个原始视频，本文只是个简单的笔记没啥可看的，原视频才是精华。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;参考资料&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.usenix.org/conference/srecon18asia/presentation/goh"&gt;Safe Client Behaviour | USENIX&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.youtube.com/watch?v=NHNZab_AzZo"&gt;SREcon18 Asia/Australia - Safe Client Behaviour - YouTube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="/static/downloads/Safe-Client-Behaviour.pdf"&gt;Sides of Safe Client Behaviour&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/"&gt;Exponential Backoff And Jitter | AWS Architecture Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="client"></category></entry><entry><title>负载均衡策略之一致性哈希</title><link href="https://mozillazg.com/2019/03/load-balancing-strategy-algorithm-Consistent-hashing.html" rel="alternate"></link><updated>2019-03-17T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2019-03-17:2019/03/load-balancing-strategy-algorithm-Consistent-hashing.html</id><summary type="html">&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;前言&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文简单介绍一下一致性哈希相关知识。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;一致性哈希&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;所谓的一致性哈希策略指的是根据后端节点的某个固定属性计算 hash 值，然后把所有节点计算出来的 hash 值组成一个 hash 圆环。 请求过来的时候根据请求的特征（比如，来源 ip 、cookie、用户名等特定信息）计算该特征的 hash 值（使用跟计算后端节点 hash 值相同的 hash 函数进行计算）， 然后顺时针查找 hash 环上的 hash 值，第一个比请求特征的 hash 值大的 hash 值所对应的节点即为被选中的节点。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/static/images/other/consisten-hashing.png" /&gt;&lt;/p&gt;
&lt;p&gt;（图片来源出处： &lt;a class="reference external" href="https://charlee.li/memcached-004.html"&gt;memcached全面剖析--4. memcached的分布式算法&lt;/a&gt; ）&lt;/p&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3 id="hidid4"&gt;改进&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;上面的 hash 圆环有一个问题就是节点的 hash 值不一定是均匀的分布在 hash 环上的，这样就会导致部分节点上承受太多的请求。&lt;/p&gt;
&lt;p&gt;解决的办法也比较简单，然后就是引入虚拟节点：每个节点重复 n 次，把这些虚拟节点的 hash 值（跟实际节点的 hash 值不一样，也就是说需要在节点属性中加点东西保证每个虚拟节点跟实际节点的 hash 值不一样，互相之间也要不一样）也加入到 hash 环中以此来保证分布更均匀。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3 id="hidid5"&gt;注意点&lt;a class="headerlink" href="#hidid5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这里有一个需要注意的点那就是临界值的处理问题：可能会有部分请求处在 hash 环上最后一个点的后面，即 hash 环上找不到一个比请求特征的 hash 值更大的一个 hash。&lt;/p&gt;
&lt;p&gt;对于这种无法在 hash 环上找到对应的下一个节点的情况，一般是把 hash 环上的第一个 hash 值作为被选中的点，即进行第二圈的顺时针查找。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2 id="hidid6"&gt;总结&lt;a class="headerlink" href="#hidid6" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文简单介绍了一下一致性哈希相关知识，更详细的信息请阅读参考资料。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2 id="hidid7"&gt;参考资料&lt;a class="headerlink" href="#hidid7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Consistent_hashing"&gt;Consistent hashing - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://charlee.li/memcached-004.html"&gt;memcached全面剖析--4. memcached的分布式算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://blog.codinglabs.org/articles/consistent-hashing.html"&gt;CodingLabs - 一致性哈希算法及其在分布式系统中的应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.openstack.org/swift/latest/ring_background.html"&gt;OpenStack Docs: Building a Consistent Hashing Ring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://timyang.net/architecture/consistent-hashing-practice/"&gt;某分布式应用实践一致性哈希的一些问题 – 后端技术 by Tim Yang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/"&gt;一致性哈希算法的理解与实践 | Yikun&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="load-balancer"></category><category term="load-balancing"></category><category term="consisten-hashing"></category></entry><entry><title>网络负载均衡器中的动态权重功能</title><link href="https://mozillazg.com/2019/03/load-balancer-load-balancing-dynamic-weight-max-connections-slow-start-mode.html" rel="alternate"></link><updated>2019-03-10T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2019-03-10:2019/03/load-balancer-load-balancing-dynamic-weight-max-connections-slow-start-mode.html</id><summary type="html">&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;前言&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;有时候我们可能希望能够动态调整负载均衡器中某个节点权重和最大连接数限制，
比如，某个节点负载有点高，当时又不想完全不接受连接，
此时就可以通过调整权重或最大连接数限制来减少新的连接数，防止节点出现过载的情况。&lt;/p&gt;
&lt;p&gt;下面就简单记录一下相关需求和实现。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;手动调整&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;手动调整节点权重和最大连接数是最简单也最直观的一种方法，一般可以通过下面的方法实现：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;配置文件支持热更新，通过更新配置文件中节点权重或最大连接数限制来实现。&lt;/li&gt;
&lt;li&gt;如果配置信息不是通过文件读取而是从配置管理系统读取的话，那就只要支持监听配置管理系统的更新推送并热更新内存中的配置就好。&lt;/li&gt;
&lt;li&gt;支持通过 API 更新运行时信息，比如支持通过 HTTP API 来更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;自动调整&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在某些场景下可能有需要负载均衡器支持自动动态调整节点权重和最大连接数限制的功能：
比如，新加了一个节点到负载均衡器中，但是后端节点是需要一段时间的预热才能处理大量连接，
当我们使用的是类似 【最少连接】这种负载均衡策略时，因为是新增的节点连接数最少会出现短时间连接大量涌入新节点的情况，
此时就会出现节点过载的情况（前面说了假设我们的节点需要预热才能处理大量连接），甚至出现打垮新节点的情况。&lt;/p&gt;
&lt;div class="section" id="slow-start"&gt;
&lt;h3 id="hidslow-start"&gt;slow start 模式&lt;a class="headerlink" href="#hidslow-start" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;对于这种类似需要预热的场景，需要负载均衡器支持类似 slow start 模式：
slow start 模式下，节点的权重和最大连接数会从 1 开始随着时间线性增长，直至增长到配置的权重和最大连接数的值。
slow start 模式给予了节点一段时间的预热期，并且预热期间的连接数是线性缓慢增长的，
既达到了预热的效果又不会出现瞬间涌入大量连接打垮后端节点的情况，非常适合需要预热的情况。&lt;/p&gt;
&lt;p&gt;那么，在什么情况下一个节点会自动进入 slow start 模式呢，一般在下面的情况会考虑自动进入 slow start 模式：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;新增节点。&lt;/li&gt;
&lt;li&gt;节点健康状态从不健康切换到健康。此时一般是后端节点之前在发布或重启，亦或是刚刚从故障中恢复。&lt;/li&gt;
&lt;li&gt;节点状态从 Down 状态切换为可以接受新连接的状态。这个状态切换可能是手动通过页面或API进行的操作，也可能是程序内部的状态自动切换。 原因一般跟上面的健康检查状态切分类似。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于这个 slow start 模式有一点需要注意的是：在负载均衡器启动的时候一般不会触发 slow start 模式，虽然满足上面的新增节点的情况。因为如果在负载均衡器启动的时候就触发的话，会出现所有节点都进入 slow start 模式，可能会导致只能处理少量连接的情况，无法实际需求。如果确实需要启动时就进入 slow start 模式的话需要考虑一下这种情况会导致的容量问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3 id="hidid5"&gt;根据响应/负载情况自动调整&lt;a class="headerlink" href="#hidid5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;还有一种方式是根据后端负载或响应情况来自动调整，比如后端连续多次返回的响应码是 5xx  或者响应时间或后端服务负载超出阈值等，此时可以根据需要降低一下该节点的权重和最大连接数限制（注意要在适当的时机把权重恢复回来，比如一段时间不再返回 5xx 或后端负载恢复到正常水平 则逐步恢复到原来的权重值）或者把节点切换为不接受新请求的状态，一段时间后进入 slow start 模式慢慢恢复正常。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2 id="hidid6"&gt;总结&lt;a class="headerlink" href="#hidid6" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文简单介绍了一下负载均衡器中动态权重相关的内容，欢迎大家补充其他知识。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2 id="hidid7"&gt;参考资料&lt;a class="headerlink" href="#hidid7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://support.citrix.com/article/CTX108886"&gt;NetScaler Load Balancing - Slow Start Mode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/haproxy/haproxy/blob/a51885621d5bf8fa63a82e8beb8438841098251f/doc/configuration.txt#L12174"&gt;haproxy/configuration.txt at master · haproxy/haproxy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="load-balancer"></category><category term="load-balancing"></category><category term="slow-start"></category></entry><entry><title>负载均衡策略之两次随机选择策略</title><link href="https://mozillazg.com/2019/03/load-balancing-strategy-algorithm-the-power-of-two-random-choices.html" rel="alternate"></link><updated>2019-03-03T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2019-03-03:2019/03/load-balancing-strategy-algorithm-the-power-of-two-random-choices.html</id><summary type="html">&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;前言&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文简单介绍一下两次随机选择这个负载均衡策略。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="two-random-choices"&gt;
&lt;h2 id="hidtwo-random-choices"&gt;两次随机选择（Two Random Choices）&lt;a class="headerlink" href="#hidtwo-random-choices" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;两次随机选择策略出自论文
&lt;a class="reference external" href="http://www.eecs.harvard.edu/~michaelm/postscripts/handbook2001.pdf"&gt;《The Power of Two Random Choices: A Survey of Techniques and Results》&lt;/a&gt; ，主要思想是：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;从可用节点列表中做两次随机选择操作，得到节点 A、B&lt;/li&gt;
&lt;li&gt;比较 A、B 两个节点，选出负载最低（一般是正在处理的连接数/请求数最少）的节点作为被选中的节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至于简单实现这里就不贴出来了，可以参考下面的伪代码以及前面的 &lt;a class="reference external" href="https://mozillazg.com/2019/01/load-balancing-strategy-algorithm-weighted-random.html"&gt;负载均衡策略之随机选择&lt;/a&gt;
和 &lt;a class="reference external" href="https://mozillazg.com/2019/02/load-balancing-strategy-algorithm-weighted-least-connection.html"&gt;负载均衡策略之最少连接&lt;/a&gt; 结合这两个就可以了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;random_choice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;random_choice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;least_connection_choice&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;总结&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文简单介绍了一下两次随机选择这个负载均衡策略。
关于两次随机选择策略的更详细信息可以参考参考资料中列出来的资源。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;参考资料&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://brooker.co.za/blog/2012/01/17/two-random.html"&gt;The power of two random choices - Marc's Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.eecs.harvard.edu/~michaelm/postscripts/handbook2001.pdf"&gt;The Power of Two Random Choices: A Survey of Techniques and Results&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.haproxy.com/blog/power-of-two-load-balancing/"&gt;Test Driving &amp;quot;Power of Two Random Choices&amp;quot; Load Balancing - HAProxy Technologies&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="load-balancing"></category><category term="load-balancer"></category></entry><entry><title>负载均衡策略之最少连接</title><link href="https://mozillazg.com/2019/02/load-balancing-strategy-algorithm-weighted-least-connection.html" rel="alternate"></link><updated>2019-02-19T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2019-02-19:2019/02/load-balancing-strategy-algorithm-weighted-least-connection.html</id><summary type="html">&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;前言&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文简单介绍一下最少连接这个负载均衡策略。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="least-connection"&gt;
&lt;h2 id="hidleast-connection"&gt;最少连接 (Least Connection)&lt;a class="headerlink" href="#hidleast-connection" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最少连接策略指的是从已有的后端列表中选择正在处理的连接数/请求数（对于七层负载均衡器来说可能更多的是说的最少请求数）
最少的节点出来提供服务。&lt;/p&gt;
&lt;p&gt;既然要判断连接数/请求数，那么每个节点都需要保存一个正在处理的连接数/请求数的信息，然后选取节点的时候判断一下，
选择连接数最少的那个节点。&lt;/p&gt;
&lt;p&gt;用 python 简单表示就是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connections&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__repr__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;Node: {}, conn: {}&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connections&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LC&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;select&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connections&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;best&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connections&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;

        &lt;span class="n"&gt;best&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connections&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;best&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;release&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connections&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="weighted-least-connection"&gt;
&lt;h2 id="hidweighted-least-connection"&gt;带权重的最少连接 (Weighted Least Connection)&lt;a class="headerlink" href="#hidweighted-least-connection" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;实际使用中各个节点往往都带有不同的权重，比较连接数时需要同时考虑节点的权重信息，
被选中的节点的连接数与权重的比要最小。 即，被选中的节点满足下面的条件：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;假设用 C 表示连接数、W 表示权重、S 表示被选中的节点、Sn 表示未被选中的节点&lt;/li&gt;
&lt;li&gt;那么 S 必须满足 C(S) / W(S) &amp;lt; C(Sn) / W(Sn) ，这个条件也可以表示为 C(S) * W(Sn) &amp;lt; C(Sn) * W(S)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用 python 简单表示就是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connections&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__repr__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;Node: {}, weight: {}, conn: {}&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connections&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;LC&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;select&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                    &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connections&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;best&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt;
                    &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;best&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connections&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;

        &lt;span class="n"&gt;best&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connections&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;best&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;release&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connections&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3 id="hidid3"&gt;改进&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;上面的 Python 简单实现其实有一点小瑕疵：当有多个节点满足条件时，上面的方法可能会连续多次选中同一个节点，
导致结果不够平滑。&lt;/p&gt;
&lt;p&gt;解决这个瑕疵的方法也比较简单，那就是把所有满足条件的节点都选出来，然后对这些节点应用其他负载均衡策略来选出合适的节点（比如使用前面介绍过的轮询策略、随机选择策略等）。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;总结&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文简单记录了一下最少连接策略以及带权重的最少连接策略这两个负载均衡策略的实现方法，
当然还有其他的实现方法欢迎一起探讨。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2 id="hidid5"&gt;参考资料&lt;a class="headerlink" href="#hidid5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/nginx/nginx/blob/d8ccef021588cf79d2dae7c132a0b1225ed52c30/src/http/modules/ngx_http_upstream_least_conn_module.c"&gt;nginx/ngx_http_upstream_least_conn_module.c at master · nginx/nginx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://kb.linuxvirtualserver.org/wiki/Weighted_Least-Connection_Scheduling"&gt;Weighted Least-Connection Scheduling - LVSKB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="load-balancing"></category><category term="load-balancer"></category></entry><entry><title>负载均衡策略之轮询策略</title><link href="https://mozillazg.com/2019/02/load-balancing-strategy-algorithm-weighted-round-robin.html" rel="alternate"></link><updated>2019-02-17T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2019-02-17:2019/02/load-balancing-strategy-algorithm-weighted-round-robin.html</id><summary type="html">&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;前言&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文简单介绍一下轮询(Round Robin)这个负载均衡策略。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="round-robin"&gt;
&lt;h2 id="hidround-robin"&gt;轮询选择 (Round Robin)&lt;a class="headerlink" href="#hidround-robin" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;轮询选择指的是从已有的后端节点列表中按顺序依次选择一个节点出来提供服务。&lt;/p&gt;
&lt;p&gt;一种轮询选择的方法是把所有的节点看做一个一个的点，并把这些点连起来组成一个圆，
轮询选择就是在这个圆上按顺时针选择一个点。&lt;/p&gt;
&lt;p&gt;可以通过用请求次数取模来实现这个顺时针选择的功能，比如用 python 来表示就是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;choices&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="n"&gt;choices&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;choices&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="weighted-round-robin"&gt;
&lt;h2 id="hidweighted-round-robin"&gt;带权重的轮询选择 (Weighted Round Robin)&lt;a class="headerlink" href="#hidweighted-round-robin" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;实际使用中各个节点往往都带有不同的权重，所以一般都需要实现带权重的轮询选择。
权重高的被选中的次数多，权重低的被选中的次数少。&lt;/p&gt;
&lt;p&gt;我们还是可以把带权重信息的节点排成一个圆，不过这一次根据不同的权重把对应的节点重复不同的次数。&lt;/p&gt;
&lt;p&gt;然后还是顺时针选择一个点，因为每个节点根据权重重复了相应的次数，所以不同权重的节点被选中的次数也不一样并且选中的次数跟它本身的权重有关，这样就就简单实现了带权重的轮询选择。&lt;/p&gt;
&lt;p&gt;同样的 python 表示（假设 A、B、C 的权重分别是 3、2、1）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;choices&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="n"&gt;choices&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;     &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;choices&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3 id="hidid3"&gt;改进&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;上面的按权重重复节点的方式有一个明显的问题就是不够平滑：&lt;/p&gt;
&lt;p&gt;权重高的节点会先被选中直至达到权重次数才会选择下一个节点或者说会出现请求连续的打在同一个节点上的情况，导致权重低的节点可能会处于空闲状态，没有平滑分配请求。&lt;/p&gt;
&lt;p&gt;一种改进方法是：使用 nginx 中实现的一种平滑的带权重轮询的方法 &lt;a class="footnote-reference" href="#id9" id="id4"&gt;[1]&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="c1"&gt;# 普通带权重轮询结果示例：&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="c1"&gt;# nginx 实现的平滑的带权重轮询的结果示例：&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法的原文描述如下 &lt;a class="footnote-reference" href="#id9" id="id5"&gt;[1]&lt;/a&gt; :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For edge case weights like { 5, 1, 1 } we now produce { a, a, b, a, c, a, a }
sequence instead of { c, b, a, a, a, a, a } produced previously.&lt;/p&gt;
&lt;p&gt;Algorithm is as follows: on each peer selection we increase current_weight
of each eligible peer by its weight, select peer with greatest current_weight
and reduce its current_weight by total number of weight points distributed
among peers.&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;To preserve weight reduction in case of failures the effective_weight
variable was introduced, which usually matches peer's weight, but is
reduced temporarily on peer failures.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个节点有三个属性，这三个属性的含义如下：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;weight&lt;/tt&gt;: 节点权重值，这个值固定不变。&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;effective_weight&lt;/tt&gt;: 节点的有效权重。初始值等于 &lt;tt class="docutils literal"&gt;weight&lt;/tt&gt; 。之所以有个 &lt;tt class="docutils literal"&gt;effective_weight&lt;/tt&gt; 是为了
在发现后端节点异常次数过多时（比如响应完成时发现选择的节点有问题，错误次数有点多）临时降低节点的权重。
在轮询遍历选择节点时这个 &lt;tt class="docutils literal"&gt;effective_weight&lt;/tt&gt; 的值会逐步增加恢复到 &lt;tt class="docutils literal"&gt;weight&lt;/tt&gt; 的值，所以只是为了在异常时临时降低权重不会永久影响节点的权重（节点正常时会逐步恢复到原有的权重）。&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;current_weight&lt;/tt&gt;: 节点当前权重。初始值为 0，后面会动态调整：&lt;ul&gt;
&lt;li&gt;每次选取节点时，遍历可用节点，遍历时把当前节点的 &lt;tt class="docutils literal"&gt;current_weight&lt;/tt&gt; 的值加上它的 &lt;tt class="docutils literal"&gt;effective_weight&lt;/tt&gt; ，&lt;/li&gt;
&lt;li&gt;同时累加所有节点的 &lt;tt class="docutils literal"&gt;effective_weight&lt;/tt&gt; 值为 &lt;tt class="docutils literal"&gt;total&lt;/tt&gt; 。&lt;/li&gt;
&lt;li&gt;如果当前节点的 &lt;tt class="docutils literal"&gt;current_weight&lt;/tt&gt; 值最大，那么这个节点就是被选中的节点，同时把它的 &lt;tt class="docutils literal"&gt;current_weight&lt;/tt&gt; 减去 &lt;tt class="docutils literal"&gt;total&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;没有被选中的节点的 &lt;tt class="docutils literal"&gt;current_weight&lt;/tt&gt; 不用减少。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整个过程用 python 简单的表示就是（也可以直接看 nginx 的实现 &lt;a class="footnote-reference" href="#id10" id="id6"&gt;[2]&lt;/a&gt; ）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;effect_weight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current_weight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;failed_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__repr__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;lt;Node: {}&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RB&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;max_fails&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;select&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
        &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current_weight&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;effect_weight&lt;/span&gt;
            &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;effect_weight&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;effect_weight&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;effect_weight&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current_weight&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;best&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current_weight&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;

        &lt;span class="n"&gt;best&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current_weight&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;total&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;best&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;release&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;failed&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;failed_number&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;failed_number&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;max_faile&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;effect_weight&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;max_fails&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;failed_number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;effect_weight&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;effect_weight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;nodes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;rb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;RB&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;choices&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;_&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;      &lt;span class="n"&gt;choices&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rb&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;choices&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
 &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到确实是比之前的 &lt;tt class="docutils literal"&gt;['A', 'A', 'A', 'B', 'B', 'C', 'A', 'A', 'A', 'B', &lt;span class="pre"&gt;...]&lt;/span&gt;&lt;/tt&gt; 要平滑一些。&lt;/p&gt;
&lt;p&gt;上面在介绍 &lt;tt class="docutils literal"&gt;effective_weight&lt;/tt&gt; 时说这个属性主要用来临时降低节点权重，如果没有这个需求的话可以省去 &lt;tt class="docutils literal"&gt;effective_weight&lt;/tt&gt; 直接用 &lt;tt class="docutils literal"&gt;weight&lt;/tt&gt; 就好:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;select&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
    &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nodes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current_weight&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt;
        &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;weight&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current_weight&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;best&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current_weight&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;best&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;

    &lt;span class="n"&gt;best&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current_weight&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;total&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;best&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于这个 nginx 实现的平滑的带权重轮询的方法的更多细节可以阅读参考资料中列出的一些资料。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2 id="hidid7"&gt;总结&lt;a class="headerlink" href="#hidid7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文简单记录了一下轮询选择以及带权重的轮询选择这两个负载均衡策略的实现方法，
当然还有其他的实现方法欢迎一起探讨。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h2 id="hidid8"&gt;参考资料&lt;a class="headerlink" href="#hidid8" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/nginx/nginx/commit/52327e0627f49dbda1e8db695e63a4b0af4448b1"&gt;Upstream: smooth weighted round-robin balancing. · nginx/nginx&amp;#64;52327e0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://blog.csdn.net/zhangskd/article/details/50194069"&gt;Nginx的负载均衡 - 加权轮询 (Weighted Round Robin) 上篇 - zhangskd的专栏 - CSDN博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://notes.songjingsong.top/2018/11/15/grasp/3/"&gt;关于平滑加权算法的思考以及证明 | 盒饭编程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://tenfy.cn/2018/11/12/smooth-weighted-round-robin/"&gt;nginx平滑的基于权重轮询算法分析 | tenfy' blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://kb.linuxvirtualserver.org/wiki/Weighted_Round-Robin_Scheduling"&gt;Weighted Round-Robin Scheduling - LVSKB&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="docutils footnote" frame="void" id="id9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;[1]&lt;/td&gt;&lt;td&gt;&lt;em&gt;(&lt;a class="fn-backref" href="#id4"&gt;1&lt;/a&gt;, &lt;a class="fn-backref" href="#id5"&gt;2&lt;/a&gt;)&lt;/em&gt; &lt;a class="reference external" href="https://github.com/nginx/nginx/commit/52327e0627f49dbda1e8db695e63a4b0af4448b1"&gt;Upstream: smooth weighted round-robin balancing. · nginx/nginx&amp;#64;52327e0&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id10" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id6"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="https://github.com/nginx/nginx/commit/52327e0627f49dbda1e8db695e63a4b0af4448b1#diff-3f2250b728a3f5fe1e2d31cbf63c2268R527"&gt;Upstream: smooth weighted round-robin balancing. · nginx/nginx&amp;#64;52327e0&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</summary><category term="load-balancing"></category><category term="load-balancer"></category><category term="round-robin"></category></entry><entry><title>负载均衡策略之随机选择</title><link href="https://mozillazg.com/2019/01/load-balancing-strategy-algorithm-weighted-random.html" rel="alternate"></link><updated>2019-01-23T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2019-01-23:2019/01/load-balancing-strategy-algorithm-weighted-random.html</id><summary type="html">&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;前言&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文简单介绍一下随机选择这个负载均衡策略。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="random"&gt;
&lt;h2 id="hidrandom"&gt;随机选择 (Random)&lt;a class="headerlink" href="#hidrandom" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;随机选择指的是从已有的后端列表中随机选择一个节点出来提供服务。
一种随机选择的方法是把所有的节点看做一个一个的点，并把这些点连起来排成一条直线，
随机选择就是在这条直线上随机选择一个点：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;A - B - C
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至于怎么做随机选择一个点，这个可以用各个编程语言官方实现自带的生成
指定区间（直线的开始到结尾区间）内的随机数的方法来生成一个随机数的方式来选择对应的点。&lt;/p&gt;
&lt;p&gt;用 python 来表示就是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;random&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;randint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;choice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="weighted-random"&gt;
&lt;h2 id="hidweighted-random"&gt;带权重的随机选择 (Weighted Random)&lt;a class="headerlink" href="#hidweighted-random" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;实际使用中各个节点往往都带有不同的权重，即虽然是随机选择但是期望不同权重的节点被选择的几率不一样，
权重高的被选中的几率大，权重低的被选中的几率小。&lt;/p&gt;
&lt;p&gt;我们还是可以把带权重信息的节点排成一条直线，不过这一次根据不同的权重把对应的节点重复不同的次数。
假设有三个节点 A、B、C 它们的权重分别是 3、2、4 ，那么就可以这样表示:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;A1 - A2 - A3 - B1 - B2 - C1 - C2 - C3 - C4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后还是随机选择一个点，因为每个节点根据权重重复了相应的次数，所以不同权重的节点被随机选中的概率也不一样，
就简单实现了带权重的随机选择。&lt;/p&gt;
&lt;p&gt;同样的 python 表示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;randint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;choice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3 id="hidid3"&gt;改进&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;上面的按权重重复节点的方式有以下缺点：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;不支持权重信息包含小数的情况&lt;/li&gt;
&lt;li&gt;当权重的值很大时要重复很多次浪费资源&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一种改进方法是：还是连成一条直线，不过这次是用各个节点的权重值组成一条直线，直线的不同区域属于不同的节点:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  A  B   C
&lt;span class="p"&gt;|&lt;/span&gt;---&lt;span class="p"&gt;|&lt;/span&gt;--&lt;span class="p"&gt;|&lt;/span&gt;----&lt;span class="p"&gt;|&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后取直线上的任意一个点，这个点属于直线上哪个节点的区域内就是选择了哪个节点：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;所有权重相加得到 S（其实就是直线的长度）&lt;/li&gt;
&lt;li&gt;从 [0, S) 的区间内取一个随机数 R（直线中随机选择一个点）&lt;/li&gt;
&lt;li&gt;遍历节点列表，把访问过的节点的权重相加得到 V，比较 V 与 R 的值，如果 V &amp;gt; R 当前节点即为选中的节点。（查找 R 在直线中的位置属于哪个节点所在的区域）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;python 示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;random&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;weights&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
   &lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;weights&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;randint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;weights&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="n"&gt;V&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;weight&lt;/span&gt;
   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
       &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="k"&gt;break&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;总结&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文简单记录了一下随机选择以及带权重的随机选择这两个负载均衡策略的实现方法，
当然还有其他的实现方法欢迎一起探讨。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2 id="hidid5"&gt;参考资料&lt;a class="headerlink" href="#hidid5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
</summary><category term="load-balancing"></category><category term="load-balancer"></category></entry><entry><title>网络负载均衡器的类别和功能介绍</title><link href="https://mozillazg.com/2019/01/notes-about-load-balancer-types-and-feature.html" rel="alternate"></link><updated>2019-01-20T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2019-01-20:2019/01/notes-about-load-balancer-types-and-feature.html</id><summary type="html">&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;前言&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文大部分内容都是整理自 &lt;a class="reference external" href="https://blog.envoyproxy.io/introduction-to-modern-network-load-balancing-and-proxying-a57f6ff80236"&gt;Introduction to modern network load balancing and proxying&lt;/a&gt; 感兴趣的话建议直接看那篇文章。&lt;/p&gt;
&lt;p&gt;简单记录一下常见的网络负载均衡器的类别以及常见的功能。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;类别&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一般分为 L4 四层负载均衡器和 L7 七层负载均衡器。&lt;/p&gt;
&lt;div class="section" id="l4"&gt;
&lt;h3 id="hidl4"&gt;L4 四层负载均衡器&lt;a class="headerlink" href="#hidl4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;所谓的四层负载均衡器主要指的是，负载均衡器只是单纯的 TCP/UDP 数据转换不关心数据中的应用相关的协议信息，
比如 TCP/UDP 中传输的可能是 HTTP/Redis/MongoDB 或其它应用层协议数据。&lt;/p&gt;
&lt;p&gt;四层负载均衡器的例子：客户端与负载均衡建立一条 TCP 连接，负载均衡器与一个后端服务也建立一条 TCP 连接，
当负载均衡器收到客户端发送过来的数据后，会把收到的数据转发给后端服务。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;client ---&amp;gt; load balancer ----&amp;gt; backend
       TCP1               TCP2
       &amp;lt;---               &amp;lt;----
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="l7"&gt;
&lt;h3 id="hidl7"&gt;L7 七层负载均衡器&lt;a class="headerlink" href="#hidl7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;所谓的七层负载均衡器主要指的是，负载均衡器会去解析客户端发送过来的数据，按照指定的应用层协议继续为该协议的请求，以请求为单位做负载均衡等操作。&lt;/p&gt;
&lt;p&gt;七层负载均衡器的例子：客户端与负载均衡器建立一条 TCP 连接，每次客户端发送一个应用层协议的请求到负载均衡器时， 负载均衡器都会从后端选择一个节点（可能已与这个后端节点建立连接或未建立），把这个请求转发给选中的后端节点。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;client -----------&amp;gt; load balancer ----------&amp;gt; backend 1
       request &lt;span class="m"&gt;1&lt;/span&gt;                  request 1
       request &lt;span class="m"&gt;2&lt;/span&gt;                  ----------&amp;gt; backend 2
                                  request 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从这个例子可以看到七层负载均衡着重的应用层协议，转发到后端时也是按一个完整的应用层协议数据来转发的，
所以一个客户端与负载均衡器建立的这个连接中可能发送了很多个请求，这些请求可能会转发到不同的后端节点上。&lt;/p&gt;
&lt;p&gt;相比四层负载均衡器的一一对应的转发方式七层负载均衡器的这种基于协议内容的转发可以让后端节点的负载更均衡：
比如客户端 A 在一次连接中一分钟内发送了 1000 个请求，如果是 L4 的话，这 1000 个请求的数据全部会转发到同一个后端节点上，如果是 L7 的话，则 1000 个请求按照负载均衡策略可能会分别转发到 10 个后端节点上。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;功能&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;负载均衡器一般都会有如下功能：&lt;/p&gt;
&lt;div class="section" id="id5"&gt;
&lt;h3 id="hidid5"&gt;服务发现&lt;a class="headerlink" href="#hidid5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;发现可用的后端节点的功能。可以通过多种方式来实现这个服务发现的功能：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;可以在配置文件中指定可用的后端节点信息&lt;/li&gt;
&lt;li&gt;或通过 DNS 来发现&lt;/li&gt;
&lt;li&gt;也可以是通过集成第三方服务的方式来发现后端节点（比如：zookeeper, etcd, consul 等等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h3 id="hidid6"&gt;健康检查&lt;a class="headerlink" href="#hidid6" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;健康检查用于辅助决策选择哪个后端节点来接受客户端的数据。一般有主动检查和被动检查。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;主动检查：定期向可用的后端节点做健康检查操作，及时发现不可用/无法接受新请求的后端节点。&lt;/li&gt;
&lt;li&gt;被动检查：基于转发时的状态来被动判断节点健康状况，可以辅助主动检查增强节点时候健康判断的准确度。
比如：L4 的话当发现一个节点多次建立连接失败就标记为不健康，L7 的话如果发现节点返回的 HTTP 响应短时间内出现了好几次状态码是 503 就可以考虑标记为不健康或者根据响应时间之类的来判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3 id="hidid7"&gt;负载均衡&lt;a class="headerlink" href="#hidid7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;根据不同的负载均衡算法/策略来选择合适的节点来接收转发的数据，目的是希望后端节点能够负载均衡，不要出现所有请求都打到少部分节点上去了，希望能够分散请求达到负载均衡。常见的负载均衡算法/策略有：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;随机选择(Random Choice)&lt;/li&gt;
&lt;li&gt;带权重的随机选择（Weighted Random Choice）&lt;/li&gt;
&lt;li&gt;轮询（Round Robin）&lt;/li&gt;
&lt;li&gt;带权重的轮询（Weighted Round Robin）&lt;/li&gt;
&lt;li&gt;最少连接数（Least Connection）&lt;/li&gt;
&lt;li&gt;带权重的最少连接数（Weighted Least Connection）&lt;/li&gt;
&lt;li&gt;一致性哈希（Consistent Hash）&lt;/li&gt;
&lt;li&gt;两次随机选择（Two Random Choices）等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="sticky-session"&gt;
&lt;h3 id="hidsticky-session"&gt;会话粘滞（sticky session）&lt;a class="headerlink" href="#hidsticky-session" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;后端服务的一些功能可能需要同一个客户端一段时间内的请求尽量都转发到同一个后端节点上，比如后端节点间没有共享 session 数据的 HTTP 服务，此时如果客户端请求转发到了不同的后端节点上的话，可能会出现反复提示用户登录的情况。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tsl-tls-termination"&gt;
&lt;h3 id="hidtsl-tls-termination"&gt;TSL 卸载（TLS termination）&lt;a class="headerlink" href="#hidtsl-tls-termination" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;所谓的 TSL 卸载指的是客户端与负载均衡器之间通过 TSL 协议进行通信，但是负载均衡器与后端服务之间将不再使用 TSL 协议进行通过，所有针对客户端的 TSL 相关的处理都在负载均衡器这一层完成：协议卸载、证书验证、使用 &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Server_Name_Indication"&gt;SNI&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="observability"&gt;
&lt;h3 id="hidobservability"&gt;可观测性（Observability)&lt;a class="headerlink" href="#hidobservability" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;所谓的可观测性指的是负载均衡器拥有各种各样的可以用来观测运行状态或连接状态的功能，比如提供获取各种状态信息的 api 、主动上报 trace 信息、或记录一些有助于发现问题或解决问题的日志等等。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ddos"&gt;
&lt;h3 id="hidddos"&gt;安全以及 DDoS 缓解&lt;a class="headerlink" href="#hidddos" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;负载均衡器通常会实现一些安全相关的特性，比如：限速、限制并发、限制最大连接、IP/网段 block、认证、DDos 缓解等等。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3 id="hidid8"&gt;动态配置以及控制面板&lt;a class="headerlink" href="#hidid8" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;因为要实现很多的功能所以配置项也会比较多，所以一般都会有配置文件、修改运行时配置的 API、以及可以查看运行时状态和修改运行时配置的 web 面板。&lt;/p&gt;
&lt;p&gt;修改运行时配置的要点是程序要能支持配置文件热更新或通过 api 动态修改程序运行过程中在使用的配置项。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="gracefully-upgrade"&gt;
&lt;h3 id="hidgracefully-upgrade"&gt;热升级/平滑升级（Gracefully Upgrade）&lt;a class="headerlink" href="#hidgracefully-upgrade" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;所谓的热升级指的是可以当需要升级正在运行的负载均衡器服务的时候，可以安全的对正在处理连接的负载均衡器进行升级操作。升级期间不会中断正在处理的连接也不会拒绝新进来的连接，实现热升级/无缝升级/平滑升级。&lt;/p&gt;
&lt;p&gt;如果无法实现热升级的话，也可以实现平滑重启(Gracefully Restart)。&lt;/p&gt;
&lt;p&gt;所谓的平滑重启指的是重启服务的时候不会中断正在处理的连接，等连接处理完或达到指定的超时时间后再进行重启，从而实现平滑重启。平滑重启的场景是要求不要有新的连接进来，否则新的连接会被拒绝，一般通过把准备重启的服务从 DNS 记录上删除的方式或通过 iptables 直接拒绝连接的方式或者再前面的接入层屏蔽这个节点的 方式来实现避免新连接进来。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h3 id="hidid9"&gt;七层负载均衡器的更多功能&lt;a class="headerlink" href="#hidid9" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="id10"&gt;
&lt;h4 id="hidid10"&gt;多协议支持&lt;a class="headerlink" href="#hidid10" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在很多场景下可能会需要多协议支持。比如支持多种应用层协议，并根据协议相关的请求内容做路由。&lt;/p&gt;
&lt;p&gt;一些负载均衡器会支持 HTTP/1, HTTP2, gRPC, Redis, MongoDB，MySQL, PostgreSQL 或 Kafka 等常见的协议。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h4 id="hidid11"&gt;高级负载均衡&lt;a class="headerlink" href="#hidid11" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;因为会解析协议相关的请求内容所以七层负载均衡器可以做更多更高级的功能，比如：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;超时：请求或响应的超时机制&lt;/li&gt;
&lt;li&gt;重试：请求失败时的重试&lt;/li&gt;
&lt;li&gt;限速：基于请求的限速&lt;/li&gt;
&lt;li&gt;限制并发：基于请求的并发限制/正在处理的请求限制&lt;/li&gt;
&lt;li&gt;熔断：在持续异常时的特定场景下直接熔断保护后端服务&lt;/li&gt;
&lt;li&gt;route：基于请求内容的 route 功能&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h4 id="hidid12"&gt;可扩展性（插件系统）&lt;a class="headerlink" href="#hidid12" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;很多负载均衡器都支持通过脚本的方式来扩展负载均衡器已有的功能（比如支持运行 Lua 脚本的插件系统）。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id13"&gt;
&lt;h2 id="hidid13"&gt;总结&lt;a class="headerlink" href="#hidid13" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文简单总结了负载均衡器相关的部分知识，后面有空时候再继续更新补充 :joy&lt;/p&gt;
&lt;p&gt;感兴趣的话强烈建议阅读 &lt;a class="reference external" href="https://blog.envoyproxy.io/introduction-to-modern-network-load-balancing-and-proxying-a57f6ff80236"&gt;Introduction to modern network load balancing and proxying&lt;/a&gt; 这篇文章。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id14"&gt;
&lt;h2 id="hidid14"&gt;参考资料&lt;a class="headerlink" href="#hidid14" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://blog.envoyproxy.io/introduction-to-modern-network-load-balancing-and-proxying-a57f6ff80236"&gt;Introduction to modern network load balancing and proxying&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://brooker.co.za/blog/2012/01/17/two-random.html"&gt;The power of two random choices - Marc's Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Load_balancing_(computing)#Server-side_load_balancers"&gt;Load balancing (computing) - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://security.stackexchange.com/questions/30403/should-ssl-be-terminated-at-a-load-balancer"&gt;tls - Should SSL be terminated at a load balancer? - Information Security Stack Exchange&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mozillazg.com/2019/01/notes-about-design-health-checking.html"&gt;健康检查功能相关的一些备忘 - Huang Huang 的博客&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="load-balancer"></category></entry><entry><title>健康检查功能相关的一些备忘</title><link href="https://mozillazg.com/2019/01/notes-about-design-health-checking.html" rel="alternate"></link><updated>2019-01-13T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2019-01-13:2019/01/notes-about-design-health-checking.html</id><summary type="html">&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;前言&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文记录一些健康检查功能相关的笔记/经验。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;检查方法&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;常见的健康检查一般分为主机层面的检查以及应用/服务层面的检查。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;主机层面的检查&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;主机层面的检查一般用下面的方法进行检查：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;用是否能够 ping 通来检查&lt;/li&gt;
&lt;li&gt;尝试用 tcp 连接一下目标 ip:port ，看看是否可以连通来检查&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 tcp 连通性检查这里有时会用一个非常规的方法去做 tcp 健康检查 &lt;a class="footnote-reference" href="#id16" id="id5"&gt;[1]&lt;/a&gt; ：&lt;/p&gt;
&lt;p&gt;一般建立 tcp 连接都会经过 tcp 三次握手的过程:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Client -&amp;gt; Server: SYN&lt;/li&gt;
&lt;li&gt;Server -&amp;gt; Client: SYN-ACK&lt;/li&gt;
&lt;li&gt;Client -&amp;gt; Server: ACK&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是其实最后一次的 ACK 可以不用发，因为对于健康检查来说，收到服务端发送回来的 SYN-ACK 的时候，
我们就可以简单的认为客户端跟服务端是可联通的。所以 tcp 健康检查可以考虑省去最后一个 ACK:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Client -&amp;gt; Server: SYN&lt;/li&gt;
&lt;li&gt;Server -&amp;gt; Client: SYN-ACK&lt;/li&gt;
&lt;li&gt;Client -&amp;gt; Server: RST&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样做的好处是，因为没有完成三次握手而是直接 RST 掉了，所以就不会有后续关闭连接时的四次挥手了，
可以减少好几个包（客户端和服务端都省了一些包）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2 id="hidid6"&gt;应用/服务层面的检查&lt;a class="headerlink" href="#hidid6" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;应用/服务层面的检查，一般指的是按照应用/服务认可的普通客户端的方式去做健康检查，
比如发送合法的符合约定格式的 tcp/udp 包、http 请求、rpc 请求等。&lt;/p&gt;
&lt;p&gt;一般这种检查都是服务端定义一个专门用来响应健康检查请求的 api ，针对客户端发送的健康检查请求发回约定的响应格式数据。&lt;/p&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3 id="hidid7"&gt;反应服务真正的健康情况&lt;a class="headerlink" href="#hidid7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;服务层面的健康检查一个很重要的一点是要反应服务真正的健康状况，所以服务端在实现健康检查接口时要考虑自身情况，
检查各种强依赖项，然后反馈给客户端当前服务端是否足够健康可以接受新的请求：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;检查强依赖的外部服务的连通性、响应时间等信息(db/redis/queue/...)&lt;/li&gt;
&lt;li&gt;检查机器负载情况，当前机器负载是否在健康范围内&lt;/li&gt;
&lt;li&gt;检查 CPU 利用率、内存使用率&lt;/li&gt;
&lt;li&gt;检查程序后台任务的排队情况&lt;/li&gt;
&lt;li&gt;检查磁盘剩余空间、IO 情况&lt;/li&gt;
&lt;li&gt;检查机器带宽是否快跑满了&lt;/li&gt;
&lt;li&gt;。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要根据服务本身的实际情况选择合适的检查项（不是每个都需要检查,不同的服务的强依赖项不一样），以及有些检查项可能不适合在请求内完成（比如会导致响应时间太长客户端超时了），这种可能需要安装外部程序来协助检查，比如带宽/IO 信息可以从外部获取。&lt;/p&gt;
&lt;p&gt;总之就是要真正反应服务真正的健康状况，一般不会啥都不做就回一个标志正常的响应。
如果这样的话跟普通的端口探活似乎没有太大的区别。&lt;/p&gt;
&lt;p&gt;当然，如果场景就是只需要检查协议以及端口探活的话，直接响应一个表示成功的响应也没啥问题。:joy&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3 id="hidid8"&gt;响应或请求包含服务标识信息&lt;a class="headerlink" href="#hidid8" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;还有一个必须要提及的是，健康检查的请求或响应信息中最好标识相关的服务信息：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;客户端在请求中包含要检查的服务的标识信息，比如服务名/appid 之类的，当服务端收到请求的时候发现不是请求本服务的，可以直接返回相应的错误信息。&lt;/li&gt;
&lt;li&gt;客户端检查服务端返回的错误信息或响应中包含的服务标识信息时，就可以知道请求发错对象了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么请求或响应中包含服务标识信息很重要呢，因为现在很多服务都在容器中运行，服务经常性的扩容/缩容/容器漂移 导致相同的 ip:port 可能会在不同时刻对应的是不同的服务，如果因为一些原因导致客户端没有感知到这个变化，然后健康检查请求了旧的 ip:port ，此时健康检查虽然通过了，但是实际上请求过去还是会失败了，因为远端已经不是原来客户端以为的那个服务了。
通过在请求和响应中包含服务标识信息就可以在客户端和服务端防御这种 case。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h2 id="hidid9"&gt;健康与不健康之外的第三种状态&lt;a class="headerlink" href="#hidid9" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一般健康检查的结果都是只有两种状态：健康或不健康。这里介绍的是根据需要可以考虑引入第三种状态：overload 。
这个状态的目的是应对一种 case: 服务可以正常处理健康检查，但是本身的负载已经非常高了，再接入多一点请求可能就要宕机了，然后节点宕机对整体服务的影响比较大（比如一些有状态服务宕机导致的客户端重连会对剩下的健康节点造成比较大的影响）。一般这种情况都会触发系统负载相关告警（比如 CPU 或内存使用率告警），然后人工手动介入把节点从负载均衡器或者哪里给摘除防止持续处理请求导致宕机。&lt;/p&gt;
&lt;p&gt;对于这种 case 可以考虑引入上面所说的第三种状态 overload。对于处于 overload 状态的节点不再接受新的请求，等到节点恢复为健康状态后再接受新的请求。至于为啥不直接把 overload 的解决标记为不健康呢，因为不健康状态一般都是节点宕机了不能自动恢复的情况，以及部分系统对于不健康的节点会自动触发实例重启的操作，这个自动重启的操作可能不是我们预期的也可能会触发更大的问题（比如引发客户端大量重连），所以不健康状态跟 overload 还是有一点区别，可以根据实际情况选择是引入 overload 状态还是直接用不健康状态代替。&lt;/p&gt;
&lt;p&gt;这第三种状态也不一样要是跟负载有关，只要是一种介于健康和不健康两者之间的状态都可以考虑引入第三种状态（比如同时支持读写操作的节点在这第三种状态的时候只支持 读 操作，不接受 写 操作）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h2 id="hidid10"&gt;必要的配置项&lt;a class="headerlink" href="#hidid10" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一般健康检查都会有一些必要的配置项用来控制健康检查功能：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;最基本的肯定是要有待检查的目标服务信息，ip:port 之类的用于发送健康检查请求&lt;/li&gt;
&lt;li&gt;健康检查所使用的协议（如果支持多协议的话）以及发送的数据（比如 http 协议的话检查所访问的 url path, http method, 认证信息等，tcp 的话可能是发送特定的数据表示请求做健康检查等）&lt;/li&gt;
&lt;li&gt;判断服务健康的依据：&lt;ul&gt;
&lt;li&gt;基本的连通性&lt;/li&gt;
&lt;li&gt;响应的内容，比如表示服务健康的 http 响应状态码是哪些，响应的 body 内容需要包含什么内容等&lt;/li&gt;
&lt;li&gt;检查不通过几次算服务不健康（有一个特例那就是：对于 Connection refused 错误一般建议直接标记为不健康而不是等几次失败再标记为不健康，），从不健康到健康需要通过几次检查才算恢复健康 &lt;a class="footnote-reference" href="#id17" id="id11"&gt;[2]&lt;/a&gt; &lt;a class="footnote-reference" href="#id18" id="id12"&gt;[3]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;以及健康检查的间隔，健康检查太频繁可能会影响被检查的服务，间隔太长可能会失去健康检查的意义无法及时探查到不健康的状态&lt;/li&gt;
&lt;li&gt;超时，访问外部服务一定不能忘了超时相关的设置，健康检查也不例外&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id13"&gt;
&lt;h2 id="hidid13"&gt;手动禁用/下线服务的能力&lt;a class="headerlink" href="#hidid13" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;所谓的手动禁用/下线服务的能力，指的是可以在检查端或被检查端把一个服务标记为不健康/下线的能力。
这个功能主要用于临时禁用一个服务，比如想对这个服务进行一些调试操作，但是又不希望这期间有请求进来进行干扰。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id14"&gt;
&lt;h2 id="hidid14"&gt;总结&lt;a class="headerlink" href="#hidid14" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文简单记录了一些健康检查功能相关的笔记/经验，如果以后还有新的知识会随时更新的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id15"&gt;
&lt;h2 id="hidid15"&gt;参考资料&lt;a class="headerlink" href="#hidid15" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://medium.com/&amp;#64;copyconstruct/health-checks-in-distributed-systems-aa8a0e8c1672"&gt;Health Checks and Graceful Degradation in Distributed Systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/health-endpoint-monitoring"&gt;Health Endpoint Monitoring pattern - Cloud Design Patterns | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.nginx.com/nginx/admin-guide/load-balancer/tcp-health-check/#fine-tuning-tcp-health-checks"&gt;NGINX Docs | TCP Health Checks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.haproxy.com/documentation/aloha/10-0/traffic-management/lb-layer7/health-checks/#defining-health-check-parameters"&gt;Performing Health Checks | ALOHA 10.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/tevino/tcp-shaker"&gt;tevino/tcp-shaker: Performing TCP handshake without ACK in Go, useful for health checking, that is SYN, SYN-ACK, RST.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://developer20.com/learning-on-mistakes/"&gt;Learning on mistakes | Developer 2.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-health.html"&gt;Cluster Health | Elasticsearch Reference [6.7] | Elastic&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="docutils footnote" frame="void" id="id16" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id5"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="https://github.com/tevino/tcp-shaker"&gt;tevino/tcp-shaker: Performing TCP handshake without ACK in Go, useful for health checking, that is SYN, SYN-ACK, RST.&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id17" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id11"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="https://docs.nginx.com/nginx/admin-guide/load-balancer/tcp-health-check/#fine-tuning-tcp-health-checks"&gt;NGINX Docs | TCP Health Checks&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id18" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id12"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="https://www.haproxy.com/documentation/aloha/10-0/traffic-management/lb-layer7/health-checks/#defining-health-check-parameters"&gt;Performing Health Checks | ALOHA 10.0&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</summary><category term="health-check"></category><category term="load-balancer"></category></entry><entry><title>rate limiting 之 token bucket</title><link href="https://mozillazg.com/2019/01/rate-limiting-intro-token-bucket.html" rel="alternate"></link><updated>2019-01-03T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2019-01-03:2019/01/rate-limiting-intro-token-bucket.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;前言&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在实现限速功能的时候，其中一种常用的方法是使用 token bucket 算法来实现。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="token-bucket"&gt;
&lt;h2 id="hidtoken-bucket"&gt;token bucket&lt;a class="headerlink" href="#hidtoken-bucket" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img alt="token bucket" src="/static/images/other/token_bucket.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;(图片来自 &lt;a class="reference external" href="https://gateoverflow.in/39720/gate2016-1-54"&gt;https://gateoverflow.in/39720/gate2016-1-54&lt;/a&gt; ）&lt;/p&gt;
&lt;p&gt;token bucket 常见的中文解释是：令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务 &lt;a class="footnote-reference" href="#id8" id="id2"&gt;[1]&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;维基百科 &lt;a class="footnote-reference" href="#id9" id="id3"&gt;[2]&lt;/a&gt; 上 token bucket 算法的简单描述如下：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;A token is added to the bucket every 1/r seconds.
每隔 1/r 秒向 bucket 中增加一个 token。&lt;/li&gt;
&lt;li&gt;The bucket can hold at the most b tokens. If a token arrives when the bucket is full, it is discarded.
这个 bucket 最多只能存放 b 个 token。如果放置 token 时 bucket 已经满了，丢弃这个 token。&lt;/li&gt;
&lt;li&gt;When a packet (network layer PDU) of n bytes arrives,
当一个包含 n 个字节的数据包进来的时候，&lt;ul&gt;
&lt;li&gt;if at least n tokens are in the bucket, n tokens are removed from the bucket, and the packet is sent to the network.
如果 bucket 中有 &amp;gt;= n 个 token，将从 bucket 中移除 n 个 token，然后把这个数据包发送出去。&lt;/li&gt;
&lt;li&gt;if fewer than n tokens are available, no tokens are removed from the bucket, and the packet is considered to be non-conformant.
如果可用的 token &amp;lt; n，此时不会从 bucket 中移除任何的 token，但是这个数据包会被认为是被限制的数据包。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;常见实现方法&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;一般有两种实现方法。&lt;/p&gt;
&lt;p&gt;一种是按照 token bucket 的说明，真的做放 token 的操作：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;后台有个线程每 1/n 秒将 bucket 中的 token 数量加一，直至达到 bucket 容量。&lt;/li&gt;
&lt;li&gt;主线程检查限速时，比较 bucket 中 token 的数量，如果少于需要的数量，表示当前被限制。
（比如，一个请求进来，检查 bucket 中的 token 数量是否 &amp;gt; 1，如果 &amp;gt; 1请求放行同时把 token 数量减 1，
如果 &amp;lt; 1 说明当前请求已超出速率限制，请求被拒绝。）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种方法有一个很大的缺点，那就是因为每个 token bucket 都会有一个繁忙的后台线程在更新 token 数量，会
导致严重占用系统 CPU 出现严重的性能问题。假设我们的限速是限制为 1000/s，此时后台每隔 1ms 就会更新一次 token 数量，可以想像每个后台线程都会频繁占用 CPU，用这种方法实现的 rate limiting 处理不了几个请求就会出现 CPU 接近 100% 的情况。所以实践中一般用另一种方法来实现 token bucket。&lt;/p&gt;
&lt;p&gt;另一种是在取 token 时计算上次取跟这次取之间按照速率会产生多少个 token 加上上次剩余的 token （不能超过 bucket 容量限制），然后比较剩余 token 数是否满足需要。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2 id="hidid5"&gt;特点&lt;a class="headerlink" href="#hidid5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通过 token bucket 的介绍以及对具体实现的了解，可以发现 token bucket 有以下特点：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;当 bucket 满的时候，将不再放入 token，即 token 数不能超过 bucket 容量限制。&lt;/li&gt;
&lt;li&gt;因为可以一次性从 bucket 拿出大量的 token 所以 token bucket 允许突发的峰值，
即，限速不是绝对的，而是允许存在尖峰/波峰。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2 id="hidid6"&gt;总结&lt;a class="headerlink" href="#hidid6" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文简单介绍了一下 token bucket 算法以及两种常见的实现方法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2 id="hidid7"&gt;参考资料&lt;a class="headerlink" href="#hidid7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Token_bucket"&gt;Token bucket - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/juju/ratelimit"&gt;juju/ratelimit: Efficient token-bucket-based rate limiter package.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/falconry/token-bucket"&gt;falconry/token-bucket&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gateoverflow.in/39720/gate2016-1-54"&gt;GATE2016-1-54 - GATE Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://colobu.com/2014/11/13/rate-limiting/"&gt;流量调整和限流技术 | 鸟窝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://stripe.com/blog/rate-limiters"&gt;Scaling your API with rate limiters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gist.github.com/ptarjan/e38f45f2dfe601419ca3af937fff574d"&gt;0-rate-limiters.md&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="https://colobu.com/2014/11/13/rate-limiting/"&gt;流量调整和限流技术 | 鸟窝&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id9" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Token_bucket"&gt;Token bucket - Wikipedia&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
</summary><category term="rate-limiting"></category><category term="token-bucket"></category></entry><entry><title>调用远程服务的一些备忘录</title><link href="https://mozillazg.com/2018/08/call-remote-service-checklist.html" rel="alternate"></link><updated>2018-08-16T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2018-08-16:2018/08/call-remote-service-checklist.html</id><summary type="html">&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;前言&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;大部分程序或多或少都会调用其他远程服务，比如访问 HTTP API、操作数据等各种远程操作。
因为是调用其他服务所以会有很多不可控的因素，在编写相关代码的时候需要有一些注意事项或者说是备忘录。&lt;/p&gt;
&lt;p&gt;本文就列一些常见的备忘录（主要针对调用网络服务）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;超时&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;为了防止对方服务响应时间太长或者因为网络等各种因素导致响应时间变长，导致拖慢我们自己的程序，
在调用远程服务的时候记得配置或实现合适的超时机制。&lt;/p&gt;
&lt;p&gt;如果设置的超时时间不合理或者没有实现超时功能的话，
就会出现对方服务故障或与对方服务通信故障拖垮我们自己服务的尴尬情况。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;重试&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;当调用远程服务失败的时候，就涉及到是否需要重试的问题。是否需要重试设计到各种情况：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;连接未到达对方服务，可以安全重试&lt;/li&gt;
&lt;li&gt;连接到达对方服务，对方服务故障，无法处理请求，可以安全重试&lt;/li&gt;
&lt;li&gt;连接到达对方服务，对方处理了请求，看情况重试:&lt;ul&gt;
&lt;li&gt;虽然处理了请求，但是响应信息提示请求的参数有问题，无需重试，因为是我们自己代码的问题，重试也是一样的结果&lt;/li&gt;
&lt;li&gt;对方处理请求时间过长导致超时，根据实际情况，酌情重试&lt;/li&gt;
&lt;li&gt;操作是幂等的，可以安全重试&lt;/li&gt;
&lt;li&gt;其他场景，主要是要考虑重试是否会产生非预期的副作用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重试的时候所使用的重试策略也需要精心考虑，不能无脑重试、无限重试：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;限制重试次数，增加重试间隔&lt;/li&gt;
&lt;li&gt;重试间隔一般不要是固定间隔，间隔时间可以是指数递增，也可以加上在一定区间内波动的随机数，
防止出现雪崩效应，打垮对方服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于重试及重试策略可以参考：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/transient-faults"&gt;Retry general guidance | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="circuit-breaker"&gt;
&lt;h2 id="hidcircuit-breaker"&gt;熔断/断路器（Circuit Breaker）&lt;a class="headerlink" href="#hidcircuit-breaker" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;为了处理调用远程服务短时间内失败率很高或者总是失败的场景，程序可以考虑实现自动熔断/断路器的功能。
即：如果发现失败率比较高的时候，自动在后续一段时间内逐步减少对对方服务的调用
（限制请求，对部分操作直接报错不访问远程服务），
当发现成功率上去后逐步放开限制直至恢复正常访问。&lt;/p&gt;
&lt;p&gt;关于熔断/断路器可以参考：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker"&gt;Circuit Breaker | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.ibm.com/cloud/garage/content/manage/practice_circuit_breaker_pattern/"&gt;Preventing system failure with the Circuit Breaker pattern - IBM Cloud Garage Method&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2 id="hidid5"&gt;降级&lt;a class="headerlink" href="#hidid5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;上面的熔断是调用方程序实现在失败率很高时减少请求数，降级的话就是可以外部介入程序的功能。
比如当通过监控发现调用远程服务故障率特别高，或者收到通知对方服务在某个时间不可用，
可以直接降级到这个功能，彻底不发送任何请求。&lt;/p&gt;
&lt;p&gt;比如，我们有个服务同时支持微信支付收款和支付宝支付收款，当发现微信支付大面积故障的时候，
可以人工/第三方程序自动降级掉程序里的微信支付功能，此时用户付款的时候就只会看到一个支付宝支付的功能，
微信支付的功能会被临时下掉。&lt;/p&gt;
&lt;p&gt;关于降级的另一种应用是: fallback，即：调用主服务失败时，改为调用备用服务。
比如上传图片，平时都把图片上传到阿里云 oss，这次调用是发现 oss 故障，然后程序就尝试改为
调用腾讯云 cos，把图片上传到 cos。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2 id="hidid6"&gt;日志&lt;a class="headerlink" href="#hidid6" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;当程序正常运行或出现故障时我们可能都需要借助日志来提供有用的信息。&lt;/p&gt;
&lt;p&gt;比如当调用远程服务故障时，可能需要记录一些有用的信息:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;调用的服务信息，比如请求的 url、ip、端口之类的&lt;/li&gt;
&lt;li&gt;请求参数，可以用于复现或 debug 的相关请求参数&lt;/li&gt;
&lt;li&gt;失败原因，比如异常信息，根据需要区分不同的异常&lt;/li&gt;
&lt;li&gt;如果有响应返回的话，响应中包含的有用信息，比如 http 响应码、http response 中的有用信息等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当时在记日志的时候也需要注意一些问题：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;日志数量问题，有些场景下日志量太大会影响程序性能，不要随意记无用的日志&lt;/li&gt;
&lt;li&gt;不要记录敏感数据，记得对日志内容脱密，比如：不要记密码、token 等敏感信息&lt;/li&gt;
&lt;li&gt;单条日志大小问题，需要考虑控制单条日志大小，比如上面说的 http response 之类的无法预料到大小的信息
需要考虑对大的信息进行截断处理或者干脆不记录（比如调用上传文件接口之类的不记录文件内容）&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2 id="hidid7"&gt;异常处理&lt;a class="headerlink" href="#hidid7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;调用失败时往往伴随着各种异常，比如上面的超时的功能，一般超时的时候都会以异常的方式体现。&lt;/p&gt;
&lt;p&gt;对于调用时出现的各种异常要根据实际情况进行区别，对不同的异常采取不同的措施：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;判断异常是系统异常还是用户异常，针对不同的异常可能需要不同的处理方法&lt;/li&gt;
&lt;li&gt;判断异常是否是表示特定功能的某种状态的异常，比如上面的超时/重试/熔断 之类的功能
都会有特定的异常用来对应某种状态&lt;/li&gt;
&lt;li&gt;判断异常是否是可重试解决的异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;慎重考虑忽略异常的情况，不要一股脑的忽略所有异常同时还不记日志
（将来进行 debug 的人会喷死你，这个人还有可能会是你自己）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h2 id="hidid8"&gt;监控&lt;a class="headerlink" href="#hidid8" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通过监控我们可以掌握程序的各种运行指标/状况，这样就可以及时/提前发现问题。&lt;/p&gt;
&lt;p&gt;常见的针对远程调用的监控指标如下：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;响应时间&lt;/li&gt;
&lt;li&gt;调用失败计数&lt;/li&gt;
&lt;li&gt;特定错误计数&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h2 id="hidid9"&gt;告警&lt;a class="headerlink" href="#hidid9" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;虽然有了监控数据，但是我们不可能 24 小时不眠不休的盯着监控数据，此时就需要有告警程序来帮助我们
自动发现可能的异常和已经出现的问题。&lt;/p&gt;
&lt;p&gt;这样即可以及时发现问题也可以解放生产力， 在没有异常的时候去做更有创造力的事情。&lt;/p&gt;
&lt;p&gt;根据告警数据的不同有一些常见的针对远程调用的告警：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;响应时间阈值告警&lt;/li&gt;
&lt;li&gt;一段时间内特定错误/失败数告警&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h2 id="hidid10"&gt;连接池&lt;a class="headerlink" href="#hidid10" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;补充一个忘了说的一项，那就是连接池。少量的远程调用可能不需要关心连接池的事情，如果
是大量调用某个服务的话，就需要使用连接池技术了，如果不用连接池的话，
一方面新建连接需要时间另一方面服务端维护大量连接也需要消耗资源。&lt;/p&gt;
&lt;p&gt;使用连接池既可以通过复用已有的连接来加快调用时间，也可以节省服务端的资源防止资源浪费。&lt;/p&gt;
&lt;p&gt;一般常见的应用层协议的通用客户端库都实现了连接池，所以很少需要去操心实现连接池的问题，
但是如果你用的客户端库没有实现连接池功能的话，
就需要考虑实现连接池功能或者使用其他支持连接池的客户端库。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h2 id="hidid11"&gt;总结&lt;a class="headerlink" href="#hidid11" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文罗列了一些编写调用远程服务相关代码时需要注意的一下注意事项。&lt;/p&gt;
&lt;p&gt;其中有几个功能在进行远程调用时建议最好都实现，就算是写一个临时 debug 或
临时运维用的小脚本也要考虑实现这几个功能：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;超时：必需要实现/配置合适的超时时间&lt;/li&gt;
&lt;li&gt;重试：酌情重试，不是说一定要重新发送请求，而是说要对某些可以重试的异常进行重试处理&lt;/li&gt;
&lt;li&gt;异常处理：酌情处理，如果程序中会多次进行远程调用的话，就必须要考虑异常处理，
至少要防止因为异常导致的非预期的程序提前退出&lt;/li&gt;
&lt;li&gt;日志：最好是有，就算是用 &lt;tt class="docutils literal"&gt;print&lt;/tt&gt; 代替也好过没有记录任何信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;至于是否实现 熔断/降级/监控/告警 需要看实际情况：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;临时的/一次性的运维脚本之类的可能就没必要实现了&lt;/li&gt;
&lt;li&gt;基础设施不完善或者没有对应的基础设施的话，实现这些功能可能就不适合了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;欢迎大家在评论里一起讨论/补充其他的注意事项。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h2 id="hidid12"&gt;参考资料&lt;a class="headerlink" href="#hidid12" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.microsoft.com/en-us/azure/architecture/best-practices/transient-faults"&gt;Retry general guidance | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker"&gt;Circuit Breaker | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.ibm.com/cloud/garage/content/manage/practice_circuit_breaker_pattern/"&gt;Preventing system failure with the Circuit Breaker pattern - IBM Cloud Garage Method&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://pragprog.com/book/mnee2/release-it-second-edition"&gt;Release It! Second Edition: Design and Deploy Production-Ready Software by Michael Nygard | The Pragmatic Bookshelf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="checklist"></category><category term="client"></category></entry><entry><title>jq 常用操作</title><link href="https://mozillazg.com/2018/01/jq-use-examples-cookbook.html" rel="alternate"></link><updated>2018-01-28T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2018-01-28:2018/01/jq-use-examples-cookbook.html</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="https://stedolan.github.io/jq/"&gt;jq&lt;/a&gt; 是个非常强大的处理 JSON 数据的命令行工具。这里记录一下最近使用 jq 所使用的一些操作，方便以后使用的时候直接参考。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;基本操作&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;jq 的命令行使用方法如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ jq -h
jq - commandline JSON processor &lt;span class="o"&gt;[&lt;/span&gt;version 1.5&lt;span class="o"&gt;]&lt;/span&gt;
Usage: jq &lt;span class="o"&gt;[&lt;/span&gt;options&lt;span class="o"&gt;]&lt;/span&gt; &amp;lt;jq filter&amp;gt; &lt;span class="o"&gt;[&lt;/span&gt;file...&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本文主要讲的是常用的 &amp;lt;jq filter&amp;gt;。&lt;/p&gt;
&lt;div class="section" id="json"&gt;
&lt;h3 id="hidjson"&gt;输出原始的 JSON 数据&lt;a class="headerlink" href="#hidjson" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;默认不指定 filter 就会原样输出，也可以使用 &lt;tt class="docutils literal"&gt;.&lt;/tt&gt; 过滤器&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;.&lt;/tt&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{&amp;quot;url&amp;quot;: &amp;quot;mozillazg.com&amp;quot;}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq .
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;&amp;quot;url&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;mozillazg.com&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play 在线运行链接：&lt;a class="reference external" href="https://jqplay.org/s/KhRuUFCP2h"&gt;https://jqplay.org/s/KhRuUFCP2h&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="object"&gt;
&lt;h3 id="hidobject"&gt;object 操作&lt;a class="headerlink" href="#hidobject" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="key"&gt;
&lt;h4 id="hidkey"&gt;获取某个 key 的值&lt;a class="headerlink" href="#hidkey" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;.key&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;.foo.bar&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;.[&amp;quot;key&amp;quot;]&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{&amp;quot;url&amp;quot;: &amp;quot;mozillazg.com&amp;quot;}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq .url
&lt;span class="s2"&gt;&amp;quot;mozillazg.com&amp;quot;&lt;/span&gt;
$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{&amp;quot;url&amp;quot;: &amp;quot;mozillazg.com&amp;quot;}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; jq &lt;span class="s1"&gt;&amp;#39;.[&amp;quot;url&amp;quot;]&amp;#39;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;mozillazg.com&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/Tn7NUbP4Dr"&gt;https://jqplay.org/s/Tn7NUbP4Dr&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以在后面加个问号表示当输入不是 object 时不会报错 &lt;tt class="docutils literal"&gt;.key?&lt;/tt&gt; :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq &lt;span class="s1"&gt;&amp;#39;.a&amp;#39;&lt;/span&gt;
jq: error &lt;span class="o"&gt;(&lt;/span&gt;at &amp;lt;stdin&amp;gt;:1&lt;span class="o"&gt;)&lt;/span&gt;: Cannot index number with string &lt;span class="s2"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;
$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;1&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq &lt;span class="s1"&gt;&amp;#39;.a?&amp;#39;&lt;/span&gt;
$
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;?&lt;/tt&gt; 规则适合所有正确的 filter，在 filter 最后加上 &lt;tt class="docutils literal"&gt;?&lt;/tt&gt; 可以忽略错误信息&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h4 id="hidid2"&gt;所有的 key 组成的数组&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;keys&lt;/tt&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{&amp;quot;url&amp;quot;: &amp;quot;mozillazg.com&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;mozillazg&amp;quot;}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq keys
&lt;span class="o"&gt;[&lt;/span&gt;
  &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;,
  &lt;span class="s2"&gt;&amp;quot;url&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/_5KiPRS75r"&gt;https://jqplay.org/s/_5KiPRS75r&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="value"&gt;
&lt;h4 id="hidvalue"&gt;所有的 value&lt;a class="headerlink" href="#hidvalue" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;.[]&lt;/tt&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{&amp;quot;url&amp;quot;: &amp;quot;mozillazg.com&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;mozillazg&amp;quot;}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq .&lt;span class="o"&gt;[]&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;mozillazg.com&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;mozillazg&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/6HRvEND8AB"&gt;https://jqplay.org/s/6HRvEND8AB&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4 id="hidid3"&gt;所有的 value 组成的数组&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;[.[]]&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{&amp;quot;url&amp;quot;: &amp;quot;mozillazg.com&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;mozillazg&amp;quot;}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq &lt;span class="o"&gt;[&lt;/span&gt;.&lt;span class="o"&gt;[]]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;
  &lt;span class="s2"&gt;&amp;quot;mozillazg.com&amp;quot;&lt;/span&gt;,
  &lt;span class="s2"&gt;&amp;quot;mozillazg&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/JGIX6hTt_8"&gt;https://jqplay.org/s/JGIX6hTt_8&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3 id="hidid4"&gt;数组操作&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;div class="section" id="id5"&gt;
&lt;h4 id="hidid5"&gt;取出所有元素&lt;a class="headerlink" href="#hidid5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;.[]&lt;/tt&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;[{&amp;quot;name&amp;quot;: &amp;quot;tom&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;mozillazg&amp;quot;}]&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq .&lt;span class="o"&gt;[]&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;tom&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;mozillazg&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/Y9UgK_4xxE"&gt;https://jqplay.org/s/Y9UgK_4xxE&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="slice"&gt;
&lt;h4 id="hidslice"&gt;切分(slice)&lt;a class="headerlink" href="#hidslice" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;.[1]&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;.[0:2]&lt;/tt&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;[{&amp;quot;name&amp;quot;: &amp;quot;tom&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;mozillazg&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;jim&amp;quot;}]&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq .&lt;span class="o"&gt;[&lt;/span&gt;1&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;mozillazg&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;[{&amp;quot;name&amp;quot;: &amp;quot;tom&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;mozillazg&amp;quot;}, {&amp;quot;name&amp;quot;: &amp;quot;jim&amp;quot;}]&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq .&lt;span class="o"&gt;[&lt;/span&gt;0:2&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;tom&amp;quot;&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;,
  &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;mozillazg&amp;quot;&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/seNL7hW38W"&gt;https://jqplay.org/s/seNL7hW38W&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h4 id="hidid6"&gt;操作 object 组成的数组&lt;a class="headerlink" href="#hidid6" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;比如取出数组元素中 name 的值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;[{&amp;quot;name&amp;quot;: &amp;quot;foo&amp;quot;},{&amp;quot;name&amp;quot;: &amp;quot;bar&amp;quot;},{&amp;quot;name&amp;quot;: &amp;quot;foobar&amp;quot;}]&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq .&lt;span class="o"&gt;[]&lt;/span&gt;.name
&lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;foobar&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/Z5qjhJnRyn"&gt;https://jqplay.org/s/Z5qjhJnRyn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也可以用下面会提到的管道操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;[{&amp;quot;name&amp;quot;: &amp;quot;foo&amp;quot;},{&amp;quot;name&amp;quot;: &amp;quot;bar&amp;quot;},{&amp;quot;name&amp;quot;: &amp;quot;foobar&amp;quot;}]&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq &lt;span class="s1"&gt;&amp;#39;.[]|.name&amp;#39;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;foobar&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果要将结果重新组成数组，可以这样:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;[{&amp;quot;name&amp;quot;: &amp;quot;foo&amp;quot;},{&amp;quot;name&amp;quot;: &amp;quot;bar&amp;quot;},{&amp;quot;name&amp;quot;: &amp;quot;foobar&amp;quot;}]&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq &lt;span class="o"&gt;[&lt;/span&gt;.&lt;span class="o"&gt;[]&lt;/span&gt;.name&lt;span class="o"&gt;]&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;
  &lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;,
  &lt;span class="s2"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;,
  &lt;span class="s2"&gt;&amp;quot;foobar&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以使用下面会提到的 &lt;tt class="docutils literal"&gt;map&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;[{&amp;quot;name&amp;quot;: &amp;quot;foo&amp;quot;},{&amp;quot;name&amp;quot;: &amp;quot;bar&amp;quot;},{&amp;quot;name&amp;quot;: &amp;quot;foobar&amp;quot;}]&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq &lt;span class="s1"&gt;&amp;#39;map(.name)&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;
  &lt;span class="s2"&gt;&amp;quot;foo&amp;quot;&lt;/span&gt;,
  &lt;span class="s2"&gt;&amp;quot;bar&amp;quot;&lt;/span&gt;,
  &lt;span class="s2"&gt;&amp;quot;foobar&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="filter"&gt;
&lt;h3 id="hidfilter"&gt;使用多个 filter&lt;a class="headerlink" href="#hidfilter" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;,&lt;/tt&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{&amp;quot;url&amp;quot;: &amp;quot;mozillazg.com&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;mozillazg&amp;quot;}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq &lt;span class="s1"&gt;&amp;#39;.url, .name&amp;#39;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;mozillazg.com&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;mozillazg&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/02CPHO1ESj"&gt;https://jqplay.org/s/02CPHO1ESj&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id7"&gt;
&lt;h2 id="hidid7"&gt;高级操作&lt;a class="headerlink" href="#hidid7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3 id="hidid8"&gt;管道&lt;a class="headerlink" href="#hidid8" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;tt class="docutils literal"&gt;|&lt;/tt&gt; 实现类似管道的功能:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{&amp;quot;url&amp;quot;: &amp;quot;mozillazg.com&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;mozillazg&amp;quot;}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq &lt;span class="s1"&gt;&amp;#39;.|.url&amp;#39;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;mozillazg.com&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/L5bu1ovLr-"&gt;https://jqplay.org/s/L5bu1ovLr-&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id9"&gt;
&lt;h3 id="hidid9"&gt;获取内容的长度(字符串，数组的长度)&lt;a class="headerlink" href="#hidid9" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;length&lt;/tt&gt; 可以获取字符串或数组的长度:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{&amp;quot;url&amp;quot;: &amp;quot;mozillazg.com&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;mozillazg&amp;quot;}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq &lt;span class="s1"&gt;&amp;#39;.url|length&amp;#39;&lt;/span&gt;
13
$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;[&amp;quot;mozillazg.com&amp;quot;, &amp;quot;mozillazg&amp;quot;]&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq &lt;span class="s1"&gt;&amp;#39;.|length&amp;#39;&lt;/span&gt;
2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/9TqdXbe0lo"&gt;https://jqplay.org/s/9TqdXbe0lo&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="map"&gt;
&lt;h3 id="hidmap"&gt;map&lt;a class="headerlink" href="#hidmap" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;map(foo)&lt;/tt&gt; 可以实现对数组的每一项进行操作，然后合并结果的功能:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;[&amp;quot;mozillazg.com&amp;quot;, &amp;quot;mozillazg&amp;quot;]&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; jq &lt;span class="s1"&gt;&amp;#39;map(length)&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;
  13,
  9
&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/BjgdGsjPem"&gt;https://jqplay.org/s/BjgdGsjPem&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="filter-select"&gt;
&lt;h3 id="hidfilter-select"&gt;filter(select)&lt;a class="headerlink" href="#hidfilter-select" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;select(foo)&lt;/tt&gt; 可以实现对输入项进行判断，只返回符合条件的项:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;[&amp;quot;mozillazg.com&amp;quot;, &amp;quot;mozillazg&amp;quot;]&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; jq &lt;span class="s1"&gt;&amp;#39;map(select(.|length &amp;gt; 9))&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;
  &lt;span class="s2"&gt;&amp;quot;mozillazg.com&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/8Zrwy7dDxW"&gt;https://jqplay.org/s/8Zrwy7dDxW&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h3 id="hidid10"&gt;字符串插值，拼接&lt;a class="headerlink" href="#hidid10" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以使用 &lt;tt class="docutils literal"&gt;\(foo)&lt;/tt&gt; 实现字符串插值功能:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{&amp;quot;url&amp;quot;: &amp;quot;mozillazg.com&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;mozillazg&amp;quot;}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq &lt;span class="s1"&gt;&amp;#39;&amp;quot;hi \(.name)&amp;quot;&amp;#39;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;hi mozillazg&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意要用双引号包围起来，表示是一个字符串。&lt;/p&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/k90JFcDqPz"&gt;https://jqplay.org/s/k90JFcDqPz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用 &lt;tt class="docutils literal"&gt;+&lt;/tt&gt; 实现字符串拼接:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{&amp;quot;url&amp;quot;: &amp;quot;mozillazg.com&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;mozillazg&amp;quot;}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq &lt;span class="s1"&gt;&amp;#39;&amp;quot;hi &amp;quot; + .name&amp;#39;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;hi mozillazg&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="if-elif-else"&gt;
&lt;h3 id="hidif-elif-else"&gt;if/elif/else&lt;a class="headerlink" href="#hidif-elif-else" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以使用 &lt;tt class="docutils literal"&gt;if .. then .. elif .. then .. else .. end&lt;/tt&gt; 实现条件判断:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;[0, 1, 2, 3]&amp;#39;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="p"&gt;|&lt;/span&gt; jq &lt;span class="s1"&gt;&amp;#39;map(if . == 0 then &amp;quot;zero&amp;quot; elif . == 1 then &amp;quot;one&amp;quot; elif . == 2 then &amp;quot;two&amp;quot; else &amp;quot;many&amp;quot; end)&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;
  &lt;span class="s2"&gt;&amp;quot;zero&amp;quot;&lt;/span&gt;,
  &lt;span class="s2"&gt;&amp;quot;one&amp;quot;&lt;/span&gt;,
  &lt;span class="s2"&gt;&amp;quot;two&amp;quot;&lt;/span&gt;,
  &lt;span class="s2"&gt;&amp;quot;many&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/y8WwvHISH4"&gt;https://jqplay.org/s/y8WwvHISH4&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id11"&gt;
&lt;h3 id="hidid11"&gt;构造 object 或数组&lt;a class="headerlink" href="#hidid11" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;tt class="docutils literal"&gt;{}&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;[]&lt;/tt&gt; 构造新的 object 或 数组。&lt;/p&gt;
&lt;p&gt;object:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;[&amp;quot;mozillazg.com&amp;quot;, &amp;quot;mozillazg&amp;quot;]&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq &lt;span class="s1"&gt;&amp;#39;{name: .[1]}&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;mozillazg&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/sccwJi75jb"&gt;https://jqplay.org/s/sccwJi75jb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数组:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{&amp;quot;url&amp;quot;: &amp;quot;mozillazg.com&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;mozillazg&amp;quot;}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq &lt;span class="s1"&gt;&amp;#39;[.name, .url]&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;
  &lt;span class="s2"&gt;&amp;quot;mozillazg&amp;quot;&lt;/span&gt;,
  &lt;span class="s2"&gt;&amp;quot;mozillazg.com&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;jq play: &lt;a class="reference external" href="https://jqplay.org/s/LYflwM4kJM"&gt;https://jqplay.org/s/LYflwM4kJM&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;{&amp;quot;name&amp;quot;: &amp;quot;mozillazg&amp;quot;, &amp;quot;ages&amp;quot;: [1, 2]}&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; jq &lt;span class="s1"&gt;&amp;#39;{name, age: .ages[]}&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;mozillazg&amp;quot;&lt;/span&gt;,
  &lt;span class="s2"&gt;&amp;quot;age&amp;quot;&lt;/span&gt;: 1
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="s2"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;mozillazg&amp;quot;&lt;/span&gt;,
  &lt;span class="s2"&gt;&amp;quot;age&amp;quot;&lt;/span&gt;: 2
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="join"&gt;
&lt;h3 id="hidjoin"&gt;数组 join&lt;a class="headerlink" href="#hidjoin" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;join&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;[&amp;quot;mozillazg.com&amp;quot;, &amp;quot;mozillazg&amp;quot;]&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; jq &lt;span class="s1"&gt;&amp;#39;.|join(&amp;quot; | &amp;quot;)&amp;#39;&lt;/span&gt;
&lt;span class="s2"&gt;&amp;quot;mozillazg.com | mozillazg&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="split"&gt;
&lt;h3 id="hidsplit"&gt;字符串 split&lt;a class="headerlink" href="#hidsplit" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;split&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;quot;mozillazg.com | mozillazg&amp;quot;&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt;jq &lt;span class="s1"&gt;&amp;#39;split(&amp;quot; | &amp;quot;)&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;[&lt;/span&gt;
  &lt;span class="s2"&gt;&amp;quot;mozillazg.com&amp;quot;&lt;/span&gt;,
  &lt;span class="s2"&gt;&amp;quot;mozillazg&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多的函数和用法详见 &lt;a class="reference external" href="https://stedolan.github.io/jq/manual/"&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h2 id="hidid12"&gt;参考资料&lt;a class="headerlink" href="#hidid12" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://stedolan.github.io/jq/"&gt;jq&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://jqplay.org/"&gt;jq play&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="jq"></category></entry><entry><title>ZooKeeper FastLeader 选举</title><link href="https://mozillazg.com/2017/03/zookeeper-fastleader-elect-leader.html" rel="alternate"></link><updated>2017-03-11T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2017-03-11:2017/03/zookeeper-fastleader-elect-leader.html</id><summary type="html">&lt;p&gt;ZooKeeper 在集群模式下默认会使用 FastLeader 算法来选举 leader。下面将说说 ZooKeeper 集群使用 FastLeader 算法选举的具体过程。写的过程中参考了多篇文章，详见文末的参考资料。&lt;/p&gt;
&lt;p&gt;首先需要明确几个概念:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;节点状态：每个集群中的节点都有一个状态 LOOKING/FOLLOWING/LEADING/OBSERVING。每个节点启动的时候都是 LOOKING 状态，如果这个节点参与选举但最后不是leader，则状态是 FOLLOWING，如果不参与选举则是 OBSERVING，leader 的状态是 LEADING。&lt;/li&gt;
&lt;li&gt;epoch: 表示选举轮数。&lt;/li&gt;
&lt;li&gt;zxid: 事务 zxid 包含了本地数据的最后更新时间相关的信息。&lt;/li&gt;
&lt;li&gt;serverid: 当前 server 的 ID, 通过配置文件指定(比如: &lt;tt class="docutils literal"&gt;echo '1' &amp;gt; myid&lt;/tt&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先用文字描述一下大概的选举思想：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;在没有遇到比我牛的人之前，第一票推荐我自己&lt;/li&gt;
&lt;li&gt;当接收到其他人的选举信息时，如果他们推荐的人没我牛，那我还是推荐我自己&lt;/li&gt;
&lt;li&gt;我有一个票箱，保存了当前这一轮选举中自己的推荐人以及接收到的推荐人信息，一人一票，重复或过期的票概不接受&lt;/li&gt;
&lt;li&gt;当我发现了比我牛的人的时候，改为推荐这个牛人&lt;/li&gt;
&lt;li&gt;如果我发现我的选举轮数落后了，清空票箱，改为推荐接收到的最新选举中大家推荐的最牛的那个人（如果没有人比我牛，那还是推荐我自己）&lt;/li&gt;
&lt;li&gt;不断的重复上面的过程，不断的告诉别人“我的投票是第几轮”、“我推举的人是谁”。直到我的票箱中“我推举的最牛的人”收到了不少于 &lt;strong&gt;N / 2 + 1&lt;/strong&gt; 的推举投票，此时这个人就是我认定的最终 leader。&lt;/li&gt;
&lt;li&gt;当我确定了谁是最终 leader 并且这个 leader 一切正常，我就更新我的状态为 FOLLOWING/LEADING（我自己是最终  leader 则是 LEADING 否则就是 FOLLOWING），之后的选举中都直接反馈我确定的这个最终 leader。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么，以什么标准来确定一个节点可以成为一个 leader 呢？
依次比较 epoch, zxid, serverid ：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;接收到的消息中，有 epoch 比我大的，则选 epoch 大的消息中确定的 server&lt;/li&gt;
&lt;li&gt;如果 epoch 相等，则选 zxid 最大的 server&lt;/li&gt;
&lt;li&gt;如果 zxid 也相等，则选 serverid 最大的 server (有的节点生来就是当 leader 的 😂）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;state&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;//LOOKING消息，则&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="n"&gt;LOOKING&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="o"&gt;......&lt;/span&gt;
    &lt;span class="c1"&gt;//检查下收到的这张选票是否可以胜出，依次比较选举轮数epoch，事务zxid，服务器编号server id&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;totalOrderPredicate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;leader&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;zxid&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;peerEpoch&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;proposedLeader&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;proposedZxid&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;proposedEpoch&lt;/span&gt;&lt;span class="o"&gt;))&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//胜出了，就把自己的投票修改为对方的，然后广播消息&lt;/span&gt;
        &lt;span class="n"&gt;updateProposal&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;leader&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;zxid&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;peerEpoch&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;sendNotifications&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;totalOrderPredicate&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;newId&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;newZxid&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;newEpoch&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;curId&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;curZxid&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;curEpoch&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;
        &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newEpoch&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;curEpoch&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
        &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;newEpoch&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;curEpoch&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;newZxid&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;curZxid&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;newZxid&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;curZxid&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newId&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;curId&lt;/span&gt;&lt;span class="o"&gt;))))&lt;/span&gt;
    &lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从网上找了一个流程图，可以看看：&lt;/p&gt;
&lt;p&gt;&lt;img alt="flow.png" src="/static/images/zookeeper/elect-leader.png" /&gt;&lt;/p&gt;
&lt;p&gt;举个例子，理想情况下，先后启动三个节点的选举过程如下：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;第一轮：每个节点广播选自己（此时只有 node1)&lt;/li&gt;
&lt;li&gt;第二轮：node2 启动了，发起一轮投票。node1 收到了 node2 选它自己的投票，发现 node2 比自己牛，广播选 node2。此时 node1 发现 node2 获得了2票 &amp;gt;= N / 2 + 1，认定 node2 为 leader 进入 following 状态。
node2 收到了 node1 选自己的广播，此时 node2 发现自己 获得了2票 &amp;gt;= N / 2 + 1，进入 leading 状态。&lt;/li&gt;
&lt;li&gt;第三轮：node3 启动了，发起一轮投票。node1 和 node2 都选 node2 , node3 通过比对发现 node2 的票数 &amp;gt;= N /2 + 1，认定 node2 是 leader 进入 following 状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面就是 FastLeader 算法选举的简单介绍了，更详细的信息可以查阅官方文档和代码。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;参考&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://codemacro.com/2014/10/19/zk-fastleaderelection/"&gt;图解zookeeper FastLeader选举算法 - loop in codes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://blog.csdn.net/xhh198781/article/details/6619203"&gt;zookeeper3.3.3源码分析(二)FastLeader选举算法 - xhh198781的专栏 - 博客频道 - CSDN.NET&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://iwinit.iteye.com/blog/1773531"&gt;深入浅出Zookeeper之五 Leader选举 - 吊丝码农 - ITeye技术网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cnblogs.com/yuyijq/p/4116365.html"&gt;Zookeeper-Zookeeper leader选举 - 横刀天笑 - 博客园&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://blog.csdn.net/yinwenjie/article/details/47613309"&gt;hadoop系列：zookeeper（2）——zookeeper核心原理（选举） - JAVA入门中 - 博客频道 - CSDN.NET&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/apache/zookeeper/blob/branch-3.4/src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java"&gt;zookeeper/FastLeaderElection.java at branch-3.4 · apache/zookeeper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://zookeeper.apache.org/doc/r3.4.10/zookeeperAdmin.html#sc_configuration"&gt;ZooKeeper Administrator's Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="zookeeper"></category><category term="leader选举"></category></entry><entry><title>pinyin-data: 汉字拼音数据库</title><link href="https://mozillazg.com/2016/03/introduce-pinyin-data.html" rel="alternate"></link><updated>2016-03-07T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2016-03-07:2016/03/introduce-pinyin-data.html</id><summary type="html">&lt;h2&gt;缘起&lt;/h2&gt;
&lt;!-- 因为我维护了三个拼音相关的仓库（
[python-pinyin][1]
[go-pinyin][2]
[rust-pinyin][3]
），每次修改拼音数据的时候都需要手动修改不同编程语言版本的
拼音库，感觉这样不是很方便。

同时也  --&gt;

&lt;p&gt;希望建立一个跟编程语言无关的拼音数据库，
方便大家使用这个拼音数据库去开发不同编程语言的拼音模块。&lt;/p&gt;
&lt;h2&gt;项目介绍&lt;/h2&gt;
&lt;p&gt;项目地址: &lt;a href="https://github.com/mozillazg/pinyin-data"&gt;https://github.com/mozillazg/pinyin-data&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要用的是 &lt;a href="http://unicode.org/"&gt;Unicode.org&lt;/a&gt; 旗下的 &lt;a href="http://www.unicode.org/charts/unihan.html"&gt;Unihan Database&lt;/a&gt; 项目里的拼音数据。
通过程序自动解析和合并 &lt;a href="http://www.unicode.org/charts/unihan.html"&gt;Unihan Database&lt;/a&gt; 中的拼音数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据格式：&lt;code&gt;{code point}: {pinyins}  # {hanzi}&lt;/code&gt; （示例：&lt;code&gt;U+4E2D: zhōng,zhòng  # 中&lt;/code&gt;）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kHanyuPinyin.txt&lt;/code&gt;: &lt;a href="http://www.unicode.org/charts/unihan.html"&gt;Unihan Database&lt;/a&gt; 中 &lt;a href="http://www.unicode.org/reports/tr38/#kHanyuPinyin"&gt;kHanyuPinyin&lt;/a&gt; 部分的拼音数据（来源于《漢語大字典》的拼音数据）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kHanyuPinlu.txt&lt;/code&gt;: &lt;a href="http://www.unicode.org/charts/unihan.html"&gt;Unihan Database&lt;/a&gt; 中 &lt;a href="http://www.unicode.org/reports/tr38/#kHanyuPinlu"&gt;kHanyuPinlu&lt;/a&gt; 部分的拼音数据（来源于《現代漢語頻率詞典》的拼音数据）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kXHC1983.txt&lt;/code&gt;: &lt;a href="http://www.unicode.org/charts/unihan.html"&gt;Unihan Database&lt;/a&gt; 中 &lt;a href="http://www.unicode.org/reports/tr38/#kXHC1983"&gt;kXHC1983&lt;/a&gt; 部分的拼音数据（来源于《现代汉语词典》的拼音数据）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nonCJKUI.txt&lt;/code&gt;: 不属于 &lt;a href="https://en.wikipedia.org/wiki/CJK_Unified_Ideographs"&gt;CJK Unified Ideograph&lt;/a&gt; 但是却有拼音的字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kMandarin.txt&lt;/code&gt;: &lt;a href="http://www.unicode.org/charts/unihan.html"&gt;Unihan Database&lt;/a&gt; 中 &lt;a href="http://www.unicode.org/reports/tr38/#kMandarin"&gt;kMandarin&lt;/a&gt; 部分的拼音数据（普通话中最常用的一个读音。zh-CN 为主，如果 zh-CN 中没有则使用 zh-TW 中的拼音）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;overwrite.txt&lt;/code&gt;: 手工校验的拼音数据（上面的拼音数据都是自动生成的，修改的话只修改这个就可以了）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pinyin.txt&lt;/code&gt;: 合并上述文件后的拼音数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zdic.txt&lt;/code&gt;: &lt;a href="http://zdic.net"&gt;汉典网&lt;/a&gt; 的拼音数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;后续计划&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将 &lt;a href="https://github.com/mozillazg/python-pinyin"&gt;python-pinyin&lt;/a&gt;, &lt;a href="https://github.com/mozillazg/go-pinyin"&gt;go-pinyin&lt;/a&gt;, &lt;a href="https://github.com/mozillazg/rust-pinyin"&gt;rust-pinyin&lt;/a&gt; 里的拼音数据改为基于 &lt;a href="https://github.com/mozillazg/pinyin-data"&gt;pinyin-data&lt;/a&gt; 自动生成相关代码。
  然后统一在 &lt;a href="https://github.com/mozillazg/rust-pinyin"&gt;pinyin-data&lt;/a&gt; 这个项目中维护拼音数据（在 README 或 CONTRIBUTING.md 中增加提示）。&lt;/li&gt;
&lt;li&gt;向 &lt;a href="https://github.com/hotoo/pinyin"&gt;hotoo/pinyin&lt;/a&gt; 提一下这个仓库，看他是否有意使用这个仓库的数据。&lt;/li&gt;
&lt;/ul&gt;</summary><category term="pinyin"></category></entry><entry><title>multipart form data 的数据格式</title><link href="https://mozillazg.com/2016/02/http-multipart-form-data.html" rel="alternate"></link><updated>2016-02-19T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2016-02-19:2016/02/http-multipart-form-data.html</id><summary type="html">&lt;p&gt;假设 form 如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;form&lt;/span&gt; &lt;span class="na"&gt;action=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/upload&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;enctype=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;multipart/form-data&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;method=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;post&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    Username: &lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;username&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    Password: &lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;password&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;password&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    File: &lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;file&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;file&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;submit&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;header&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;Content-Type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;multipart&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;form-data&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;boundary&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;boundary&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;r&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;n&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;body&lt;/h2&gt;
&lt;h3&gt;普通 input 数据&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;--&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;boundary&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;r&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;n&lt;/span&gt;
&lt;span class="nt"&gt;Content-Disposition&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;form-data&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;username&amp;quot;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;r&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;n&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;r&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;n&lt;/span&gt;
&lt;span class="nt"&gt;Tom&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;r&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;n&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;文件上传 input 数据&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;--&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;boundary&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;r&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;n&lt;/span&gt;
&lt;span class="nt"&gt;Content-Disposition&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;form-data&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;file&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;myfile.txt&amp;quot;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;r&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;n&lt;/span&gt;
&lt;span class="nt"&gt;Content-Type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;text&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;plain&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;r&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;n&lt;/span&gt;
&lt;span class="nt"&gt;Content-Transfer-Encoding&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;binary&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;r&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;n&lt;/span&gt;
&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;r&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;n&lt;/span&gt;
&lt;span class="nt"&gt;hello&lt;/span&gt; &lt;span class="nt"&gt;word&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;r&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nt"&gt;n&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;结束标志&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;--{boundary}--\r\n
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;数据示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;POST&lt;/span&gt; &lt;span class="nn"&gt;/upload&lt;/span&gt; &lt;span class="kr"&gt;HTTP&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="m"&gt;1.1&lt;/span&gt;
&lt;span class="na"&gt;Host&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="l"&gt;172.16.100.128:5000&lt;/span&gt;
&lt;span class="na"&gt;Content-Length&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="l"&gt;394 &lt;/span&gt;
&lt;span class="na"&gt;Content-Type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="l"&gt;multipart/form-data; boundary=----WebKitFormBoundaryLumpDpF3AwbRwRBn&lt;/span&gt;
&lt;span class="na"&gt;Referer&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="l"&gt;http://172.16.100.128:5000/&lt;/span&gt;

------WebKitFormBoundaryUNZIuug9PIVmZWuw
Content-Disposition: form-data; name=&amp;quot;username&amp;quot;

Tom
------WebKitFormBoundaryUNZIuug9PIVmZWuw
Content-Disposition: form-data; name=&amp;quot;password&amp;quot;

passwd
------WebKitFormBoundaryUNZIuug9PIVmZWuw
Content-Disposition: form-data; name=&amp;quot;file&amp;quot;; filename=&amp;quot;myfile.txt&amp;quot;
Content-Type: text/plain

hello world
------WebKitFormBoundaryUNZIuug9PIVmZWuw--
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://tools.ietf.org/html/rfc2388"&gt;https://tools.ietf.org/html/rfc2388&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2"&gt;https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://d.hatena.ne.jp/satox/20110726/1311665904"&gt;http://d.hatena.ne.jp/satox/20110726/1311665904&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://mugenup-tech.hatenadiary.com/entry/2014/08/28/100910"&gt;http://mugenup-tech.hatenadiary.com/entry/2014/08/28/100910&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="http"></category></entry><entry><title>解决 gitlab 配置不正确导致 ci 中 git clone 时出现 “You appear to have cloned an empty repository” 的问题</title><link href="https://mozillazg.com/2015/11/gitlab-ci-fix-reference-is-not-a-tree-you-appear-to-have-cloned-an-empty.html" rel="alternate"></link><updated>2015-11-02T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2015-11-02:2015/11/gitlab-ci-fix-reference-is-not-a-tree-you-appear-to-have-cloned-an-empty.html</id><summary type="html">&lt;p&gt;最近在使用 gitlab 的 ci 服务时出现了如下问题：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;gitlab-ci-multi-runner ...
...

Cloning repository... 
Cloning into &amp;#39;/builds/...&amp;#39;... 
warning: You appear to have cloned an empty repository. 
Checking out 2c80f515 as develop... 
fatal: reference is not a tree: 1b53f5157b357f4c006ceccf0e36035bad340185
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;经过多翻搜索验证后发现是 gitlab-git-http-server 的配置问题：
这个 gitlab 服务没有使用内置的 nginx 来反向代理 gitlab 服务而是使用的 yum 安装的 nginx。
由于配置有问题导致 ci 任务一直失败。&lt;/p&gt;
&lt;p&gt;解决办法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;修改 &lt;code&gt;/etc/gitlab/gitlab.rb&lt;/code&gt;, 找到如下配置并修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nginx[&amp;#39;enabled&amp;#39;] = false
gitlab_git_http_server[&amp;#39;listen_network&amp;#39;] = &amp;quot;tcp&amp;quot;
# 这个端口修改为你实际需要的端口
gitlab_git_http_server[&amp;#39;listen_addr&amp;#39;] = &amp;quot;localhost:8081&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用更改 &lt;code&gt;sudo gitlab-ctl reconfigure&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载官方 nginx 配置（选择相应版本分支下的文件）:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget https://gitlab.com/gitlab-org/gitlab-ce/raw/v8.1.2/lib/support/nginx/gitlab -O /etc/nginx/conf.d/gitlab.conf
# 如果你的 ci 服务器使用的是独立的域名或者使用了 ssl 的话，可以去
# https://gitlab.com/gitlab-org/gitlab-ce/tree/master/lib/support/nginx
# 下载相应的配置文件
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改 nginx 配置文件中的 &lt;code&gt;upstream&lt;/code&gt;， &lt;code&gt;server_name&lt;/code&gt;, &lt;code&gt;root&lt;/code&gt;，提示：
   如果不存在 &lt;code&gt;/home/git/gitlab/public&lt;/code&gt; 目录的话，那么 &lt;code&gt;root&lt;/code&gt; 就是
   &lt;code&gt;/opt/gitlab/embedded/service/gitlab-rails/public&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;reload nginx: &lt;code&gt;nginx -t &amp;amp;&amp;amp; nginx -s reload&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gitlab.com/gitlab-org/gitlab-ce/issues/2727"&gt;https://gitlab.com/gitlab-org/gitlab-ce/issues/2727&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/nginx.md#gitlab"&gt;https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/doc/settings/nginx.md#gitlab&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://gitlab.com/gitlab-org/gitlab-ce/tree/master/lib/support/nginx"&gt;https://gitlab.com/gitlab-org/gitlab-ce/tree/master/lib/support/nginx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="gitlab"></category><category term="gitlab-git-http-server"></category></entry><entry><title>修复 gitlab 中 fork 失败，提示 "visibility level private visibility has been restricted"</title><link href="https://mozillazg.com/2015/10/gitlab-fix-fork-error-because-visibility-level-private-visibility-has-been-restricted-by-your-gitlab-administrator.html" rel="alternate"></link><updated>2015-10-20T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2015-10-20:2015/10/gitlab-fix-fork-error-because-visibility-level-private-visibility-has-been-restricted-by-your-gitlab-administrator.html</id><summary type="html">&lt;p&gt;版本：Gitlab 8.0.4, 错误截图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="gitlab-fork-error-1.png" src="/static/images/2015/gitlab-fork-error-1.png" /&gt;&lt;/p&gt;
&lt;p&gt;出现这个错误是因为管理员没有配置 private 仓库允许 被 fork。解决办法如下（管理员身份操作）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进入【admin area】                 &lt;br /&gt;
&lt;img alt="" src="/static/images/2015/gitlab-fork-error-2.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【settings】             &lt;br /&gt;
&lt;img alt="" src="/static/images/2015/gitlab-fork-error-3.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改【Restricted visibility levels】，&lt;strong&gt;取消&lt;/strong&gt; Private 的选中状态          &lt;br /&gt;
&lt;img alt="" src="/static/images/2015/gitlab-fork-error-4.png" /&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary><category term="gitlab"></category></entry><entry><title>微信开发过程中遇到的问题</title><link href="https://mozillazg.com/2015/06/wechat-develop-note.html" rel="alternate"></link><updated>2015-06-08T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2015-06-08:2015/06/wechat-develop-note.html</id><summary type="html">&lt;div class="section" id="jssdk"&gt;
&lt;h2 id="hidjssdk"&gt;JSSDK&lt;a class="headerlink" href="#hidjssdk" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;invalid signature&lt;/strong&gt;, 排查:&lt;/p&gt;
&lt;p&gt;前端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;url&lt;/tt&gt; 参数动态获取&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;注意参数大小写:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
appId: '',         //  I 大写
timestamp: 134xxx, // 全小写, 必须与后端签名时 timestamp 的值一致
nonceStr: '',      //  ** 尤其注意 S 是大写 **, 必须与后端签名时 noncestr 的值一致
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;确保 jsapi_ticket 未过期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;确认参与签名的参数，注意大小写:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
noncestr        // 全小写，** 尤其注意 s 是小写 **
jsapi_ticket    // 全小写
timestamp       // 全小写
url             // 小写，必须是前端动态获取
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;签名算法
* 是否按字段名的ASCII 码从小到大排序
* 使用 sha1 签名&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;微信支付 &lt;strong&gt;商户签名错误&lt;/strong&gt;, 排查:&lt;/p&gt;
&lt;p&gt;前端:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;检查参数大小写:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
timestamp: 0,                     // ** 小写 **
nonceStr: '',                     // S 大写
package: 'prepay_id=wx2015xxxx',  // 内容是否对了？
paySign: 'MD5',                   // 新版是 MD5
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后端:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;检查参与签名的参数大小写:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
appId            // I 大写
timeStamp        // ** S 大写 **
nonceStr         // S 大写
package          // prepay_id=wx2015xxxx
signType         // 新版是 MD5
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;a class="reference external" href="http://pay.weixin.qq.com/wiki/doc/api/index.php?chapter=4_3"&gt;签名算法&lt;/a&gt; 是否正确&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;微信支付&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使用 &lt;tt class="docutils literal"&gt;requests&lt;/tt&gt; 模块发送请求时，如何使用商户证书?&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cert = ('/path/to/apiclient_cert.pem', '/path/to/apiclient_key.pem')
requests.post(url, data=data, cert=cert)
&lt;/pre&gt;
&lt;p&gt;使用证书发送请求时，出现 &lt;tt class="docutils literal"&gt;UnicodeEncodeError&lt;/tt&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
File &amp;quot;/xxx/lib/python2.7/ssl.py&amp;quot;, line 198, in send
v = self._sslobj.write(data)
UnicodeEncodeError: 'ascii' codec can't encode characters in position 363-364: ordinal not in range(128)
&lt;/pre&gt;
&lt;p&gt;ssl data 不支持 unicode, data 参数不要传 &lt;tt class="docutils literal"&gt;unicode&lt;/tt&gt;, 改为 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;utf-8&lt;/span&gt;&lt;/tt&gt; 编码字符串:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
xml = u'&amp;lt;xml&amp;gt;巴拉巴拉巴拉&amp;lt;xml&amp;gt;'
requests.post(url, data=xml, cert=cert)   # UnicodeEncodeError
改为
requests.post(url, data=xml.encode('utf8'), cert=cert)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;企业付款&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;参数错误:输入的商户号有误&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;检查提交的参数名称是否有误:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
mch_appid         # ** 在其他支付 api 中参数的名称是 appid **
mchid             # ** 在其他支付 api 中参数的名称是 mch_id **
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="微信"></category></entry><entry><title>解决通过 ifttt 把 Feed 中的图片转发到 twritter 时，总是出现 "image not found" 的问题</title><link href="https://mozillazg.com/2015/05/fix-ifttt-feed-image-not-found.html" rel="alternate"></link><updated>2015-08-27T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2015-05-01:2015/05/fix-ifttt-feed-image-not-found.html</id><summary type="html">&lt;p&gt;之前使用 ifttt 把 Feed 中的图片转发到 twritter 时，总是出现 "image not found"。然后就不再使用 ifttt 转发图片了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image not found" src="/static/images/ifttt-image-not-found.png" /&gt;&lt;/p&gt;
&lt;p&gt;趁着今天给 &lt;a href="http://comic.mozillazg.com"&gt;comic.mozillazg.com&lt;/a&gt; 增加 Atom Feed 的功能的时候，研究了一下 ifttt 获取图片的规则。通过搜索后得知，ifttt 只会从文章内容的开头位置获取图片地址，如果获取不到的话，就 "image not found":&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;&amp;lt;!-- bad: &amp;quot;image not found&amp;quot;  --&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;content&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;html&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;译自：http://explosm.net/comics/3908/&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt; AT 2015-05-01 &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;img&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://tmp-images.qiniudn.com/comics/3908.you-should.zh-cn.png&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;alt=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Cyanide &amp;amp; Happiness #3908：你应该&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/content&amp;gt;&lt;/span&gt;

&lt;span class="c"&gt;&amp;lt;!-- good --&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;content&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;html&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;img&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://tmp-images.qiniudn.com/comics/3908.you-should.zh-cn.png&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;alt=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Cyanide &amp;amp; Happiness #3908：你应该&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;译自：http://explosm.net/comics/3908/&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt; AT 2015-05-01 &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/content&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://twitter.com/ifttt/status/372166382172925952"&gt;https://twitter.com/ifttt/status/372166382172925952&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="Excerpthttps://winwar.co.uk/2015/02/include-wordpress-posts-featured-image-rss-feed-excerpt/"&gt;How To Include Your WordPress Post’s Featured Image in a RSS Feed Excerpt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><title>修复无法启动 Oracle SQL Developer，提示：could not install some modules</title><link href="https://mozillazg.com/2014/11/fix-could-not-install-some-modules-when-start-Oracle-SQL-Developer.html" rel="alternate"></link><updated>2014-11-02T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2014-11-02:2014/11/fix-could-not-install-some-modules-when-start-Oracle-SQL-Developer.html</id><summary type="html">&lt;p&gt;今天启动 Oracle SQL Developer时，提示如下错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Warning - could not install some modules:
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;导致不能成功启动 Oracle SQL Developer。&lt;/p&gt;
&lt;p&gt;最后的解决办法是（ &lt;strong&gt;注意，这个办法会导致丢失所有之前定义的数据库连接配置&lt;/strong&gt; ）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除 c:\Users\yourusername\AppData\Roaming\SQL Developer\ 目录下的 system4.0.0.12.84 文件夹&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://community.oracle.com/thread/2560920?start=0&amp;amp;tstart=0"&gt;Sql Developer 4.0 EA Winsdows 7 Could not insta... | Oracle Community&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><title>修复启动 sqldeveloper 时出现“Unable to create an instance of the Java Virtual Machine Located at path”错误</title><link href="https://mozillazg.com/2014/07/fix-Unable-to-create-an-instance-of-the-Java-Virtual-Machine-Located-at-path-error-for-oracle-sqldeveloper.html" rel="alternate"></link><updated>2014-07-17T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2014-07-17:2014/07/fix-Unable-to-create-an-instance-of-the-Java-Virtual-Machine-Located-at-path-error-for-oracle-sqldeveloper.html</id><summary type="html">&lt;p&gt;刚才打开 sqldeveloper 时提示如下错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Unable to create an instance of the Java Virtual Machine
Located at path:
x:\xxxx\jre\bin\client\jvm.dll
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后的解决办法是：编辑 &lt;code&gt;sqldeveloper.exe&lt;/code&gt; 所在目录下的 &lt;code&gt;ide\bin\ide.conf&lt;/code&gt; 文件，
将 38 行左右的 &lt;code&gt;AddVMOption  -Xmx800M&lt;/code&gt; 改为 &lt;code&gt;AddVMOption -Xmx512M&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# AddVMOption  -Xmx800M
AddVMOption -Xmx512M
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://pisceansheart.wordpress.com/2009/08/06/solution-to-unable-to-create-an-instance-of-the-java-virtual-machine-for-jdeveloper/"&gt;Solution to ‘Unable to Create an Instance of the Java Virtual Machine’ for JDeveloper | In Piscean's Heart &lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="sqldeveloper"></category></entry><entry><title>给终端文字加点颜色和特效</title><link href="https://mozillazg.com/2013/08/ansi-escape-sequences.html" rel="alternate"></link><updated>2013-08-25T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2013-08-25:2013/08/ansi-escape-sequences.html</id><summary type="html">&lt;p&gt;这个叫做：ANSI Escape Sequences/Code 。&lt;/p&gt;
&lt;p&gt;文字特效相关的字符格式是：&lt;code&gt;ESC[#;#;....;#m&lt;/code&gt; ，其中 # 的取值见下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;# 的值&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;python 代码&lt;/th&gt;
&lt;th&gt;截图&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;00 或 0&lt;/td&gt;
&lt;td&gt;正常显示&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[00m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;01 或 1&lt;/td&gt;
&lt;td&gt;粗体&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[01m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;02 或 2&lt;/td&gt;
&lt;td&gt;模糊&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[02m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;03 或 3&lt;/td&gt;
&lt;td&gt;斜体&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[03m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;04 或 4&lt;/td&gt;
&lt;td&gt;下划线&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[04m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/04.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;05 或 5&lt;/td&gt;
&lt;td&gt;闪烁（慢）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[05m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;06 或 6&lt;/td&gt;
&lt;td&gt;闪烁（快）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[06m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;07 或 7&lt;/td&gt;
&lt;td&gt;反转显示（前景色与背景色调过来）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[07m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/07.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;08 或 8&lt;/td&gt;
&lt;td&gt;隐藏&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[08m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/08.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;正常&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[22m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;不斜体&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[23m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;无下划线&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[24m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;不闪烁&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[25m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;27&lt;/td&gt;
&lt;td&gt;不反转&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[26m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;td&gt;不隐藏&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[27m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;前景色&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;黑色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[30m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/30.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;31&lt;/td&gt;
&lt;td&gt;红色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[31m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/31.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;绿色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[32m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/32.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;33&lt;/td&gt;
&lt;td&gt;黄色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[33m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/33.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;34&lt;/td&gt;
&lt;td&gt;蓝色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[34m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/34.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;35&lt;/td&gt;
&lt;td&gt;品红/紫红&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[35m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/35.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;36&lt;/td&gt;
&lt;td&gt;青色/蓝绿&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[36m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/36.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;37&lt;/td&gt;
&lt;td&gt;白色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[37m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/37.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;38&lt;/td&gt;
&lt;td&gt;xterm-256 色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[38;5;7m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/38.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;39&lt;/td&gt;
&lt;td&gt;默认色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[39m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;背景色&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;td&gt;黑色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[40m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/38.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;41&lt;/td&gt;
&lt;td&gt;红色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[41m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/41.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;42&lt;/td&gt;
&lt;td&gt;绿色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[42m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/42.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;43&lt;/td&gt;
&lt;td&gt;黄色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[43m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/43.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;44&lt;/td&gt;
&lt;td&gt;蓝色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[44m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/44.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;品红/紫红&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[45m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/45.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;td&gt;青色/蓝绿&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[46m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/46.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;47&lt;/td&gt;
&lt;td&gt;白色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[47m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/47.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;48&lt;/td&gt;
&lt;td&gt;xterm-256 色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[48;5;7m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;img alt="" src="/static/images/48.png" /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;49&lt;/td&gt;
&lt;td&gt;默认色&lt;/td&gt;
&lt;td&gt;&lt;code&gt;'\033[49m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;!--
https://github.com/robertknight/konsole/blob/master/tests/color-spaces.pl
Quoting &lt;https://github.com/robertknight/konsole/blob/master/user-doc/README.moreColors&gt;:
   ESC[ … 38;2;&lt;r&gt;;&lt;g&gt;;&lt;b&gt; … m Select RGB foreground color
   ESC[ … 48;2;&lt;r&gt;;&lt;g&gt;;&lt;b&gt; … m Select RGB background color

## 示例

print('\033[31m \033[44m' + 'some red text' + '\033[0;39m' + 'ab')
--&gt;

&lt;p&gt;同时指定背景及前景色： &lt;code&gt;'\033[47;31m' + 'hello' + '\033[0;39m'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/static/images/47-31.png" /&gt;&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.isthe.com/chongo/tech/comp/ansi_escapes.html"&gt;ANSI Escape Sequences&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/ANSI_escape_code"&gt;ANSI escape code - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.pixelbeat.org/docs/terminal_colours/"&gt;Terminal colour highlights&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Xterm"&gt;xterm - Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="ansi"></category><category term="color"></category><category term="terminal"></category></entry><entry><title>Cygwin 中的软件包管理工具： apt-cyg</title><link href="https://mozillazg.com/2013/06/cygwin-install-packages-by-apt-cyg.html" rel="alternate"></link><updated>2013-06-23T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2013-06-23:2013/06/cygwin-install-packages-by-apt-cyg.html</id><summary type="html">&lt;p&gt;apt-cyg 可以在 Cygwin 中实现类似 linux 下的 &lt;code&gt;yum&lt;/code&gt; 或 &lt;code&gt;apt-get&lt;/code&gt; 的功能。&lt;/p&gt;
&lt;h2&gt;主页&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://code.google.com/p/apt-cyg/"&gt;http://code.google.com/p/apt-cyg/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ svn --force &lt;span class="nb"&gt;export&lt;/span&gt; http://apt-cyg.googlecode.com/svn/trunk/ /bin/
$ chmod +x /bin/apt-cyg
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;使用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;apt-cyg install &amp;lt;package names&amp;gt;      # 安装软件包&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-cyg install bind-utils
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;apt-cyg remove &amp;lt;package names&amp;gt;      # 移除软件包&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-cyg update     # 更新 setup.ini 文件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-cyg show      # 列出已安装的软件包&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-cyg find &amp;lt;pattern(s)&amp;gt;     # 查找名称匹配的软件包&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-cyg describe &amp;lt;pattern(s)&amp;gt;     # 查找描述匹配的软件包&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;apt-cyg packageof &amp;lt;commands or files&amp;gt;     # 定位命令或文件属于哪个软件包&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ apt-cyg packageof dig
Found usr/bin/dig in the package bind-utils
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;apt-cyg     # 显示帮助信息&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ apt-cyg
apt-cyg: Installs and removes Cygwin packages.
&lt;span class="s2"&gt;&amp;quot;apt-cyg install &amp;lt;package names&amp;gt;&amp;quot;&lt;/span&gt; to install packages
&lt;span class="s2"&gt;&amp;quot;apt-cyg remove &amp;lt;package names&amp;gt;&amp;quot;&lt;/span&gt; to remove packages
&lt;span class="s2"&gt;&amp;quot;apt-cyg update&amp;quot;&lt;/span&gt; to update setup.ini
&lt;span class="s2"&gt;&amp;quot;apt-cyg show&amp;quot;&lt;/span&gt; to show installed packages
&lt;span class="s2"&gt;&amp;quot;apt-cyg find &amp;lt;patterns&amp;gt;&amp;quot;&lt;/span&gt; to find packages matching patterns
&lt;span class="s2"&gt;&amp;quot;apt-cyg describe &amp;lt;patterns&amp;gt;&amp;quot;&lt;/span&gt; to describe packages matching patterns
&lt;span class="s2"&gt;&amp;quot;apt-cyg packageof &amp;lt;commands or files&amp;gt;&amp;quot;&lt;/span&gt; to locate parent packages
Options:
--mirror, -m &amp;lt;url&amp;gt; : &lt;span class="nb"&gt;set&lt;/span&gt; mirror
--cache, -c &amp;lt;dir&amp;gt;  : &lt;span class="nb"&gt;set&lt;/span&gt; cache
--file, -f &amp;lt;file&amp;gt;  : &lt;span class="nb"&gt;read&lt;/span&gt; package names from file
--noupdate, -u     : don&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;t update setup.ini from mirror
--help
--version
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Cygwin"></category></entry><entry><title>pelican 使用笔记</title><link href="https://mozillazg.com/2013/03/pelican-notes.html" rel="alternate"></link><updated>2013-03-04T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2013-03-04:2013/03/pelican-notes.html</id><summary type="html">&lt;p&gt;记录一些使用 Pelican 写博客的经验。&lt;/p&gt;
&lt;h2&gt;Markdown&lt;/h2&gt;
&lt;h3&gt;多级列表&lt;/h3&gt;
&lt;p&gt;官方的 Markdown 语法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;* list
  * sublist
  * sublist
* list
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;pelican 使用的是 python-markdown 来解析 markdown 文件，
而 python-markdown 的关于多级列表的语法跟官方的有点不一样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;* list
    * sublist
    * sublist
* list
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;子列表与父列表之间的对齐方式是：至少空出4个空格或1一个 Tab 键。
官方的语法兼容 python-markdown 的语法，所以不要担心兼容性。&lt;/p&gt;
&lt;h3&gt;语法高亮&lt;/h3&gt;
&lt;p&gt;python-markdown 使用 pygments 来实现语法高亮的功能，并且支持指定编程语言。&lt;/p&gt;
&lt;p&gt;比如，指定代码用的是 Python 编程语言：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;:::python
print &amp;#39;hello, world&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;效果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;hello, world&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我用的比较多的语言标记：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;:::text&lt;/li&gt;
&lt;li&gt;:::python&lt;/li&gt;
&lt;li&gt;:::django&lt;/li&gt;
&lt;li&gt;:::html+django&lt;/li&gt;
&lt;li&gt;:::bash&lt;/li&gt;
&lt;li&gt;:::console&lt;/li&gt;
&lt;li&gt;:::nginx&lt;/li&gt;
&lt;li&gt;:::apacheconf&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多的语言标记，可以通过查看网站 &lt;a href="http://pygments.org/demo/"&gt;Pygments — Python syntax highlighter&lt;/a&gt; 的源代码操作相关的语言标记（查看 id 为 flt_lang 的 select 的 option 值）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：该语法不兼容官方 markdown 语法。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://docs.getpelican.com/"&gt;Pelican — Pelican documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pythonhosted.org/Markdown/extensions/code_hilite.html"&gt;CodeHilite Extension — Python Markdown&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="pelican"></category><category term="markdown"></category><category term="pygments"></category><category term="python-markdown"></category></entry><entry><title>更改 phpMyAdmin 默认访问端口(apache2)</title><link href="https://mozillazg.com/2013/02/change-phpmyadmin-default-visit-port.html" rel="alternate"></link><updated>2013-02-27T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2013-02-27:2013/02/change-phpmyadmin-default-visit-port.html</id><summary type="html">&lt;p&gt;将访问 phpMyAdmin 的端口从默认的 80 改为 8081 。&lt;/p&gt;
&lt;p&gt;本文的 phpmyadmin 目录：&lt;code&gt;/var/www/phpmyadmin/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;编辑 apache 配置文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# vi /etc/apache2/sites-available/phpmyadmin&lt;/span&gt;

&amp;lt;VirtualHost *:8081&amp;gt;
    ServerName 127.0.0.1
    DocumentRoot /var/www/phpmyadmin
&amp;lt;/VirtualHost&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配置 apache 监听 8081 端口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# vi /etc/apache2/ports.conf&lt;/span&gt;

&lt;span class="c1"&gt;# 添加&lt;/span&gt;
NameVirtualHost *:8081
Listen 8081
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;重启 apache 服务：&lt;code&gt;service apache2 restart&lt;/code&gt;，
现在可以通过 http://ip:8081/phpmyadmin/ 访问 phpMyAdmin 了。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://ubuntuforums.org/showthread.php?t=1329607"&gt;PHPMyAdmin Port Change - Ubuntu Forums&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="phpmyadmin"></category><category term="mysql"></category><category term="ubuntu"></category></entry><entry><title>修改 pelican 3.1 使之支持中文文件夹作为分类目录</title><link href="https://mozillazg.com/2013/01/fix-pelican-use-chinese-folder-as-category.html" rel="alternate"></link><updated>2013-01-31T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2013-01-31:2013/01/fix-pelican-use-chinese-folder-as-category.html</id><summary type="html">&lt;p&gt;前提：&lt;/p&gt;
&lt;p&gt;windows + pelican 3.1 + python 2.6    &lt;br /&gt;
并且 pelican 配置文件中设置了 &lt;code&gt;USE_FOLDER_AS_CATEGORY = True&lt;/code&gt;（默认为 True，只要不设置为 False 即可）&lt;/p&gt;
&lt;p&gt;默认情况下，pelican 不支持中文文件夹作为分类目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;d:\myblog&amp;gt;pelican content -o output -s pelicanconf.py -D&lt;/span&gt;
&lt;span class="go"&gt;...&lt;/span&gt;

&lt;span class="go"&gt;CRITICAL: &amp;#39;utf8&amp;#39; codec can&amp;#39;t decode byte 0xd3 in position 2: invalid continuation byte&lt;/span&gt;
&lt;span class="go"&gt;Traceback (most recent call last):&lt;/span&gt;
&lt;span class="go"&gt;  File &amp;quot;C:\Python26\Scripts\pelican-script.py&amp;quot;, line 9, in &amp;lt;module&amp;gt;&lt;/span&gt;
&lt;span class="go"&gt;    load_entry_point(&amp;#39;pelican==3.1&amp;#39;, &amp;#39;console_scripts&amp;#39;, &amp;#39;pelican&amp;#39;)()&lt;/span&gt;
&lt;span class="go"&gt;  File &amp;quot;C:\Python26\lib\site-packages\pelican\__init__.py&amp;quot;, line 319, in main&lt;/span&gt;
&lt;span class="go"&gt;    pelican.run()&lt;/span&gt;
&lt;span class="go"&gt;  File &amp;quot;C:\Python26\lib\site-packages\pelican\__init__.py&amp;quot;, line 152, in run&lt;/span&gt;
&lt;span class="go"&gt;    p.generate_context()&lt;/span&gt;
&lt;span class="go"&gt;  File &amp;quot;C:\Python26\lib\site-packages\pelican\generators.py&amp;quot;, line 337, in generate_context&lt;/span&gt;
&lt;span class="go"&gt;    .decode(&amp;#39;utf-8&amp;#39;)&lt;/span&gt;
&lt;span class="go"&gt;  File &amp;quot;C:\Python26\lib\encodings\utf_8.py&amp;quot;, line 16, in decode&lt;/span&gt;
&lt;span class="go"&gt;    return codecs.utf_8_decode(input, errors, True)&lt;/span&gt;
&lt;span class="go"&gt;UnicodeDecodeError: &amp;#39;utf8&amp;#39; codec can&amp;#39;t decode byte 0xd3 in position 2: invalid continuation byte&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从错误信息中我们可以看到 pelican 对文件夹名称默认按 utf8 编码进行解码，而在 windows 下文件（夹）名称默认是按 gbk 进行编码的，所以就出现了编码错误。&lt;/p&gt;
&lt;p&gt;下面我们来修复这个错误。&lt;/p&gt;
&lt;p&gt;编辑文件 &lt;code&gt;C:\Python26\lib\site-packages\pelican\generators.py&lt;/code&gt; 进行以下两步操作即可：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先导入 sys 模块：&lt;code&gt;import sys&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后编辑第 338 行左右的&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;category&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;basename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dirname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;\
           &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;category&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;basename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dirname&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;\
           &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此处的修改是为了让程序使用系统默认的输入编码（简体中文版 Windows 下默认是 gbk）进行解码。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;进行相关修改后，再次执行 &lt;code&gt;pelican content -o output -s pelicanconf.py -D&lt;/code&gt; 生成 html 文件，执行过程一切顺利。&lt;/p&gt;
&lt;p&gt;但也有一个不完美的地方：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/static/images/2013-1-pelican-issue-01.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/static/images/2013-1-pelican-issue-02.png" /&gt;&lt;/p&gt;
&lt;p&gt;虽然在浏览器中这个不会是乱码，但看起来还是有点不爽。
下面我们要将它变成中文拼音，这样就不会乱码了。&lt;/p&gt;
&lt;p&gt;继续编辑 generators.py 文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;导入相关模块：&lt;code&gt;from pelican.utils import slugify&lt;/code&gt; 。
   这个模块的作用是将非 ASCII 字符转换为 ASCII 字符，比如，将 &lt;code&gt;中国&lt;/code&gt; 转换为 &lt;code&gt;zhong-guo&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;将 199 行左右的&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arts&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;categories&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;arts&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;attrgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;date&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;改为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arts&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;categories&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cat&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;arts&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;attrgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;date&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;修改后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/static/images/2013-1-pelican-fixed-01.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="/static/images/2013-1-pelican-fixed-02.png" /&gt;&lt;/p&gt;</summary><category term="pelican"></category><category term="python"></category></entry><entry><title>使用 Pelican 生成静态博客</title><link href="https://mozillazg.com/2013/01/use-pelican-to-generate-static-blog.html" rel="alternate"></link><updated>2013-01-15T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2013-01-15:2013/01/use-pelican-to-generate-static-blog.html</id><summary type="html">&lt;h2&gt;安装 Pelican&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;sudo pip install pelican&lt;/span&gt;
&lt;span class="go"&gt;sudo pip install webassets&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;使用&lt;/h2&gt;
&lt;h3&gt;配置&lt;/h3&gt;
&lt;h3&gt;主题&lt;/h3&gt;</summary><category term="pelican"></category></entry></feed>