<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>mozillazg's Blog</title><link>https://mozillazg.com/</link><description></description><lastBuildDate>Sat, 13 Jul 2024 00:00:00 +0000</lastBuildDate><item><title>[译] BPF CO-RE 参考指南 (2021)</title><link>https://mozillazg.com/2024/07/bpf-core-reference-guide-zh.html</link><description>&lt;p&gt;本文译自 &lt;a class="reference external" href="https://nakryiko.com/posts/bpf-core-reference-guide/"&gt;BPF CO-RE reference guide - Andrii Nakryiko's Blog&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="section-1"&gt;
&lt;span id="the-missing-manual"&gt;&lt;/span&gt;&lt;h2 id="hidsection-1"&gt;缺失的手册&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;BPF CO-RE (Compile Once – Run Everywhere)（一次编译，到处运行）是一种现代的用于编写可移植 BPF 应用程序的方法。
通过这个方法编写的 BPF 程序无需修改就能在多个内核版本和配置上运行，
并且还不需要在目标机器上编译源代码。
这与更传统的 &lt;a class="reference external" href="https://github.com/iovisor/bcc"&gt;BCC&lt;/a&gt; 框架提供的方法形成鲜明对比，
后者将 BPF 应用程序源代码编译推迟到目标主机的运行时，这需要携带庞大的编译器工具链才能实现。
请查看 &lt;a class="reference external" href="https://nakryiko.com/posts/bpf-portability-and-co-re/"&gt;这篇博文&lt;/a&gt; ，
它介绍了 BPF CO-RE 的概念，并解释了为什么这对许多真实世界的 BPF 应用程序至关重要和必要，
以及在没有 &lt;a class="reference external" href="https://nakryiko.com/posts/btf-dedup/"&gt;内核 BTF&lt;/a&gt; 的情况下，这会变得多么困难。&lt;/p&gt;
&lt;p&gt;随着 BPF CO-RE 成为一种成熟的方法，关于其所有功能以及如何在实践中使用它的一些建议非常缺失。
在这篇博客文章中，我将尝试填补这一空白，并将介绍 BPF CO-RE
（以及作为其官方实现的 &lt;a class="reference external" href="https://github.com/libbpf/libbpf"&gt;libbpf&lt;/a&gt; ）提供的所有不同功能。
如果您之前编写过 BPF CO-RE 应用程序，您很可能已经使用了本文描述的一些功能。
但遗憾的是，其中一些功能仍然鲜为人知。然而，正是这些鲜为人知的 BPF CO-RE 秘密有时
使真实世界的 BPF 应用程序变得可行，简单且易于实现和支持，避免了在主机上编译或预编译同一 BPF 应用程序的
多个变体（flavors），每个变体针对不同的内核。&lt;/p&gt;
&lt;p&gt;这篇文章很长，但因为它的目标是作为一个参考指南，因此将其保持为一个整体而不是将其分成几个部分分几周发布会更好。
它分为三个部分，从最常用的功能开始，逐渐向更高级和不太常用的功能发展，
希望能够自然地引导刚开始使用 BPF CO-RE 范式编写 BPF 应用程序的人。&lt;/p&gt;
&lt;p&gt;在本文中，我将假设您正在使用 &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; ，它为内核提供了 CO-RE 可重定位类型定义（CO-RE-relocatable type definitions），
这个文件可以通过 &lt;tt class="docutils literal"&gt;bpftool&lt;/tt&gt; 工具生成。如果您对 &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; 不熟悉，请参阅
&lt;a class="reference external" href="https://nakryiko.com/posts/libbpf-bootstrap/#includes-vmlinux-h-libbpf-and-app-headers"&gt;libbpf-bootstrap 博文&lt;/a&gt;
。在接近文章末尾的更高级用法部分，我还将详细介绍如何在没有 &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; 的情况下使用 BPF CO-RE。&lt;/p&gt;
&lt;p&gt;在讨论过程中，我会尽量保持高层次的描述，除非绝对必要我将避免深入到细节的实现部分。
如果您想进一步了解，建议查看 &lt;a class="reference external" href="https://github.com/libbpf/libbpf/tree/master/src/bpf_core_read.h"&gt;bpf_core_read.h&lt;/a&gt;
头文件，以及在 &lt;a class="reference external" href="http://vger.kernel.org/vger-lists.html#bpf"&gt;BPF 邮件列表&lt;/a&gt; 中提问。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;span id="reading-kernel-data"&gt;&lt;/span&gt;&lt;h2 id="hidsection-2"&gt;读取内核数据&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;目前，BPF CO-RE 操作中最常见的操作是从内核结构中读取字段的值。
libbpf 提供了一整套辅助函数，使得读取字段变得简单且 CO-RE 可重定位（CO-RE-relocatable）。
&lt;strong&gt;CO-RE 可重定位&lt;/strong&gt; 意味着无论结构体的实际内存布局如何（这取决于实际使用的 &lt;em&gt;内核版本&lt;/em&gt; 和 &lt;em&gt;内核配置&lt;/em&gt; ），
BPF 程序将被调整以在结构体的开始处相对正确的偏移处读取字段。&lt;/p&gt;
&lt;div class="section" id="bpf-core-read-1"&gt;
&lt;span id="bpf-core-read"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-read-1"&gt;bpf_core_read()&lt;a class="headerlink" href="#hidbpf-core-read-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;最基本的以 CO-RE 可重定位方式读取字段的辅助函数是 &lt;tt class="docutils literal"&gt;bpf_core_read(dst, sz, src)&lt;/tt&gt; ，
它将从 &lt;tt class="docutils literal"&gt;src&lt;/tt&gt; 引用的字段中读取 &lt;tt class="docutils literal"&gt;sz&lt;/tt&gt; 字节，然后将其读入 &lt;tt class="docutils literal"&gt;dst&lt;/tt&gt; 指向的内存中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;bpf_get_current_task&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent_task&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bpf_core_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;parent_task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* handle error */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* parent_task contains the value of task-&amp;gt;parent pointer */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;bpf_core_read()&lt;/tt&gt; 与 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel()&lt;/tt&gt; BPF 辅助函数类似，
不同之处在于它记录的是应该在目标内核上重新定位的字段的信息。
比如，如果由于在 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 前面添加了新字段而导致其中的 &lt;tt class="docutils literal"&gt;parent&lt;/tt&gt; 字段被移动到了不同的偏移量，
libbpf 将自动调整实际偏移量到正确的值。&lt;/p&gt;
&lt;p&gt;有一个重要的一点需要记住，字段的 &lt;strong&gt;大小&lt;/strong&gt; &lt;em&gt;并不会自动重定位&lt;/em&gt; ，
只有其偏移量会自动重定位。所以，如果你正在读取的字段是一个 &lt;tt class="docutils literal"&gt;struct&lt;/tt&gt; ， 并且其大小发生了变化，你可能会遇到问题。
请参阅 &lt;a class="reference external" href="#sizing-kernel-types-and-fields"&gt;&amp;quot;计算内核类型和字段的大小&amp;quot;&lt;/a&gt;
部分以了解处理这种情况的方法。一般的建议是尽可能不要将整个结构体字段一次性读取，最好只读取你最感兴趣的基本字段。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bpf-core-read-str-1"&gt;
&lt;span id="bpf-core-read-str"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-read-str-1"&gt;bpf_core_read_str()&lt;a class="headerlink" href="#hidbpf-core-read-str-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;就像有 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel()&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel_str()&lt;/tt&gt; 这一对 BPF 助手函数一样，
前者读取指定数量的字节，而后者读取一个变长的以零结尾的 C 字符串，
&lt;tt class="docutils literal"&gt;bpf_core_read()&lt;/tt&gt; 也有个对应的函数 &lt;tt class="docutils literal"&gt;bpf_core_read_str()&lt;/tt&gt; 。
它的工作方式类似于 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel_str()&lt;/tt&gt; ，不同之处在于它记录了包含以零结尾的 C 字符串的源字符数组字段
的 CO-RE 重定位信息。因此，&lt;tt class="docutils literal"&gt;bpf_core_read_str()&lt;/tt&gt; 是 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel_str()&lt;/tt&gt; 的可 CO-RE 重定位版本。&lt;/p&gt;
&lt;p&gt;注意 &lt;strong&gt;字符数组&lt;/strong&gt; 字段和 &lt;strong&gt;字符指针&lt;/strong&gt; 字段之间的重要但微妙区别。在 C 语言中，当读取字符串值时，它们可以互换使用，
因为编译器会自动将数组视为指针。然而，在 CO-RE 的上下文中，这种区别 &lt;em&gt;非常重要&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;让我们来看看我们希望读取的假想内核类型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;my_kernel_type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;name&lt;/tt&gt; 字段指向存储字符串的位置，但 &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; 字段实际上 &lt;strong&gt;就是&lt;/strong&gt; 包含字符串的内存。
如果您需要使用 CO-RE 读取 &lt;tt class="docutils literal"&gt;name&lt;/tt&gt; 指向的字符串，正确的处理方式是首先以 CO-RE 可重定位的方式读取指针的值，
然后进行普通的（非 CO-RE） &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel_str()&lt;/tt&gt;  读取（为简洁起见，下面的示例忽略了错误处理）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;my_kernel_type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="cm"&gt;/* get string pointer, CO-RE-relocatable */&lt;/span&gt;
&lt;span class="n"&gt;bpf_core_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/* read the string, non-CO-RE-relocatable, pointer is valid regardless */&lt;/span&gt;
&lt;span class="n"&gt;bpf_probe_read_kernel_str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们需要读取 &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; 字符串，相应的示例将是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;my_kernel_type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="cm"&gt;/* read string as CO-RE-relocatable */&lt;/span&gt;
&lt;span class="n"&gt;bpf_core_read_str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请花点时间思考为什么第一个示例不能使用 &lt;tt class="docutils literal"&gt;bpf_core_read_str()&lt;/tt&gt;
（_提示_ ：您可能会将 &lt;strong&gt;指针值&lt;/strong&gt; 解释为 C 字符串本身），
以及为什么第二个示例不能作为指针读取然后在进行字符串读取
（_提示_ ：字符串本身是结构体的一部分，所以没有专用指针，它位于相对于 &lt;tt class="docutils literal"&gt;t&lt;/tt&gt; 指针指向位置的
&lt;strong&gt;偏移量&lt;/strong&gt; ）。这种情况很微妙，幸运的是很少遇到，但如果您不清楚这种差异，在实践中可能会感到非常困惑。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bpf-core-read-2"&gt;
&lt;span id="bpf-core-read-1-1"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-read-2"&gt;BPF_CORE_READ()&lt;a class="headerlink" href="#hidbpf-core-read-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;bpf_core_read()&lt;/tt&gt; 函数虽然允许进行大量的控制和精细的错误处理，但直接使用起来确实有些繁琐，
特别是在读取需要通过较长指针解引用链访问的字段时。&lt;/p&gt;
&lt;p&gt;让我们来看一个读取运行中进程的可执行文件名称的例子。
如果你正在用 C 语言编写简单的内核代码，并想要实现这个功能，你需要像下面这样做：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fpath&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/* now read string contents with bpf_probe_read_kernel_str() */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意指针解引用的顺序，其中夹杂了一些子结构的访问（即 &lt;tt class="docutils literal"&gt;fpath.dentry&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;d_name.name&lt;/tt&gt; ）。
使用 &lt;tt class="docutils literal"&gt;bpf_core_read()&lt;/tt&gt; 做这样的事情很快就会变得一团糟：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;mm_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;file&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;dentry&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;bpf_core_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;bpf_core_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;bpf_core_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;bpf_core_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* now read string contents with bpf_probe_read_kernel_str() */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;诚然，这是一个相当极端的例子，通常指针解引用链不会那么长，但观点依然存在：
使用这种方法是很痛苦的。尽管上面的例子完全忽略了错误处理，但这一切仍然存在。&lt;/p&gt;
&lt;p&gt;为了更容易编写这样的多步读取操作，libbpf 提供了 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 宏。
让我们看看如何通过使用 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 简化上述代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_CORE_READ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fpath&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* now read string contents with bpf_probe_read_kernel_str() */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对比一下 &amp;quot;原生 C&amp;quot; 示例和使用 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 的示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* direct pointer dereference */&lt;/span&gt;
&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fpath&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/* using BPF_CORE_READ() helper */&lt;/span&gt;
&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_CORE_READ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fpath&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基本上，每个指针解引用在宏调用中都会被转换成逗号，而每个子结构访问则保持原样。非常简单明了。&lt;/p&gt;
&lt;p&gt;你可能已经注意到 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 直接返回读取的值，不会传播错误。
如果任何指针为 NULL 或指向无效内存，你将会得到 &lt;tt class="docutils literal"&gt;0&lt;/tt&gt; （或 &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt; ）作为返回值。
但如果你需要错误传播和处理，你就必须使用低级的 &lt;tt class="docutils literal"&gt;bpf_core_read()&lt;/tt&gt; 原语并显式地处理错误。
在实践中，这通常不是问题或必要的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bpf-core-read-into-1"&gt;
&lt;span id="bpf-core-read-into"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-read-into-1"&gt;BPF_CORE_READ_INTO()&lt;a class="headerlink" href="#hidbpf-core-read-into-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在某些情况下，将结果读入目标内存而不是直接返回结果可能必要的或更方便的，
比如当你从 C 数组中读取值时（比如，从套接字结构中读取 IPv4 地址），因为 C 语言不允许直接从表达式中返回数组。
对于这种情况，libbpf 提供了 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_INTO()&lt;/tt&gt; 宏，它的行为类似于 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; ，
除了会将最终字段的值读入目标内存。将上述示例转换为 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_INTO()&lt;/tt&gt; ，我们将得到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_CORE_READ_INTO&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;binfmt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;executable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fpath&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* handle errors */&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cm"&gt;/* now `name` contains the pointer to the string */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意在 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_INTO()&lt;/tt&gt; 中添加了额外的 &lt;tt class="docutils literal"&gt;&amp;amp;name&lt;/tt&gt; ，以及可以获取上次操作的错误代码
（比如，读取 &lt;tt class="docutils literal"&gt;d_name.name&lt;/tt&gt; ）。总的来说， &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 在实践中更加方便，更易于阅读。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bpf-core-read-str-into-1"&gt;
&lt;span id="bpf-core-read-str-into"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-read-str-into-1"&gt;BPF_CORE_READ_STR_INTO()&lt;a class="headerlink" href="#hidbpf-core-read-str-into-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;对于最后一个字段是字符数组字段的情况（就像上面的假设示例中的 &lt;tt class="docutils literal"&gt;name&lt;/tt&gt; vs &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; 一样），
有一个对应的 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_STR_INTO()&lt;/tt&gt; 宏，你现在应该对它的工作原理有一个很好的猜测了。
如果没有，请重新查看 &lt;a class="reference external" href="#bpf-core-read-str"&gt;bpf_core_read_str()&lt;/a&gt; 部分。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="btf-enabled-bpf"&gt;
&lt;span id="btf-enabled-bpf-program-types-with-direct-memory-reads"&gt;&lt;/span&gt;&lt;h3 id="hidbtf-enabled-bpf"&gt;可以直接读取内存的 BTF-enabled 的 BPF 程序类型&lt;a class="headerlink" href="#hidbtf-enabled-bpf" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在上面讨论了 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 系列宏之后，有个非常重要一点需要注意，
那就是您并不总是需要使用它们来进行 CO-RE 可重定位读取。
或者说，并不总是需要通过 &lt;em&gt;&amp;quot;probe read&amp;quot;&lt;/em&gt; 的方式（比如，使用 BPF 辅助函数来读取）来读取内存。
有时候你可以 &lt;em&gt;直接访问&lt;/em&gt; 内核内存。&lt;/p&gt;
&lt;p&gt;一些 BPF 程序类型是 &amp;quot;BTF-enabled&amp;quot;，这意味着内核中的 BPF 验证器知道与传递给 BPF 程序的输入参数相关联的类型信息。
这使得 BPF 验证器能够知道哪些内存可以在不调用 &lt;tt class="docutils literal"&gt;bpf_core_read()&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel()&lt;/tt&gt; 的情况下直接
从内核中安全读取。其中一些 BTF-enabled BPF 程序类型包括：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;BTF-enabled raw tracepoint (libbpf 术语中的 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;SEC(&amp;quot;tp_btf/...&amp;quot;)&lt;/span&gt;&lt;/tt&gt; );&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;fentry&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;fexit&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;fmod_ret&lt;/tt&gt; BPF 程序;&lt;/li&gt;
&lt;li&gt;BPF LSM 程序;&lt;/li&gt;
&lt;li&gt;可能还有一些，但是我懒得去确认了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这些程序中，如果它们获取到某种内核类型的指针（例如， &lt;tt class="docutils literal"&gt;struct task_struct *&lt;/tt&gt; ），
BPF 程序代码可以直接访问内存进行解引用，甚至可以跟踪指针。
因此，在我们上面用来演示 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 使用的详细示例中，
当使用 &lt;tt class="docutils literal"&gt;fentry&lt;/tt&gt; BPF 程序时，你所需要做的只是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;binfmt&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;executable&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fpath&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是的，这与 “原生 C” 的假设示例完全相同。但请记住，要获取字符串的内容本身，
您仍然需要使用 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel_str()&lt;/tt&gt; 。&lt;/p&gt;
&lt;p&gt;这种直接访问内存的方法快速、方便且简单，您应当在可能的情况下尽量使用这种方法。
不幸的是，在许多真实世界的场景下，您仍然必须明确依赖于 “probe reading”，
因此 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 将在可预见的未来成为您的朋友，因此一定要熟悉它。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;span id="reading-bitfields-and-integers-of-varying-sizes"&gt;&lt;/span&gt;&lt;h3 id="hidsection-3"&gt;读取不同大小的位域和整数&lt;a class="headerlink" href="#hidsection-3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;从 BPF 中读取位域（bitfields）一直是一个挑战。BPF 应用程序开发人员必须费尽心思地编写非常难维护和极其痛苦的的代码，
才能从内核类型中提取位域值。以 &lt;tt class="docutils literal"&gt;struct tcp_sock&lt;/tt&gt; 为例。
它包含了很多编码为位字域的有用信息。即便使用 BCC 及其源代码编译方法，
提取这些位域仍然是一个主要的麻烦和维护负担。&lt;/p&gt;
&lt;p&gt;幸运的是，libbpf 提供了两个易于使用的宏，用于以 CO-RE 可重定位的方式读取位域：
&lt;tt class="docutils literal"&gt;BPF_CORE_READ_BITFIELD()&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_BITFIELD_PROBED()&lt;/tt&gt; 。
当要读取的数据需要进行 &amp;quot;probe read&amp;quot; 时，必须使用 &lt;tt class="docutils literal"&gt;_PROBED&lt;/tt&gt; 变体，
就像使用 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 一样。只有在可以直接访问内存时
（例如，来自 &lt;tt class="docutils literal"&gt;fentry/&lt;/tt&gt; BPF 程序，参见上文
&lt;a class="reference external" href="#btf-enabled-bpf-program-types-with-direct-memory-reads"&gt;&amp;quot;可以直接读取内存的 BTF-enabled 的 BPF 程序类型&amp;quot;&lt;/a&gt; 部分），
才应该使用 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_BITFIELD()&lt;/tt&gt; 。
这两个宏都以 &lt;tt class="docutils literal"&gt;u64&lt;/tt&gt; 整数的形式返回位域的值。
下面是从 &lt;tt class="docutils literal"&gt;struct tcp_sock&lt;/tt&gt; 中读取位字段的示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;u64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;sk_get_syn_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;tcp_sock&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* extract tp-&amp;gt;syn_data bitfield value */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_CORE_READ_BITFIELD_PROBED&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;syn_data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是这么简单。使用 BCC，实现相同效果可能会导致如下结果
（作为练习，读者可以自行思考为什么这样可以工作以及何时会出现问题）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;u64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;sk_get_syn_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;tcp_sock&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;u8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* get byte before tlp_high_seq */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;bpf_probe_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;tlp_high_seq&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* syn_data is the third bit of that byte in little-endian */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;随着内核版本的变化，编写、阅读和维护 &lt;tt class="docutils literal"&gt;struct tcp_sock&lt;/tt&gt; 变得越来越困难，令人感到头痛。
但有了 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_BITFIELD_PROBED()&lt;/tt&gt; 后，这些问题就都迎刃而解了，变得轻而易举。&lt;/p&gt;
&lt;p&gt;值得注意的是 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_BITFIELD()&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_BITFIELD_PROBED()&lt;/tt&gt; 还有一个重要特性。
它们不仅可以读取位域，还可以读取 &lt;strong&gt;任意整数&lt;/strong&gt; 字段。无论字段的实际类型是什么（位域或最多 8 字节大小的整数），
这些宏都会正确地返回符号扩展的 8 字节整数。即使字段从整数变为位域，或者反之，它们仍然能正常工作。
即使字段从 &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; 变为 &lt;tt class="docutils literal"&gt;u8&lt;/tt&gt; ，它们也可以继续工作。
因此， &lt;tt class="docutils literal"&gt;BPF_CORE_READ_BITFIELD()&lt;/tt&gt; 宏是 &lt;strong&gt;一种通用的读取任何整数字段&lt;/strong&gt; 的方法，不受字段性质或大小的限制。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;span id="sizing-kernel-types-and-fields"&gt;&lt;/span&gt;&lt;h3 id="hidsection-4"&gt;计算内核类型和字段的大小&lt;a class="headerlink" href="#hidsection-4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;正如在前面某个小节中提到的， &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 并不会自动让读取大小不固定的字段（例如整个结构体或数组）的操作变得
CO-RE 可重定位，因为在内核中预先分配足够的目标内存以适应任何的大小变化通常相当的困难。&lt;/p&gt;
&lt;p&gt;然而，在某些情况下，了解字段或类型的大小是很重要的。为了满足这种需求，
BPF CO-RE 提供了两个辅助函数： &lt;tt class="docutils literal"&gt;bpf_core_type_size()&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;bpf_core_field_size()&lt;/tt&gt; 。
它们的使用方式类似于 &lt;tt class="docutils literal"&gt;bpf_core_type_exists()&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;bpf_core_field_exists()&lt;/tt&gt; （将在下一节中介绍），
不同的是，它们不返回 0 或 1，而是以字节为单位返回字段或类型的大小。&lt;/p&gt;
&lt;p&gt;您可以根据需要自行处理这个值：您可以将其作为第二个参数传递给 &lt;tt class="docutils literal"&gt;bpf_core_read()&lt;/tt&gt; ，
让读取变得完全 CO-RE 可重定位。如果您处理的是结构体数组，并且需要跳过前几个实例，
您可以使用 &lt;tt class="docutils literal"&gt;bpf_core_type_size()&lt;/tt&gt; 来计算正确的字节偏移量，以便找到第 N 个元素的起始位置。
或者您可以仅将其用于调试和报告用途，这完全取决于您，BPF CO-RE 并没有限制您如何使用它的特性。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;span id="dealing-with-kernel-changes-and-feature-detection"&gt;&lt;/span&gt;&lt;h2 id="hidsection-5"&gt;处理内核变更和特性检测&lt;a class="headerlink" href="#hidsection-5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 系列宏是 BPF CO-RE 的主力军，然而使用 BPF CO-RE 构建实用的 BPF 应用程序还需要更多的技巧。&lt;/p&gt;
&lt;p&gt;BPF 应用程序经常需要处理的一个常见问题是进行特性检测。也就是说，检测特定主机内核是否支持某种新的可选特性，
BPF 应用程序可以利用这些特性来获取更多信息或提高效率。如果不支持，
BPF 应用程序会选择回退到支持旧版内核的代码，而不是简单地直接失败。&lt;/p&gt;
&lt;p&gt;BPF CO-RE 提供了多种不同的机制来满足这类需求。当然，除了特性检测外，您也可以在其他场景下使用下面介绍的机制，
但是，我将以特性检测为主要场景来介绍所有的内容。&lt;/p&gt;
&lt;div class="section" id="bpf-core-field-exists-1"&gt;
&lt;span id="bpf-core-field-exists"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-field-exists-1"&gt;bpf_core_field_exists()&lt;a class="headerlink" href="#hidbpf-core-field-exists-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;bpf_core_field_exists()&lt;/tt&gt; 函数允许检查给定的内核类型是否包含特定的字段。
在内核特性检测的场景下中，如果某个期望的内核特性在被引入的时候，还引入了一些特定字段到其中一个内核类型，
那么就可以简单的通过直接使用 &lt;tt class="docutils literal"&gt;bpf_core_field_exists()&lt;/tt&gt; 函数来检测这类特性。&lt;/p&gt;
&lt;p&gt;举个具体的例子，一种检测内核是否支持 BPF cookie for perf-based BPF program types（tracepoints、kprobes、uprobes）
（由 &lt;a class="reference external" href="https://github.com/torvalds/linux/commit/82e6b1eee6a8875ef4eacfd60711cce6965c6b04"&gt;这个提交&lt;/a&gt; 引入）
特性的方法是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;bpf_attr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* could be NULL */&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_core_field_exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;link_create&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;perf_event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bpf_cookie&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* bpf_cookie is supported */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* bpf_cookie is NOT supported */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的示例假设 BPF 程序中有一个 &lt;tt class="docutils literal"&gt;union bpf_attr *&lt;/tt&gt; 类型的变量。
这个变量可以是 &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt; ，这实际上并不重要，因为指针本身从未被读取，
它只是为了向编译器传递类型信息而存在。
对于没有所需类型的现成变量可用的场景，您可以编写如下等效的检查代码（利用 C 语言的类型系统特性）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_core_field_exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;bpf_attr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;link_create&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;perf_event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bpf_cookie&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* bpf_cookie is supported */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* bpf_cookie is NOT supported */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这段代码中，如果主机内核的 &lt;tt class="docutils literal"&gt;union bpf_attr&lt;/tt&gt; 中没有 &lt;tt class="docutils literal"&gt;link_create.perf_event.bpf_cookie&lt;/tt&gt; ，
那么 &lt;tt class="docutils literal"&gt;if&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;else&lt;/tt&gt; 结构中的第一个分支中的代码将 &lt;em&gt;永远不会被执行&lt;/em&gt; （也 &lt;em&gt;不会被验证&lt;/em&gt; ）。&lt;/p&gt;
&lt;p&gt;值得重申的是 BPF 验证器会正确地将这样的代码识别为 &lt;strong&gt;死代码（dead code）&lt;/strong&gt; ，
因此这些代码 &lt;strong&gt;不会被验证&lt;/strong&gt; 。这意味着这样的代码可以使用主机内核上不存在的
内核和 BPF 功能（比如，新的 BPF 辅助函数），并且不需要担心 BPF 验证失败的问题。
比如，如果上述第一个分支要使用 &lt;tt class="docutils literal"&gt;bpf_get_attach_cookie()&lt;/tt&gt; 辅助函数来使用 BPF cookie 特性，
那么该程序将能够在尚未具有该辅助函数的旧内核上被正确的验证。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bpf-core-type-exists-1"&gt;
&lt;span id="bpf-core-type-exists"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-type-exists-1"&gt;bpf_core_type_exists()&lt;a class="headerlink" href="#hidbpf-core-type-exists-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在一些场景下，类型的存在本身就很重要，BPF CO-RE 提供了一种检查类型存在性的方式，
即 &lt;tt class="docutils literal"&gt;bpf_core_type_exists()&lt;/tt&gt; 辅助函数。
以下是一个检测内核是否支持 BPF 环形缓冲区（ring buffer）的示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_core_type_exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;bpf_ringbuf&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* BPF ringbuf helpers (e.g., bpf_ringbuf_reserve()) exist */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请务必确保你在某处定义了 &lt;tt class="docutils literal"&gt;struct bpf_ringbuf&lt;/tt&gt; （即使是空的），
否则你将会检查 &lt;tt class="docutils literal"&gt;bpf_ringbuf&lt;/tt&gt; 的 &lt;strong&gt;前向声明（forward declaration）&lt;/strong&gt; 是否存在，
这几乎肯定不是你想要的结果。在足够新的 &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; 中，这应该不会成为问题，但是仍然需要注意这一点。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bpf-core-enum-value-exists-1"&gt;
&lt;span id="bpf-core-enum-value-exists"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-enum-value-exists-1"&gt;bpf_core_enum_value_exists()&lt;a class="headerlink" href="#hidbpf-core-enum-value-exists-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;能够检测特定枚举值是否存在是非常有用的。这种检查的一个重要的实际应用是 &lt;strong&gt;检测是否支持某个 BPF 辅助函数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;每个 BPF 辅助函数都对应着 &lt;tt class="docutils literal"&gt;enum bpf_func_id&lt;/tt&gt; 中的一个枚举值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bpf_func_id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;BPF_FUNC_ringbuf_output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;130&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;BPF_FUNC_ringbuf_reserve&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;131&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此，检查 BPF 助手函数 &lt;tt class="docutils literal"&gt;bpf_xxx()&lt;/tt&gt; 是否存在的最简单方法是检查 &lt;tt class="docutils literal"&gt;enum bpf_func_id&lt;/tt&gt; 中是否存在 &lt;tt class="docutils literal"&gt;BPF_FUNC_xxx&lt;/tt&gt; 。
因此，与在之前的示例中使用 &lt;tt class="docutils literal"&gt;bpf_core_type_exists(struct bpf_ringbuf)&lt;/tt&gt; 进行类型检查不同，我们可以更明确地表达我们的意图：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_core_enum_value_exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bpf_func_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_FUNC_ringbuf_reserve&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* use bpf_ringbuf_reserve() safely */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* fall back to using bpf_perf_event_output() */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;许多其他 BPF 功能也可以类似地被检测到。BPF 程序类型和 BPF map 类型的支持只是另一个例子。&lt;/p&gt;
&lt;p&gt;当然，这种功能并不仅限于与 BPF 相关的功能。任何可以通过字段、类型或枚举值的存在
来检测的内核特性都可以轻松地通过 BPF CO-RE 进行处理。&lt;/p&gt;
&lt;p&gt;特性检测也不仅仅局限于基于类型系统的检查。在接下来的几节中，我们将看一些其他可以用于执行内核特性检测的 BPF CO-RE 机制。而且不仅仅是特性检测，它们还允许在运行时提取内核特定信息（如 Kconfig 值），这通常无法被事先知道。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="linux-kernel-version-1"&gt;
&lt;span id="linux-kernel-version"&gt;&lt;/span&gt;&lt;h3 id="hidlinux-kernel-version-1"&gt;LINUX_KERNEL_VERSION&lt;a class="headerlink" href="#hidlinux-kernel-version-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有时候检测必要功能存在的唯一方法是通过检查 Linux 内核版本。
Libbpf 允许在 BPF 程序代码中使用特殊的 &lt;tt class="docutils literal"&gt;extern&lt;/tt&gt; 变量来实现这一点。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LINUX_KERNEL_VERSION&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦声明了 &lt;tt class="docutils literal"&gt;LINUX_KERNEL_VERSION&lt;/tt&gt; ，它会以与内核本身相同的方式编码当前运行的内核版本。
这样的变量可以像任何其他变量一样使用：可以与之进行比较，打印它，记录并发送到用户态（user-space）等。
在所有的这些情况下，BPF 验证器都知道它的确切值，因此它可以检测死代码，就像上面描述的基于类型系统的检查一样。&lt;/p&gt;
&lt;p&gt;Libbpf 还提供了一个方便的 &lt;tt class="docutils literal"&gt;KERNEL_VERSION(major, minor, patch)&lt;/tt&gt; 宏，用于与 &lt;tt class="docutils literal"&gt;LINUX_KERNEL_VERSION&lt;/tt&gt; 进行比较：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;bpf/bpf_helpers.h&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LINUX_KERNEL_VERSION&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LINUX_KERNEL_VERSION&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;KERNEL_VERSION&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* we are on v5.15+ */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="kconfig-extern"&gt;
&lt;span id="kconfig-extern-variables"&gt;&lt;/span&gt;&lt;h3 id="hidkconfig-extern"&gt;Kconfig extern 变量&lt;a class="headerlink" href="#hidkconfig-extern" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;事实上，libbpf 允许为任何内核配置（Kconfig）值声明特殊的 &lt;tt class="docutils literal"&gt;extern&lt;/tt&gt; 变量。
请记住，这 &lt;em&gt;仅在内核通过 /proc/config.gz 公开其内核配置时&lt;/em&gt; 才被支持，
幸运的是，这在现代 Linux 发行版中是非常普遍的情况。
libbpf 支持几种不同类型的变量。它们的使用取决于实际的 Kconfig 值类型：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;对于 &lt;tt class="docutils literal"&gt;y&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;n&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;m&lt;/tt&gt; 三态（tri-state） Kconfig 值，您可以使用 &lt;tt class="docutils literal"&gt;extern enum libbpf_tristate&lt;/tt&gt; 变量，
它定义了三个可能的值： &lt;tt class="docutils literal"&gt;TRI_YES&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;TRI_NO&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;TRI_MODULE&lt;/tt&gt; 。
或者，声明一个 &lt;tt class="docutils literal"&gt;extern char&lt;/tt&gt; 变量，它将直接捕获字符值
（比如，您将确实拥有一个具有 &lt;tt class="docutils literal"&gt;'y'&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;'n'&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;'m'&lt;/tt&gt; 字符值之一的变量）。&lt;/li&gt;
&lt;li&gt;对于 &lt;tt class="docutils literal"&gt;y&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;n&lt;/tt&gt; 两状态（two-state）（布尔值）的 Kconfig 值，您还可以使用 &lt;tt class="docutils literal"&gt;bool&lt;/tt&gt; 类型
（除了已经介绍过的 &lt;tt class="docutils literal"&gt;char&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;enum libbpf_tristate&lt;/tt&gt; 类型）。
在这种情况下， &lt;tt class="docutils literal"&gt;y&lt;/tt&gt; 对应 &lt;tt class="docutils literal"&gt;true&lt;/tt&gt; ，而 &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; 则被转换为 &lt;tt class="docutils literal"&gt;false&lt;/tt&gt; 。&lt;/li&gt;
&lt;li&gt;对于整数 Kconfig 值，请使用 C 语言中的整型数据类型：支持所有 1、2、4 和 8 字节的有符号和无符号整数。
如果实际的 Kconfig 值超出了已声明的整数类型范围，libbpf 将会报错而不是截断数值。&lt;/li&gt;
&lt;li&gt;对于字符串 Kconfig 值，使用 &lt;tt class="docutils literal"&gt;const char[N]&lt;/tt&gt; 数组变量。如果实际值太长了，它将被截断并在末尾添加零终止符，
但是 libbpf 将会发出一个警告而不是报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请记住，如果从 &lt;tt class="docutils literal"&gt;/proc/config.gz&lt;/tt&gt; 中请求的 Kconfig 值缺失，libbpf 将会因为错误而中止程序加载。
为了更好地处理这种情况，可以将这样的 Kconfig extern 变量声明为弱（weak）变量，并加上 &lt;tt class="docutils literal"&gt;__weak&lt;/tt&gt; 属性。
在这种情况下，如果值缺失，将会被假定为 &lt;tt class="docutils literal"&gt;false&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;TRI_NO&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;'\0'&lt;/tt&gt; （零字符）、
&lt;tt class="docutils literal"&gt;0&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;&amp;quot;&amp;quot;&lt;/tt&gt; （空字符串），具体取决于所使用的类型。&lt;/p&gt;
&lt;p&gt;以下是一个快速示例，展示如何声明和使用不同类型的 Kconfig extern 变量:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LINUX_KERNEL_VERSION&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;libbpf_tristate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_BPF_PRELOAD&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__weak&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_BPF_JIT_ALWAYS_ON&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__weak&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_BPF_JIT_DEFAULT_ON&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__weak&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_HZ&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_MODPROBE_PATH&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__weak&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LINUX_KERNEL_VERSION&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;KERNEL_VERSION&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;switch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CONFIG_BPF_PRELOAD&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;TRI_NO&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;TRI_YES&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;TRI_MODULE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;CONFIG_BPF_JIT_ALWAYS_ON&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;bpf_printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;BPF_JIT_DEFAULT_ON: %c&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_BPF_JIT_DEFAULT_ON&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;bpf_printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;HZ is %d, MODPROBE_PATH: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_HZ&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_MODPROBE_PATH&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;span id="relocatable-enums"&gt;&lt;/span&gt;&lt;h3 id="hidsection-6"&gt;可重定位枚举&lt;a class="headerlink" href="#hidsection-6" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个有趣的挑战是，一些 BPF 应用程序需要处理“不稳定”的内核枚举。也就是说，这些枚举没有固定的常量集或整数值分配给它们。
一个很好的例子是 &lt;tt class="docutils literal"&gt;enum cgroup_subsys_id&lt;/tt&gt; ，
在 &lt;a class="reference external" href="https://github.com/torvalds/linux/blob/87066fdd2e30fe9dd531125d95257c118a74617e/include/linux/cgroup-defs.h#L43-L47"&gt;include/linux/cgroup-defs.h&lt;/a&gt; 中被定义，
其定义可能会根据内核编译时启用的 cgroup 特性而异（详情请参阅 &lt;a class="reference external" href="https://github.com/torvalds/linux/blob/87066fdd2e30fe9dd531125d95257c118a74617e/include/linux/cgroup_subsys.h"&gt;include/linux/cgroup_subsys.h&lt;/a&gt; ）。
因此，如果您需要知道，比如 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;cgroup_subsys_id::cpu_cgrp_id&lt;/span&gt;&lt;/tt&gt; 的实际整数值，
这可能是一个大问题，因为这个枚举是内核内部的，并且是动态生成的。&lt;/p&gt;
&lt;p&gt;再次，BPF CO-RE 发挥了作用。它允许使用 &lt;tt class="docutils literal"&gt;bpf_core_enum_value()&lt;/tt&gt; 宏来捕获实际的值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bpf_core_enum_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cgroup_subsys_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cpu_cgrp_id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* id will contain the actual integer value in the host kernel */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;span id="guarding-potentially-failing-relocations"&gt;&lt;/span&gt;&lt;h3 id="hidsection-7"&gt;防护可能会失败的重定位操作&lt;a class="headerlink" href="#hidsection-7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在某些内核上缺少某些字段并不罕见。如果一个 BPF 程序尝试使用 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 读取一个缺失的字段，
这将在 BPF 验证过程中导致错误。同样，当获取在主机内核中不存在的枚举值（或类型大小）时，CO-RE 重定位将失败。&lt;/p&gt;
&lt;p&gt;不幸的是，目前这个错误相当晦涩（但将由 libbpf &lt;a class="reference external" href="https://github.com/libbpf/libbpf/issues/371"&gt;很快&lt;/a&gt; 改进。译注：最新版的 libbpf 已改进这个错误），
所以最好意识到这一点，以防您意外遇到它。如果您遇到类似下面的错误，
要知道这是因为 CO-RE 重定位未能找到相应的字段/类型/枚举：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;85&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unknown&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;195896080&lt;/span&gt;
&lt;span class="n"&gt;invalid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unknown&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;195896080&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;195896080&lt;/tt&gt; 的十六进制表示是 &lt;tt class="docutils literal"&gt;0xbad2310&lt;/tt&gt; （代表&amp;quot;bad relo&amp;quot;），它是 libbpf 使用的一个常量，
用于标记失败的 CO-RE 重定位指令。libbpf 不立即报告此类错误的原因是，如果需要，
BPF 应用程序可以优雅地处理缺少的字段/类型/枚举以及相应的 CO-RE 重定位失败。
这使得仅通过一个 BPF 应用程序就能适应内核类型的极端变化成为可能（这是 &amp;quot;Compile Once – Run Everywhere&amp;quot; 哲学的关键目标）。&lt;/p&gt;
&lt;p&gt;当某个字段/类型/枚举可能缺失时，您可以使用在处理内核变更部分中描述的检查之一来保护这样的代码路径。
如果被正确保护，BPF 验证器将知道在该特定内核中不可能触发该代码路径，因此会将其排除为死代码。&lt;/p&gt;
&lt;p&gt;这种方法允许在必要时灵活地捕获内核信息的片段，如果实际运行的内核确实包含这些片段的话。
否则，BPF 应用程序可以优雅地退回到另一种替代逻辑，并妥善处理缺失的功能或数据。
只要适当保护潜在失败的 CO-RE 重定位，一切都能正常运作。这里所说的 CO-RE 重定位指的是任何使用
&lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 系列宏、类型/字段大小重定位或枚举值捕获的操作。
如果目标字段/类型/枚举不存在或定义不兼容的话，这些操作就毫无意义。&lt;/p&gt;
&lt;p&gt;继续前面关于 &lt;tt class="docutils literal"&gt;cpu_cgrp_id&lt;/tt&gt; 枚举值的例子，为了处理那些可能没有定义这种枚举值的内核
（例如，由于未设置 &lt;tt class="docutils literal"&gt;CONFIG_CGROUP_PIDS&lt;/tt&gt; Kconfig 开关），
可以使用 &lt;tt class="docutils literal"&gt;bpf_core_enum_value_exists()&lt;/tt&gt; 进行检查（ &lt;strong&gt;存在性检查永远不会失败！&lt;/strong&gt; ），
该检查返回 &lt;tt class="docutils literal"&gt;true&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;false&lt;/tt&gt; （严格来说，在 C 中是 &lt;tt class="docutils literal"&gt;0&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;1&lt;/tt&gt; ）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_core_enum_value_exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cgroup_subsys_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cpu_cgrp_id&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bpf_core_enum_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cgroup_subsys_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cpu_cgrp_id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* fallback value */&lt;/span&gt;

&lt;span class="cm"&gt;/* use id even if cpu_cgrp_id isn&amp;#39;t defined */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的示例在任何内核上都能正常运行，无论是否存在 &lt;tt class="docutils literal"&gt;cpu_cgrp_id&lt;/tt&gt; 枚举，
即使 &lt;tt class="docutils literal"&gt;bpf_core_enum_value()&lt;/tt&gt; 操作在没有 &lt;tt class="docutils literal"&gt;cpu_cgrp_id&lt;/tt&gt; 枚举的内核上失败也不会由影响。
这一切都是因为代码路径得到了适当的保护。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-8"&gt;
&lt;span id="advanced-topics"&gt;&lt;/span&gt;&lt;h2 id="hidsection-8"&gt;高级话题&lt;a class="headerlink" href="#hidsection-8" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;前面的部分介绍了大多数常见的 CO-RE 功能。本节将涵盖一些您可能会需要面对的更高级的话题，
这取决于您的 BPF 应用程序需要处理多复杂的内核状态以及在不同内核版本中的变化。&lt;/p&gt;
&lt;div class="section" id="co-re"&gt;
&lt;span id="defining-own-co-re-relocatable-type-definitions"&gt;&lt;/span&gt;&lt;h3 id="hidco-re"&gt;定义自己的 CO-RE 可重定位类型定义&lt;a class="headerlink" href="#hidco-re" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;直到现在，我们一直假设上述示例中使用的内核类型来自于 &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; 头文件，这个头文件是基于最近且足够完整的内核
BTF 生成的。但是，在 BPF CO-RE 中使用 &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; 并不是必需的。它主要是为了方便 BPF 应用程序开发者。&lt;/p&gt;
&lt;p&gt;此外，有时候 &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; 可能不足以解决更高级的情况。这可能是因为所需的类型尚未包含在内核 BTF 中，
或者因为内核中的某些内容以不兼容的方式发生了变化（例如，字段被重命名），
现在您需要处理两个不兼容的相同内核类型的定义（我们将在下文讨论如何处理这种令人沮丧的情况）。&lt;/p&gt;
&lt;p&gt;无论是什么原因，您都很容易定义自己对内核类型的期望，并使其 CO-RE 可重定位。
让我们以 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 作为一个典型的例子。
这是一个庞大而复杂的结构体，但通常你只需要从其完整定义中提取几个简单的字段。
利用 BPF CO-RE 只需要声明你将需要的字段，跳过所有其余部分，保持类型定义简单而简洁。&lt;/p&gt;
&lt;p&gt;假设你只关心 &lt;tt class="docutils literal"&gt;pid&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;group_leader&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;comm&lt;/tt&gt;  字段。
按照以下方式声明 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 就足以让一切正常运作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;comm&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;group_leader&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__attribute__&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;preserve_access_index&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先，&lt;em&gt;字段的顺序不重要&lt;/em&gt; 。完全不重要。&lt;/p&gt;
&lt;p&gt;其次，对于允许直接内存读取的 BPF 程序， &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;__attribute__((preserve_access_index))&lt;/span&gt;&lt;/tt&gt; 是必需的。
例如，BTF-enabled raw tracepoints（ &lt;tt class="docutils literal"&gt;SEC(tp_btf)&lt;/tt&gt; ）和
&lt;tt class="docutils literal"&gt;fentry&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;fexit&lt;/tt&gt; BPF 程序。
有了这个属性，任何 &lt;em&gt;使用此结构体定义进行直接内存读取的操作都将自动变得 CO-RE 可重定位&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;当使用显式的 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 宏系列时，不需要使用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;__attribute__((preserve_access_index))&lt;/span&gt;&lt;/tt&gt; ，
因为这些宏会自动强制执行。但如果直接使用旧的 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel()&lt;/tt&gt; 辅助函数，
如果结构体具有 &lt;tt class="docutils literal"&gt;preserve_access_index&lt;/tt&gt; 属性，这种 probe read 操作也会变得 CO-RE 可重定位。
因此，简单来说， &lt;em&gt;指定这个属性总是一个好主意&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;基本就是这样。您可以将此类型用于任何 CO-RE 读取或检查操作。正如您所看到的，它并不需要完全匹配真正的 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 定义。
只需要存在并且兼容的必要字段子集即可。您的 BPF 程序不需要的 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 中定义的其他所有内容对
于 BPF CO-RE 来说都是无关紧要的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-9"&gt;
&lt;span id="handling-incompatible-field-and-type-changes"&gt;&lt;/span&gt;&lt;h3 id="hidsection-9"&gt;处理不兼容的字段和类型变更&lt;a class="headerlink" href="#hidsection-9" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;正如前面所提到的，有些情况下，内核类型和字段的变更会导致两个不同内核中的类型定义不兼容。
比如，考虑在一个结构体中对字段进行重命名。
作为一个非常真实和具体的例子，让我们看一个最近将 &lt;tt class="docutils literal"&gt;task_struct&lt;/tt&gt; 的 &lt;tt class="docutils literal"&gt;state&lt;/tt&gt; 字段重命名为
&lt;tt class="docutils literal"&gt;__state&lt;/tt&gt; 的 &lt;a class="reference external" href="https://github.com/torvalds/linux/commit/2f064a59a11ff9bc22e52e9678bc601404c7cb34"&gt;提交&lt;/a&gt; 。
如果您要编写一个需要读取任务状态的 BPF 应用程序，那么根据内核版本的不同，
您可能需要通过 &lt;strong&gt;两个不同的名称&lt;/strong&gt; 来获取 &lt;strong&gt;相同的字段&lt;/strong&gt; 。让我们看看 BPF CO-RE 如何处理这种情况。&lt;/p&gt;
&lt;p&gt;BPF CO-RE 有一个重要的命名约定（我将其称为 &lt;strong&gt;&amp;quot;忽略后缀规则&amp;quot;&lt;/strong&gt; ）。
这是一个相对不太知名的特性，但它是处理上述情况的关键机制。
对于任何类型、字段、枚举或枚举器，如果实体的名称包含形式为 &lt;tt class="docutils literal"&gt;___something&lt;/tt&gt; （三个下划线加上一些文本）的后缀，
那么这类名称后缀在 CO-RE 重定位的过程中会被忽略，就好像它们从未存在过一样。&lt;/p&gt;
&lt;p&gt;这意味着，如果您在 BPF 应用程序中定义并使用了一个名为 &lt;tt class="docutils literal"&gt;struct task_struct___my_own_copy&lt;/tt&gt; 的结构体，
对于 BPF CO-RE 来说，该结构体就等同于内核中的 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; ，将被匹配和重定位。
字段名称也适用相同的规则（因此 &lt;tt class="docutils literal"&gt;state&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;state___custom&lt;/tt&gt; 实际上是相同的），
枚举类型也是如此（包括枚举类型名称本身以及其中的枚举值名称）。实际上，这种匹配是双向的，
所以如果内核中有 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;struct task_struct___2&lt;/tt&gt; 这样的结构体
（有时由于 C 类型系统和内核源代码中的头文件包含相互作用），
那么这两个结构体都将成为与在 BPF 程序源代码中定义的 &lt;tt class="docutils literal"&gt;struct task_struct___my&lt;/tt&gt; 匹配的候选对象。&lt;/p&gt;
&lt;p&gt;这在实践中意味着，您现在可以拥有多个独立且相互冲突的相同内核类型/字段/枚举的定义，
并且可以将代码编译为有效的 C 代码，同时您可以根据您使用的任何
&lt;a class="reference external" href="#dealing-with-kernel-changes-and-feature-detection"&gt;特性检测&lt;/a&gt;
方法在运行时选择正确的定义。&lt;/p&gt;
&lt;p&gt;让我们来看一个例子，说明如何处理前面提到的将 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;task_struct-&amp;gt;state&lt;/span&gt;&lt;/tt&gt; 重命名为 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;task_struct-&amp;gt;__state&lt;/span&gt;&lt;/tt&gt; 的场景：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* latest kernel task_struct definition, which can also come from vmlinux.h */&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__attribute__&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;preserve_access_index&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct___old&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__attribute__&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;preserve_access_index&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;bpf_get_current_task&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_core_field_exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;__state&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_CORE_READ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__state&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* recast pointer to capture task_struct___old type for compiler */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct___old&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t_old&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* now use old &amp;quot;state&amp;quot; name of the field */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_CORE_READ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t_old&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的例子中，有两个最关键的部分。&lt;/p&gt;
&lt;p&gt;首先，基于最新的 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 定义进行字段存在性检查。如果运行的内核版本较旧，尚未具有 &lt;tt class="docutils literal"&gt;__state&lt;/tt&gt; 字段，
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;bpf_core_field_exists(t-&amp;gt;__state)&lt;/span&gt;&lt;/tt&gt; 将返回 0，对于 &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; 语句的第一个分支, BPF 验证器将
&lt;a class="reference external" href="#guarding-potentially-failing-relocations"&gt;跳过并消除这段死代码&lt;/a&gt; ，
因此 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;t-&amp;gt;__state&lt;/span&gt;&lt;/tt&gt; 将永远不会被尝试读取。&lt;/p&gt;
&lt;p&gt;其次，将 &lt;tt class="docutils literal"&gt;struct task_struct *&lt;/tt&gt; 指针重新转换为 &lt;tt class="docutils literal"&gt;struct task_struct___old *&lt;/tt&gt; 指针。
这是为了让 C 编译器能够跟踪 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 的“替代定义”
（即本例中的 &lt;tt class="docutils literal"&gt;struct task_struct___old&lt;/tt&gt; ）的类型信息。
编译器将按有效的 C 表达式识别并编译 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;t_old-&amp;gt;state&lt;/span&gt;&lt;/tt&gt; 字段引用（隐藏在 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 实现内部），
同时还会记录相应的 CO-RE 重定位信息，以便让 libbpf 知道 BPF 程序预期读取的类型和字段信息。&lt;/p&gt;
&lt;p&gt;通过 &lt;tt class="docutils literal"&gt;___suffix&lt;/tt&gt; 规则，所有操作都会正确工作。当由 libbpf 预处理一个 BPF 程序以供发送到内核进行验证时，
libbpf 会执行 CO-RE 重定位并正确调整偏移量。其中一个 CO-RE 重定位将无法被解析
（因为 &lt;tt class="docutils literal"&gt;__state&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;state&lt;/tt&gt; 在内核中不能同时存在），这将导致相应的 BPF 指令被“污染（poisoning）”
（回想一下之前介绍过的 &lt;tt class="docutils literal"&gt;0xbad2310&lt;/tt&gt; ），但该指令将受到字段存在逻辑的保护，并在程序加载期间被验证器所消除。&lt;/p&gt;
&lt;p&gt;随着 BPF CO-RE 应用程序数量和复杂性的增长，以及 Linux 内核的演进和不可避免的内部变更和重构，
处理不兼容的内核变更的能力将变得越来越重要，因此请注意这项技术。
上述介绍忽略了一堆实现细节，但仍希望能有助于理解如何在实践中使用这个特性。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-10"&gt;
&lt;span id="reading-kernel-data-structures-from-user-space-memory"&gt;&lt;/span&gt;&lt;h3 id="hidsection-10"&gt;从用户态内存中读取内核数据结构&lt;a class="headerlink" href="#hidsection-10" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在一些情况下可能会出现的一个（尽管不太常见的）需求是需要从用户态内存中读取内核类型。
这个类型很可能是内核 UAPI 类型之一，或者是作为系统调用的输入参数传递。
为了满足这类需求（以及为了完整性），libbpf 提供了其 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 宏系列的用户态等效版本：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;bpf_core_read_user()&lt;/tt&gt;;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;bpf_core_read_user_str()&lt;/tt&gt;;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;BPF_CORE_READ_USER_STR_INTO()&lt;/tt&gt;;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;BPF_CORE_READ_USER_INTO()&lt;/tt&gt;;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;BPF_CORE_READ_USER()&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们的功能和行为与它们的非“user”变体完全相同，唯一的区别在于所有的内存读取都是通过
&lt;tt class="docutils literal"&gt;bpf_probe_read_user()&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;bpf_probe_read_user_str()&lt;/tt&gt; BPF 辅助函数完成的，
因此需要传递用户态指针。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="btf-id"&gt;
&lt;span id="capturing-btf-type-ids"&gt;&lt;/span&gt;&lt;h3 id="hidbtf-id"&gt;捕获 BTF 类型 ID&lt;a class="headerlink" href="#hidbtf-id" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如果你熟悉 &lt;a class="reference external" href="https://nakryiko.com/posts/btf-dedup"&gt;BTF&lt;/a&gt; ，你就会知道 BTF 中的任何类型定义都有对应的
BTF 类型 ID。无论是用于调试和日志记录，还是作为某些 BPF API 的一部分，
了解 BPF 程序正在处理的类型/字段/枚举的 BTF 类型 ID 可能是重要的。
BPF CO-RE 提供了一种从 BPF 程序代码内部捕获这些 BTF 类型 ID 作的整数值的方法。
实际上，它提供了一个捕获两种不同 BTF 类型 ID 的方法。
一种是目标内核 BTF（ &lt;em&gt;内核类型 ID&lt;/em&gt; ），另一种是 BPF 程序自身的 BTF（ &lt;em&gt;本地类型 ID&lt;/em&gt; ）：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;bpf_core_type_id_kernel()&lt;/tt&gt; 函数从运行内核的 BTF 中返回已解析的类型 ID；&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;bpf_core_type_id_local()&lt;/tt&gt; 函数捕获在 BPF 程序编译期间由编译器捕获的类型 ID。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，使用 BPF CO-RE 重定位时，总是涉及到两种 BTF 类型。其中一种是 BPF 程序对 &lt;strong&gt;类型定义的本地期望&lt;/strong&gt;
（比如， &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; 中的类型或使用 &lt;tt class="docutils literal"&gt;preserve_access_index&lt;/tt&gt; 属性
&lt;a class="reference external" href="#defining-own-co-re-relocatable-type-definitions"&gt;手动定义&lt;/a&gt;
的类型）。这种本地 BTF 类型为 libbpf 提供了在内核 BTF 中搜索什么的指导。
因此，它可以是类型/字段/枚举的最小定义，可以只包含必要的字段和枚举值。&lt;/p&gt;
&lt;p&gt;然后 Libbpf 可以使用本地 BTF 类型定义来找到匹配的实际完整的内核 BTF 类型。
上述辅助函数允许捕获参与 CO-RE 重定位的两种类型的 BTF 类型 ID。
它们可能用于在运行时区分不同的内核或本地类型，用于调试和日志记录，
或者潜在地用于未来的 BPF API，这些 API 将接受 BTF 类型 ID 作为输入参数。
目前还没有这样的 API，但它们肯定会在不久的将来出现。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-11"&gt;
&lt;span id="conclusion"&gt;&lt;/span&gt;&lt;h2 id="hidsection-11"&gt;结语&lt;a class="headerlink" href="#hidsection-11" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;希望这篇文章在高效地使用 BPF CO-RE 技术方面提供了足够的信息和实用指导。
欢迎在您的 BPF 需求中创造性地使用它们。
如果有任何不对或无法正常工作的地方，请通过 &lt;a class="reference external" href="http://vger.kernel.org/vger-lists.html#bpf"&gt;BPF 邮件列表&lt;/a&gt; 报告问题。&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sat, 13 Jul 2024 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2024-07-13:2024/07/bpf-core-reference-guide-zh.html</guid><category>ebpf</category><category>bpf</category><category>CO-RE</category><category>libbpf</category></item><item><title>ptcpdump: Capturing the Network Traffic of any Process, Container, or Pod</title><link>https://mozillazg.com/2024/07/ebpf-ptcpdump-capturing-the-network-traffic-of-a-process-or-container-or-pod-en.html</link><description>&lt;div class="section" id="preface"&gt;
&lt;h2 id="hidpreface"&gt;Preface&lt;a class="headerlink" href="#hidpreface" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;tcpdump is a widely used network packet capture tool known for its powerful functionality.
Despite its strengths, it still lacks a long-requested feature:
displaying process information associated with network requests/traffic
in the output and enabling the capture of network traffic for specific processes.&lt;/p&gt;
&lt;p&gt;To retrieve process information corresponding to the traffic captured by tcpdump,
a common approach involves associating process details with connection information using tools
such as &lt;tt class="docutils literal"&gt;ss&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;netstat&lt;/tt&gt;.
However, this method has drawbacks—it can be cumbersome to execute and may not effectively
identify network traffic from processes with short lifecycles.&lt;/p&gt;
&lt;p&gt;When capturing network traffic of a specific process using tcpdump, common methods include:
filtering traffic by destination address when knowing the target service address the
process will access; or running the target process in a specific network namespace
and then using tcpdump to capture packets within that namespace.
These methods have limitations as they require prior knowledge of the
target process's destination address or altering the target process's execution, restricting their practicality.&lt;/p&gt;
&lt;p&gt;This article will introduce a new tool called ptcpdump. With this tool, we can directly detect the
process information of the sending traffic while capturing packets.
We can also capture network packets directly for any running or pending process.
If the traffic is generated by a process inside a container, it also supports displaying
the container or Pod information of the traffic and capturing packets for specific containers or Pods.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ptcpdump-introduction"&gt;
&lt;h2 id="hidptcpdump-introduction"&gt;ptcpdump Introduction&lt;a class="headerlink" href="#hidptcpdump-introduction" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ptcpdump is a network packet capture tool developed using eBPF technology,
designed in a tcpdump-like style.
In addition to supporting tcpdump's common command-line parameters
and packet filtering syntax, it also offers the following core features:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Capture and display information about the processes, containers, and Pods responsible for sending network traffic in the output.&lt;/li&gt;
&lt;li&gt;Support packet capture for specific processes, containers, and Pods.&lt;/li&gt;
&lt;li&gt;Save captured packets in pcapng format for further analysis using tcpdump or Wireshark.&lt;/li&gt;
&lt;li&gt;When opening the saved pcapng file in Wireshark, you can view the details of the process, container, and Pod associated with each data packet.&lt;/li&gt;
&lt;li&gt;Compile this tool using static linking to eliminate the need for additional system libraries installation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For additional information, please refer to the project's source code repository: &lt;a class="reference external" href="https://github.com/mozillazg/tcpdump"&gt;https://github.com/mozillazg/tcpdump&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The following will showcase the core functions of ptcpdump through examples.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="common-command-line-parameters-and-packet-filtering-syntax-compatible-with-tcpdump"&gt;
&lt;h2 id="hidcommon-command-line-parameters-and-packet-filtering-syntax-compatible-with-tcpdump"&gt;Common command-line parameters and packet filtering syntax compatible with tcpdump&lt;a class="headerlink" href="#hidcommon-command-line-parameters-and-packet-filtering-syntax-compatible-with-tcpdump" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ptcpdump compatible with tcpdump include filtering syntax and most command-line parameters. for example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo tcpdump -i eth0 tcp
sudo tcpdump -i eth0 -A -v tcp and port 80 and host 10.10.1.1
sudo tcpdump -i eth0 'tcp[tcpflags] &amp;amp; (tcp-syn|tcp-fin) != 0'
sudo tcpdump -i any
sudo tcpdump -i any -s 0 -n -c 100 -w demo.pcapng port 80
&lt;/pre&gt;
&lt;p&gt;The common tcpdump commands mentioned above can be easily replaced with the corresponding
ptcpdump commands by simply changing &lt;tt class="docutils literal"&gt;tcpdump&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;ptcpdump&lt;/tt&gt;.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo ptcpdump -i eth0 tcp
sudo ptcpdump -i eth0 -A -v tcp and port 80 and host 10.10.1.1
sudo ptcpdump -i eth0 'tcp[tcpflags] &amp;amp; (tcp-syn|tcp-fin) != 0'
sudo ptcpdump -i any
sudo ptcpdump -i any -s 0 -n -c 100 -w demo.pcapng port 80
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="capture-and-showcase-the-processes-containers-and-pod-details-involved-in-transmitting-network-traffic-within-the-output"&gt;
&lt;h2 id="hidcapture-and-showcase-the-processes-containers-and-pod-details-involved-in-transmitting-network-traffic-within-the-output"&gt;Capture and showcase the processes, containers, and Pod details involved in transmitting network traffic within the output&lt;a class="headerlink" href="#hidcapture-and-showcase-the-processes-containers-and-pod-details-involved-in-transmitting-network-traffic-within-the-output" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;By default, ptcpdump will show basic information about processes, containers, and Pods in the output.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 4 port 80 or port 443
2024-07-07 12:56:56 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 12:56:56 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
12:56:59.517657 veth18618a4a wget.13626 In IP 10.244.0.4.46834 &amp;gt; 13.251.96.10.443: Flags [S], seq 2743105662, win 64240, length 0, Container [test], Pod [test.default]
12:56:59.517836 eth0 wget.13626 Out IP 172.19.0.2.46834 &amp;gt; 13.251.96.10.443: Flags [S], seq 2743105662, win 64240, length 0, Container [test], Pod [test.default]
12:56:59.692593 eth0 wget.13626 In IP 13.251.96.10.443 &amp;gt; 172.19.0.2.46834: Flags [S.], seq 1966397178, ack 2743105663, win 65084, length 0, Container [test], Pod [test.default]
12:56:59.692754 veth18618a4a wget.13626 Out IP 13.251.96.10.443 &amp;gt; 10.244.0.4.46834: Flags [S.], seq 1966397178, ack 2743105663, win 65084, length 0, Container [test], Pod [test.default]
4 packets captured
6 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;By specifying the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-v&lt;/span&gt;&lt;/tt&gt; parameter, you can access detailed information about processes, containers, and pods.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ptcpdump -i any -c 4 -v port 80 or port 443
2024-07-07 12:58:59 WARN ptcpdump: capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
12:59:02.265356 veth18618a4a In IP (tos 0x0, ttl 64, id 35996, offset 0, flags [DF], proto TCP (6), length 60)
    10.244.0.4.41666 &amp;gt; 13.215.144.61.443: Flags [S], cksum 0xa93a, seq 40651020, win 64240, options [mss 1460,sackOK,TS val 2665081987 ecr 0,nop,wscale 7], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
12:59:02.265606 eth0 Out IP (tos 0x0, ttl 63, id 35996, offset 0, flags [DF], proto TCP (6), length 60)
    172.19.0.2.41666 &amp;gt; 13.215.144.61.443: Flags [S], cksum 0x4a58, seq 40651020, win 64240, options [mss 1460,sackOK,TS val 2665081987 ecr 0,nop,wscale 7], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
12:59:02.462586 eth0 In IP (tos 0x4, ttl 47, id 0, offset 0, flags [DF], proto TCP (6), length 60)
    13.215.144.61.443 &amp;gt; 172.19.0.2.41666: Flags [S.], cksum 0x9772, seq 3160052321, ack 40651021, win 65084, options [mss 1240,sackOK,TS val 3710435767 ecr 2665081987,nop,wscale 9], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
12:59:02.462782 veth18618a4a Out IP (tos 0x4, ttl 46, id 0, offset 0, flags [DF], proto TCP (6), length 60)
    13.215.144.61.443 &amp;gt; 10.244.0.4.41666: Flags [S.], cksum 0x3890, seq 3160052321, ack 40651021, win 65084, options [mss 1240,sackOK,TS val 3710435767 ecr 2665081987,nop,wscale 9], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
4 packets captured
6 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;With &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-A&lt;/span&gt;&lt;/tt&gt; to print data in ASCII:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:44:34.457504 ens33 curl.205562 Out IP 10.0.2.15.39984 &amp;gt; 139.178.84.217.80: Flags [P.], seq 2722472188:2722472262, ack 892036871, win 64240, length 74, ParentProc [bash.180205]
E..r.,&amp;#64;.&amp;#64;.o.
.....T..0.P.E..5+g.P.......GET / HTTP/1.1
Host: kernel.org
User-Agent: curl/7.81.0
Accept: */*
&lt;/pre&gt;
&lt;p&gt;With &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-x&lt;/span&gt;&lt;/tt&gt; to print data in hex:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:44:34.457504 ens33 curl.205562 IP 10.0.2.15.39984 &amp;gt; 139.178.84.217.80: Flags [P.], seq 2722472188:2722472262, ack 892036871, win 64240, length 74, ParentProc [bash.180205]
        0x0000:  4500 0072 de2c 4000 4006 6fbf 0a00 020f
        0x0010:  8bb2 54d9 9c30 0050 a245 a0fc 352b 6707
        0x0020:  5018 faf0 ecfe 0000 4745 5420 2f20 4854
        0x0030:  5450 2f31 2e31 0d0a 486f 7374 3a20 6b65
        0x0040:  726e 656c 2e6f 7267 0d0a 5573 6572 2d41
        0x0050:  6765 6e74 3a20 6375 726c 2f37 2e38 312e
        0x0060:  300d 0a41 6363 6570 743a 202a 2f2a 0d0a
        0x0070:  0d0a
&lt;/pre&gt;
&lt;p&gt;With &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-X&lt;/span&gt;&lt;/tt&gt; to print data in hex and ASCII:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:44:34.457504 ens33 curl.205562 IP 10.0.2.15.39984 &amp;gt; 139.178.84.217.80: Flags [P.], seq 2722472188:2722472262, ack 892036871, win 64240, length 74, ParentProc [bash.180205]
        0x0000:  4500 0072 de2c 4000 4006 6fbf 0a00 020f  E..r.,&amp;#64;.&amp;#64;.o.....
        0x0010:  8bb2 54d9 9c30 0050 a245 a0fc 352b 6707  ..T..0.P.E..5+g.
        0x0020:  5018 faf0 ecfe 0000 4745 5420 2f20 4854  P.......GET / HT
        0x0030:  5450 2f31 2e31 0d0a 486f 7374 3a20 6b65  TP/1.1..Host: ke
        0x0040:  726e 656c 2e6f 7267 0d0a 5573 6572 2d41  rnel.org..User-A
        0x0050:  6765 6e74 3a20 6375 726c 2f37 2e38 312e  gent: curl/7.81.
        0x0060:  300d 0a41 6363 6570 743a 202a 2f2a 0d0a  0..Accept: */*..
        0x0070:  0d0a                                     ..
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="support-capturing-packets-for-specified-processes-containers-or-pods"&gt;
&lt;h2 id="hidsupport-capturing-packets-for-specified-processes-containers-or-pods"&gt;Support capturing packets for specified processes, containers, or Pods&lt;a class="headerlink" href="#hidsupport-capturing-packets-for-specified-processes-containers-or-pods" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="capture-packets-for-a-specific-process-identified-by-its-pid"&gt;
&lt;h3 id="hidcapture-packets-for-a-specific-process-identified-by-its-pid"&gt;Capture packets for a specific process identified by its PID&lt;a class="headerlink" href="#hidcapture-packets-for-a-specific-process-identified-by-its-pid" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You can use the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--pid&lt;/span&gt;&lt;/tt&gt; parameter to specify the process ID for capturing packets,
allowing you to capture packets specifically for the designated process.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 4 --pid 82106
2024-07-07 13:11:40 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:11:40 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:11:50.170538 ens33 python3.10.82106 Out IP 10.0.2.15.36648 &amp;gt; 13.251.96.10.443: Flags [S], seq 1633417447, win 64240, length 0
13:11:50.369972 ens33 python3.10.82106 In IP 13.251.96.10.443 &amp;gt; 10.0.2.15.36648: Flags [S.], seq 1793291274, ack 1633417448, win 64240, length 0
2 packets captured
3 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;You can also capture packets from the subprocesses created by this process by specifying the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-f&lt;/span&gt;&lt;/tt&gt; parameter.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 4 --pid 82106 -f 'tcp[tcpflags] &amp;amp; tcp-fin != 0'
2024-07-07 13:17:31 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:17:31 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:17:37.800903 ens33 python3.10.82106 Out IP 10.0.2.15.38576 &amp;gt; 52.74.166.77.443: Flags [F.], seq 2442149577, ack 367271121, win 62780, length 0
13:17:37.977316 ens33 python3.10.82106 In IP 52.74.166.77.443 &amp;gt; 10.0.2.15.38576: Flags [FP.], seq 367271145, ack 2442149578, win 64239, length 0
13:17:44.390627 ens33 curl.95920 Out IP 10.0.2.15.38590 &amp;gt; 52.74.166.77.443: Flags [F.], seq 3726932781, ack 1510095004, win 63045, length 0
13:17:44.564990 ens33 curl.95920 In IP 52.74.166.77.443 &amp;gt; 10.0.2.15.38590: Flags [FP.], seq 1510095028, ack 3726932782, win 64239, length 0
4 packets captured
4 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="capture-packets-based-on-a-specified-process-name"&gt;
&lt;h3 id="hidcapture-packets-based-on-a-specified-process-name"&gt;Capture packets based on a specified process name&lt;a class="headerlink" href="#hidcapture-packets-based-on-a-specified-process-name" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You can capture packets for a specified process name by using the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--pname&lt;/span&gt;&lt;/tt&gt; parameter to specify the process name (comm).&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --pname curl
2024-07-07 13:23:18 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:23:18 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:23:24.881499 lo curl.26511 Out IP 127.0.0.1.43332 &amp;gt; 127.0.0.53.53: 44133+ [1au] A? mozillazg.com. (42)
13:23:24.881663 lo curl.26511 Out IP 127.0.0.1.43332 &amp;gt; 127.0.0.53.53: 14694+ [1au] AAAA? mozillazg.com. (42)
2 packets captured
2 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="capture-packets-by-executing-the-target-program"&gt;
&lt;h3 id="hidcapture-packets-by-executing-the-target-program"&gt;Capture packets by executing the target program&lt;a class="headerlink" href="#hidcapture-packets-by-executing-the-target-program" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If needed, you can capture packets for specific programs by running the target program with the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--&lt;/span&gt;&lt;/tt&gt; parameter.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -- curl -I https://mozillazg.com
2024-07-07 13:26:44 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:26:44 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:26:44.055757 lo curl.28094 Out IP 127.0.0.1.48826 &amp;gt; 127.0.0.53.53: 8942+ [1au] A? mozillazg.com. (42)
13:26:44.055914 lo curl.28094 Out IP 127.0.0.1.48826 &amp;gt; 127.0.0.53.53: 34274+ [1au] AAAA? mozillazg.com. (42)
13:26:44.775840 lo curl.28094 In IP 127.0.0.53.53 &amp;gt; 127.0.0.1.48826: 8942 3/0/1 CNAME mozillazg.netlify.com., A 13.251.96.10, A 46.137.195.11 (106)
13:26:45.135988 lo curl.28094 In IP 127.0.0.53.53 &amp;gt; 127.0.0.1.48826: 34274 3/0/1 CNAME mozillazg.netlify.com., AAAA 2406:da18:880:3802::c8, AAAA 2406:da18:b3d:e202::64 (130)
13:26:45.136819 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [S], seq 3460683104, win 64800, length 0
13:26:45.310505 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [S.], seq 630810442, ack 3460683105, win 65232, length 0
13:26:45.310821 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683105, ack 630810443, win 507, length 0
13:26:45.414551 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683105:3460683622, ack 630810443, win 507, length 517
13:26:45.595214 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630810443, ack 3460683622, win 127, length 0
13:26:45.595413 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630810443:630811651, ack 3460683622, win 127, length 1208
13:26:45.595595 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630811651, win 501, length 0
13:26:45.595702 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630811651:630812859, ack 3460683622, win 127, length 1208
13:26:45.595797 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630812859, win 492, length 0
13:26:45.595862 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630812859:630813338, ack 3460683622, win 127, length 479
13:26:45.595934 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630813338, win 489, length 0
13:26:45.600998 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683622:3460683686, ack 630813338, win 489, length 64
13:26:45.601344 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683686:3460683781, ack 630813338, win 489, length 95
13:26:45.616759 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683781:3460683882, ack 630813338, win 501, length 101
13:26:45.779516 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813338, ack 3460683781, win 127, length 0
13:26:45.779792 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813338:630813399, ack 3460683781, win 127, length 61
13:26:45.779996 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813399:630813443, ack 3460683781, win 127, length 44
13:26:45.780318 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683882:3460683913, ack 630813443, win 501, length 31
HTTP/2 200
13:26:45.788787 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813443:630813677, ack 3460683882, win 127, length 234
accept-ranges: bytes
age: 79059
cache-control: public,max-age=0,must-revalidate
cache-status: &amp;quot;Netlify Edge&amp;quot;; hit
content-type: text/html; charset=UTF-8
date: Sun, 07 Jul 2024 05:26:44 GMT
etag: &amp;quot;80cf37f5974e2232d976c6f622121dee-ssl&amp;quot;
server: Netlify
strict-transport-security: max-age=31536000
x-nf-request-id: 01J25THACQSN9364YHSR2C0X5F
content-length: 11727

13:26:45.789558 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683913:3460683937, ack 630813677, win 501, length 24
13:26:45.791514 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [F.], seq 3460683937, ack 630813677, win 501, length 0
13:26:45.963642 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813677, ack 3460683937, win 127, length 0
13:26:45.963956 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813677:630813701, ack 3460683937, win 127, length 24
13:26:45.964172 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683937, win 0, length 0
13:26:45.964415 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [F.], seq 630813701, ack 3460683937, win 127, length 0
13:26:45.964506 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683937, win 0, length 0
13:26:45.966158 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813702, ack 3460683938, win 127, length 0
13:26:45.966299 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683938, win 0, length 0
32 packets captured
32 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="capturing-packets-for-a-specific-container"&gt;
&lt;h3 id="hidcapturing-packets-for-a-specific-container"&gt;Capturing Packets for a Specific Container&lt;a class="headerlink" href="#hidcapturing-packets-for-a-specific-container" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You can capture network packets by specifying the container ID using the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--container-id&lt;/span&gt;&lt;/tt&gt; parameter.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --container-id 36f0310403b1
2024-07-07 13:36:19 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:36:19 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:36:24.191242 veth09dec8f curl.32636 In IP 172.19.0.2.48960 &amp;gt; 18.139.194.139.443: Flags [S], seq 3213779351, win 64240, length 0, Container [kind-control-plane]
13:36:24.191369 wlp4s0 curl.32636 Out IP 192.168.1.50.48960 &amp;gt; 18.139.194.139.443: Flags [S], seq 3213779351, win 64240, length 0, Container [kind-control-plane]
2 packets captured
2 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;You can also capture packets by specifying the container name using the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--container-name&lt;/span&gt;&lt;/tt&gt; parameter.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --container-name kind-control-plane
2024-07-07 13:37:16 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:37:16 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:37:22.560764 veth09dec8f curl.33093 In IP 172.19.0.2.39084 &amp;gt; 18.139.194.139.443: Flags [S], seq 3645727033, win 64240, length 0, Container [kind-control-plane]
13:37:22.561010 wlp4s0 curl.33093 Out IP 192.168.1.50.39084 &amp;gt; 18.139.194.139.443: Flags [S], seq 3645727033, win 64240, length 0, Container [kind-control-plane]
2 packets captured
2 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="capture-packets-for-a-specific-pod"&gt;
&lt;h3 id="hidcapture-packets-for-a-specific-pod"&gt;Capture packets for a specific Pod&lt;a class="headerlink" href="#hidcapture-packets-for-a-specific-pod" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You can capture packets by specifying the Pod name using the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--pod-name&lt;/span&gt;&lt;/tt&gt; parameter.
The format for the parameter value should be &lt;tt class="docutils literal"&gt;&amp;lt;pod &lt;span class="pre"&gt;name&amp;gt;.&amp;lt;pod&lt;/span&gt; namespace&amp;gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --pod-name test.default
2024-07-07 13:38:29 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:38:29 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:38:34.175752 eth0 wget.33660 Out IP 172.19.0.2.51564 &amp;gt; 13.215.144.61.443: Flags [S], seq 567383917, win 64240, length 0, Container [test], Pod [test.default]
13:38:34.372894 eth0 wget.33660 In IP 13.215.144.61.443 &amp;gt; 172.19.0.2.51564: Flags [S.], seq 2654865684, ack 567383918, win 65084, length 0, Container [test], Pod [test.default]
2 packets captured
3 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="save-the-data-in-pcapng-format-and-analyze-it-using-tcpdump-or-wireshark"&gt;
&lt;h2 id="hidsave-the-data-in-pcapng-format-and-analyze-it-using-tcpdump-or-wireshark"&gt;Save the data in pcapng format and analyze it using tcpdump or Wireshark&lt;a class="headerlink" href="#hidsave-the-data-in-pcapng-format-and-analyze-it-using-tcpdump-or-wireshark" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="save-as-pcapng-format"&gt;
&lt;h3 id="hidsave-as-pcapng-format"&gt;Save as pcapng format&lt;a class="headerlink" href="#hidsave-as-pcapng-format" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You can save captured data in pcapng format by using the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-w&lt;/span&gt;&lt;/tt&gt; parameter.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 5 -w demo.pcapng
2024-07-07 13:41:32 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:41:32 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
5 packets captured
22 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="analyzing-with-tcpdump"&gt;
&lt;h3 id="hidanalyzing-with-tcpdump"&gt;Analyzing with tcpdump&lt;a class="headerlink" href="#hidanalyzing-with-tcpdump" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You can analyze the captured data using tcpdump through a pipeline method.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 5 -w - port 80 | tcpdump -n -r -
reading from file -, link-type EN10MB (Ethernet), snapshot length 65535
2024-07-07 13:44:33 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:44:33 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:44:44.530637 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &amp;gt; 2406:da18:880:3801::c8.80: Flags [S], seq 495824072, win 64800, options [mss 1440,sackOK,TS val 2411675580 ecr 0,nop,wscale 7], length 0
13:44:44.708902 IP6 2406:da18:880:3801::c8.80 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858: Flags [S.], seq 640438481, ack 495824073, win 65232, options [mss 1220,sackOK,TS val 1591525382 ecr 2411675580,nop,wscale 9], length 0
13:44:44.709261 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &amp;gt; 2406:da18:880:3801::c8.80: Flags [.], ack 1, win 507, options [nop,nop,TS val 2411675670 ecr 1591525382], length 0
13:44:44.709475 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &amp;gt; 2406:da18:880:3801::c8.80: Flags [P.], seq 1:78, ack 1, win 507, options [nop,nop,TS val 2411675670 ecr 1591525382], length 77: HTTP: GET / HTTP/1.1
5 packets captured
6 packets received by filter
0 packets dropped by kernel
13:44:44.877110 IP6 2406:da18:880:3801::c8.80 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858: Flags [P.], seq 1:266, ack 78, win 128, options [nop,nop,TS val 1591525469 ecr 2411675670], length 265: HTTP: HTTP/1.1 301 Moved Permanently
&lt;/pre&gt;
&lt;p&gt;You can also analyze the captured data by reading files using tcpdump.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ tcpdump -n -r demo.pcapng
reading from file demo.pcapng, link-type EN10MB (Ethernet), snapshot length 65535
13:47:41.169584 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &amp;gt; 2406:da18:b3d:e201::64.80: Flags [S], seq 3876639697, win 64800, options [mss 1440,sackOK,TS val 2072195434 ecr 0,nop,wscale 7], length 0
13:47:41.571055 IP 192.168.1.50.60580 &amp;gt; 18.139.194.139.80: Flags [S], seq 481256927, win 64240, options [mss 1460,sackOK,TS val 2707199178 ecr 0,nop,wscale 7], length 0
13:47:41.956270 IP6 2406:da18:b3d:e201::64.80 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038: Flags [S.], seq 2283576526, ack 3876639698, win 65232, options [mss 1220,sackOK,TS val 4276006323 ecr 2072195434,nop,wscale 9], length 0
13:47:41.956437 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &amp;gt; 2406:da18:b3d:e201::64.80: Flags [.], ack 1, win 507, options [nop,nop,TS val 2072195828 ecr 4276006323], length 0
13:47:41.956733 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &amp;gt; 2406:da18:b3d:e201::64.80: Flags [P.], seq 1:78, ack 1, win 507, options [nop,nop,TS val 2072195828 ecr 4276006323], length 77: HTTP: GET / HTTP/1.1
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="analyzing-network-traffic-with-wireshark"&gt;
&lt;h3 id="hidanalyzing-network-traffic-with-wireshark"&gt;Analyzing Network Traffic with Wireshark&lt;a class="headerlink" href="#hidanalyzing-network-traffic-with-wireshark" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When using Wireshark to open a saved pcapng format file, the relevant process, container,
and Pod information will be displayed in the Wireshark interface:&lt;/p&gt;
&lt;img alt="" src="/static/images/bpf/ptcpdump-wireshark.png" /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="references"&gt;
&lt;h2 id="hidreferences"&gt;References&lt;a class="headerlink" href="#hidreferences" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/ptcpdump"&gt;mozillazg/ptcpdump: Process-aware, eBPF-based tcpdump&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.tcpdump.org/manpages/tcpdump.1-4.99.4.html"&gt;tcpdump(1) man page | TCPDUMP &amp;amp; LIBPCAP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sat, 06 Jul 2024 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2024-07-06:2024/07/ebpf-ptcpdump-capturing-the-network-traffic-of-a-process-or-container-or-pod-en.html</guid><category>ebpf</category><category>ptcpdump</category><category>tcpdump</category><category>pcapng</category><category>wireshark</category><category>container</category><category>pod</category><category>en-version</category></item><item><title>ptcpdump: 抓包时显示进程信息以及对任意进程、容器或 Pod 进行抓包</title><link>https://mozillazg.com/2024/07/ebpf-ptcpdump-capturing-the-network-traffic-of-a-process-or-container-or-pod.html</link><description>&lt;div class="section" id="section-1"&gt;
&lt;h2 id="hidsection-1"&gt;前言&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;tcpdump 是我们常用的一个网络抓包工具，它的功能非常的强大。但是它还缺少一个大家反馈很久却一直没实现的一个特性，
那就是：在结果中包含/显示发送网络请求/流量的进程信息，以及支持抓取指定进程的网络流量。&lt;/p&gt;
&lt;p&gt;当前针对 tcpdump 抓取的流量信息，如果要获取对应的进程信息的话，常见的方法是：
基于请求的连接信息，通过 &lt;tt class="docutils literal"&gt;ss&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;netstat&lt;/tt&gt; 之内的工具反查进程信息。
这个方法的缺点是：操作起来比较繁琐以及无法查找匹配短生命周期的进程所发送的网络流量。&lt;/p&gt;
&lt;p&gt;至于基于 tcpdump 实现抓取指定进程的网络流量，常见的方法是：在知晓进程要访问的目标服务地址信息的前提下，
在使用 tcpdump 时按目的地址信息过滤流量；
或者是在特定的网络命名空间中运行目标进程，然后再在该网络命名空间下使用 tcpdump 抓包。
这两个方法的缺点是：需要提前知晓目标进程访问的目的地址或者需要改变目标进程的执行方式，适用场景有限。&lt;/p&gt;
&lt;p&gt;本文将介绍一个新的工具 ptcpdump，基于这个工具，我们既可以在抓包时直接感知发送流量的进程信息，
也可以直接对运行中或待运行的任意进程进行网络抓包。如果流量是从容器内的进程发出的话，
它还支持显示流量的容器或 Pod 信息以及对特定容器或 Pod 进行抓包。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ptcpdump"&gt;
&lt;h2 id="hidptcpdump"&gt;ptcpdump 介绍&lt;a class="headerlink" href="#hidptcpdump" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ptcpdump 是一个使用 eBPF 技术开发的、类 tcpdump 的网络抓包工具。
它除了兼容 tcpdump 的常用命令行参数以及包过滤语法外，
还额外提供了如下核心特性：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;在输出中记录和显示发送网络流量的进程、容器、Pod 信息。&lt;/li&gt;
&lt;li&gt;支持对指定进程、容器以及 Pod 进行抓包。&lt;/li&gt;
&lt;li&gt;支持将抓取的数据包保存为 pcapng 格式，可以使用 tcpdump 或者 Wireshark 做进一步分析。&lt;/li&gt;
&lt;li&gt;当在 Wireshark 中打开保存的 pcapng 文件时，将能够看到每个数据包对应的进程、容器、Pod 信息。&lt;/li&gt;
&lt;li&gt;使用静态链接的方式编译该工具，系统中不需要安装额外的系统链接库。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多信息请参考项目的源代码仓库： &lt;a class="reference external" href="https://github.com/mozillazg/ptcpdump"&gt;https://github.com/mozillazg/ptcpdump&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面将以示例的形式介绍 ptcpdump 的核心功能。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tcpdump"&gt;
&lt;h2 id="hidtcpdump"&gt;兼容 tcpdump 的常用命令行参数和包过滤语法&lt;a class="headerlink" href="#hidtcpdump" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ptcpdump 兼容 tcpdump 的包过滤语法和常用的命令行参数，比如：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo tcpdump -i eth0 tcp
sudo tcpdump -i eth0 -A -v tcp and port 80 and host 10.10.1.1
sudo tcpdump -i eth0 'tcp[tcpflags] &amp;amp; (tcp-syn|tcp-fin) != 0'
sudo tcpdump -i any
sudo tcpdump -i any -s 0 -n -c 100 -w demo.pcapng port 80
&lt;/pre&gt;
&lt;p&gt;上面这些常见的 tcpdump 命令可以直接无缝替换为对应的 ptcpdump 命令，只需要将 tcpdump 改为 ptcpdump 即可:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo ptcpdump -i eth0 tcp
sudo ptcpdump -i eth0 -A -v tcp and port 80 and host 10.10.1.1
sudo ptcpdump -i eth0 'tcp[tcpflags] &amp;amp; (tcp-syn|tcp-fin) != 0'
sudo ptcpdump -i any
sudo ptcpdump -i any -s 0 -n -c 100 -w demo.pcapng port 80
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="pod"&gt;
&lt;h2 id="hidpod"&gt;在输出中记录和显示发送网络流量的进程、容器和 Pod 信息&lt;a class="headerlink" href="#hidpod" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;默认情况下，ptcpdump 将在输出中显示简单的进程、容器以及 Pod 信息:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 4 port 80 or port 443
2024-07-07 12:56:56 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 12:56:56 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
12:56:59.517657 veth18618a4a wget.13626 In IP 10.244.0.4.46834 &amp;gt; 13.251.96.10.443: Flags [S], seq 2743105662, win 64240, length 0, Container [test], Pod [test.default]
12:56:59.517836 eth0 wget.13626 Out IP 172.19.0.2.46834 &amp;gt; 13.251.96.10.443: Flags [S], seq 2743105662, win 64240, length 0, Container [test], Pod [test.default]
12:56:59.692593 eth0 wget.13626 In IP 13.251.96.10.443 &amp;gt; 172.19.0.2.46834: Flags [S.], seq 1966397178, ack 2743105663, win 65084, length 0, Container [test], Pod [test.default]
12:56:59.692754 veth18618a4a wget.13626 Out IP 13.251.96.10.443 &amp;gt; 10.244.0.4.46834: Flags [S.], seq 1966397178, ack 2743105663, win 65084, length 0, Container [test], Pod [test.default]
4 packets captured
6 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;可以通过指定 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-v&lt;/span&gt;&lt;/tt&gt; 参数，查看更详细的进程、容器以及 Pod 信息:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ptcpdump -i any -c 4 -v port 80 or port 443
2024-07-07 12:58:59 WARN ptcpdump: capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
12:59:02.265356 veth18618a4a In IP (tos 0x0, ttl 64, id 35996, offset 0, flags [DF], proto TCP (6), length 60)
    10.244.0.4.41666 &amp;gt; 13.215.144.61.443: Flags [S], cksum 0xa93a, seq 40651020, win 64240, options [mss 1460,sackOK,TS val 2665081987 ecr 0,nop,wscale 7], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
12:59:02.265606 eth0 Out IP (tos 0x0, ttl 63, id 35996, offset 0, flags [DF], proto TCP (6), length 60)
    172.19.0.2.41666 &amp;gt; 13.215.144.61.443: Flags [S], cksum 0x4a58, seq 40651020, win 64240, options [mss 1460,sackOK,TS val 2665081987 ecr 0,nop,wscale 7], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
12:59:02.462586 eth0 In IP (tos 0x4, ttl 47, id 0, offset 0, flags [DF], proto TCP (6), length 60)
    13.215.144.61.443 &amp;gt; 172.19.0.2.41666: Flags [S.], cksum 0x9772, seq 3160052321, ack 40651021, win 65084, options [mss 1240,sackOK,TS val 3710435767 ecr 2665081987,nop,wscale 9], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
12:59:02.462782 veth18618a4a Out IP (tos 0x4, ttl 46, id 0, offset 0, flags [DF], proto TCP (6), length 60)
    13.215.144.61.443 &amp;gt; 10.244.0.4.41666: Flags [S.], cksum 0x3890, seq 3160052321, ack 40651021, win 65084, options [mss 1240,sackOK,TS val 3710435767 ecr 2665081987,nop,wscale 9], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
4 packets captured
6 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-A&lt;/span&gt;&lt;/tt&gt; 参数以 ASCII 格式输出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:44:34.457504 ens33 curl.205562 Out IP 10.0.2.15.39984 &amp;gt; 139.178.84.217.80: Flags [P.], seq 2722472188:2722472262, ack 892036871, win 64240, length 74, ParentProc [bash.180205]
E..r.,&amp;#64;.&amp;#64;.o.
.....T..0.P.E..5+g.P.......GET / HTTP/1.1
Host: kernel.org
User-Agent: curl/7.81.0
Accept: */*
&lt;/pre&gt;
&lt;p&gt;通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-x&lt;/span&gt;&lt;/tt&gt; 参数以 16 进制格式输出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:44:34.457504 ens33 curl.205562 IP 10.0.2.15.39984 &amp;gt; 139.178.84.217.80: Flags [P.], seq 2722472188:2722472262, ack 892036871, win 64240, length 74, ParentProc [bash.180205]
        0x0000:  4500 0072 de2c 4000 4006 6fbf 0a00 020f
        0x0010:  8bb2 54d9 9c30 0050 a245 a0fc 352b 6707
        0x0020:  5018 faf0 ecfe 0000 4745 5420 2f20 4854
        0x0030:  5450 2f31 2e31 0d0a 486f 7374 3a20 6b65
        0x0040:  726e 656c 2e6f 7267 0d0a 5573 6572 2d41
        0x0050:  6765 6e74 3a20 6375 726c 2f37 2e38 312e
        0x0060:  300d 0a41 6363 6570 743a 202a 2f2a 0d0a
        0x0070:  0d0a
&lt;/pre&gt;
&lt;p&gt;通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-X&lt;/span&gt;&lt;/tt&gt; 参数以 16 进制和 ASCII 格式输出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:44:34.457504 ens33 curl.205562 IP 10.0.2.15.39984 &amp;gt; 139.178.84.217.80: Flags [P.], seq 2722472188:2722472262, ack 892036871, win 64240, length 74, ParentProc [bash.180205]
        0x0000:  4500 0072 de2c 4000 4006 6fbf 0a00 020f  E..r.,&amp;#64;.&amp;#64;.o.....
        0x0010:  8bb2 54d9 9c30 0050 a245 a0fc 352b 6707  ..T..0.P.E..5+g.
        0x0020:  5018 faf0 ecfe 0000 4745 5420 2f20 4854  P.......GET / HT
        0x0030:  5450 2f31 2e31 0d0a 486f 7374 3a20 6b65  TP/1.1..Host: ke
        0x0040:  726e 656c 2e6f 7267 0d0a 5573 6572 2d41  rnel.org..User-A
        0x0050:  6765 6e74 3a20 6375 726c 2f37 2e38 312e  gent: curl/7.81.
        0x0060:  300d 0a41 6363 6570 743a 202a 2f2a 0d0a  0..Accept: */*..
        0x0070:  0d0a                                     ..
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="pod-1"&gt;
&lt;h2 id="hidpod-1"&gt;支持对指定进程、容器或 Pod 进行抓包&lt;a class="headerlink" href="#hidpod-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="pid"&gt;
&lt;h3 id="hidpid"&gt;指定进程 pid 抓包&lt;a class="headerlink" href="#hidpid" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--pid&lt;/span&gt;&lt;/tt&gt; 参数指定要抓包的进程 pid，实现对指定进程进行抓包:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 4 --pid 82106
2024-07-07 13:11:40 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:11:40 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:11:50.170538 ens33 python3.10.82106 Out IP 10.0.2.15.36648 &amp;gt; 13.251.96.10.443: Flags [S], seq 1633417447, win 64240, length 0
13:11:50.369972 ens33 python3.10.82106 In IP 13.251.96.10.443 &amp;gt; 10.0.2.15.36648: Flags [S.], seq 1793291274, ack 1633417448, win 64240, length 0
2 packets captured
3 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;同时还可以通过指定 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-f&lt;/span&gt;&lt;/tt&gt; 参数对该进程创建的子进程也进行抓包:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 4 --pid 82106 -f 'tcp[tcpflags] &amp;amp; tcp-fin != 0'
2024-07-07 13:17:31 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:17:31 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:17:37.800903 ens33 python3.10.82106 Out IP 10.0.2.15.38576 &amp;gt; 52.74.166.77.443: Flags [F.], seq 2442149577, ack 367271121, win 62780, length 0
13:17:37.977316 ens33 python3.10.82106 In IP 52.74.166.77.443 &amp;gt; 10.0.2.15.38576: Flags [FP.], seq 367271145, ack 2442149578, win 64239, length 0
13:17:44.390627 ens33 curl.95920 Out IP 10.0.2.15.38590 &amp;gt; 52.74.166.77.443: Flags [F.], seq 3726932781, ack 1510095004, win 63045, length 0
13:17:44.564990 ens33 curl.95920 In IP 52.74.166.77.443 &amp;gt; 10.0.2.15.38590: Flags [FP.], seq 1510095028, ack 3726932782, win 64239, length 0
4 packets captured
4 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h3 id="hidsection-2"&gt;指定进程名称抓包&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--pname&lt;/span&gt;&lt;/tt&gt; 参数指定进程名称（comm），实现指定进程名称抓包:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --pname curl
2024-07-07 13:23:18 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:23:18 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:23:24.881499 lo curl.26511 Out IP 127.0.0.1.43332 &amp;gt; 127.0.0.53.53: 44133+ [1au] A? mozillazg.com. (42)
13:23:24.881663 lo curl.26511 Out IP 127.0.0.1.43332 &amp;gt; 127.0.0.53.53: 14694+ [1au] AAAA? mozillazg.com. (42)
2 packets captured
2 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h3 id="hidsection-3"&gt;通过运行目标程序来抓包&lt;a class="headerlink" href="#hidsection-3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有需要的话，也可以通过使用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--&lt;/span&gt;&lt;/tt&gt; 参数运行目标程序的方式来实现对特定程序进行抓包:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -- curl -I https://mozillazg.com
2024-07-07 13:26:44 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:26:44 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:26:44.055757 lo curl.28094 Out IP 127.0.0.1.48826 &amp;gt; 127.0.0.53.53: 8942+ [1au] A? mozillazg.com. (42)
13:26:44.055914 lo curl.28094 Out IP 127.0.0.1.48826 &amp;gt; 127.0.0.53.53: 34274+ [1au] AAAA? mozillazg.com. (42)
13:26:44.775840 lo curl.28094 In IP 127.0.0.53.53 &amp;gt; 127.0.0.1.48826: 8942 3/0/1 CNAME mozillazg.netlify.com., A 13.251.96.10, A 46.137.195.11 (106)
13:26:45.135988 lo curl.28094 In IP 127.0.0.53.53 &amp;gt; 127.0.0.1.48826: 34274 3/0/1 CNAME mozillazg.netlify.com., AAAA 2406:da18:880:3802::c8, AAAA 2406:da18:b3d:e202::64 (130)
13:26:45.136819 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [S], seq 3460683104, win 64800, length 0
13:26:45.310505 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [S.], seq 630810442, ack 3460683105, win 65232, length 0
13:26:45.310821 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683105, ack 630810443, win 507, length 0
13:26:45.414551 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683105:3460683622, ack 630810443, win 507, length 517
13:26:45.595214 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630810443, ack 3460683622, win 127, length 0
13:26:45.595413 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630810443:630811651, ack 3460683622, win 127, length 1208
13:26:45.595595 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630811651, win 501, length 0
13:26:45.595702 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630811651:630812859, ack 3460683622, win 127, length 1208
13:26:45.595797 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630812859, win 492, length 0
13:26:45.595862 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630812859:630813338, ack 3460683622, win 127, length 479
13:26:45.595934 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630813338, win 489, length 0
13:26:45.600998 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683622:3460683686, ack 630813338, win 489, length 64
13:26:45.601344 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683686:3460683781, ack 630813338, win 489, length 95
13:26:45.616759 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683781:3460683882, ack 630813338, win 501, length 101
13:26:45.779516 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813338, ack 3460683781, win 127, length 0
13:26:45.779792 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813338:630813399, ack 3460683781, win 127, length 61
13:26:45.779996 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813399:630813443, ack 3460683781, win 127, length 44
13:26:45.780318 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683882:3460683913, ack 630813443, win 501, length 31
HTTP/2 200
13:26:45.788787 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813443:630813677, ack 3460683882, win 127, length 234
accept-ranges: bytes
age: 79059
cache-control: public,max-age=0,must-revalidate
cache-status: &amp;quot;Netlify Edge&amp;quot;; hit
content-type: text/html; charset=UTF-8
date: Sun, 07 Jul 2024 05:26:44 GMT
etag: &amp;quot;80cf37f5974e2232d976c6f622121dee-ssl&amp;quot;
server: Netlify
strict-transport-security: max-age=31536000
x-nf-request-id: 01J25THACQSN9364YHSR2C0X5F
content-length: 11727

13:26:45.789558 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683913:3460683937, ack 630813677, win 501, length 24
13:26:45.791514 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [F.], seq 3460683937, ack 630813677, win 501, length 0
13:26:45.963642 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813677, ack 3460683937, win 127, length 0
13:26:45.963956 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813677:630813701, ack 3460683937, win 127, length 24
13:26:45.964172 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683937, win 0, length 0
13:26:45.964415 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [F.], seq 630813701, ack 3460683937, win 127, length 0
13:26:45.964506 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683937, win 0, length 0
13:26:45.966158 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813702, ack 3460683938, win 127, length 0
13:26:45.966299 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683938, win 0, length 0
32 packets captured
32 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3 id="hidsection-4"&gt;指定容器抓包&lt;a class="headerlink" href="#hidsection-4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--container-id&lt;/span&gt;&lt;/tt&gt; 参数指定容器 id 进行抓包:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --container-id 36f0310403b1
2024-07-07 13:36:19 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:36:19 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:36:24.191242 veth09dec8f curl.32636 In IP 172.19.0.2.48960 &amp;gt; 18.139.194.139.443: Flags [S], seq 3213779351, win 64240, length 0, Container [kind-control-plane]
13:36:24.191369 wlp4s0 curl.32636 Out IP 192.168.1.50.48960 &amp;gt; 18.139.194.139.443: Flags [S], seq 3213779351, win 64240, length 0, Container [kind-control-plane]
2 packets captured
2 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;也可以通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--container-name&lt;/span&gt;&lt;/tt&gt; 参数指定容器名称进行抓包:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --container-name kind-control-plane
2024-07-07 13:37:16 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:37:16 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:37:22.560764 veth09dec8f curl.33093 In IP 172.19.0.2.39084 &amp;gt; 18.139.194.139.443: Flags [S], seq 3645727033, win 64240, length 0, Container [kind-control-plane]
13:37:22.561010 wlp4s0 curl.33093 Out IP 192.168.1.50.39084 &amp;gt; 18.139.194.139.443: Flags [S], seq 3645727033, win 64240, length 0, Container [kind-control-plane]
2 packets captured
2 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="pod-2"&gt;
&lt;h3 id="hidpod-2"&gt;指定 Pod 抓包&lt;a class="headerlink" href="#hidpod-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--pod-name&lt;/span&gt;&lt;/tt&gt; 参数指定 Pod 名称进行抓包, 参数值的格式为 &lt;tt class="docutils literal"&gt;&amp;lt;pod &lt;span class="pre"&gt;名称&amp;gt;.&amp;lt;pod&lt;/span&gt; 命名空间&amp;gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --pod-name test.default
2024-07-07 13:38:29 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:38:29 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:38:34.175752 eth0 wget.33660 Out IP 172.19.0.2.51564 &amp;gt; 13.215.144.61.443: Flags [S], seq 567383917, win 64240, length 0, Container [test], Pod [test.default]
13:38:34.372894 eth0 wget.33660 In IP 13.215.144.61.443 &amp;gt; 172.19.0.2.51564: Flags [S.], seq 2654865684, ack 567383918, win 65084, length 0, Container [test], Pod [test.default]
2 packets captured
3 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pcapng-tcpdump-wireshark"&gt;
&lt;h2 id="hidpcapng-tcpdump-wireshark"&gt;将数据保存为 pcapng 格式使用 tcpdump 或 Wireshark 进行分析&lt;a class="headerlink" href="#hidpcapng-tcpdump-wireshark" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="pcapng"&gt;
&lt;h3 id="hidpcapng"&gt;保存为 pcapng 格式&lt;a class="headerlink" href="#hidpcapng" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-w&lt;/span&gt;&lt;/tt&gt; 参数将抓包数据保存为 pcapng 格式:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 5 -w demo.pcapng
2024-07-07 13:41:32 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:41:32 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
5 packets captured
22 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="tcpdump-1"&gt;
&lt;h3 id="hidtcpdump-1"&gt;使用 tcpdump 进行分析&lt;a class="headerlink" href="#hidtcpdump-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以直接通过管道的方式通过 tcpdump 对抓取的数据进行分析:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 5 -w - port 80 | tcpdump -n -r -
reading from file -, link-type EN10MB (Ethernet), snapshot length 65535
2024-07-07 13:44:33 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:44:33 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:44:44.530637 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &amp;gt; 2406:da18:880:3801::c8.80: Flags [S], seq 495824072, win 64800, options [mss 1440,sackOK,TS val 2411675580 ecr 0,nop,wscale 7], length 0
13:44:44.708902 IP6 2406:da18:880:3801::c8.80 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858: Flags [S.], seq 640438481, ack 495824073, win 65232, options [mss 1220,sackOK,TS val 1591525382 ecr 2411675580,nop,wscale 9], length 0
13:44:44.709261 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &amp;gt; 2406:da18:880:3801::c8.80: Flags [.], ack 1, win 507, options [nop,nop,TS val 2411675670 ecr 1591525382], length 0
13:44:44.709475 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &amp;gt; 2406:da18:880:3801::c8.80: Flags [P.], seq 1:78, ack 1, win 507, options [nop,nop,TS val 2411675670 ecr 1591525382], length 77: HTTP: GET / HTTP/1.1
5 packets captured
6 packets received by filter
0 packets dropped by kernel
13:44:44.877110 IP6 2406:da18:880:3801::c8.80 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858: Flags [P.], seq 1:266, ack 78, win 128, options [nop,nop,TS val 1591525469 ecr 2411675670], length 265: HTTP: HTTP/1.1 301 Moved Permanently
&lt;/pre&gt;
&lt;p&gt;也可以通过读取文件的方式通过 tcpdump 对抓取的数据进行分析:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ tcpdump -n -r demo.pcapng
reading from file demo.pcapng, link-type EN10MB (Ethernet), snapshot length 65535
13:47:41.169584 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &amp;gt; 2406:da18:b3d:e201::64.80: Flags [S], seq 3876639697, win 64800, options [mss 1440,sackOK,TS val 2072195434 ecr 0,nop,wscale 7], length 0
13:47:41.571055 IP 192.168.1.50.60580 &amp;gt; 18.139.194.139.80: Flags [S], seq 481256927, win 64240, options [mss 1460,sackOK,TS val 2707199178 ecr 0,nop,wscale 7], length 0
13:47:41.956270 IP6 2406:da18:b3d:e201::64.80 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038: Flags [S.], seq 2283576526, ack 3876639698, win 65232, options [mss 1220,sackOK,TS val 4276006323 ecr 2072195434,nop,wscale 9], length 0
13:47:41.956437 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &amp;gt; 2406:da18:b3d:e201::64.80: Flags [.], ack 1, win 507, options [nop,nop,TS val 2072195828 ecr 4276006323], length 0
13:47:41.956733 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &amp;gt; 2406:da18:b3d:e201::64.80: Flags [P.], seq 1:78, ack 1, win 507, options [nop,nop,TS val 2072195828 ecr 4276006323], length 77: HTTP: GET / HTTP/1.1
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="wireshark"&gt;
&lt;h3 id="hidwireshark"&gt;使用 Wireshark 进行分析&lt;a class="headerlink" href="#hidwireshark" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;当使用 Wireshark 打开保存的 pcapng 格式的文件时，将在 Wireshark 的界面中显示相关的进程、容器以及 Pod 信息：&lt;/p&gt;
&lt;img alt="" src="/static/images/bpf/ptcpdump-wireshark.png" /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h2 id="hidsection-5"&gt;参考资料&lt;a class="headerlink" href="#hidsection-5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/ptcpdump"&gt;mozillazg/ptcpdump: Process-aware, eBPF-based tcpdump&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.tcpdump.org/manpages/tcpdump.1-4.99.4.html"&gt;tcpdump(1) man page | TCPDUMP &amp;amp; LIBPCAP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sat, 06 Jul 2024 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2024-07-06:2024/07/ebpf-ptcpdump-capturing-the-network-traffic-of-a-process-or-container-or-pod.html</guid><category>ebpf</category><category>ptcpdump</category><category>tcpdump</category><category>pcapng</category><category>wireshark</category><category>container</category><category>pod</category></item><item><title>A case in which tracing the execve system call with tracepoints does not accurately capture the system call parameters</title><link>https://mozillazg.com/2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case-en.html</link><description>&lt;div class="section" id="background"&gt;
&lt;h2 id="hidbackground"&gt;Background&lt;a class="headerlink" href="#hidbackground" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Some time ago, a netizen consulted a problem he encountered in the &lt;a class="reference external" href="https://ebpf.io/slack"&gt;ebpf channel on slack&lt;/a&gt; :&lt;/p&gt;
&lt;!-- `question &lt;https://cilium.slack.com/archives/C4XCTGYEM/p1710380136906129?thread_ts=1710284853.310149&amp;cid=C4XCTGYEM&gt;`__ ： --&gt;
&lt;p&gt;When writing an eBPF program that uses &lt;tt class="docutils literal"&gt;tracepoint/syscalls/sys_enter_execve&lt;/tt&gt; to trace the execve system call,
encountered a situation where there is a failure in reading the &lt;tt class="docutils literal"&gt;filename&lt;/tt&gt;
parameter of &lt;tt class="docutils literal"&gt;execve&lt;/tt&gt; using &lt;tt class="docutils literal"&gt;bpf_probe_read_user_str&lt;/tt&gt; in the recorded events,
with an error code of -14/EFAULT. Especially when executing the &lt;tt class="docutils literal"&gt;tmux&lt;/tt&gt; command,
there will always be an event of a failed read:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ret = bpf_probe_read_user_str(event-&amp;gt;args, ARGSIZE, (const char*)ctx-&amp;gt;args[0]);
if (ret &amp;lt; 0) {
        bpf_printk(&amp;quot;comm=%s XXX cannot read file name&amp;quot;, tgid, pid, event-&amp;gt;comm);
        return 0;
}

utempter-4031732 [027] d...1 3878624.643948: bpf_trace_printk: comm=tmux: server XXX cannot read file name
   &amp;lt;...&amp;gt;-4035723 [077] d...1 3878668.047954: bpf_trace_printk: comm=tmux: server XXX cannot read file name
&lt;/pre&gt;
&lt;p&gt;This article will delve into the causes of this problem and propose a solution specifically designed for this situation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="reproduce-the-problem-code"&gt;
&lt;h2 id="hidreproduce-the-problem-code"&gt;Reproduce the Problem Code&lt;a class="headerlink" href="#hidreproduce-the-problem-code" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Since the problem mentioned that the issue always occurs when executing the &lt;tt class="docutils literal"&gt;tmux&lt;/tt&gt; command,
and we can see in the output of &lt;tt class="docutils literal"&gt;bpf_printk&lt;/tt&gt; that the process name
for the corresponding event is &lt;tt class="docutils literal"&gt;utempter&lt;/tt&gt;, we can try to write
a simple program to reproduce the problem based on these two pieces of information.&lt;/p&gt;
&lt;p&gt;After searching online for the relationship between tmux and utempter,
and reading the relevant tmux source code, I learned the following information:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;tmux uses the &lt;a class="reference external" href="https://github.com/tmux/tmux/blob/b79e28b2c30e7ef9b1f7ec6233eeb70a1a177231/spawn.c#L473"&gt;utempter_add_record&lt;/a&gt;
function provided by &lt;tt class="docutils literal"&gt;utempter.h&lt;/tt&gt; to create the required pseudo-terminal:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
xasprintf(&amp;amp;cp, &amp;quot;tmux(%lu).%%%u&amp;quot;, (long)getpid(), new_wp-&amp;gt;id);
utempter_add_record(new_wp-&amp;gt;fd, cp);
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;In the &lt;cite&gt;utempter_add_record&lt;/cite&gt; function, it will first construct an &lt;cite&gt;args&lt;/cite&gt; from the passed parameters and then invoke the
&lt;a class="reference external" href="https://github.com/altlinux/libutempter/blob/9f291816a746292547ac8aaea0c88e16fc2fb29a/libutempter/iface.c#L121"&gt;execute_helper&lt;/a&gt;
function:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#define UTEMPTER_DEFAULT_PATHNAME     LIBEXECDIR &amp;quot;/utempter/utempter&amp;quot;
static const char *utempter_pathname;

int utempter_add_record(int master_fd, const char *hostname)
  {
      const char *const args[] = {
          utempter_pathname ? : UTEMPTER_DEFAULT_PATHNAME,
          &amp;quot;add&amp;quot;,
          hostname,
          0
      };
      int status = execute_helper(master_fd, args);
      // ...
  }
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;In the &lt;tt class="docutils literal"&gt;execute_helper&lt;/tt&gt; function, the passed &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; will eventually be used to call the
&lt;tt class="docutils literal"&gt;fork()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;execv()&lt;/tt&gt; functions to start a new process
( &lt;a class="reference external" href="https://github.com/altlinux/libutempter/blob/9f291816a746292547ac8aaea0c88e16fc2fb29a/libutempter/iface.c#L84"&gt;source code&lt;/a&gt; ):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static int execute_helper(int master_fd, const char *const argv[])
{
    // ...
    child = fork();
    if (!child) {
        do_child(master_fd, argv[0], (char *const *) argv);
    } else if (child &amp;lt; 0) {
    // ...
}
static void __attribute__((__noreturn__))
do_child(int master_fd, const char *path, char *const *argv)
{
    // ...
    execv(path, argv);
    print_dbg(&amp;quot;execv: %s&amp;quot;, strerror(errno));
    //...
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Based on the above information, we can write the following program to reproduce this issue
&lt;a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce.c"&gt;reproduce.c&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#define PATHNAME &amp;quot;/usr/bin/echo&amp;quot;

int main(int argc, char **argv) {
    const char *hostname = argv[0];
    const char *const args[] = {
        PATHNAME,
        &amp;quot;add&amp;quot;,
        hostname,
        0
    };
    if (!fork()) {
        execv(args[0], (char *const *) args);
    }
}
&lt;/pre&gt;
&lt;p&gt;Let's test the effectiveness of this program below:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Compile using GCC:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gcc -o reproduce reproduce.c
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Trace the &lt;tt class="docutils literal"&gt;tracepoint/syscalls/sys_enter_execve&lt;/tt&gt; event using &lt;a class="reference external" href="https://github.com/bpftrace/bpftrace"&gt;bpftrace&lt;/a&gt;
in another terminal:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo bpftrace -e 'tracepoint:syscalls:sys_enter_execve{printf(&amp;quot;%s[%d]: %s\n&amp;quot;, comm, pid, str(args-&amp;gt;filename));}'
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Run the example program:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
./reproduce
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;At this time, the terminal running bpftrace will output results similar to the following:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bash[34882]: ./reproduce
reproduce[34883]:
&lt;/pre&gt;
&lt;p&gt;In the previous results, we did not capture the value of the &lt;cite&gt;filename&lt;/cite&gt; parameter used during
the execution of the &lt;cite&gt;execve()&lt;/cite&gt; system call by the reproducing program.
From this, it can be seen that our program has reproduced the original issue.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="reason"&gt;
&lt;h2 id="hidreason"&gt;Reason&lt;a class="headerlink" href="#hidreason" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Reminded by &lt;a class="reference external" href="https://github.com/ssfdust"&gt;&amp;#64;ssfdust&lt;/a&gt;, someone in the bpftrace community
has previously raised a similar issue: &lt;a class="reference external" href="https://github.com/bpftrace/bpftrace/issues/2523"&gt;#2523&lt;/a&gt; .
In this issue, &lt;a class="reference external" href="https://github.com/fbs"&gt;&amp;#64;fbs&lt;/a&gt; provided an
&lt;a class="reference external" href="https://github.com/bpftrace/bpftrace/issues/2523#issuecomment-1466936511"&gt;explanation&lt;/a&gt; :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Like I said earlier, the data you're using isn't in memory yet. These static strings are compiled in and are not actually faulted into memory until they're accessed. The access won't happen until its read, which is after your bpftrace probe ran. BPF won't pull the data in so you get an EFAULT/-14.&lt;/p&gt;
&lt;p&gt;By printing the values or just a random print of a constant string you pull the small amount of data into memory (as it goes by page, not by var) and then it works&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That is:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;In the sample program, when executing &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt;, the file name string referred to by &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; is a static string.
These static strings are stored in the &lt;tt class="docutils literal"&gt;.rodata&lt;/tt&gt; section of the ELF (Executable and Linkable Format) file
after compilation. They are loaded into memory only when the program accesses them,
specifically when accessing the data stored in the &lt;tt class="docutils literal"&gt;.rodata&lt;/tt&gt; section.&lt;/li&gt;
&lt;li&gt;Based on point 1, the static string referenced by &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; in the sample program is only
loaded into memory during the execution of the &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; system call. However,
since our eBPF program runs before the &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; system call, attempting to read &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; using
bpf_probe_read_user_str will fail and result in an &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;EFAULT/-14&lt;/span&gt;&lt;/tt&gt; error code.&lt;/li&gt;
&lt;li&gt;By actively loading strings into memory through &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; and other methods, this problem can be resolved.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Summary from &lt;a class="reference external" href="https://github.com/jschwinger233"&gt;&amp;#64;jschwinger233&lt;/a&gt; :&lt;/p&gt;
&lt;blockquote&gt;
bpf_probe_read_user can only read data that has been loaded into memory (page-faulted into memory),
and the above code has not read .rodata until the execve(2) time, thus not triggering a page fault.
This can be verified using tracepoint:exceptions:page_fault*.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="verification"&gt;
&lt;h2 id="hidverification"&gt;Verification&lt;a class="headerlink" href="#hidverification" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="add-a-printf-statement"&gt;
&lt;h3 id="hidadd-a-printf-statement"&gt;Add a printf statement&lt;a class="headerlink" href="#hidadd-a-printf-statement" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;From the above, it can be seen that actually we only need to modify the program to proactively
load the data in &lt;tt class="docutils literal"&gt;.rodata&lt;/tt&gt; into memory before executing &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt;, for example, using the &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; function.&lt;/p&gt;
&lt;p&gt;You can use the &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; function to print &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt;, or you can directly print a static string:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if (!fork()) {
    printf(&amp;quot;test\n&amp;quot;);
    // or
    // printf(&amp;quot;argv[0]: %s\n&amp;quot;, args[0]);
    execv(args[0], (char *const *) args);
}
&lt;/pre&gt;
&lt;p&gt;After verification, the modified program
&lt;a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce_printf1.c"&gt;reproduce_printf1.c&lt;/a&gt;
does allow the ebpf program to correctly read the value of filename.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="not-using-static-strings"&gt;
&lt;h3 id="hidnot-using-static-strings"&gt;Not using static strings&lt;a class="headerlink" href="#hidnot-using-static-strings" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Since the issue is caused by the fact that &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; is a static string, you can try changing
&lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; to use a non-static string to see if the problem still exists.
The modified content is as follows:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
const char *const args[] = {
    argv[1],
    &amp;quot;add&amp;quot;,
    hostname,
    0
};
&lt;/pre&gt;
&lt;p&gt;After verification, the modified program
&lt;a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce_non_static.c"&gt;reproduce_non_static.c&lt;/a&gt;
can also allow the ebpf program to correctly read the value of filename.&lt;/p&gt;
&lt;p&gt;I wonder if anyone has noticed that the value of &lt;tt class="docutils literal"&gt;argv[2]&lt;/tt&gt; in
our program reproducing the issue is actually a non-static string,
so it can also be verified by reading the content of this data in the eBPF program.
The expectation is to be able to read the content of this non-static string &lt;tt class="docutils literal"&gt;argv[2]&lt;/tt&gt;
without making any modifications:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Run the new bpftrace command:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo bpftrace -e 'tracepoint:syscalls:sys_enter_execve{
    printf(&amp;quot;%s[%d]: filename: %s, argv[1]: %s, argv[2]: %s\n&amp;quot;, comm, pid, str(args-&amp;gt;filename), str(args-&amp;gt;argv[1]), str(args-&amp;gt;argv[2]));
}'
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Run &lt;tt class="docutils literal"&gt;./reproduce&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;The output example of the bpftrace command is as follows:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bash[36523]: filename: ./reproduce, argv[1]: , argv[2]:
reproduce[36524]: filename: , argv[1]: , argv[2]: ./reproduce
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="page-fault"&gt;
&lt;h3 id="hidpage-fault"&gt;page fault&lt;a class="headerlink" href="#hidpage-fault" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In modern Linux systems, when we run a binary executable file,
the program loader (ELF executable loader) will use &lt;tt class="docutils literal"&gt;mmap&lt;/tt&gt; for lazy loading based on
the information defined in the ELF file, delaying the loading of some data.
When the program actually tries to read these data, if the data being read has
not been loaded into memory yet, it will trigger a page fault.&lt;/p&gt;
&lt;!-- CPU 就会生成一个缺页异常（page fault exception）。此时，内核中的缺页处理程序（page fault handler） --&gt;
&lt;!-- 会负责处理该异常，将缺失的页面加载到内存中，然后 CPU 重新执行引起缺页异常的指令。 --&gt;
&lt;p&gt;The data stored in the &lt;tt class="docutils literal"&gt;.rodata&lt;/tt&gt; section of ELF files is exactly the data that will be lazily loaded.&lt;/p&gt;
&lt;div class="section" id="rodata"&gt;
&lt;h4 id="hidrodata"&gt;.rodata&lt;a class="headerlink" href="#hidrodata" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;.rodata&lt;/tt&gt; section in an ELF file stores some read-only data, such as static strings.
Let's first take a look at the data in the &lt;tt class="docutils literal"&gt;.rodata&lt;/tt&gt; section of the compiled example program binary ELF file.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;You can use the &lt;tt class="docutils literal"&gt;objdump&lt;/tt&gt; command to view the contents:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ objdump -s -j .rodata ./reproduce

./reproduce:     file format elf64-x86-64

Contents of section .rodata:
2000 01000200 2f757372 2f62696e 2f656368  ..../usr/bin/ech
2010 6f006164 6400                        o.add.
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;You can also use the &lt;a class="reference external" href="https://docs.pwntools.com/en/stable/"&gt;pwntools&lt;/a&gt; library from the Python community for reading:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; from pwn import ELF
&amp;gt;&amp;gt;&amp;gt; elf = ELF('reproduce')
&amp;gt;&amp;gt;&amp;gt; elf.section('.rodata')
b'\x01\x00\x02\x00/usr/bin/echo\x00add\x00'
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From the above output, it can be seen that it contains two static strings used in the source code.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="observing-page-fault"&gt;
&lt;h4 id="hidobserving-page-fault"&gt;Observing page fault&lt;a class="headerlink" href="#hidobserving-page-fault" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;In the Linux system, when the kernel executes the &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; system call, it calls the kernel function
&lt;tt class="docutils literal"&gt;strncpy_from_user&lt;/tt&gt; (&lt;tt class="docutils literal"&gt;execve() &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; getname() &lt;span class="pre"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pre"&gt;getname_flags(),&lt;/span&gt; strncpy_from_user()&lt;/tt&gt;) to copy the string data
contained in &lt;tt class="docutils literal"&gt;argv&lt;/tt&gt; from user space to kernel space. This process involves reading user space data.
If the user space data being read has not yet been loaded into memory, it will trigger a page fault.&lt;/p&gt;
&lt;p&gt;We can perceive this event by observing &lt;tt class="docutils literal"&gt;exceptions/page_fault_kernel&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;exceptions/page_fault_user&lt;/tt&gt;:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;To simplify the verification process, we need to make a modification to the example code. Add a line of &lt;tt class="docutils literal"&gt;sleep(15)&lt;/tt&gt;
before executing the &lt;tt class="docutils literal"&gt;execv()&lt;/tt&gt; function to ensure the program does not terminate too quickly
(&lt;a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce_sleep.c"&gt;reproduce_sleep.c&lt;/a&gt; ):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if (!fork()) {
     sleep(15);
     execv(args[0], (char *const *) args);
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Run the following bpftrace script in a terminal to observe page faults:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cat &amp;lt;&amp;lt;EOF | sudo bpftrace -
tracepoint:exceptions:page_fault_kernel /comm == &amp;quot;reproduce_sleep&amp;quot;/ {
    printf(&amp;quot;[%s] page_fault_kernel: %s[%d] addr=%llx ip=%llx err=%lld\n&amp;quot;,
            strftime(&amp;quot;%M:%S&amp;quot;, nsecs), comm, pid, args-&amp;gt;address, args-&amp;gt;ip, args-&amp;gt;error_code);
}

tracepoint:exceptions:page_fault_user /comm == &amp;quot;reproduce_sleep&amp;quot;/ {
    printf(&amp;quot;[%s] page_fault_user:   %s[%d] addr=%llx ip=%llx err=%lld\n&amp;quot;,
            strftime(&amp;quot;%M:%S&amp;quot;, nsecs), comm, pid, args-&amp;gt;address, args-&amp;gt;ip, args-&amp;gt;error_code);
}
EOF
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Then run ./reproduce_sleep in another terminal.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;View the memory mapping of the running reproduce_sleep process in the third terminal:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo cat /proc/41291/maps | grep reproduce_sleep
55b4d9e31000-55b4d9e32000 r--p 00000000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e32000-55b4d9e33000 r-xp 00001000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e33000-55b4d9e34000 r--p 00002000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e34000-55b4d9e35000 r--p 00002000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e35000-55b4d9e36000 rw-p 00003000 08:01 1634479                    /XXX/reproduce_sleep
&lt;/pre&gt;
&lt;p&gt;From the above, it can be seen that the memory mapping starting address of this process is &lt;tt class="docutils literal"&gt;55b4d9e31000&lt;/tt&gt;,
that is, &lt;tt class="docutils literal"&gt;0x55b4d9e&lt;/tt&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;After the example program finishes running, the last two lines of the output of the bpftrace command
will be similar to the following:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[47:40] page_fault_user:   reproduce_sleep[41290] addr=7f669db86a50 ip=7f669d9f8940 err=7
[47:55] page_fault_kernel: reproduce_sleep[41291] addr=55b4d9e33004 ip=ffffffff8e092a40 err=0
&lt;/pre&gt;
&lt;p&gt;The 15-second gap between these two outputs confirms that the last page fault event was triggered
when the &lt;tt class="docutils literal"&gt;execv()&lt;/tt&gt; function was executed. Now let's locate the corresponding data based on
the &lt;tt class="docutils literal"&gt;addr&lt;/tt&gt; result in the event.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;The value of the &lt;cite&gt;addr&lt;/cite&gt; output of the last &lt;tt class="docutils literal"&gt;page_fault_kernel&lt;/tt&gt; event above is &lt;tt class="docutils literal"&gt;55b4d9e33004&lt;/tt&gt;,
which means the virtual memory address that triggered this page fault event is &lt;tt class="docutils literal"&gt;0x55b4d9e33004&lt;/tt&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Based on the recipe shared by &lt;a class="reference external" href="https://github.com/jschwinger233"&gt;&amp;#64;jschwinger233&lt;/a&gt;:
&lt;tt class="docutils literal"&gt;real_addr = start_addr + (elf_address - section.Address + section.Offset)&lt;/tt&gt; can be known:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
0x55b4d9e33004 = 0x55b4d9e31000 + (elf_address - section.Address + section.Offset)
(elf_address - section.Address + section.Offset) = 0x55b4d9e33004 - 0x55b4d9e31000 = 8196 = 0x2004
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Use the &lt;tt class="docutils literal"&gt;readelf&lt;/tt&gt; command to read the virtual address, offset, and data size of the ELF &lt;tt class="docutils literal"&gt;.rodata&lt;/tt&gt; section
in the binary file &lt;tt class="docutils literal"&gt;reproduce_sleep&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ readelf -S -W reproduce_sleep  | egrep '.rodata|Address'
  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
  [18] .rodata           PROGBITS        0000000000002000 002000 000016 00   A  0   0  4
&lt;/pre&gt;
&lt;p&gt;From the above output, it can be seen that the virtual address of the &lt;tt class="docutils literal"&gt;.rodata&lt;/tt&gt; section in this ELF file
is &lt;tt class="docutils literal"&gt;0000000000002000&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;0x2000&lt;/tt&gt;, the offset is &lt;tt class="docutils literal"&gt;002000&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;0x2000&lt;/tt&gt;, the data size is &lt;tt class="docutils literal"&gt;0x16&lt;/tt&gt;, that is,
the address range is &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;0x2000-0x2016&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Through 7 and 8, it can be known that the virtual memory address of the page fault event triggered when
executing the &lt;tt class="docutils literal"&gt;execv()&lt;/tt&gt; function is &lt;tt class="docutils literal"&gt;0x55b4d9e33004&lt;/tt&gt;, corresponding to the ELF address &lt;tt class="docutils literal"&gt;0x2004&lt;/tt&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
0x55b4d9e33004 = 0x55b4d9e31000 + (elf_address - section.Address + section.Offset)
(elf_address - section.Address + section.Offset) = 0x55b4d9e33004 - 0x55b4d9e31000 = 8196 = 0x2004
(elf_address - 0x2000 + 0x2000) = 0x2004
elf_address = 0x2004
&lt;/pre&gt;
&lt;p&gt;This address is within the range of the &lt;tt class="docutils literal"&gt;.rodata&lt;/tt&gt; address in the ELF file (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;0x2000-0x2016&lt;/span&gt;&lt;/tt&gt;),
corresponding to the static string &lt;tt class="docutils literal"&gt;/usr/bin/echo&lt;/tt&gt; used in &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ objdump -s -j .rodata ./reproduce_sleep

./reproduce_sleep:     file format elf64-x86-64

Contents of section .rodata:
 2000 01000200 2f757372 2f62696e 2f656368  ..../usr/bin/ech
 2010 6f006164 6400                        o.add.

&amp;gt;&amp;gt;&amp;gt; elf = ELF('reproduce_sleep')
&amp;gt;&amp;gt;&amp;gt; elf.read(0x2004, 14)
b'/usr/bin/echo\x00'

$ gdb -ex 'disas/m main' -ex q reproduce_sleep | grep 'args\[\]' -A 13
9       const char *const args[] = {
   0x00000000000011d6 &amp;lt;+45&amp;gt;:        lea    0xe27(%rip),%rax        # 0x2004
   0x00000000000011dd &amp;lt;+52&amp;gt;:        mov    %rax,-0x30(%rbp)
   0x00000000000011e1 &amp;lt;+56&amp;gt;:        lea    0xe2a(%rip),%rax        # 0x2012
   0x00000000000011e8 &amp;lt;+63&amp;gt;:        mov    %rax,-0x28(%rbp)
   0x00000000000011ec &amp;lt;+67&amp;gt;:        mov    -0x38(%rbp),%rax
   0x00000000000011f0 &amp;lt;+71&amp;gt;:        mov    %rax,-0x20(%rbp)
   0x00000000000011f4 &amp;lt;+75&amp;gt;:        movq   $0x0,-0x18(%rbp)

10          PATHNAME,
11          &amp;quot;add&amp;quot;,
12          hostname,
13          0
14      };
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;You can also confirm by printing the pointer address of &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;args-&amp;gt;filename&lt;/span&gt;&lt;/tt&gt; in the eBPF program or
bpftrace script. The value at this address will be consistent with the value of &lt;tt class="docutils literal"&gt;addr&lt;/tt&gt;
in the previous page fault event, both being &lt;tt class="docutils literal"&gt;0x55b4d9e33004&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tracepoint:syscalls:sys_enter_execve {
    printf(&amp;quot;%s[%d]: %p\n&amp;quot;, comm, pid, args-&amp;gt;filename);
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;BTW, you can trace the function information that triggers page fault events by using the &lt;tt class="docutils literal"&gt;perf trace &lt;span class="pre"&gt;-F&lt;/span&gt;&lt;/tt&gt; all command.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="solution"&gt;
&lt;h2 id="hidsolution"&gt;Solution&lt;a class="headerlink" href="#hidsolution" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There are many methods to solve this problem, one of which is to change to tracking the
&lt;tt class="docutils literal"&gt;tracepoint/sched/sched_process_exec&lt;/tt&gt; event to obtain the values of the filename and
argv parameters in the &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; system call. Below is an example program corresponding to the implementation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Example script for tracing the &lt;tt class="docutils literal"&gt;tracepoint/sched/sched_process_exec&lt;/tt&gt; event using bpftrace(from &lt;a class="reference external" href="https://github.com/jschwinger233"&gt;&amp;#64;jschwinger233&lt;/a&gt; ):&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tracepoint:sched:sched_process_exec {
  $task=curtask;
  $arg_start=$task-&amp;gt;mm-&amp;gt;arg_start;
  $arg_end=$task-&amp;gt;mm-&amp;gt;arg_end;
  printf(&amp;quot;%s[%d]: filename: %s, argv: %r\n&amp;quot;, comm, pid, str(args-&amp;gt;filename), buf(uptr($arg_start), $arg_end-$arg_start));
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;An example program that traces the &lt;tt class="docutils literal"&gt;tracepoint/sched/sched_process_exec&lt;/tt&gt; event through eBPF C code:
&lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/blob/master/37-tracepoint-sched_process_exec/main.bpf.c"&gt;main.bpf.c&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="references"&gt;
&lt;h2 id="hidreferences"&gt;References&lt;a class="headerlink" href="#hidreferences" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/tmux/tmux/tree/master"&gt;tmux/tmux: tmux source code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/bpftrace/bpftrace/issues/2523"&gt;Can't trace sys_execve inside a c program · Issue #2523 · bpftrace/bpftrace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.osdev.org/ELF"&gt;ELF - OSDev Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://stackoverflow.com/questions/57761007/why-an-elf-executable-could-have-4-load-segments"&gt;unix - Why an ELF executable could have 4 LOAD segments? - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.cs.bham.ac.uk/~exr/lectures/opsys/13_14/docs/kernelAPI/r4206.html"&gt;strncpy_from_user&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Guidance from &lt;a class="reference external" href="https://github.com/jschwinger233"&gt;&amp;#64;jschwinger233&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lists.iovisor.org/g/iovisor-dev/topic/accessing_user_memory_and/21386221"&gt;iovisor-dev&amp;#64;lists.iovisor.org | Accessing user memory and minor page faults&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sun, 31 Mar 2024 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2024-03-31:2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case-en.html</guid><category>tracepoint</category><category>libbpf</category><category>bpftrace</category><category>ELF</category><category>en-version</category></item><item><title>一个使用 tracepoint 追踪 execve 系统调用时无法正确获取系统调用参数的场景</title><link>https://mozillazg.com/2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case.html</link><description>&lt;div class="section" id="section-1"&gt;
&lt;h2 id="hidsection-1"&gt;背景&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;前段时间有网友在 slack 上的 &lt;a class="reference external" href="https://ebpf.io/slack"&gt;ebpf 频道&lt;/a&gt;
中咨询一个他遇到的问题：&lt;/p&gt;
&lt;!-- `问题 &lt;https://cilium.slack.com/archives/C4XCTGYEM/p1710380136906129?thread_ts=1710284853.310149&amp;cid=C4XCTGYEM&gt;`__ ： --&gt;
&lt;p&gt;在编写使用 &lt;tt class="docutils literal"&gt;tracepoint/syscalls/sys_enter_execve&lt;/tt&gt; 追踪 execve 系统调用的 ebpf 程序时，
遇到了记录的部分事件中存在使用 &lt;tt class="docutils literal"&gt;bpf_probe_read_user_str&lt;/tt&gt; 读取
&lt;tt class="docutils literal"&gt;execve&lt;/tt&gt; 的 &lt;tt class="docutils literal"&gt;filename&lt;/tt&gt; 参数失败的现象，错误码为 -14/EFAULT。
尤其是在执行 tmux 命令的时候，必定会伴随一个读取失败的事件:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ret = bpf_probe_read_user_str(event-&amp;gt;args, ARGSIZE, (const char*)ctx-&amp;gt;args[0]);
if (ret &amp;lt; 0) {
        bpf_printk(&amp;quot;comm=%s XXX cannot read file name&amp;quot;, tgid, pid, event-&amp;gt;comm);
        return 0;
}

utempter-4031732 [027] d...1 3878624.643948: bpf_trace_printk: comm=tmux: server XXX cannot read file name
   &amp;lt;...&amp;gt;-4035723 [077] d...1 3878668.047954: bpf_trace_printk: comm=tmux: server XXX cannot read file name
&lt;/pre&gt;
&lt;p&gt;本文将探讨一下该问题出现的原因以及针对该场景的一种解决方法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2 id="hidsection-2"&gt;复现问题的代码&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;因为问题中提到只要执行 tmux 命令就必定会复现该问题，并且我们在 &lt;tt class="docutils literal"&gt;bpf_printk&lt;/tt&gt; 的输出中看到对应事件的进程名称为 &lt;tt class="docutils literal"&gt;utempter&lt;/tt&gt; ，
因此，我们可以基于这两点信息来尝试编写一个简单的复现问题的程序。&lt;/p&gt;
&lt;p&gt;通过在网络上查找 tmux 与 utempter 的关联关系，以及阅读了相关的 tmux 源代码后，我了解到了如下信息：&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;tmux 会调用 &lt;tt class="docutils literal"&gt;utempter.h&lt;/tt&gt; 提供的
&lt;a class="reference external" href="https://github.com/tmux/tmux/blob/b79e28b2c30e7ef9b1f7ec6233eeb70a1a177231/spawn.c#L473"&gt;utempter_add_record&lt;/a&gt;
函数创建所需的伪终端（pseudo-terminal）:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
xasprintf(&amp;amp;cp, &amp;quot;tmux(%lu).%%%u&amp;quot;, (long)getpid(), new_wp-&amp;gt;id);
utempter_add_record(new_wp-&amp;gt;fd, cp);
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;utempter_add_record&lt;/tt&gt; 函数中会首先使用传入的参数构造一个 &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; 然后调用
&lt;a class="reference external" href="https://github.com/altlinux/libutempter/blob/9f291816a746292547ac8aaea0c88e16fc2fb29a/libutempter/iface.c#L121"&gt;execute_helper&lt;/a&gt;
函数:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#define UTEMPTER_DEFAULT_PATHNAME     LIBEXECDIR &amp;quot;/utempter/utempter&amp;quot;
static const char *utempter_pathname;

int utempter_add_record(int master_fd, const char *hostname)
  {
      const char *const args[] = {
          utempter_pathname ? : UTEMPTER_DEFAULT_PATHNAME,
          &amp;quot;add&amp;quot;,
          hostname,
          0
      };
      int status = execute_helper(master_fd, args);
      // ...
  }
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;execute_helper&lt;/tt&gt; 函数中最终会使用传入的 &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; 调用 &lt;tt class="docutils literal"&gt;fork()&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;execv()&lt;/tt&gt; 函数启动一个新的进程
（ &lt;a class="reference external" href="https://github.com/altlinux/libutempter/blob/9f291816a746292547ac8aaea0c88e16fc2fb29a/libutempter/iface.c#L84"&gt;源代码&lt;/a&gt; ）:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static int execute_helper(int master_fd, const char *const argv[])
{
    // ...
    child = fork();
    if (!child) {
        do_child(master_fd, argv[0], (char *const *) argv);
    } else if (child &amp;lt; 0) {
    // ...
}
static void __attribute__((__noreturn__))
do_child(int master_fd, const char *path, char *const *argv)
{
    // ...
    execv(path, argv);
    print_dbg(&amp;quot;execv: %s&amp;quot;, strerror(errno));
    //...
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据上面这些信息，我们可以编写如下这个可复现该问题的程序
&lt;a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce.c"&gt;reproduce.c&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#define PATHNAME &amp;quot;/usr/bin/echo&amp;quot;

int main(int argc, char **argv) {
    const char *hostname = argv[0];
    const char *const args[] = {
        PATHNAME,
        &amp;quot;add&amp;quot;,
        hostname,
        0
    };
    if (!fork()) {
        execv(args[0], (char *const *) args);
    }
}
&lt;/pre&gt;
&lt;p&gt;下面测试一下这个程序的效果:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;使用 gcc 编译:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gcc -o reproduce reproduce.c
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;在另一个终端使用 &lt;a class="reference external" href="https://github.com/bpftrace/bpftrace"&gt;bpftrace&lt;/a&gt; 追踪 tracepoint/syscalls/sys_enter_execve 事件:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo bpftrace -e 'tracepoint:syscalls:sys_enter_execve{printf(&amp;quot;%s[%d]: %s\n&amp;quot;, comm, pid, str(args-&amp;gt;filename));}'
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;运行示例程序:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
./reproduce
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时，运行 bpftrace 的终端将输出类似下面这样的结果:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bash[34882]: ./reproduce
reproduce[34883]:
&lt;/pre&gt;
&lt;p&gt;在上面结果中，我们没有获取到 reproduce 进程执行 &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; 系统调用时使用的 &lt;tt class="docutils literal"&gt;filename&lt;/tt&gt; 参数的值。
由此可见，我们的这个程序复现了最初的问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2 id="hidsection-3"&gt;原因&lt;a class="headerlink" href="#hidsection-3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;经 &lt;a class="reference external" href="https://github.com/ssfdust"&gt;&amp;#64;ssfdust&lt;/a&gt; 提醒，bpftrace 社区之前已经有人提过类似的问题：
&lt;a class="reference external" href="https://github.com/bpftrace/bpftrace/issues/2523"&gt;#2523&lt;/a&gt; 。
在这个 issue 中 &lt;a class="reference external" href="https://github.com/fbs"&gt;&amp;#64;fbs&lt;/a&gt;
给出的 &lt;a class="reference external" href="https://github.com/bpftrace/bpftrace/issues/2523#issuecomment-1466936511"&gt;解释&lt;/a&gt; 是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Like I said earlier, the data you're using isn't in memory yet. These static strings are compiled in and are not actually faulted into memory until they're accessed. The access won't happen until its read, which is after your bpftrace probe ran. BPF won't pull the data in so you get an EFAULT/-14.&lt;/p&gt;
&lt;p&gt;By printing the values or just a random print of a constant string you pull the small amount of data into memory (as it goes by page, not by var) and then it works&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;示例程序中，执行 &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; 时传入的 &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; 指向的文件名称字符串是一个静态字符串
（这些静态字符串在程序被编译后存储在 ELF（Executable and Linkable Format） 文件的 &lt;tt class="docutils literal"&gt;.rodata&lt;/tt&gt; section），
这些字符串只会在程序真正去访问他们的时候（访问 &lt;tt class="docutils literal"&gt;.rodata&lt;/tt&gt; section 存储的数据时）才会被加载到内存中。&lt;/li&gt;
&lt;li&gt;由1可知，示例程序中 &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; 指向的静态字符串只会在执行 &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; 系统调用的时候被读取到内存中，
但是我们的 ebpf 程序其实是在执行 &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; 系统调用之前被执行的，因此 ebpf 程序里使用 &lt;tt class="docutils literal"&gt;bpf_probe_read_user_str&lt;/tt&gt;
读取 &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; 会失败并返回 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;EFAULT/-14&lt;/span&gt;&lt;/tt&gt; 。&lt;/li&gt;
&lt;li&gt;通过 &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; 等方式主动将字符串加载到内存中可以让该问题消失。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;来自 &lt;a class="reference external" href="https://github.com/jschwinger233"&gt;&amp;#64;jschwinger233&lt;/a&gt; 的总结：&lt;/p&gt;
&lt;blockquote&gt;
bpf_probe_read_user 只能读到已经载入内存 (page-faulted into memory) 的数据，
而上面代码直到 execve(2) 之时都还未读过 .rodata，未曾触发 page fault。
这可以用 tracepoint:exceptions:page_fault* 来验证。&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h2 id="hidsection-4"&gt;验证&lt;a class="headerlink" href="#hidsection-4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="printf"&gt;
&lt;h3 id="hidprintf"&gt;增加 printf&lt;a class="headerlink" href="#hidprintf" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;由上面可知，其实我们只需要修改程序在执行 &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; 之前主动将 &lt;tt class="docutils literal"&gt;.rodata&lt;/tt&gt; 中的数据加载到内存中即可避免该问题，
比如使用 &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; 函数。&lt;/p&gt;
&lt;p&gt;既可以使用 &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; 函数打印 &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; ，也可以直接打印一个静态字符串:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if (!fork()) {
    printf(&amp;quot;test\n&amp;quot;);
    // or
    // printf(&amp;quot;argv[0]: %s\n&amp;quot;, args[0]);
    execv(args[0], (char *const *) args);
}
&lt;/pre&gt;
&lt;p&gt;经验证，修改后的程序
&lt;a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce_printf1.c"&gt;reproduce_printf1.c&lt;/a&gt;
确实可以让 ebpf 程序正确读取到 filename 的值。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h3 id="hidsection-5"&gt;不使用静态字符串&lt;a class="headerlink" href="#hidsection-5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;既然是因为 &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; 是静态字符串导致的问题，那么可以尝试将 &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; 改为使用非静态字符串，看看问题是否还存在。
修改的内容如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
const char *const args[] = {
    argv[1],
    &amp;quot;add&amp;quot;,
    hostname,
    0
};
&lt;/pre&gt;
&lt;p&gt;经验证，修改后的程序
&lt;a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce_non_static.c"&gt;reproduce_non_static.c&lt;/a&gt;
也可以让 ebpf 程序正确读取到 filename 的值。&lt;/p&gt;
&lt;p&gt;不知道大家有没有注意到，我们的复现问题的程序里 &lt;tt class="docutils literal"&gt;argv[2]&lt;/tt&gt; 的值其实是一个非静态字符串，
所以也可以通过在 ebpf 程序中读取这个数据的内容来验证，
预期是不做任何修改就可以读取到 &lt;tt class="docutils literal"&gt;argv[2]&lt;/tt&gt; 这个非静态字符串的内容：&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;执行新的 bpftrace 命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo bpftrace -e 'tracepoint:syscalls:sys_enter_execve{
    printf(&amp;quot;%s[%d]: filename: %s, argv[1]: %s, argv[2]: %s\n&amp;quot;, comm, pid, str(args-&amp;gt;filename), str(args-&amp;gt;argv[1]), str(args-&amp;gt;argv[2]));
}'
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;执行 &lt;tt class="docutils literal"&gt;./reproduce&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;bpftrace 命令的输出示例如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bash[36523]: filename: ./reproduce, argv[1]: , argv[2]:
reproduce[36524]: filename: , argv[1]: , argv[2]: ./reproduce
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="page-fault"&gt;
&lt;h3 id="hidpage-fault"&gt;page fault&lt;a class="headerlink" href="#hidpage-fault" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在现代 Linux 系统中，当我们运行二进制可执行文件的时候，程序加载器（ELF executable loader）
会根据 ELF 文件中定义的信息使用 &lt;tt class="docutils literal"&gt;mmap&lt;/tt&gt; 进行懒加载（lazy loading），延迟加载一些数据。
当程序真正去读取这些数据的时候，如果被读取的数据还没有被加载到内存里，就会触发 page fault。&lt;/p&gt;
&lt;!-- CPU 就会生成一个缺页异常（page fault exception）。此时，内核中的缺页处理程序（page fault handler） --&gt;
&lt;!-- 会负责处理该异常，将缺失的页面加载到内存中，然后 CPU 重新执行引起缺页异常的指令。 --&gt;
&lt;p&gt;ELF 文件的 .rodata section 中存储的数据恰好就是会被延迟加载的数据。&lt;/p&gt;
&lt;div class="section" id="rodata"&gt;
&lt;h4 id="hidrodata"&gt;.rodata&lt;a class="headerlink" href="#hidrodata" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;ELF 文件中的 .rodata section 存储了一些只读数据，比如静态字符串。
我们首先来看一下编译后的示例程序二进制 ELF 文件中的 .rodata section 的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;可以使用 &lt;tt class="docutils literal"&gt;objdump&lt;/tt&gt; 命令进行查看:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ objdump -s -j .rodata ./reproduce

./reproduce:     file format elf64-x86-64

Contents of section .rodata:
2000 01000200 2f757372 2f62696e 2f656368  ..../usr/bin/ech
2010 6f006164 6400                        o.add.
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;也可以使用 python 社区的 &lt;a class="reference external" href="https://docs.pwntools.com/en/stable/"&gt;pwntools&lt;/a&gt; 库进行读取:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; from pwn import ELF
&amp;gt;&amp;gt;&amp;gt; elf = ELF('reproduce')
&amp;gt;&amp;gt;&amp;gt; elf.section('.rodata')
b'\x01\x00\x02\x00/usr/bin/echo\x00add\x00'
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面的输出中可以看到其中包含了源码中使用的两个静态字符串。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="page-fault-1"&gt;
&lt;h4 id="hidpage-fault-1"&gt;观测 page fault&lt;a class="headerlink" href="#hidpage-fault-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在 Linux 系统中，当内核执行 &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; 系统调用时，
会调用内核函数 &lt;tt class="docutils literal"&gt;strncpy_from_user&lt;/tt&gt; （
&lt;a class="reference external" href="https://elixir.bootlin.com/linux/v5.13/source/fs/exec.c#L2063"&gt;execve()&lt;/a&gt; -&amp;gt;
&lt;a class="reference external" href="https://elixir.bootlin.com/linux/v5.13/source/fs/namei.c#L207"&gt;getname()&lt;/a&gt; -&amp;gt;
&lt;a class="reference external" href="https://elixir.bootlin.com/linux/v5.15/source/fs/namei.c#L149"&gt;getname_flags(),strncpy_from_user()&lt;/a&gt; ）
将 &lt;tt class="docutils literal"&gt;argv&lt;/tt&gt; 中包含的字符串数据从用户态复制到内核态，
这个过程涉及读取用户态数据的操作。
如果被读取的用户态数据还未被加载到内存中，就会触发 page fault。&lt;/p&gt;
&lt;p&gt;我们可以通过观测 &lt;tt class="docutils literal"&gt;exceptions/page_fault_kernel&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;exceptions/page_fault_user&lt;/tt&gt; 感知到这个事件:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;为了方便验证，我们需要先修改一下示例代码，在执行 &lt;tt class="docutils literal"&gt;execv()&lt;/tt&gt; 函数前增加一行 &lt;tt class="docutils literal"&gt;sleep(15)&lt;/tt&gt; ，避免程序太快结束
（&lt;a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce_sleep.c"&gt;reproduce_sleep.c&lt;/a&gt; ）&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if (!fork()) {
     sleep(15);
     execv(args[0], (char *const *) args);
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;在一个终端中运行下面这个 bpftrace 脚本，观测 page fault:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cat &amp;lt;&amp;lt;EOF | sudo bpftrace -
tracepoint:exceptions:page_fault_kernel /comm == &amp;quot;reproduce_sleep&amp;quot;/ {
    printf(&amp;quot;[%s] page_fault_kernel: %s[%d] addr=%llx ip=%llx err=%lld\n&amp;quot;,
            strftime(&amp;quot;%M:%S&amp;quot;, nsecs), comm, pid, args-&amp;gt;address, args-&amp;gt;ip, args-&amp;gt;error_code);
}

tracepoint:exceptions:page_fault_user /comm == &amp;quot;reproduce_sleep&amp;quot;/ {
    printf(&amp;quot;[%s] page_fault_user:   %s[%d] addr=%llx ip=%llx err=%lld\n&amp;quot;,
            strftime(&amp;quot;%M:%S&amp;quot;, nsecs), comm, pid, args-&amp;gt;address, args-&amp;gt;ip, args-&amp;gt;error_code);
}
EOF
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;然后在另一个终端中运行 &lt;tt class="docutils literal"&gt;./reproduce_sleep&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;在第3个终端中查看运行中的 reproduce_sleep 进程的内存映射关系（memory mapping）:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo cat /proc/41291/maps | grep reproduce_sleep
55b4d9e31000-55b4d9e32000 r--p 00000000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e32000-55b4d9e33000 r-xp 00001000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e33000-55b4d9e34000 r--p 00002000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e34000-55b4d9e35000 r--p 00002000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e35000-55b4d9e36000 rw-p 00003000 08:01 1634479                    /XXX/reproduce_sleep
&lt;/pre&gt;
&lt;p&gt;由上面可知，该进程的内存映射起始地址是 &lt;tt class="docutils literal"&gt;55b4d9e31000&lt;/tt&gt; ，即 &lt;tt class="docutils literal"&gt;0x55b4d9e31000&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;待示例程序运行结束后，bpftrace 命令的输出中的最后两条数据将类似下面这样:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[47:40] page_fault_user:   reproduce_sleep[41290] addr=7f669db86a50 ip=7f669d9f8940 err=7
[47:55] page_fault_kernel: reproduce_sleep[41291] addr=55b4d9e33004 ip=ffffffff8e092a40 err=0
&lt;/pre&gt;
&lt;p&gt;这两个输出间隔了 15 秒，由此可以确定最后那个 page fault 事件是执行 &lt;tt class="docutils literal"&gt;execv()&lt;/tt&gt; 函数的时候触发的。
下面来通过事件中的 &lt;tt class="docutils literal"&gt;addr&lt;/tt&gt; 结果定位对应的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;上面最后那条 &lt;tt class="docutils literal"&gt;page_fault_kernel&lt;/tt&gt; 事件输出的 addr 的值是 &lt;tt class="docutils literal"&gt;55b4d9e33004&lt;/tt&gt; ，
即触发这个 page fault 事件的虚拟内存地址是 &lt;tt class="docutils literal"&gt;0x55b4d9e33004&lt;/tt&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;基于 &lt;a class="reference external" href="https://github.com/jschwinger233"&gt;&amp;#64;jschwinger233&lt;/a&gt;  分享的秘籍：
&lt;tt class="docutils literal"&gt;real_addr = start_addr + (elf_address - section.Address + section.Offset)&lt;/tt&gt; 可知:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
0x55b4d9e33004 = 0x55b4d9e31000 + (elf_address - section.Address + section.Offset)
(elf_address - section.Address + section.Offset) = 0x55b4d9e33004 - 0x55b4d9e31000 = 8196 = 0x2004
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;使用 readelf 命令读取二进制文件 reproduce_sleep 中 ELF .rodata section 的虚拟地址、偏移量以及数据大小:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ readelf -S -W reproduce_sleep  | egrep '.rodata|Address'
  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
  [18] .rodata           PROGBITS        0000000000002000 002000 000016 00   A  0   0  4
&lt;/pre&gt;
&lt;p&gt;由上面的输出可知，该 ELF 文件中 .rodata section 的虚拟地址是 &lt;tt class="docutils literal"&gt;0000000000002000&lt;/tt&gt; 即 &lt;tt class="docutils literal"&gt;0x2000&lt;/tt&gt; ，
偏移量是 &lt;tt class="docutils literal"&gt;002000&lt;/tt&gt; 即 &lt;tt class="docutils literal"&gt;0x2000&lt;/tt&gt; ， 数据大小是 &lt;tt class="docutils literal"&gt;0x16&lt;/tt&gt; ，即地址范围是 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;0x2000-0x2016&lt;/span&gt;&lt;/tt&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;通过 7 和 8 可知，执行 &lt;tt class="docutils literal"&gt;execv()&lt;/tt&gt; 函数时触发的 page fault 事件的虚拟内存地址
&lt;tt class="docutils literal"&gt;0x55b4d9e33004&lt;/tt&gt; 对应的 ELF 地址是 &lt;tt class="docutils literal"&gt;0x2004&lt;/tt&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
0x55b4d9e33004 = 0x55b4d9e31000 + (elf_address - section.Address + section.Offset)
(elf_address - section.Address + section.Offset) = 0x55b4d9e33004 - 0x55b4d9e31000 = 8196 = 0x2004
(elf_address - 0x2000 + 0x2000) = 0x2004
elf_address = 0x2004
&lt;/pre&gt;
&lt;p&gt;这个地址在 ELF 文件的 .rodata 地址范围（ &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;0x2000-0x2016&lt;/span&gt;&lt;/tt&gt; ）内，
对应的是 &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; 中使用的静态字符串 &lt;tt class="docutils literal"&gt;/usr/bin/echo&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ objdump -s -j .rodata ./reproduce_sleep

./reproduce_sleep:     file format elf64-x86-64

Contents of section .rodata:
 2000 01000200 2f757372 2f62696e 2f656368  ..../usr/bin/ech
 2010 6f006164 6400                        o.add.

&amp;gt;&amp;gt;&amp;gt; elf = ELF('reproduce_sleep')
&amp;gt;&amp;gt;&amp;gt; elf.read(0x2004, 14)
b'/usr/bin/echo\x00'

$ gdb -ex 'disas/m main' -ex q reproduce_sleep | grep 'args\[\]' -A 13
9       const char *const args[] = {
   0x00000000000011d6 &amp;lt;+45&amp;gt;:        lea    0xe27(%rip),%rax        # 0x2004
   0x00000000000011dd &amp;lt;+52&amp;gt;:        mov    %rax,-0x30(%rbp)
   0x00000000000011e1 &amp;lt;+56&amp;gt;:        lea    0xe2a(%rip),%rax        # 0x2012
   0x00000000000011e8 &amp;lt;+63&amp;gt;:        mov    %rax,-0x28(%rbp)
   0x00000000000011ec &amp;lt;+67&amp;gt;:        mov    -0x38(%rbp),%rax
   0x00000000000011f0 &amp;lt;+71&amp;gt;:        mov    %rax,-0x20(%rbp)
   0x00000000000011f4 &amp;lt;+75&amp;gt;:        movq   $0x0,-0x18(%rbp)

10          PATHNAME,
11          &amp;quot;add&amp;quot;,
12          hostname,
13          0
14      };
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;也可以通过在 ebpf 程序或 bpftrace 脚本中打印 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;args-&amp;gt;filename&lt;/span&gt;&lt;/tt&gt; 的指针地址来确认，
这个地址的值会跟前面 page fault 事件中 addr 的值一致，都是 &lt;tt class="docutils literal"&gt;0x55b4d9e33004&lt;/tt&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tracepoint:syscalls:sys_enter_execve {
    printf(&amp;quot;%s[%d]: %p\n&amp;quot;, comm, pid, args-&amp;gt;filename);
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;BTW，可以通过 &lt;tt class="docutils literal"&gt;perf trace &lt;span class="pre"&gt;-F&lt;/span&gt; all&lt;/tt&gt; 命令追踪触发 page fault 事件的函数信息。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h2 id="hidsection-6"&gt;解决方法&lt;a class="headerlink" href="#hidsection-6" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;解决这个问题的方法有很多，其中一种解决方法是改为通过追踪 &lt;tt class="docutils literal"&gt;tracepoint/sched/sched_process_exec&lt;/tt&gt;
事件来获取 &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; 系统调用中 &lt;tt class="docutils literal"&gt;filename&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;argv&lt;/tt&gt; 参数的值。下面是对应实现的示例程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;通过 bpftrace 追踪 &lt;tt class="docutils literal"&gt;tracepoint/sched/sched_process_exec&lt;/tt&gt; 事件的示例脚本（来自 &lt;a class="reference external" href="https://github.com/jschwinger233"&gt;&amp;#64;jschwinger233&lt;/a&gt; ）:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tracepoint:sched:sched_process_exec {
  $task=curtask;
  $arg_start=$task-&amp;gt;mm-&amp;gt;arg_start;
  $arg_end=$task-&amp;gt;mm-&amp;gt;arg_end;
  printf(&amp;quot;%s[%d]: filename: %s, argv: %r\n&amp;quot;, comm, pid, str(args-&amp;gt;filename), buf(uptr($arg_start), $arg_end-$arg_start));
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;通过 ebpf c 代码追踪 &lt;tt class="docutils literal"&gt;tracepoint/sched/sched_process_exec&lt;/tt&gt; 事件的示例程序：
&lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/blob/master/37-tracepoint-sched_process_exec/main.bpf.c"&gt;main.bpf.c&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h2 id="hidsection-7"&gt;参考资料&lt;a class="headerlink" href="#hidsection-7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/tmux/tmux/tree/master"&gt;tmux/tmux: tmux source code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/bpftrace/bpftrace/issues/2523"&gt;Can't trace sys_execve inside a c program · Issue #2523 · bpftrace/bpftrace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.osdev.org/ELF"&gt;ELF - OSDev Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://stackoverflow.com/questions/57761007/why-an-elf-executable-could-have-4-load-segments"&gt;unix - Why an ELF executable could have 4 LOAD segments? - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.cs.bham.ac.uk/~exr/lectures/opsys/13_14/docs/kernelAPI/r4206.html"&gt;strncpy_from_user&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/jschwinger233"&gt;&amp;#64;jschwinger233&lt;/a&gt; 的谆谆教诲&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lists.iovisor.org/g/iovisor-dev/topic/accessing_user_memory_and/21386221"&gt;iovisor-dev&amp;#64;lists.iovisor.org | Accessing user memory and minor page faults&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sun, 31 Mar 2024 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2024-03-31:2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case.html</guid><category>tracepoint</category><category>libbpf</category><category>bpftrace</category><category>ELF</category></item><item><title>使用 except 命令解决无法在无 tty 的环境里执行 kubectl exec -it 命令的问题</title><link>https://mozillazg.com/2024/03/fix-can-not-run-kubectl-exec-it-in-no-tty-env.html</link><description>&lt;div class="section" id="section-1"&gt;
&lt;h2 id="hidsection-1"&gt;问题&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;当我们在无 tty 环境下执行 &lt;tt class="docutils literal"&gt;kubectl exec &lt;span class="pre"&gt;-it&lt;/span&gt;&lt;/tt&gt; 命令的时候，
kubectl 会输出如下警告然后自动禁用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-t&lt;/span&gt;&lt;/tt&gt; 选项:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
Unable to use a TTY - input is not a terminal or the right kind of file
&lt;/pre&gt;
&lt;p&gt;无 tty 的场景包括但不限于：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;在未启用 tty 的容器中执行 kubectl 命令&lt;/li&gt;
&lt;li&gt;使用 nohup 执行包含 kubectl 命令的脚本（可以使用该方法在不修改原脚本的情况下复现上面的报错）&lt;/li&gt;
&lt;li&gt;使用管道或 &lt;tt class="docutils literal"&gt;&amp;lt;&lt;/tt&gt; 作为 kubectl 命令的输入&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2 id="hidsection-2"&gt;解决方法&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;对于无需进行交互式操作的场景，通常可以通过主动去除 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-t&lt;/span&gt;&lt;/tt&gt; 选项来去掉该告警。
但是有时我们的场景确实需要进行交互式操作，
或者我们的场景是即便不需要进行交互式操作也会需要依赖 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-t&lt;/span&gt;&lt;/tt&gt; 选项（比如，为了测试 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-t&lt;/span&gt;&lt;/tt&gt; 选项的功能）。&lt;/p&gt;
&lt;p&gt;此时，我们可以通过 &lt;a class="reference external" href="https://linux.die.net/man/1/expect"&gt;except&lt;/a&gt; 这个工具来启用一个 tty，
满足 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-t&lt;/span&gt;&lt;/tt&gt; 选项所依赖的环境:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cat &amp;lt;&amp;lt;EOF &amp;gt; test.sh

# 执行 kubectl exec -it 命令
spawn kubectl exec -it xxxx yyy

# 可以通过 send 和 expect 进行交互式操作
# send &amp;quot;&amp;lt;CMD&amp;gt;\r&amp;quot;
# expect &amp;quot;&amp;lt;STR&amp;gt;&amp;quot;

# 发送 exit 命令，退出交互式终端
# send &amp;quot;exit\r&amp;quot;
# expect eof

EOF

except -f test.sh
&lt;/pre&gt;
&lt;p&gt;关于 &lt;tt class="docutils literal"&gt;except&lt;/tt&gt; 命令的详细使用方式大家可以在网络上自行搜索。&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sat, 23 Mar 2024 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2024-03-23:2024/03/fix-can-not-run-kubectl-exec-it-in-no-tty-env.html</guid><category>kubectl</category></item><item><title>How to Checkout Codes from a Fork's Branch for PRs Submitted by External Contributors on GitHub Locally</title><link>https://mozillazg.com/2024/03/git-checkout-github-pr-codes-to-local-en.html</link><description>&lt;p&gt;When handling PRs (Pull Requests) from external contributors on GitHub, you might want to checkout those PR codes to your local machine.
This guide covers how to quickly checkout the branch code from the fork repository associated with a PR.&lt;/p&gt;
&lt;p&gt;Typically, you might clone the fork repository directly, but there's a more efficient way that doesn't require cloning in a new directory.&lt;/p&gt;
&lt;p&gt;To quickly checkout the branch code from a fork repository for a PR, use the following commands:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
git fetch origin pull/&amp;lt;ID&amp;gt;/head:&amp;lt;BRANCHNAME&amp;gt;
git checkout &amp;lt;BRANCHNAME&amp;gt;
&lt;/pre&gt;
&lt;p&gt;For practical use, replace &lt;tt class="docutils literal"&gt;&amp;lt;ID&amp;gt;&lt;/tt&gt; in the command with the actual PR ID, and &lt;tt class="docutils literal"&gt;&amp;lt;BRANCHNAME&amp;gt;&lt;/tt&gt; with the name you want to assign to the new local branch.
Here's an example of how to checkout the code for a PR with ID 47 into a local branch named pr47:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ git fetch origin pull/47/head:pr47
remote: Enumerating objects: 10, done.
remote: Counting objects: 100% (10/10), done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 10 (delta 4), reused 3 (delta 0), pack-reused 0
Unpacking objects: 100% (10/10), 3.25 MiB | 862.00 KiB/s, done.
From github.com:mozillazg/XXXX
 * [new ref]         refs/pull/47/head -&amp;gt; pr47

$ git log pr47

$ git checkout pr47
Switched to branch 'pr47'
&lt;/pre&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sun, 10 Mar 2024 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2024-03-10:2024/03/git-checkout-github-pr-codes-to-local-en.html</guid><category>en-version</category></item><item><title>如何在本地 checkout GitHub 上外部贡献者提交的 PR 所在 fork 仓库的分支代码</title><link>https://mozillazg.com/2024/03/git-checkout-github-pr-codes-to-local.html</link><description>&lt;p&gt;在日常处理 GitHub 上外部贡献者提交的 PR 时，可能会想将 PR 对应的代码 checkout 到本地，
这里涉及到如何快速 checkout PR 所在 fork 仓库的分支代码。&lt;/p&gt;
&lt;p&gt;通常我们可能会通过 git clone 对应的 fork 仓库来实现，但是其实还有一个更便捷、不需要切换目录进行 clone 的方法。&lt;/p&gt;
&lt;p&gt;我们可以通过下面的方法实现快速 checkout PR 对应的 fork 仓库分支代码的需求:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
git fetch origin pull/&amp;lt;ID&amp;gt;/head:&amp;lt;BRANCHNAME&amp;gt;
git checkout &amp;lt;BRANCHNAME&amp;gt;
&lt;/pre&gt;
&lt;p&gt;实际使用时，需要将上面命令中的 &lt;tt class="docutils literal"&gt;&amp;lt;ID&amp;gt;&lt;/tt&gt; 替换为对应的 PR ID，需要将 &lt;tt class="docutils literal"&gt;&amp;lt;BRANCHNAME&amp;gt;&lt;/tt&gt; 替换为你想在本地新建的分支名称。
下面是一个实际使用的示例（将 ID 为 47 的 PR 代码 checkout 到本地的 pr47 分支中）:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ git fetch origin pull/47/head:pr47
remote: Enumerating objects: 10, done.
remote: Counting objects: 100% (10/10), done.
remote: Compressing objects: 100% (10/10), done.
remote: Total 10 (delta 4), reused 3 (delta 0), pack-reused 0
Unpacking objects: 100% (10/10), 3.25 MiB | 862.00 KiB/s, done.
From github.com:mozillazg/XXXX
 * [new ref]         refs/pull/47/head -&amp;gt; pr47

$ git log pr47

$ git checkout pr47
Switched to branch 'pr47'
&lt;/pre&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sun, 10 Mar 2024 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2024-03-10:2024/03/git-checkout-github-pr-codes-to-local.html</guid></item></channel></rss>