<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>mozillazg's Blog</title><link href="https://mozillazg.com/" rel="alternate"></link><link href="https://mozillazg.com/feeds/ebpf.atom.xml" rel="self"></link><id>https://mozillazg.com/</id><updated>2024-03-31T00:00:00+00:00</updated><entry><title>一个使用 tracepoint 追踪 execve 系统调用时无法正确获取系统调用参数的场景</title><link href="https://mozillazg.com/2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case.html" rel="alternate"></link><published>2024-03-31T00:00:00+00:00</published><updated>2024-03-31T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2024-03-31:2024/03/ebpf-tracepoint-syscalls-sys-enter-execve-can-not-get-filename-argv-values-case.html</id><summary type="html">&lt;div class="section" id="section-1"&gt;
&lt;h2 id="hidsection-1"&gt;背景&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;前段时间有网友在 slack 上的 &lt;a class="reference external" href="https://ebpf.io/slack"&gt;ebpf 频道&lt;/a&gt;
中咨询一个他遇到的问题：&lt;/p&gt;
&lt;!-- `问题 &lt;https://cilium.slack.com/archives/C4XCTGYEM/p1710380136906129?thread_ts=1710284853.310149&amp;cid=C4XCTGYEM&gt;`__ ： --&gt;
&lt;p&gt;在编写使用 &lt;tt class="docutils literal"&gt;tracepoint/syscalls/sys_enter_execve&lt;/tt&gt; 追踪 execve 系统调用的 ebpf 程序时，
遇到了记录的部分事件中存在使用 &lt;tt class="docutils literal"&gt;bpf_probe_read_user_str&lt;/tt&gt; 读取
&lt;tt class="docutils literal"&gt;execve&lt;/tt&gt; 的 &lt;tt class="docutils literal"&gt;filename&lt;/tt&gt; 参数失败的现象，错误码为 -14/EFAULT。
尤其是在执行 tmux 命令的时候，必定会伴随一个读取失败的事件:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
ret = bpf_probe_read_user_str(event-&amp;gt;args, ARGSIZE, (const char*)ctx-&amp;gt;args[0]);
if (ret &amp;lt; 0) {
        bpf_printk(&amp;quot;comm=%s XXX cannot read file name&amp;quot;, tgid, pid, event-&amp;gt;comm);
        return 0;
}

utempter-4031732 [027] d...1 3878624.643948: bpf_trace_printk: comm=tmux: server XXX cannot read file name
   &amp;lt;...&amp;gt;-4035723 [077] d...1 3878668.047954: bpf_trace_printk: comm=tmux: server XXX cannot read file name
&lt;/pre&gt;
&lt;p&gt;本文将探讨一下该问题出现的原因以及针对该场景的一种解决方法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2 id="hidsection-2"&gt;复现问题的代码&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;因为问题中提到只要执行 tmux 命令就必定会复现该问题，并且我们在 &lt;tt class="docutils literal"&gt;bpf_printk&lt;/tt&gt; 的输出中看到对应事件的进程名称为 &lt;tt class="docutils literal"&gt;utempter&lt;/tt&gt; ，
因此，我们可以基于这两点信息来尝试编写一个简单的复现问题的程序。&lt;/p&gt;
&lt;p&gt;通过在网络上查找 tmux 与 utempter 的关联关系，以及阅读了相关的 tmux 源代码后，我了解到了如下信息：&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;tmux 会调用 &lt;tt class="docutils literal"&gt;utempter.h&lt;/tt&gt; 提供的
&lt;a class="reference external" href="https://github.com/tmux/tmux/blob/b79e28b2c30e7ef9b1f7ec6233eeb70a1a177231/spawn.c#L473"&gt;utempter_add_record&lt;/a&gt;
函数创建所需的伪终端（pseudo-terminal）:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
xasprintf(&amp;amp;cp, &amp;quot;tmux(%lu).%%%u&amp;quot;, (long)getpid(), new_wp-&amp;gt;id);
utempter_add_record(new_wp-&amp;gt;fd, cp);
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;utempter_add_record&lt;/tt&gt; 函数中会首先使用传入的参数构造一个 &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; 然后调用
&lt;a class="reference external" href="https://github.com/altlinux/libutempter/blob/9f291816a746292547ac8aaea0c88e16fc2fb29a/libutempter/iface.c#L121"&gt;execute_helper&lt;/a&gt;
函数:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#define UTEMPTER_DEFAULT_PATHNAME     LIBEXECDIR &amp;quot;/utempter/utempter&amp;quot;
static const char *utempter_pathname;

int utempter_add_record(int master_fd, const char *hostname)
  {
      const char *const args[] = {
          utempter_pathname ? : UTEMPTER_DEFAULT_PATHNAME,
          &amp;quot;add&amp;quot;,
          hostname,
          0
      };
      int status = execute_helper(master_fd, args);
      // ...
  }
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;execute_helper&lt;/tt&gt; 函数中最终会使用传入的 &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; 调用 &lt;tt class="docutils literal"&gt;fork()&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;execv()&lt;/tt&gt; 函数启动一个新的进程
（ &lt;a class="reference external" href="https://github.com/altlinux/libutempter/blob/9f291816a746292547ac8aaea0c88e16fc2fb29a/libutempter/iface.c#L84"&gt;源代码&lt;/a&gt; ）:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
static int execute_helper(int master_fd, const char *const argv[])
{
    // ...
    child = fork();
    if (!child) {
        do_child(master_fd, argv[0], (char *const *) argv);
    } else if (child &amp;lt; 0) {
    // ...
}
static void __attribute__((__noreturn__))
do_child(int master_fd, const char *path, char *const *argv)
{
    // ...
    execv(path, argv);
    print_dbg(&amp;quot;execv: %s&amp;quot;, strerror(errno));
    //...
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据上面这些信息，我们可以编写如下这个可复现该问题的程序
&lt;a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce.c"&gt;reproduce.c&lt;/a&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#define PATHNAME &amp;quot;/usr/bin/echo&amp;quot;

int main(int argc, char **argv) {
    const char *hostname = argv[0];
    const char *const args[] = {
        PATHNAME,
        &amp;quot;add&amp;quot;,
        hostname,
        0
    };
    if (!fork()) {
        execv(args[0], (char *const *) args);
    }
}
&lt;/pre&gt;
&lt;p&gt;下面测试一下这个程序的效果:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;使用 gcc 编译:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
gcc -o reproduce reproduce.c
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;在另一个终端使用 &lt;a class="reference external" href="https://github.com/bpftrace/bpftrace"&gt;bpftrace&lt;/a&gt; 追踪 tracepoint/syscalls/sys_enter_execve 事件:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo bpftrace -e 'tracepoint:syscalls:sys_enter_execve{printf(&amp;quot;%s[%d]: %s\n&amp;quot;, comm, pid, str(args-&amp;gt;filename));}'
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;运行示例程序:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
./reproduce
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时，运行 bpftrace 的终端将输出类似下面这样的结果:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bash[34882]: ./reproduce
reproduce[34883]:
&lt;/pre&gt;
&lt;p&gt;在上面结果中，我们没有获取到 reproduce 进程执行 &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; 系统调用时使用的 &lt;tt class="docutils literal"&gt;filename&lt;/tt&gt; 参数的值。
由此可见，我们的这个程序复现了最初的问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2 id="hidsection-3"&gt;原因&lt;a class="headerlink" href="#hidsection-3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;经 &lt;a class="reference external" href="https://github.com/ssfdust"&gt;&amp;#64;ssfdust&lt;/a&gt; 提醒，bpftrace 社区之前已经有人提过类似的问题：
&lt;a class="reference external" href="https://github.com/bpftrace/bpftrace/issues/2523"&gt;#2523&lt;/a&gt; 。
在这个 issue 中 &lt;a class="reference external" href="https://github.com/fbs"&gt;&amp;#64;fbs&lt;/a&gt;
给出的 &lt;a class="reference external" href="https://github.com/bpftrace/bpftrace/issues/2523#issuecomment-1466936511"&gt;解释&lt;/a&gt; 是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Like I said earlier, the data you're using isn't in memory yet. These static strings are compiled in and are not actually faulted into memory until they're accessed. The access won't happen until its read, which is after your bpftrace probe ran. BPF won't pull the data in so you get an EFAULT/-14.&lt;/p&gt;
&lt;p&gt;By printing the values or just a random print of a constant string you pull the small amount of data into memory (as it goes by page, not by var) and then it works&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;示例程序中，执行 &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; 时传入的 &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; 指向的文件名称字符串是一个静态字符串
（这些静态字符串在程序被编译后存储在 ELF（Executable and Linkable Format） 文件的 &lt;tt class="docutils literal"&gt;.rodata&lt;/tt&gt; section），
这些字符串只会在程序真正去访问他们的时候（访问 &lt;tt class="docutils literal"&gt;.rodata&lt;/tt&gt; section 存储的数据时）才会被加载到内存中。&lt;/li&gt;
&lt;li&gt;由1可知，示例程序中 &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; 指向的静态字符串只会在执行 &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; 系统调用的时候被读取到内存中，
但是我们的 ebpf 程序其实是在执行 &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; 系统调用之前被执行的，因此 ebpf 程序里使用 &lt;tt class="docutils literal"&gt;bpf_probe_read_user_str&lt;/tt&gt;
读取 &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; 会失败并返回 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;EFAULT/-14&lt;/span&gt;&lt;/tt&gt; 。&lt;/li&gt;
&lt;li&gt;通过 &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; 等方式主动将字符串加载到内存中可以让该问题消失。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;来自 &lt;a class="reference external" href="https://github.com/jschwinger233"&gt;&amp;#64;jschwinger233&lt;/a&gt; 的总结：&lt;/p&gt;
&lt;blockquote&gt;
bpf_probe_read_user 只能读到已经载入内存 (page-faulted into memory) 的数据，
而上面代码直到 execve(2) 之时都还未读过 .rodata，未曾触发 page fault。
这可以用 tracepoint:exceptions:page_fault* 来验证。&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h2 id="hidsection-4"&gt;验证&lt;a class="headerlink" href="#hidsection-4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="printf"&gt;
&lt;h3 id="hidprintf"&gt;增加 printf&lt;a class="headerlink" href="#hidprintf" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;由上面可知，其实我们只需要修改程序在执行 &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; 之前主动将 &lt;tt class="docutils literal"&gt;.rodata&lt;/tt&gt; 中的数据加载到内存中即可避免该问题，
比如使用 &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; 函数。&lt;/p&gt;
&lt;p&gt;即，可以使用 &lt;tt class="docutils literal"&gt;printf&lt;/tt&gt; 函数打印 &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; ，也可以直接打印一个静态字符串:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if (!fork()) {
    printf(&amp;quot;test\n&amp;quot;);
    // or
    // printf(&amp;quot;argv[0]: %s\n&amp;quot;, args[0]);
    execv(args[0], (char *const *) args);
}
&lt;/pre&gt;
&lt;p&gt;经验证，修改后的程序
&lt;a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce_printf1.c"&gt;reproduce_printf1.c&lt;/a&gt;
确实可以让 ebpf 程序正确读取到 filename 的值。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h3 id="hidsection-5"&gt;不使用静态字符串&lt;a class="headerlink" href="#hidsection-5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;既然是因为 &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; 是静态字符串导致的问题，那么可以尝试将 &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; 改为使用非静态字符串，看看问题是否还存在。
修改的内容如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
const char *const args[] = {
    argv[1],
    &amp;quot;add&amp;quot;,
    hostname,
    0
};
&lt;/pre&gt;
&lt;p&gt;经验证，修改后的程序
&lt;a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce_non_static.c"&gt;reproduce_non_static.c&lt;/a&gt;
也可以让 ebpf 程序正确读取到 filename 的值。&lt;/p&gt;
&lt;p&gt;不知道大家有没有注意到，我们的复现问题的程序里 &lt;tt class="docutils literal"&gt;argv[2]&lt;/tt&gt; 的值其实是一个非静态字符串，
所以也可以通过在 ebpf 程序中读取这个数据的内容来验证，
预期是不做任何修改就可以读取到 &lt;tt class="docutils literal"&gt;argv[2]&lt;/tt&gt; 这个非静态字符串的内容：&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;执行新的 bpftrace 命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo bpftrace -e 'tracepoint:syscalls:sys_enter_execve{
    printf(&amp;quot;%s[%d]: filename: %s, argv[1]: %s, argv[2]: %s\n&amp;quot;, comm, pid, str(args-&amp;gt;filename), str(args-&amp;gt;argv[1]), str(args-&amp;gt;argv[2]));
}'
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;执行 &lt;tt class="docutils literal"&gt;./reproduce&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;bpftrace 命令的输出示例如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bash[36523]: filename: ./reproduce, argv[1]: , argv[2]:
reproduce[36524]: filename: , argv[1]: , argv[2]: ./reproduce
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="page-fault"&gt;
&lt;h3 id="hidpage-fault"&gt;page fault&lt;a class="headerlink" href="#hidpage-fault" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在现代 Linux 系统中，当我们运行二进制可执行文件的时候，程序加载器（ELF executable loader）
会根据 ELF 文件中定义的信息使用 &lt;tt class="docutils literal"&gt;mmap&lt;/tt&gt; 进行懒加载（lazy loading），延迟加载一些数据。
当程序真正去读取这些数据的时候，如果被读取的数据还没有被加载到内存里，就会触发 page fault。&lt;/p&gt;
&lt;!-- CPU 就会生成一个缺页异常（page fault exception）。此时，内核中的缺页处理程序（page fault handler） --&gt;
&lt;!-- 会负责处理该异常，将缺失的页面加载到内存中，然后 CPU 重新执行引起缺页异常的指令。 --&gt;
&lt;p&gt;ELF 文件的 .rodata section 中存储的数据恰好就是会被延迟加载的数据。&lt;/p&gt;
&lt;div class="section" id="rodata"&gt;
&lt;h4 id="hidrodata"&gt;.rodata&lt;a class="headerlink" href="#hidrodata" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;ELF 文件中的 .rodata section 存储了一些只读数据，比如静态字符串。
我们首先来看一下编译后的示例程序二进制 ELF 文件中的 .rodata section 的数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;可以使用 &lt;tt class="docutils literal"&gt;objdump&lt;/tt&gt; 命令进行查看:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ objdump -s -j .rodata ./reproduce

./reproduce:     file format elf64-x86-64

Contents of section .rodata:
2000 01000200 2f757372 2f62696e 2f656368  ..../usr/bin/ech
2010 6f006164 6400                        o.add.
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;也可以使用 python 社区的 &lt;a class="reference external" href="https://docs.pwntools.com/en/stable/"&gt;pwntools&lt;/a&gt; 库进行读取:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; from pwn import ELF
&amp;gt;&amp;gt;&amp;gt; elf = ELF('reproduce')
&amp;gt;&amp;gt;&amp;gt; elf.section('.rodata')
b'\x01\x00\x02\x00/usr/bin/echo\x00add\x00'
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面的输出中可以看到其中包含了源码中使用的两个静态字符串。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="page-fault-1"&gt;
&lt;h4 id="hidpage-fault-1"&gt;观测 page fault&lt;a class="headerlink" href="#hidpage-fault-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在 Linux 系统中，当内核执行 &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; 系统调用时，
会使用内核函数 &lt;tt class="docutils literal"&gt;strncpy_from_user&lt;/tt&gt; 将 &lt;tt class="docutils literal"&gt;argv&lt;/tt&gt; 中包含的字符串数据从用户态复制到内核态，
这个过程涉及读取用户态数据的操作。
如果被读取的用户态数据还未被加载到内存中，就会触发 page fault。&lt;/p&gt;
&lt;p&gt;我们可以通过观测 &lt;tt class="docutils literal"&gt;exceptions/page_fault_kernel&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;exceptions/page_fault_user&lt;/tt&gt; 感知到这个事件:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;为了方便验证，我们需要先修改一下示例代码，在执行 &lt;tt class="docutils literal"&gt;execv()&lt;/tt&gt; 函数前增加一行 &lt;tt class="docutils literal"&gt;sleep(15)&lt;/tt&gt; ，避免程序太快结束
（&lt;a class="reference external" href="https://github.com/mozillazg/ebpf-tracepoint-execve-argv-issue/blob/master/reproduce_sleep.c"&gt;reproduce_sleep.c&lt;/a&gt; ）&lt;/p&gt;
&lt;pre class="literal-block"&gt;
if (!fork()) {
     sleep(15);
     execv(args[0], (char *const *) args);
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;在一个终端中运行下面这个 bpftrace 脚本，观测 page fault:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
cat &amp;lt;&amp;lt;EOF | sudo bpftrace -
tracepoint:exceptions:page_fault_kernel /comm == &amp;quot;reproduce_sleep&amp;quot;/ {
    printf(&amp;quot;[%s] page_fault_kernel: %s[%d] addr=%llx ip=%llx err=%lld\n&amp;quot;,
            strftime(&amp;quot;%M:%S&amp;quot;, nsecs), comm, pid, args-&amp;gt;address, args-&amp;gt;ip, args-&amp;gt;error_code);
}

tracepoint:exceptions:page_fault_user /comm == &amp;quot;reproduce_sleep&amp;quot;/ {
    printf(&amp;quot;[%s] page_fault_user:   %s[%d] addr=%llx ip=%llx err=%lld\n&amp;quot;,
            strftime(&amp;quot;%M:%S&amp;quot;, nsecs), comm, pid, args-&amp;gt;address, args-&amp;gt;ip, args-&amp;gt;error_code);
}
EOF
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;然后在另一个终端中运行 &lt;tt class="docutils literal"&gt;./reproduce_sleep&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;在第3个终端中查看运行中的 reproduce_sleep 进程的内存映射关系（memory mapping）:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo cat /proc/41291/maps | grep reproduce_sleep
55b4d9e31000-55b4d9e32000 r--p 00000000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e32000-55b4d9e33000 r-xp 00001000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e33000-55b4d9e34000 r--p 00002000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e34000-55b4d9e35000 r--p 00002000 08:01 1634479                    /XXX/reproduce_sleep
55b4d9e35000-55b4d9e36000 rw-p 00003000 08:01 1634479                    /XXX/reproduce_sleep
&lt;/pre&gt;
&lt;p&gt;由上面可知，该进程的内存映射起始地址是 &lt;tt class="docutils literal"&gt;55b4d9e31000&lt;/tt&gt; ，即 &lt;tt class="docutils literal"&gt;0x55b4d9e31000&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;待示例程序运行结束后，bpftrace 命令的输出中的最后两条数据将类似下面这样:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[47:40] page_fault_user:   reproduce_sleep[41290] addr=7f669db86a50 ip=7f669d9f8940 err=7
[47:55] page_fault_kernel: reproduce_sleep[41291] addr=55b4d9e33004 ip=ffffffff8e092a40 err=0
&lt;/pre&gt;
&lt;p&gt;这两个输出间隔了 15 秒，由此可以确定最后那个 page fault 事件是执行 &lt;tt class="docutils literal"&gt;execv()&lt;/tt&gt; 函数的时候触发的。
下面来通过事件中的 &lt;tt class="docutils literal"&gt;addr&lt;/tt&gt; 结果定位对应的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;上面最后那条 &lt;tt class="docutils literal"&gt;page_fault_kernel&lt;/tt&gt; 事件输出的 addr 的值是 &lt;tt class="docutils literal"&gt;55b4d9e33004&lt;/tt&gt; ，
即触发这个 page fault 事件的虚拟内存地址是 &lt;tt class="docutils literal"&gt;0x55b4d9e33004&lt;/tt&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;基于 &lt;a class="reference external" href="https://github.com/jschwinger233"&gt;&amp;#64;jschwinger233&lt;/a&gt;  分享的秘籍：
&lt;tt class="docutils literal"&gt;real_addr = start_addr + (elf_address - section.Address + section.Offset)&lt;/tt&gt; 可知:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
0x55b4d9e33004 = 0x55b4d9e31000 + (elf_address - section.Address + section.Offset)
(elf_address - section.Address + section.Offset) = 0x55b4d9e33004 - 0x55b4d9e31000 = 8196 = 0x2004
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;使用 readelf 命令读取二进制文件 reproduce_sleep 中 ELF .rodata section 的内存地址、偏移量以及数据大小:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ readelf -S -W reproduce_sleep  | egrep '.rodata|Address'
  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
  [18] .rodata           PROGBITS        0000000000002000 002000 000016 00   A  0   0  4
&lt;/pre&gt;
&lt;p&gt;由上面的输出可知，该 ELF 文件中 .rodata section 的虚拟地址是 &lt;tt class="docutils literal"&gt;0000000000002000&lt;/tt&gt; 即 &lt;tt class="docutils literal"&gt;0x2000&lt;/tt&gt; ，
偏移量是 &lt;tt class="docutils literal"&gt;002000&lt;/tt&gt; 即 &lt;tt class="docutils literal"&gt;0x2000&lt;/tt&gt; ， 数据大小是 &lt;tt class="docutils literal"&gt;0x16&lt;/tt&gt; ，即地址范围是 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;0x2000-0x2016&lt;/span&gt;&lt;/tt&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;通过 7 和 8 可知，执行 &lt;tt class="docutils literal"&gt;execv()&lt;/tt&gt; 函数时触发的 page fault 事件的虚拟内存地址
&lt;tt class="docutils literal"&gt;0x55b4d9e33004&lt;/tt&gt; 对应的 ELF 地址是 &lt;tt class="docutils literal"&gt;0x2004&lt;/tt&gt; ，这个地址在 ELF 文件的 .rodata 地址范围（0x2000-0x2016）内，
对应的是 &lt;tt class="docutils literal"&gt;argv[0]&lt;/tt&gt; 中使用的静态字符串 &lt;tt class="docutils literal"&gt;/usr/bin/echo&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ objdump -s -j .rodata ./reproduce_sleep

./reproduce_sleep:     file format elf64-x86-64

Contents of section .rodata:
 2000 01000200 2f757372 2f62696e 2f656368  ..../usr/bin/ech
 2010 6f006164 6400                        o.add.

&amp;gt;&amp;gt;&amp;gt; elf = ELF('reproduce_sleep')
&amp;gt;&amp;gt;&amp;gt; elf.read(0x2004, 14)
b'/usr/bin/echo\x00'

$ gdb -ex 'disas/m main' -ex q reproduce_sleep | grep 'args\[\]' -A 13
9       const char *const args[] = {
   0x00000000000011d6 &amp;lt;+45&amp;gt;:        lea    0xe27(%rip),%rax        # 0x2004
   0x00000000000011dd &amp;lt;+52&amp;gt;:        mov    %rax,-0x30(%rbp)
   0x00000000000011e1 &amp;lt;+56&amp;gt;:        lea    0xe2a(%rip),%rax        # 0x2012
   0x00000000000011e8 &amp;lt;+63&amp;gt;:        mov    %rax,-0x28(%rbp)
   0x00000000000011ec &amp;lt;+67&amp;gt;:        mov    -0x38(%rbp),%rax
   0x00000000000011f0 &amp;lt;+71&amp;gt;:        mov    %rax,-0x20(%rbp)
   0x00000000000011f4 &amp;lt;+75&amp;gt;:        movq   $0x0,-0x18(%rbp)

10          PATHNAME,
11          &amp;quot;add&amp;quot;,
12          hostname,
13          0
14      };
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;也可以通过在 ebpf 程序或 bpftrace 脚本中打印 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;args-&amp;gt;filename&lt;/span&gt;&lt;/tt&gt; 的指针地址来确认，
这个地址的值会跟前面 page fault 事件中 addr 的值一致，都是 &lt;tt class="docutils literal"&gt;0x55b4d9e33004&lt;/tt&gt;&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tracepoint:syscalls:sys_enter_execve {
    printf(&amp;quot;%s[%d]: %p\n&amp;quot;, comm, pid, args-&amp;gt;filename);
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;BTW，可以通过 &lt;tt class="docutils literal"&gt;perf trace &lt;span class="pre"&gt;-F&lt;/span&gt; all&lt;/tt&gt; 命令追踪触发 page fault 事件的函数信息。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h2 id="hidsection-6"&gt;解决方法&lt;a class="headerlink" href="#hidsection-6" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;解决这个问题的方法有很多，其中一种解决方法是改为通过追踪 &lt;tt class="docutils literal"&gt;tracepoint/sched/sched_process_exec&lt;/tt&gt;
事件来获取 &lt;tt class="docutils literal"&gt;execve()&lt;/tt&gt; 系统调用中 &lt;tt class="docutils literal"&gt;filename&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;argv&lt;/tt&gt; 参数的值。下面是对应实现的示例程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;通过 bpftrace 追踪 &lt;tt class="docutils literal"&gt;tracepoint/sched/sched_process_exec&lt;/tt&gt; 事件的示例脚本（来自 &lt;a class="reference external" href="https://github.com/jschwinger233"&gt;&amp;#64;jschwinger233&lt;/a&gt; ）:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
tracepoint:sched:sched_process_exec {
  $task=curtask;
  $arg_start=$task-&amp;gt;mm-&amp;gt;arg_start;
  $arg_end=$task-&amp;gt;mm-&amp;gt;arg_end;
  printf(&amp;quot;%s[%d]: filename: %s, argv: %r\n&amp;quot;, comm, pid, str(args-&amp;gt;filename), buf(uptr($arg_start), $arg_end-$arg_start));
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;通过 ebpf c 代码追踪 &lt;tt class="docutils literal"&gt;tracepoint/sched/sched_process_exec&lt;/tt&gt; 事件的示例程序：
&lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/blob/master/37-tracepoint-sched_process_exec/main.bpf.c"&gt;main.bpf.c&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h2 id="hidsection-7"&gt;参考资料&lt;a class="headerlink" href="#hidsection-7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/tmux/tmux/tree/master"&gt;tmux/tmux: tmux source code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/bpftrace/bpftrace/issues/2523"&gt;Can't trace sys_execve inside a c program · Issue #2523 · bpftrace/bpftrace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.osdev.org/ELF"&gt;ELF - OSDev Wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://stackoverflow.com/questions/57761007/why-an-elf-executable-could-have-4-load-segments"&gt;unix - Why an ELF executable could have 4 LOAD segments? - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.cs.bham.ac.uk/~exr/lectures/opsys/13_14/docs/kernelAPI/r4206.html"&gt;strncpy_from_user&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/jschwinger233"&gt;&amp;#64;jschwinger233&lt;/a&gt; 的谆谆教诲&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="tracepoint"></category><category term="bpftrace"></category><category term="ELF"></category></entry><entry><title>使用 libbpfgo 重写 BCC libbpf-tools 中各个工具的用户态程序</title><link href="https://mozillazg.com/2022/11/ebpf-libbpfgo-tools-port-rewriting-the-control-plane-of-bcc-libbpf-tools-in-golang-with-libbpfgo.html" rel="alternate"></link><published>2022-11-26T00:00:00+00:00</published><updated>2022-11-26T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2022-11-26:2022/11/ebpf-libbpfgo-tools-port-rewriting-the-control-plane-of-bcc-libbpf-tools-in-golang-with-libbpfgo.html</id><summary type="html">&lt;p&gt;最近新开源了一个 eBPF 相关的项目：
&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools"&gt;mozillazg/libbpfgo-tools&lt;/a&gt; 。
这个项目的目标是使用 &lt;a class="reference external" href="https://github.com/aquasecurity/libbpfgo"&gt;libbpfgo&lt;/a&gt; 重写/移植 &lt;a class="reference external" href="https://github.com/iovisor/bcc/tree/master/libbpf-tools"&gt;bcc/libbpf-tools&lt;/a&gt; 中各个工具的前端程序（即，用户态程序）。
希望能在如何使用 golang 编写 eBPF 程序, 尤其是如何使用 libbpfgo 这个 eBPF 库方面对大家有些许帮助。&lt;/p&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2 id="hidsection-1"&gt;目标&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这个项目的目标和原则如下：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;所有的 eBPF C 代码全部重用 BCC 仓库中 libbpf-tools 目录下的代码。
我们不会对 BCC 的代码做任何额外的修改，如果有需要修改的地方会提 PR 给上游 BCC 仓库。&lt;/li&gt;
&lt;li&gt;所有的用户态程序都使用 libbpfgo 进行实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2 id="hidsection-2"&gt;状态&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;当前，我们已经完成了最新 v0.25.0 版本 BCC libbpf-tools 全部 46 个工具中 28 个工具的移植工作，
更多工具的移植持续进行中：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/bashreadline"&gt;bashreadline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/bindsnoop"&gt;bindsnoop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/biolatency"&gt;biolatency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/biopattern"&gt;biopattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/biosnoop"&gt;biosnoop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/biostacks"&gt;biostacks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/bitesize"&gt;bitesize&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/cpudist"&gt;cpudist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/drsnoop"&gt;drsnoop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/execsnoop"&gt;execsnoop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/filelife"&gt;filelife&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/filetop"&gt;filetop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/mdflush"&gt;mdflush&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/mountsnoop"&gt;mountsnoop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/oomkill"&gt;oomkill&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/opensnoop"&gt;opensnoop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/readahead"&gt;readahead&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/sigsnoop"&gt;sigsnoop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/solisten"&gt;solisten&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/statsnoop"&gt;statsnoop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/syscount"&gt;syscount&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/tcpconnect"&gt;tcpconnect&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/tcpconnlat"&gt;tcpconnlat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/tcplife"&gt;tcplife&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/tcprtt"&gt;tcprtt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/tcpsynbl"&gt;tcpsynbl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/libbpfgo-tools/blob/master/tools/tcptracer"&gt;tcptracer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="libbpf"></category><category term="libbpfgo"></category></entry><entry><title>在 ebpf/libbpf 程序中使用尾调用（tail calls）</title><link href="https://mozillazg.com/2022/10/ebpf-libbpf-use-tail-calls.html" rel="alternate"></link><published>2022-10-07T00:00:00+00:00</published><updated>2022-10-07T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2022-10-07:2022/10/ebpf-libbpf-use-tail-calls.html</id><summary type="html">&lt;p&gt;本文将介绍如何在 ebpf/libbpf 程序中使用 eBPF 的尾调用（tail calls）特性。&lt;/p&gt;
&lt;div class="section" id="tail-calls"&gt;
&lt;h2 id="hidtail-calls"&gt;尾调用（tail calls）&lt;a class="headerlink" href="#hidtail-calls" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;eBPF 的尾调用（tail calls）特性允许一个 eBPF 程序可以调用另一个 eBPF 程序， 并且调用完成后不会返回原来的程序。
因为尾调用在调用函数的时候会重用调用方函数的 stack frame，所以它的开销比普通的函数
调用会更低。&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/static/images/bpf/bpf_tailcall.png" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;图片来源：&lt;a class="reference external" href="https://docs.cilium.io/en/v1.12/bpf/#tail-calls"&gt;https://docs.cilium.io/en/v1.12/bpf/#tail-calls&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;尾调用涉及两个步骤：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;定义一个类型为 &lt;tt class="docutils literal"&gt;BPF_MAP_TYPE_PROG_ARRAY&lt;/tt&gt; 的 map ， map 的 value 是在尾调用中被调用的 eBPF 程序的文件描述符。 我们可以在用户态程序中更新这个 map 的 key/value。&lt;/li&gt;
&lt;li&gt;在 eBPF 程序中，我们可以通过 &lt;tt class="docutils literal"&gt;bpf_tail_call()&lt;/tt&gt; 这个辅助函数 从第1步的 map 中获取 eBPF 程序然后执行该程序进行尾调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2 id="hidsection-1"&gt;使用示例&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;如前面所说，要使用尾调用特性我们需要定义一个 map 以及在 eBPF 程序中使用辅助函数执行尾调用。下面将以示例的代码的方式讲述每个步骤的关键代码。&lt;/p&gt;
&lt;div class="section" id="bpf-map-type-prog-array-map"&gt;
&lt;h3 id="hidbpf-map-type-prog-array-map"&gt;定义 BPF_MAP_TYPE_PROG_ARRAY 类型的 map&lt;a class="headerlink" href="#hidbpf-map-type-prog-array-map" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过下面的方法定义一个 &lt;tt class="docutils literal"&gt;BPF_MAP_TYPE_PROG_ARRAY&lt;/tt&gt; 类型的 map:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_MAP_TYPE_PROG_ARRAY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key_size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value_size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_entries&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tail_jmp_map&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.maps&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想要在定义这个 map 的时候初始化一些值的话，可以用下面的方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_MAP_TYPE_PROG_ARRAY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key_size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value_size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_entries&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="c1"&gt;// 这个 values 必须有&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tail_jmp_map&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.maps&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;                      &lt;/span&gt;&lt;span class="c1"&gt;// 初始化一些值&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;268&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;enter_fchmodat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="map"&gt;
&lt;h3 id="hidmap"&gt;用户态更新 map&lt;a class="headerlink" href="#hidmap" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在用户态程序中可以通过 &lt;tt class="docutils literal"&gt;bpf_map_update_elem&lt;/tt&gt; 函数更新这个 map:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;tail_jump_map_fd&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bpf_object__find_map_fd_by_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tail_jmp_map&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;bpf_map_update_elem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tail_jump_map_fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;bpf_program_fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_ANY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h3 id="hidsection-2"&gt;尾调用&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;eBPF 程序中可以通过 &lt;tt class="docutils literal"&gt;bpf_tail_call&lt;/tt&gt; 辅助函数执行尾调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;raw_tracepoint/sys_enter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;raw_tracepoint__sys_enter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;bpf_raw_tracepoint_args&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;syscall_id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// 执行尾调用&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;bpf_tail_call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;tail_jmp_map&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;syscall_id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// 如果在 map 中找不到对应的 ebpf 程序的话，会继续走到后面的代码&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;no bpf program for syscall %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;bpf_trace_printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;syscall_id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的示例程序，详见： &lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/22-tail-calls"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/22-tail-calls&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2 id="hidsection-3"&gt;参考资料&lt;a class="headerlink" href="#hidsection-3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.cilium.io/en/v1.12/bpf/"&gt;BPF and XDP Reference Guide — Cilium 1.12.2 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://man7.org/linux/man-pages/man2/bpf.2.html"&gt;bpf(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html"&gt;bpf-helpers(7) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/libbpf/libbpf/issues/354"&gt;Support static initialization of BPF_MAP_TYPE_PROG_ARRAY · Issue #354 · libbpf/libbpf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="libbpf"></category><category term="libbpfgo"></category></entry><entry><title>解决 ebpf 验证器提示类型错误问题的一种方法</title><link href="https://mozillazg.com/2022/10/ebpf-libbpf-verifier-fix-type-expected-issue.html" rel="alternate"></link><published>2022-10-06T00:00:00+00:00</published><updated>2022-10-06T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2022-10-06:2022/10/ebpf-libbpf-verifier-fix-type-expected-issue.html</id><summary type="html">&lt;p&gt;有时当我们加载编译后的 eBPF 程序的时候，eBPF 验证器会提示程序中有类型错误的问题导致程序加载失败。 本文记录一下这种错误的一种解决方法。&lt;/p&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2 id="hidsection-1"&gt;错误示例&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;比如，当下面这段 eBPF 程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;iter/bpf_sk_storage_map&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;iter__bpf_sk_storage_map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;bpf_iter__bpf_sk_storage_map&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;bpf_sk_storage_delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;sk_storage_map&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;sk&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;被加载到内核中时会提示如下类型错误:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
libbpf: prog 'iter__bpf_sk_storage_map': BPF program load failed: Permission denied
libbpf: prog 'iter__bpf_sk_storage_map': -- BEGIN PROG LOAD LOG --
R1 type=ctx expected=fp
; if (ctx-&amp;gt;sk)
0: (79) r2 = *(u64 *)(r1 +16)
; if (ctx-&amp;gt;sk)
1: (15) if r2 == 0x0 goto pc+4
 R1=ctx(id=0,off=0,imm=0) R2_w=ptr_sock(id=0,off=0,imm=0) R10=fp0
; bpf_sk_storage_delete(&amp;amp;sk_storage_map, ctx-&amp;gt;sk);
2: (79) r2 = *(u64 *)(r1 +16)
; bpf_sk_storage_delete(&amp;amp;sk_storage_map, ctx-&amp;gt;sk);
3: (18) r1 = 0xffffa0658305aa00
5: (85) call bpf_sk_storage_delete#108
R2 type=ptr_or_null_ expected=ptr_
processed 5 insns (limit 1000000) max_states_per_insn 0 total_states 0 peak_states 0 mark_read 0
-- END PROG LOAD LOG --
libbpf: prog 'iter__bpf_sk_storage_map': failed to load: -13
libbpf: failed to load object 'main.bpf.o'
failed to load BPF object: permission denied
&lt;/pre&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h3 id="hidsection-2"&gt;解决办法&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这个错误信息有两个关键错误，一个错误是:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
R1 type=ctx expected=fp
; if (ctx-&amp;gt;sk)
0: (79) r2 = *(u64 *)(r1 +16)
; if (ctx-&amp;gt;sk)
1: (15) if r2 == 0x0 goto pc+4
&lt;/pre&gt;
&lt;p&gt;其中 &lt;tt class="docutils literal"&gt;R1 type=ctx expected=fp&lt;/tt&gt; 说的是，验证器期望 &lt;tt class="docutils literal"&gt;R1&lt;/tt&gt; 的类型是 &lt;tt class="docutils literal"&gt;fp&lt;/tt&gt; 而不是 &lt;tt class="docutils literal"&gt;ctx&lt;/tt&gt; 。 所谓的 &lt;tt class="docutils literal"&gt;fp&lt;/tt&gt; 指的是栈上的指针类型，即期望 &lt;tt class="docutils literal"&gt;R1&lt;/tt&gt; 是栈上的数据而不是 &lt;tt class="docutils literal"&gt;ctx&lt;/tt&gt; 。&lt;/p&gt;
&lt;p&gt;另一个错误是:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
 R1=ctx(id=0,off=0,imm=0) R2_w=ptr_sock(id=0,off=0,imm=0) R10=fp0
; bpf_sk_storage_delete(&amp;amp;sk_storage_map, ctx-&amp;gt;sk);
2: (79) r2 = *(u64 *)(r1 +16)
; bpf_sk_storage_delete(&amp;amp;sk_storage_map, ctx-&amp;gt;sk);
3: (18) r1 = 0xffffa0658305aa00
5: (85) call bpf_sk_storage_delete#108
R2 type=ptr_or_null_ expected=ptr_
&lt;/pre&gt;
&lt;p&gt;其中 &lt;tt class="docutils literal"&gt;R2 type=ptr_or_null_ expected=ptr_&lt;/tt&gt; 说的是，验证器期望 &lt;tt class="docutils literal"&gt;R2&lt;/tt&gt; 的类型是 &lt;tt class="docutils literal"&gt;ptr&lt;/tt&gt; 而不是 &lt;tt class="docutils literal"&gt;prt_or_null&lt;/tt&gt; ，即，期望 &lt;tt class="docutils literal"&gt;R2&lt;/tt&gt; 是一个指针而不是一个指针或 &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt; 。 这里可能会有点疑惑，前面的判断 &lt;tt class="docutils literal"&gt;if &lt;span class="pre"&gt;(ctx-&amp;gt;sk)&lt;/span&gt;&lt;/tt&gt; 已经确保了不会为 &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt; ， 为啥这里还会认为它有可能为 &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt; ，这是因为前面的 if 判断的不是栈变量， 存在 &lt;tt class="docutils literal"&gt;R1 type=ctx expected=fp&lt;/tt&gt; 的问题也就无法保证它一定不是 &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt; 了。&lt;/p&gt;
&lt;p&gt;解决办法也很简单，就是用一个临时变量保存 ctx-&amp;gt;sk 的值， 然后用这个栈上的临时变量做后续的操作:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;SEC(&amp;quot;iter/bpf_sk_storage_map&amp;quot;)
&lt;span class="w"&gt; &lt;/span&gt;int iter__bpf_sk_storage_map(struct bpf_iter__bpf_sk_storage_map *ctx)
&lt;span class="w"&gt; &lt;/span&gt;{
&lt;span class="gd"&gt;-    if (ctx-&amp;gt;sk)&lt;/span&gt;
&lt;span class="gd"&gt;-        bpf_sk_storage_delete(&amp;amp;sk_storage_map, ctx-&amp;gt;sk);&lt;/span&gt;
&lt;span class="gi"&gt;+    struct sock *sk = ctx-&amp;gt;sk;&lt;/span&gt;
&lt;span class="gi"&gt;+    if (sk)&lt;/span&gt;
&lt;span class="gi"&gt;+        bpf_sk_storage_delete(&amp;amp;sk_storage_map, sk);&lt;/span&gt;

&lt;span class="w"&gt; &lt;/span&gt;    return 0;
&lt;span class="w"&gt; &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2 id="hidsection-3"&gt;常见类型关键字的含义&lt;a class="headerlink" href="#hidsection-3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这里记录一下类似前面 &lt;tt class="docutils literal"&gt;fp&lt;/tt&gt; 这样的常见类型关键字具体的含义：&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="33%" /&gt;
&lt;col width="67%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;关键字&lt;/th&gt;
&lt;th class="head"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;scalar&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;标量类型（scalar type），不是一个有效的指针类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;ctx&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;bpf_context 指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;map_ptr&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;bpf_map 类型的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;map_value&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;指向 map 中的元素 value 的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;map_value_or_null&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;指向 map 中的元素 value 的指针或 NULL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;map_key&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;指向 map 中的元素 key 的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;fp&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;栈上的指针（frame pointer）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;pkt&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;skb-&amp;gt;data 指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;pkt_meta&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;skb-&amp;gt;data - meta_len 位置的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;pkt_end&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;skb-&amp;gt;data + headlen 位置的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;sock&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;bpf_sock 类型的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;sock_or_null&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;bpf_sock 类型的指针或 NULL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;sock_common&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;sock_common 类型指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;sock_common_or_null&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;sock_common 类型指针或 NULL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;tcp_sock&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;tcp_sock 类型指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;tcp_sock_or_null&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;tcp_sock 类型指针或 NULL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;tp_buffer&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;可写的 raw tracepoint buffer 指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;xdp_sock&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;xdp_sock 类型指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;ptr_&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;一个 BTF ID，非空指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;ptr_or_null_&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;一个 BTF ID 或 NULL，可能为空的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;dynptr_ptr&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;动态指针（dynptr 指针）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;mem&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;指向一块有效内存区域的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;mem_or_null&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;指向一块有效内存区域的指针或 NULL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;buf&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;指向一个读/写 buffer 的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;func&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;BPF 程序函数指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;inv&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;无效类型（invalid type），不是一个有效的指针类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;flow_keys&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;bpf_flow_keys 类型的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;percpu_ptr_&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;指向一个 percpu 内核变量的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;rdonly_buf&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;指向一个只读 buffer 的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;rdonly_buf_or_null&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;指向一个只读 buffer 的指针或 NULL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;rdwr_buf&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;指向一个读/写 buffer 的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;tt class="docutils literal"&gt;rdwr_buf_or_null&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;指向一个读/写 buffer 的指针或 NULL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h2 id="hidsection-4"&gt;参考资料&lt;a class="headerlink" href="#hidsection-4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://elixir.bootlin.com/linux/v5.19.14/source/kernel/bpf/verifier.c#L533"&gt;verifier.c - kernel/bpf/verifier.c - Linux source code (v5.19.14) - Bootlin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://elixir.bootlin.com/linux/v5.13/source/kernel/bpf/verifier.c#L548"&gt;verifier.c - kernel/bpf/verifier.c - Linux source code (v5.13) - Bootlin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="libbpf"></category></entry><entry><title>ebpf 程序中常用的 load_byte/load_half/load_word 功能介绍</title><link href="https://mozillazg.com/2022/07/ebpf-libbpf-what-is-load_byte-load_half-load_word.html" rel="alternate"></link><published>2022-07-31T00:00:00+00:00</published><updated>2022-07-31T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2022-07-31:2022/07/ebpf-libbpf-what-is-load_byte-load_half-load_word.html</id><summary type="html">&lt;div class="section" id="section-1"&gt;
&lt;h2 id="hidsection-1"&gt;前言&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;大家在阅读一些网络相关的 ebpf 程序源码时可能会发现部分程序会使用
&lt;tt class="docutils literal"&gt;load_byte&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;load_half&lt;/tt&gt; 以及 &lt;tt class="docutils literal"&gt;load_word&lt;/tt&gt; 这几个函数来辅助解析网络数据包。&lt;/p&gt;
&lt;p&gt;那么这几个函数的功能究竟是啥？以及它们各自的使用场景是啥，怎么知道究竟该用哪个函数？
本文将记录这几个函数各种的功能以及使用场景。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="load-byte"&gt;
&lt;h2 id="hidload-byte"&gt;load_byte&lt;a class="headerlink" href="#hidload-byte" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h3 id="hidsection-2"&gt;函数定义&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;load_byte&lt;/tt&gt; 函数的定义如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;load_byte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                          &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;asm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;llvm.bpf.load.byte&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h3 id="hidsection-3"&gt;函数功能&lt;a class="headerlink" href="#hidsection-3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;它的功能是：从 &lt;tt class="docutils literal"&gt;skb&lt;/tt&gt; 指向的数据包指针中 offset 位置开始读取 &lt;strong&gt;8-bits&lt;/strong&gt; 的数据。
跟 gcc 里的 &lt;tt class="docutils literal"&gt;__builtin_bpf_load_byte&lt;/tt&gt; 函数的功能是一样的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3 id="hidsection-4"&gt;使用场景&lt;a class="headerlink" href="#hidsection-4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;当想要从 &lt;tt class="docutils literal"&gt;struct __sk_buff *skb&lt;/tt&gt; 中读取数据类型大小为 8-bits（1个字节） 的字段的值的时候，
可以使用 &lt;tt class="docutils literal"&gt;load_byte&lt;/tt&gt; 直接从指针中读取对应的数据。&lt;/p&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;__u8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;load_byte&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ETH_HLEN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;offsetof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;iphdr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="load-half"&gt;
&lt;h2 id="hidload-half"&gt;load_half&lt;a class="headerlink" href="#hidload-half" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h3 id="hidsection-5"&gt;函数定义&lt;a class="headerlink" href="#hidsection-5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;load_half&lt;/tt&gt; 函数的定义如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;load_half&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                         &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;asm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;llvm.bpf.load.half&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;h3 id="hidsection-6"&gt;函数功能&lt;a class="headerlink" href="#hidsection-6" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;它的功能是：从 &lt;tt class="docutils literal"&gt;skb&lt;/tt&gt; 指向的数据包指针中 offset 位置开始读取 &lt;strong&gt;16-bits&lt;/strong&gt; 的数据。
跟 gcc 里的 &lt;tt class="docutils literal"&gt;__builtin_bpf_load_half&lt;/tt&gt; 函数的功能是一样的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;h3 id="hidsection-7"&gt;使用场景&lt;a class="headerlink" href="#hidsection-7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;当想要从 &lt;tt class="docutils literal"&gt;struct __sk_buff *skb&lt;/tt&gt; 中读取数据类型大小为 16-bits（2个字节）的字段的值的时候，
可以使用 &lt;tt class="docutils literal"&gt;load_half&lt;/tt&gt; 直接从指针中读取对应的数据。&lt;/p&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;__u16&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;h_proto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;load_half&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;offsetof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;ethhdr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;h_proto&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="load-word"&gt;
&lt;h2 id="hidload-word"&gt;load_word&lt;a class="headerlink" href="#hidload-word" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="section-8"&gt;
&lt;h3 id="hidsection-8"&gt;函数定义&lt;a class="headerlink" href="#hidsection-8" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;load_word&lt;/tt&gt; 函数的定义如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;load_word&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;                         &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;asm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;llvm.bpf.load.word&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-9"&gt;
&lt;h3 id="hidsection-9"&gt;函数功能&lt;a class="headerlink" href="#hidsection-9" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;它的功能是：从 &lt;tt class="docutils literal"&gt;skb&lt;/tt&gt; 指向的数据包指针中 offset 位置开始读取 &lt;strong&gt;32-bits&lt;/strong&gt; 的数据。
跟 gcc 里的 &lt;tt class="docutils literal"&gt;__builtin_bpf_load_word&lt;/tt&gt; 函数的功能是一样的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-10"&gt;
&lt;h3 id="hidsection-10"&gt;使用场景&lt;a class="headerlink" href="#hidsection-10" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;当想要从 &lt;tt class="docutils literal"&gt;struct __sk_buff *skb&lt;/tt&gt; 中读取数据类型大小为 32-bits（4个字节）的字段的值的时候，
可以使用 &lt;tt class="docutils literal"&gt;load_word&lt;/tt&gt; 直接从指针中读取对应的数据。&lt;/p&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;__u32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;saddr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;load_word&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ETH_HLEN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;offsetof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;iphdr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;saddr&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-11"&gt;
&lt;h2 id="hidsection-11"&gt;替代函数&lt;a class="headerlink" href="#hidsection-11" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;如果不想依赖 llvm 实现这几个函数所提供的功能的话，可以使用 bpf-helpers 中提供的
&lt;tt class="docutils literal"&gt;bpf_skb_load_bytes&lt;/tt&gt; 函数实现类似的功能。&lt;/p&gt;
&lt;p&gt;比如前面的那几个例子可以改写为:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// __u8 protocol = load_byte(skb, ETH_HLEN + offsetof(struct iphdr, protocol));&lt;/span&gt;
&lt;span class="n"&gt;__u8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_skb_load_bytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ETH_HLEN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;offsetof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;iphdr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


&lt;span class="c1"&gt;// __u16 h_proto = load_half(skb, offsetof(struct ethhdr, h_proto));&lt;/span&gt;
&lt;span class="n"&gt;__u16&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;raw_h_proto&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_skb_load_bytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;offsetof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;ethhdr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;h_proto&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;raw_h_proto&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;raw_h_proto&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;__u16&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;h_proto&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bpf_ntohs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;raw_h_proto&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;


&lt;span class="c1"&gt;// __u32 saddr = load_word(skb, ETH_HLEN + offsetof(struct iphdr, saddr));&lt;/span&gt;
&lt;span class="n"&gt;__u32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;saddr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_skb_load_bytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;skb&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ETH_HLEN&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;offsetof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;iphdr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;saddr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;saddr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;saddr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-12"&gt;
&lt;h2 id="hidsection-12"&gt;参考资料&lt;a class="headerlink" href="#hidsection-12" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://reviews.llvm.org/D6494?id=17480"&gt;⚙ D6494 BPF backend&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/BPF-Built-in-Functions.html"&gt;BPF Built-in Functions (Using the GNU Compiler Collection (GCC))&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html"&gt;bpf-helpers(7) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="ebpf"></category><category term="libbpf"></category></entry><entry><title>ebpf/libbpf 程序使用 btf raw tracepoint 的常见问题</title><link href="https://mozillazg.com/2022/06/ebpf-libbpf-btf-powered-enabled-raw-tracepoint-common-questions.html" rel="alternate"></link><published>2022-06-14T00:00:00+00:00</published><updated>2022-06-14T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2022-06-14:2022/06/ebpf-libbpf-btf-powered-enabled-raw-tracepoint-common-questions.html</id><summary type="html">&lt;div class="section" id="section-1"&gt;
&lt;h2 id="hidsection-1"&gt;前言&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文记录一些编写 ebpf/libbpf 程序(比如编写类型为 &lt;tt class="docutils literal"&gt;BPF_TRACE_RAW_TP&lt;/tt&gt; 的 ebpf 程序) 时
涉及到的 btf raw tracepoint 相关的常见问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="btf-raw-tracepoint-raw-tracepoint"&gt;
&lt;h2 id="hidbtf-raw-tracepoint-raw-tracepoint"&gt;btf raw tracepoint 跟常规 raw tracepoint 的区别&lt;a class="headerlink" href="#hidbtf-raw-tracepoint-raw-tracepoint" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;所谓的 btf raw tracepoint 指的是 &lt;a class="reference external" href="https://lore.kernel.org/netdev/20201203204634.1325171-1-andrii&amp;#64;kernel.org/t/"&gt;BTF-powered raw tracepoint (tp_btf) 或者说是 BTF-enabled raw tracepoint&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;btf raw tracepoint 跟常规 raw tracepoint 有一个 &lt;a class="reference external" href="https://nakryiko.com/posts/bpf-core-reference-guide/#btf-enabled-bpf-program-types-with-direct-memory-reads"&gt;最主要的区别&lt;/a&gt; 是：
btf 版本可以直接在 ebpf 程序中访问内核内存，
不需要像常规 raw tracepoint 一样需要借助类似 &lt;tt class="docutils literal"&gt;bpf_core_read&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel&lt;/tt&gt; 这样 的辅助函数才能访问内核内存:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bpf_get_current_task&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ppid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_CORE_READ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;real_parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tgid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// btf enabled&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bpf_get_current_task_btf&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ppid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;real_parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;tgid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="btf-raw-tracepoint"&gt;
&lt;h2 id="hidbtf-raw-tracepoint"&gt;btf raw tracepoint 可以监控哪些事件&lt;a class="headerlink" href="#hidbtf-raw-tracepoint" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;btf raw tracepoint 跟 &lt;a class="reference external" href="https://mozillazg.com/2022/05/ebpf-libbpf-raw-tracepoint-common-questions.html"&gt;raw tracepoint&lt;/a&gt; 所能监控的事件是一样的，这里不再赘述。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sec"&gt;
&lt;h2 id="hidsec"&gt;SEC 内容的格式&lt;a class="headerlink" href="#hidsec" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;btf raw tracepoint 事件对应的 SEC 格式为:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
SEC(&amp;quot;tp_btf/&amp;lt;name&amp;gt;&amp;quot;)

// 比如:
// SEC(&amp;quot;tp_btf/sched_switch&amp;quot;)
// SEC(&amp;quot;tp_btf/sys_enter&amp;quot;)
// SEC(&amp;quot;tp_btf/sys_exit&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&amp;lt;name&amp;gt;&lt;/tt&gt; 的值跟 &lt;a class="reference external" href="https://mozillazg.com/2022/05/ebpf-libbpf-raw-tracepoint-common-questions.html"&gt;raw tracepoint&lt;/a&gt; SEC 中使用的 &lt;tt class="docutils literal"&gt;&amp;lt;name&amp;gt;&lt;/tt&gt; 是一样的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="btf-raw-tracepoint-1"&gt;
&lt;h2 id="hidbtf-raw-tracepoint-1"&gt;如何确定 btf raw tracepoint 事件处理函数的参数类型，获取对应的内核调用参数&lt;a class="headerlink" href="#hidbtf-raw-tracepoint-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;所有事件都是在 vmlinux.h 中存在一个名为 &lt;tt class="docutils literal"&gt;btf_trace_&amp;lt;name&amp;gt;&lt;/tt&gt; 的定义。&lt;/p&gt;
&lt;p&gt;比如 &lt;tt class="docutils literal"&gt;sys_enter&lt;/tt&gt; 这个事件对应的定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;btf_trace_sys_enter&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;pt_regs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应的 ebpf 函数可以定义成下面这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tp_btf/sys_enter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;btf_raw_tracepoint__sys_enter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;tt class="docutils literal"&gt;ctx[0]&lt;/tt&gt; 对应上面 &lt;tt class="docutils literal"&gt;btf_trace_sys_enter&lt;/tt&gt; 中 &lt;tt class="docutils literal"&gt;void *&lt;/tt&gt; 后面的第一个参数 &lt;tt class="docutils literal"&gt;struct pt_regs *&lt;/tt&gt;,
&lt;tt class="docutils literal"&gt;ctx[1]&lt;/tt&gt; 是第二个参数 &lt;tt class="docutils literal"&gt;long int&lt;/tt&gt; 。这两个参数的含义跟前面 &lt;a class="reference external" href="https://mozillazg.com/2022/05/ebpf-libbpf-raw-tracepoint-common-questions.html"&gt;raw tracepoint&lt;/a&gt; 中所说的 &lt;tt class="docutils literal"&gt;TP_PROTO(struct pt_regs *regs, long id)&lt;/tt&gt; 中的含义是一样的。&lt;/p&gt;
&lt;p&gt;对应的，使用 btf raw tracepoint 获取 &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; 系统调用事件的示例程序如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tp_btf/sys_enter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;btf_raw_tracepoint__sys_enter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;syscall_id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syscall_id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;268&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// fchmodat&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;pt_regs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;regs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;pt_regs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 后面的逻辑跟前面 raw tracepoint 示例程序中是一样的&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BTW, 在 btf raw tracepoint 程序中可以通过 &lt;tt class="docutils literal"&gt;bpf_get_current_task_btf()&lt;/tt&gt; 获取 btf 版本的 task 信息。&lt;/p&gt;
&lt;p&gt;完整的示例程序如下：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/16-btf-raw-tracepoint-args"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/16-btf-raw-tracepoint-args&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/17-btf-raw-tracepoint-args-sched_switch"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/17-btf-raw-tracepoint-args-sched_switch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2 id="hidsection-2"&gt;参考资料&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lore.kernel.org/netdev/20201203204634.1325171-1-andrii&amp;#64;kernel.org/t/"&gt;[PATCH v6 bpf-next 00/14] Support BTF-powered BPF tracing programs for kernel modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://nakryiko.com/posts/bpf-core-reference-guide/#btf-enabled-bpf-program-types-with-direct-memory-reads"&gt;BPF CO-RE reference guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/libbpf/libbpf/blob/12e932ac0e18546dd7247e66ea1b4aa236d2ef38/src/libbpf.c#L9002-L9081"&gt;libbpf/libbpf.c at 12e932ac0e18546dd7247e66ea1b4aa236d2ef38 · libbpf/libbpf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- * https://github.com/aya-rs/aya/pull/85 --&gt;
&lt;/div&gt;
</summary><category term="btf"></category><category term="raw-tracepoint"></category><category term="libbpf"></category><category term="libbpfgo"></category></entry><entry><title>ebpf/libbpf 程序使用 raw tracepoint 的常见问题</title><link href="https://mozillazg.com/2022/05/ebpf-libbpf-raw-tracepoint-common-questions.html" rel="alternate"></link><published>2022-05-29T00:00:00+00:00</published><updated>2022-05-29T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2022-05-29:2022/05/ebpf-libbpf-raw-tracepoint-common-questions.html</id><summary type="html">&lt;div class="section" id="section-1"&gt;
&lt;h2 id="hidsection-1"&gt;前言&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;记录一些编写 ebpf/libbpf 程序（比如编写类型为 &lt;tt class="docutils literal"&gt;BPF_PROG_TYPE_RAW_TRACEPOINT&lt;/tt&gt; 的 ebpf 程序）时
涉及到的 raw tracepoint 相关的常见问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="raw-tracepoint"&gt;
&lt;h2 id="hidraw-tracepoint"&gt;raw tracepoint 可以监控哪些事件&lt;a class="headerlink" href="#hidraw-tracepoint" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;可以通过查看 &lt;tt class="docutils literal"&gt;/sys/kernel/debug/tracing/available_events&lt;/tt&gt; 文件的内容找到 raw tracepoint 可监控的事件。
文件中每行内容的格式是:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;lt;category&amp;gt;:&amp;lt;name&amp;gt;
&lt;/pre&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sched:sched_switch
&lt;/pre&gt;
&lt;p&gt;不过，raw tracepoint 用到的是 &lt;tt class="docutils literal"&gt;&amp;lt;name&amp;gt;&lt;/tt&gt; 的值，而不是整个 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;&amp;lt;category&amp;gt;:&amp;lt;name&amp;gt;&lt;/span&gt;&lt;/tt&gt; ， 详见下方介绍。&lt;/p&gt;
&lt;!-- 内核源码中使用 ``TRACE_EVENT`` 这个宏所定义的事件都可以通过 raw tracepoint 进行监控。 --&gt;
&lt;!-- 这些事件主要集中在 `include/trace/events/ &lt;https://elixir.bootlin.com/linux/v5.13/source/include/trace/events&gt;`__   目录下。 --&gt;
&lt;!--  --&gt;
&lt;!-- 定义 raw tracepoint 可用事件的内容的格式是:: --&gt;
&lt;!--  --&gt;
&lt;!-- TRACE_EVENT(&lt;event_name&gt;, --&gt;
&lt;!-- TP_PROTO(...), --&gt;
&lt;!-- TP_ARGS(...), ...) --&gt;
&lt;!--  --&gt;
&lt;!-- .. 比如:: --&gt;
&lt;!--  --&gt;
&lt;!-- TRACE_EVENT_FN(sys_enter, --&gt;
&lt;!-- TP_PROTO(struct pt_regs *regs, long id), --&gt;
&lt;!-- TP_ARGS(regs, id), ...) --&gt;
&lt;!--  --&gt;
&lt;!-- 上面这个示例表示可以使用 ``sys_enter`` 作为 raw tracepoint 事件名称。 --&gt;
&lt;!-- 可以使用的 `include/trace/events/syscalls.h &lt;https://elixir.bootlin.com/linux/v5.13/source/include/trace/events/syscalls.h&gt;`__ 文件中定义的 ``sys_enter`` 和 ``sys_exit`` 事件来监控所有系统调用事件 --&gt;
&lt;/div&gt;
&lt;div class="section" id="sec"&gt;
&lt;h2 id="hidsec"&gt;SEC 内容的格式&lt;a class="headerlink" href="#hidsec" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;raw tracepoint 事件对应的 SEC 格式为:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
SEC(&amp;quot;raw_tracepoint/&amp;lt;name&amp;gt;&amp;quot;)

// 比如:
// SEC(&amp;quot;raw_tracepoint/sched_switch&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;或:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
SEC(&amp;quot;raw_tp/&amp;lt;name&amp;gt;&amp;quot;)

// 比如:
// SEC(&amp;quot;raw_tp/sched_switch&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&amp;lt;name&amp;gt;&lt;/tt&gt; 值为前面面 &lt;tt class="docutils literal"&gt;available_events&lt;/tt&gt; 文件中列出的那些 &lt;tt class="docutils literal"&gt;&amp;lt;name&amp;gt;&lt;/tt&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;SEC(&amp;quot;raw_tp/xx&amp;quot;)&lt;/span&gt;&lt;/tt&gt; 跟 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;SEC(&amp;quot;raw_tracepoint/xx&amp;quot;)&lt;/span&gt;&lt;/tt&gt; 其实是等效的，看个人喜好随便用哪种都行。&lt;/p&gt;
&lt;p&gt;有两个特殊情况，那就是:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;统一用 &lt;tt class="docutils literal"&gt;sys_enter&lt;/tt&gt; 表示 &lt;tt class="docutils literal"&gt;syscalls&lt;/tt&gt; 分类下的 &lt;tt class="docutils literal"&gt;sys_enter_xxx&lt;/tt&gt; 事件: &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;SEC(&amp;quot;raw_tracepoint/sys_enter&amp;quot;)&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;统一用 &lt;tt class="docutils literal"&gt;sys_exit&lt;/tt&gt; 表示 &lt;tt class="docutils literal"&gt;syscalls&lt;/tt&gt; 分类下的 &lt;tt class="docutils literal"&gt;sys_exit_xxx&lt;/tt&gt; 事件: &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;SEC(&amp;quot;raw_tracepoint/sys_exit&amp;quot;)&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即，可以用 &lt;tt class="docutils literal"&gt;sys_enter&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;sys_exit&lt;/tt&gt; 事件来监控所有系统调用事件。&lt;/p&gt;
&lt;!-- 可以使用的 `include/trace/events/syscalls.h &lt;https://elixir.bootlin.com/linux/v5.13/source/include/trace/events/syscalls.h&gt;`__ 文件中定义的 ``sys_enter`` 和 ``sys_exit`` 事件来监控所有系统调用事件 --&gt;
&lt;/div&gt;
&lt;div class="section" id="raw-tracepoint-1"&gt;
&lt;h2 id="hidraw-tracepoint-1"&gt;如何确定 raw tracepoint 事件处理函数的参数类型，获取对应的内核调用参数&lt;a class="headerlink" href="#hidraw-tracepoint-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;假设，我们想通过 raw tracepoint 监控 &lt;tt class="docutils literal"&gt;chmod&lt;/tt&gt; 这个命令涉及的 &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; 系统调用，
那么，如何确定ebpf 中事件处理函数的参数类型，以及如何获取到对应的 &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; 这个系统调用涉及的参数的内容，
比如拿到操作文件名称以及操作的权限 mode 的值。&lt;/p&gt;
&lt;p&gt;第一步，找到针对这个系统调用可以使用的 raw tracepoint 事件。前面说了，可以用 &lt;tt class="docutils literal"&gt;sys_enter&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;sys_exit&lt;/tt&gt; 事件来监控所有系统调用事件。&lt;/p&gt;
&lt;p&gt;第二步，确定函数的参数类型。raw tracepoint 统一使用 &lt;tt class="docutils literal"&gt;bpf_raw_tracepoint_args&lt;/tt&gt; 这个结构体&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;bpf_raw_tracepoint_args&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;__u64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; 中就存储了事件相关的我们可以获取的信息，至于里面包含了哪些信息就是第三步需要确定的信息。&lt;/p&gt;
&lt;!-- 第四步，确定事件本身可以获取到哪些信息。前面说了，可以使用的 `include/trace/events/syscalls.h &lt;https://elixir.bootlin.com/linux/v5.13/source/include/trace/events/syscalls.h&gt;`__ 文件中定义的 ``sys_enter`` 和 ``sys_exit`` 事件来监控所有系统调用事件。这里以 ``sys_enter`` 为例： --&gt;
&lt;p&gt;第三步，确定事件本身可以获取到哪些信息。这里以 &lt;tt class="docutils literal"&gt;sys_enter&lt;/tt&gt; 为例（内容取自 &lt;a class="reference external" href="https://elixir.bootlin.com/linux/v5.13/source/include/trace/events/syscalls.h"&gt;include/trace/events/syscalls.h&lt;/a&gt; ， 大部分事件主要集中在 &lt;a class="reference external" href="https://elixir.bootlin.com/linux/v5.13/source/include/trace/events"&gt;include/trace/events/&lt;/a&gt;   目录下） 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TRACE_EVENT_FN&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys_enter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;TP_PROTO&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;pt_regs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;regs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;TP_ARGS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;regs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;TP_STRUCT__entry&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="w"&gt;              &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="w"&gt;       &lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;TP_fast_assign&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;syscall_get_arguments&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;regs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;TP_printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;NR %ld (%lx, %lx, %lx, %lx, %lx, %lx)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
&lt;span class="w"&gt;          &lt;/span&gt;&lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;syscall_regfunc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;syscall_unregfunc&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;TP_PROTO(struct pt_regs *regs, long id)&lt;/tt&gt; 定义了可以通过 &lt;tt class="docutils literal"&gt;bpf_raw_tracepoint_args&lt;/tt&gt; 的 &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; 拿到的信息。
&lt;tt class="docutils literal"&gt;id&lt;/tt&gt; 是系统调用的 id， &lt;tt class="docutils literal"&gt;regs&lt;/tt&gt; 中包含了对应的系统调用的参数。 可以通过 id 过滤只处理 &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; 的系统调用事件（通过命令 &lt;tt class="docutils literal"&gt;ausyscall fchmodat&lt;/tt&gt; 找到对应的系统调用 id）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后在继续获取对应的系统调用参数。&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; 这个系统调用的函数定义如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;fchmodat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;dirfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;mode_t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为 &lt;tt class="docutils literal"&gt;regs&lt;/tt&gt; 是 &lt;tt class="docutils literal"&gt;pt_regs&lt;/tt&gt; 类型，所以我们可以通过 &lt;tt class="docutils literal"&gt;PT_REGS_PARM1_CORE(regs)&lt;/tt&gt; 获取第一个参数的值，
&lt;tt class="docutils literal"&gt;PT_REGS_PARM2_CORE(regs)&lt;/tt&gt; 获取第二个参数的值， &lt;tt class="docutils literal"&gt;PT_REGS_PARM3_CORE(regs)&lt;/tt&gt; 获取第三个参数的值，以此类推，
可以通过 &lt;tt class="docutils literal"&gt;PT_REGS_PARM4_CORE&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;PT_REGS_PARM5_CORE&lt;/tt&gt; 分别获取 regs 中第四个和第五个参数的值。&lt;/p&gt;
&lt;p&gt;信息都确定好了，就可以写程序了。比如上面通过 &lt;tt class="docutils literal"&gt;sys_enter&lt;/tt&gt; 事件处理 &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; 系统调用的示例 ebpf 程序如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;raw_tracepoint/sys_enter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;raw_tracepoint__sys_enter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;bpf_raw_tracepoint_args&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;syscall_id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syscall_id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;268&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 过滤系统调用 id，只处理 fchmodat 系统调用&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;pt_regs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;regs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;regs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;pt_regs&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 读取第二个参数的值&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pathname_ptr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;PT_REGS_PARM2_CORE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;regs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;bpf_core_read_user_str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pathname_ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// 读取第三个参数的值&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;PT_REGS_PARM3_CORE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;regs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;fchmodat %s %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;bpf_trace_printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的示例程序详见：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/12-raw-tracepoint-args"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/12-raw-tracepoint-args&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/13-raw-tracepoint-args-sched_switch"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/13-raw-tracepoint-args-sched_switch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="raw-tracepoint-tracepoint"&gt;
&lt;h2 id="hidraw-tracepoint-tracepoint"&gt;raw tracepoint 和 tracepoint 的区别&lt;a class="headerlink" href="#hidraw-tracepoint-tracepoint" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;主要区别是，raw tracepoint 不会像 tracepoint 一样在传递上下文给 ebpf 程序时
预先处理好事件的参数（构造好相应的参数字段），
raw tracepoint ebpf 程序中访问的都是事件的原始参数。&lt;/p&gt;
&lt;p&gt;因此，raw tracepoint 相比 tracepoint 性能通常会更好一点
(数据来自 &lt;a class="reference external" href="https://lwn.net/Articles/750569/"&gt;https://lwn.net/Articles/750569/&lt;/a&gt; )&lt;/p&gt;
&lt;pre class="literal-block"&gt;
samples/bpf/test_overhead performance on 1 cpu:

tracepoint    base  kprobe+bpf tracepoint+bpf raw_tracepoint+bpf
task_rename   1.1M   769K        947K            1.0M
urandom_read  789K   697K        750K            755K
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2 id="hidsection-2"&gt;参考资料&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/379903/"&gt;Using the TRACE_EVENT() macro (Part 1) [LWN.net]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/381064/"&gt;Using the TRACE_EVENT() macro (Part 2) [LWN.net]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/383362/"&gt;Using the TRACE_EVENT() macro (Part 3) [LWN.net]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/750569/"&gt;bpf, tracing: introduce bpf raw tracepoints [LWN.net]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://nakryiko.com/posts/bpf-core-reference-guide/"&gt;BPF CO-RE reference guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#7-raw-tracepoints"&gt;bcc/reference_guide.md at master · iovisor/bcc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/libbpf/libbpf/blob/12e932ac0e18546dd7247e66ea1b4aa236d2ef38/src/libbpf.c#L9002-L9081"&gt;libbpf/libbpf.c at 12e932ac0e18546dd7247e66ea1b4aa236d2ef38 · libbpf/libbpf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c4f6699dfcb8558d138fe838f741b2c10f416cf9"&gt;kernel/git/torvalds/linux.git - Linux kernel source tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/"&gt;BCC to libbpf conversion guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://sysdig.com/blog/the-art-of-writing-ebpf-programs-a-primer/"&gt;The art of writing eBPF programs: a primer. –Sysdig&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://unix.stackexchange.com/questions/421750/where-do-you-find-the-syscall-table-for-linux"&gt;Where do you find the syscall table for Linux? - Unix &amp;amp; Linux Stack Exchange&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://linux.die.net/man/8/ausyscall"&gt;ausyscall(8) - Linux man page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- * `linux/syscall_32.tbl at v5.13 · torvalds/linux &lt;https://github.com/torvalds/linux/blob/v5.13/arch/x86/entry/syscalls/syscall_32.tbl&gt;`__ --&gt;
&lt;!-- * `linux/syscall_64.tbl at v5.13 · torvalds/linux &lt;https://github.com/torvalds/linux/blob/v5.13/arch/x86/entry/syscalls/syscall_64.tbl&gt;`__ --&gt;
&lt;!-- * `linux/syscall.tbl at v5.13 · torvalds/linux &lt;https://github.com/torvalds/linux/blob/v5.13/arch/arm/tools/syscall.tbl&gt;`__ --&gt;
&lt;!-- * `linux/unistd.h at v5.13 · torvalds/linux &lt;https://github.com/torvalds/linux/blob/v5.13/include/uapi/asm-generic/unistd.h&gt;`__ --&gt;
&lt;/div&gt;
</summary><category term="raw-tracepoint"></category><category term="libbpf"></category><category term="libbpfgo"></category></entry><entry><title>libbpfgo 使用示例：在内核态和用户态使用 ebpf map</title><link href="https://mozillazg.com/2022/05/ebpf-libbpfgo-use-map-example.html" rel="alternate"></link><published>2022-05-22T00:00:00+00:00</published><updated>2022-05-22T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2022-05-22:2022/05/ebpf-libbpfgo-use-map-example.html</id><summary type="html">&lt;div class="section" id="section-1"&gt;
&lt;h2 id="hidsection-1"&gt;前言&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;记录一下如何在 libbpfgo 程序中使用 ebpf map（ebpf map 本身的资料可以参考参考资料）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ebpf-ebpf-map"&gt;
&lt;h2 id="hidebpf-ebpf-map"&gt;ebpf 程序中使用 ebpf map&lt;a class="headerlink" href="#hidebpf-ebpf-map" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="map"&gt;
&lt;h3 id="hidmap"&gt;定义 map&lt;a class="headerlink" href="#hidmap" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;先看一下定义一个 ebpf map 的方法，比如类型为 &lt;tt class="docutils literal"&gt;BPF_MAP_TYPE_HASH&lt;/tt&gt; 的 map:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_MAP_TYPE_HASH&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;event_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_entries&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;event_map&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.maps&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到主要需要指定 &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;key&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;value&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;max_entries&lt;/tt&gt; 这几个字段。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="map-1"&gt;
&lt;h3 id="hidmap-1"&gt;对 map 进行操作&lt;a class="headerlink" href="#hidmap-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在 ebpf 程序中可以通过下面几个常用的辅助函数对 map 对象进行操作：&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;void bpf_map_lookup_elem(map, void *key. &lt;span class="pre"&gt;...)&lt;/span&gt;&lt;/tt&gt; 通过 key 查找对应的 value&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bpf_map_lookup_elem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event_map&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;// key 不存在&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;void bpf_map_update_elem(map, void *key, &lt;span class="pre"&gt;...,&lt;/span&gt; __u64 flags)&lt;/tt&gt; 更新指定 key 的值， &lt;tt class="docutils literal"&gt;flags&lt;/tt&gt; 参数用于控制更新行为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* File: include/uapi/linux/bpf.h */&lt;/span&gt;
&lt;span class="cm"&gt;/* flags for BPF_MAP_UPDATE_ELEM command */&lt;/span&gt;
&lt;span class="cp"&gt;#define BPF_ANY       0 &lt;/span&gt;&lt;span class="cm"&gt;/* create new element or update existing */&lt;/span&gt;
&lt;span class="cp"&gt;#define BPF_NOEXIST   1 &lt;/span&gt;&lt;span class="cm"&gt;/* create new element only if it didn&amp;#39;t exist */&lt;/span&gt;
&lt;span class="cp"&gt;#define BPF_EXIST     2 &lt;/span&gt;&lt;span class="cm"&gt;/* only update existing element */&lt;/span&gt;

&lt;span class="n"&gt;bpf_map_update_elem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event_map&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_ANY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;void bpf_map_delete_elem(map, void *key)&lt;/tt&gt; 删除指定 key&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;bpf_map_delete_elem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event_map&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整示例程序详见: &lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/08-map-map-type-hash-kernel"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/08-map-map-type-hash-kernel&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pin-map"&gt;
&lt;h3 id="hidpin-map"&gt;pin map&lt;a class="headerlink" href="#hidpin-map" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;pin map 用于将 map 保存到本地文件系统中进行持久化，
libbpf 中是会自动保存到 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;/sys/fs/bpf/&amp;lt;map_name&amp;gt;&lt;/span&gt;&lt;/tt&gt; 路径下。&lt;/p&gt;
&lt;p&gt;定义 pin map 的方法只是在普通 map 的基础上加一个 &lt;tt class="docutils literal"&gt;pinning&lt;/tt&gt; 字段:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_MAP_TYPE_HASH&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;event_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_entries&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pinning&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LIBBPF_PIN_BY_NAME&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;  &lt;/span&gt;&lt;span class="c1"&gt;// &amp;lt;- pin&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;event_map&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.maps&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整示例程序详见： &lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/11-map-pin"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/11-map-pin&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="go-ebpf-map"&gt;
&lt;h2 id="hidgo-ebpf-map"&gt;go 程序中使用 ebpf map&lt;a class="headerlink" href="#hidgo-ebpf-map" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;可以使用 libbpfgo 在 go 程序中操作 ebpf 程序中定义的 ebpf map。&lt;/p&gt;
&lt;div class="section" id="map-2"&gt;
&lt;h3 id="hidmap-2"&gt;对 map 进行操作&lt;a class="headerlink" href="#hidmap-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;先通过 &lt;tt class="docutils literal"&gt;bpfmap, err := &lt;span class="pre"&gt;bpfModule.GetMap(&amp;quot;bpf_map&amp;quot;)&lt;/span&gt;&lt;/tt&gt; 拿到定义的 map 对象，然后就可以
做一些常见的操作了：&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Update(key, value unsafe.Pointer) error&lt;/tt&gt; 更新指定 key 的值，使用的 flags 是 &lt;tt class="docutils literal"&gt;BPF_ANY&lt;/tt&gt; 即
创建新元素或者更新已有的 key:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;233&lt;/span&gt;
&lt;span class="nx"&gt;keyPtr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Pointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;valuePtr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Pointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;bpfmap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;keyPtr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;valuePtr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;GetValue(key unsafe.Pointer) &lt;span class="pre"&gt;([]byte,&lt;/span&gt; error)&lt;/tt&gt; 获取指定 key 的值，当 key 不存在时会返回 error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nx"&gt;keyPtr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Pointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;bpfmap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;GetValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;keyPtr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;DeleteKey(key unsafe.Pointer) error&lt;/tt&gt; 删除指定 key，当 key 不存在时会返回 error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nx"&gt;keyPtr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Pointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;:=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;bpfmap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DeleteKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;keyPtr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整示例程序详见: &lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/09-map-map-type-hash-userspace"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/09-map-map-type-hash-userspace&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2 id="hidsection-2"&gt;参考资料&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arthurchiao.art/blog/bpf-advanced-notes-2-zh/"&gt;BPF 进阶笔记（二）：BPF Map 类型详解：使用场景、程序示例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/"&gt;BCC to libbpf conversion guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/aquasecurity/libbpfgo"&gt;aquasecurity/libbpfgo: eBPF library for Go, wrapping libbpf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://prototype-kernel.readthedocs.io/en/latest/bpf/ebpf_maps.html"&gt;eBPF maps — Prototype Kernel 0.0.1 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://man7.org/linux/man-pages/man2/bpf.2.html"&gt;bpf(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="libbpf"></category><category term="libbpfgo"></category></entry></feed>