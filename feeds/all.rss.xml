<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>mozillazg's blog</title><link>https://mozillazg.com/</link><description></description><atom:link href="https://mozillazg.com/feeds/all.rss.xml" rel="self"></atom:link><lastBuildDate>Mon, 20 Jun 2022 00:00:00 +0000</lastBuildDate><item><title>docker-credential-acr-helper: A docker credential helper for Alibaba Cloud Container Registry (ACR)</title><link>https://mozillazg.com/2022/06/use-docker-credential-acr-helper-help-auth-alibaba-cloud-container-registry-with-temporary-password-without-docker-login-en.html</link><description>&lt;div class="section" id="preface"&gt;
&lt;h2 id="hidpreface"&gt;Preface&lt;a class="headerlink" href="#hidpreface" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Normally, if we want to do &lt;tt class="docutils literal"&gt;docker pull&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;docker push&lt;/tt&gt; on private images on
Alibaba Cloud Container Registry (ACR),
we need to configure the corresponding access credentials via
&lt;tt class="docutils literal"&gt;docker login&lt;/tt&gt; command in advance.&lt;/p&gt;
&lt;p&gt;The method of configuring a username and password via the &lt;tt class="docutils literal"&gt;docker login&lt;/tt&gt;
command has several problems, as follows:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Requires users to record and maintain an additional set of docker-specific passwords,
and password management is a bit of a pain.&lt;/li&gt;
&lt;li&gt;ACR only supports the configuration of a fixed password with no expiration time.
The cost of password change and revocation is high, and users are easily afraid to operate.&lt;/li&gt;
&lt;li&gt;It is not possible to finely configure the permissions for fixed passwords,
and it is not possible to achieve the permission control requirements like only
allowing pull operations but not push operations.&lt;/li&gt;
&lt;li&gt;Although it is possible to obtain an unlimited number of temporary passwords through the Open API,
&lt;tt class="docutils literal"&gt;docker login&lt;/tt&gt; does not support the automatic refresh of temporary passwords.
If you use a temporary password for &lt;tt class="docutils literal"&gt;docker login&lt;/tt&gt;, you will need to get
the temporary password frequently and then update it with &lt;tt class="docutils literal"&gt;docker login&lt;/tt&gt;, which is also a hassle.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Fortunately, Docker provides a mechanism called &lt;a class="reference external" href="https://docs.docker.com/engine/reference/commandline/login/#credential-helpers"&gt;Credential helper&lt;/a&gt;, through which Credential helper can be plugged in in a way that The Credential helper extends the way docker can get access credentials, and is no longer limited to configuring access credentials via &lt;tt class="docutils literal"&gt;docker login&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;a class="reference external" href="https://github.com/mozillazg/docker-credential-acr-helper"&gt;docker-credential-acr-helper&lt;/a&gt;
developed for ACR is a project to help docker get access credentials to ACR image repositories project.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="introduction"&gt;
&lt;h2 id="hidintroduction"&gt;Introduction&lt;a class="headerlink" href="#hidintroduction" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As mentioned earlier, &lt;a class="reference external" href="https://github.com/mozillazg/docker-credential-acr-helper"&gt;docker-credential-acr-helper&lt;/a&gt; is a project developed specifically for ACR to help docker get access credentials to ACR image repositories.&lt;/p&gt;
&lt;p&gt;docker-credential-acr-helper solves the aforementioned problems.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Based on Aliyun's existing authentication system, you can directly use the user's familiar Aliyun access credentials, no need to record and maintain additional docker-specific username and password.&lt;/li&gt;
&lt;li&gt;Automatically obtain temporary passwords for docker operations, not relying on fixed passwords, and no need to manually refresh temporary passwords frequently.&lt;/li&gt;
&lt;li&gt;Users can configure AliCloud RAM access control policies to achieve the need for granular permission control for temporary passwords, as described in the &lt;a class="reference external" href="https://www.alibabacloud.com/help/doc-detail/72334.html"&gt;ACR documentation&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="usage"&gt;
&lt;h2 id="hidusage"&gt;Usage&lt;a class="headerlink" href="#hidusage" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;You can experience the features provided by this project by following these steps.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Go to the &lt;a class="reference external" href="https://github.com/mozillazg/docker-credential-acr-helper/releases"&gt;github releases&lt;/a&gt; page and download the latest version of the compiled binary archive&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Use the checksums.txt file on the page to verify the archive, and extract the archive to get the corresponding binaries &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;docker-credential-acr-helper&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;chmod +x &lt;span class="pre"&gt;docker-credential-acr-helper&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;cp &lt;span class="pre"&gt;docker-credential-acr-helper&lt;/span&gt; /usr/local/bin&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Configure alibaba cloud access credentials, for example, use the configuration file to specify the access credentials:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ cat ~/.alibabacloud/credentials
[default] # Default client
type = access_key # The authentication method is access_key
access_key_id = foo # Key
access_key_secret = bar # Secret
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;6. Exit the ACR registry domain you want to test with &lt;tt class="docutils literal"&gt;docker logout &amp;lt;acr_registry_domain&amp;gt;&lt;/tt&gt; and clean up the corresponding saved docker credentials.
Confirm that you do not have access to the corresponding ACR private image by &lt;tt class="docutils literal"&gt;docker pull &amp;lt;acr_image&amp;gt;&lt;/tt&gt;.
8. Modify the &lt;tt class="docutils literal"&gt;credHelpers&lt;/tt&gt; configuration item in the docker configuration file &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;~/.docker/config.json&lt;/span&gt;&lt;/tt&gt; to specify to use docker-credential-acr-helper to get access credentials when accessing an ACR registry domain (See the &lt;a class="reference external" href="https://docs.docker.com/engine/reference/commandline/login/#configure-credential-helpers"&gt;Official Docker Documentation&lt;/a&gt; or the project README for more details on this configuration) . Example configuration:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{
  &amp;quot;credHelpers&amp;quot; : {
    &amp;quot;registry.cn-beijing.aliyuncs.com&amp;quot; : &amp;quot;acr-helper&amp;quot;
  }
}
&lt;/pre&gt;
&lt;ol class="arabic simple" start="9"&gt;
&lt;li&gt;Verify that the configuration is complete with &lt;tt class="docutils literal"&gt;docker pull &amp;lt;acr_image&amp;gt;&lt;/tt&gt; and you can access the corresponding ACR private image again.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="integrated-into-third-party-projects-as-a-golang-package"&gt;
&lt;h2 id="hidintegrated-into-third-party-projects-as-a-golang-package"&gt;Integrated into third-party projects as a golang package&lt;a class="headerlink" href="#hidintegrated-into-third-party-projects-as-a-golang-package" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It is also possible to use this project as a golang package, integrating the project's capabilities into third-party projects.&lt;/p&gt;
&lt;p&gt;For example, when using &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;github.com/google/go-containerregistry/pkg/crane&lt;/span&gt;&lt;/tt&gt; to operate the
docker registry, you can integrate docker-credential-acr-helper in your project using the following method:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;github.com/google/go-containerregistry/pkg/authn&amp;quot;&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;github.com/google/go-containerregistry/pkg/crane&amp;quot;&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;github.com/mozillazg/docker-credential-acr-helper/pkg/credhelper&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;kc&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;authn&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewMultiKeychain&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="nx"&gt;authn&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DefaultKeychain&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;authn&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewKeychainFromHelper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;credhelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewACRHelper&lt;/span&gt;&lt;span class="p"&gt;()),&lt;/span&gt;  &lt;span class="c1"&gt;// &amp;lt;- here&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;ref&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Getenv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;REPO_URL&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;digest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;crane&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Digest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ref&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;crane&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;WithAuthFromKeychain&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;kc&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nb"&gt;panic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;got digest for %q:\n%s\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;ref&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;digest&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The full sample code is here： &lt;a class="reference external" href="https://github.com/mozillazg/docker-credential-acr-helper/blob/master/examples/go-containerregistry-auth/main.go"&gt;examples/go-containerregistry-auth&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="faq"&gt;
&lt;h2 id="hidfaq"&gt;FAQ&lt;a class="headerlink" href="#hidfaq" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="whether-to-support-acr-enterprise-edition"&gt;
&lt;h3 id="hidwhether-to-support-acr-enterprise-edition"&gt;Whether to support ACR Enterprise Edition?&lt;a class="headerlink" href="#hidwhether-to-support-acr-enterprise-edition" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Yes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-to-implement-different-alibaba-cloud-access-credentials-for-different-acr-domains"&gt;
&lt;h3 id="hidhow-to-implement-different-alibaba-cloud-access-credentials-for-different-acr-domains"&gt;How to implement different Alibaba Cloud access credentials for different ACR domains?&lt;a class="headerlink" href="#hidhow-to-implement-different-alibaba-cloud-access-credentials-for-different-acr-domains" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;this can be achieved by writing separate shell scripts for different access credentials.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ cat /usr/local/bin/docker-credential-acr-helper-user-1
#!/usr/bin/env bash

# export ALIBABA_CLOUD_ACCESS_KEY_ID=foo
# export ALIBABA_CLOUD_ACCESS_KEY_SECRET=bar
export ALIBABA_CLOUD_CREDENTIALS_FILE=/path/to/user-1-credentials

exec /usr/local/bin/docker-credential-acr-helper &amp;quot;$&amp;#64;&amp;quot;

$ chmod +x /usr/local/bin/docker-credential-acr-helper-user-1
&lt;/pre&gt;
&lt;p&gt;Then configure &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;~/.docker/config.json&lt;/span&gt;&lt;/tt&gt; to implement different ACR domains using shell scripts configured with different access credentials:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{
  &amp;quot;credHelpers&amp;quot; : {
    &amp;quot;registry.cn-beijing.aliyuncs.com&amp;quot; : &amp;quot;acr-helper&amp;quot;,
    &amp;quot;registry.cn-hangzhou.aliyuncs.com&amp;quot; : &amp;quot;acr-helper-user-1&amp;quot;,
    &amp;quot;registry.cn-shenzhen.aliyuncs.com&amp;quot; : &amp;quot;acr-helper-user-2&amp;quot;
  }
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="references"&gt;
&lt;h2 id="hidreferences"&gt;References&lt;a class="headerlink" href="#hidreferences" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.docker.com/engine/reference/commandline/login/"&gt;docker login | Docker Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/docker/docker-credential-helpers"&gt;docker/docker-credential-helpers: Programs to keep Docker login credentials safe by storing in platform keystores&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/docker-credential-acr-helper"&gt;mozillazg/docker-credential-acr-helper: A credential helper for the Docker daemon that makes it easier to use Alibaba Cloud Container Registry(ACR).&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://help.aliyun.com/document_detail/72334.html"&gt;GetAuthorizationToken - ACR Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate><guid>tag:mozillazg.com,2022-06-20:2022/06/use-docker-credential-acr-helper-help-auth-alibaba-cloud-container-registry-with-temporary-password-without-docker-login-en.html</guid><category>ACR</category><category>en-version</category></item><item><title>docker-credential-acr-helper: 一个辅助 docker 获取阿里云 ACR 镜像仓库访问凭证的项目</title><link>https://mozillazg.com/2022/06/use-docker-credential-acr-helper-help-auth-alibaba-cloud-container-registry-with-temporary-password-without-docker-login.html</link><description>&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;前言&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;通常情况下，如果我们想对阿里云容器镜像服务 ACR 上的私有镜像进行 &lt;tt class="docutils literal"&gt;docker pull&lt;/tt&gt;
或 &lt;tt class="docutils literal"&gt;docker push&lt;/tt&gt; 的话， 需要提前通过 &lt;tt class="docutils literal"&gt;docker login&lt;/tt&gt; 命令配置相应的访问凭证。&lt;/p&gt;
&lt;p&gt;通过 &lt;tt class="docutils literal"&gt;docker login&lt;/tt&gt; 命令配置用户名和密码的方法存在如下几个问题：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;需要用户多记录和维护一组 docker 专用的密码，密码的管理是一个比较麻烦的事情。&lt;/li&gt;
&lt;li&gt;ACR 只支持配置一个无过期时间的固定密码，密码的更换和吊销的成本很高，用户轻易不敢操作。&lt;/li&gt;
&lt;li&gt;无法精细化配置固定密码的权限，无法实现类似只允许进行 pull 操作不允许进行 push 操作的权限控制需求。&lt;/li&gt;
&lt;li&gt;虽然可以通过 Open API 获取不限量的临时密码，但是 &lt;tt class="docutils literal"&gt;docker login&lt;/tt&gt; 不支持自动刷新临时密码。
如果使用临时密码进行 &lt;tt class="docutils literal"&gt;docker login&lt;/tt&gt; 操作的话，
需要用户频繁进行获取临时密码然后再通过 &lt;tt class="docutils literal"&gt;docker login&lt;/tt&gt; 更新密码的操作，同样是一个很麻烦的事情。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;幸好，docker 提供提供了一个叫 &lt;a class="reference external" href="https://docs.docker.com/engine/reference/commandline/login/#credential-helpers"&gt;Credential helper&lt;/a&gt; 的机制，
通过 Credential helper 可以以插件化的方式
扩展 docker 获取访问凭证的方式，不再局限于只能通过 &lt;tt class="docutils literal"&gt;docker login&lt;/tt&gt; 的方式配置访问凭证。&lt;/p&gt;
&lt;p&gt;本文将介绍的 &lt;a class="reference external" href="https://github.com/mozillazg/docker-credential-acr-helper"&gt;docker-credential-acr-helper&lt;/a&gt; 就是一个专为 ACR 开发的辅助 docker 获取 ACR 镜像仓库访问凭证的项目。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;介绍&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;如前面所说， &lt;a class="reference external" href="https://github.com/mozillazg/docker-credential-acr-helper"&gt;docker-credential-acr-helper&lt;/a&gt; 是一个专为 ACR 开发的辅助 docker 获取 ACR 镜像仓库访问凭证的项目。&lt;/p&gt;
&lt;p&gt;docker-credential-acr-helper 解决了前面所说的那几个问题：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;基于阿里云已有的认证体系，可以直接使用用户熟悉的阿里云访问凭证，无需额外记录和维护 docker 专用的用户名和密码。&lt;/li&gt;
&lt;li&gt;自动获取用于进行 docker 操作的临时密码，不依赖固定密码, 也无需手动频繁刷新临时密码。&lt;/li&gt;
&lt;li&gt;用户可以通过配置阿里云 RAM 访问控制策略的方式，实现临时密码精细化权限控制的需求，详见 &lt;a class="reference external" href="https://help.aliyun.com/document_detail/72334.html#section-xzq-5zj-lr6"&gt;ACR 文档&lt;/a&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;使用示例&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;可以通过如下步骤体验这个项目提供的功能：&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;前往 &lt;a class="reference external" href="https://github.com/mozillazg/docker-credential-acr-helper/releases"&gt;github releases&lt;/a&gt; 页面下载最新版本的编译好的二进制文件压缩包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;使用页面上的那个 checksums.txt 文件验证压缩包，解压压缩包得到对应的二进制文件 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;docker-credential-acr-helper&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;chmod +x &lt;span class="pre"&gt;docker-credential-acr-helper&lt;/span&gt;&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;tt class="docutils literal"&gt;cp &lt;span class="pre"&gt;docker-credential-acr-helper&lt;/span&gt; /usr/local/bin&lt;/tt&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;配置阿里云访问凭证，比如使用配置文件指定访问凭证:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ cat ~/.alibabacloud/credentials
[default]                          # 默认客户端
type = access_key                  # 认证方式为 access_key
access_key_id = foo                # Key
access_key_secret = bar            # Secret
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;通过 &lt;tt class="docutils literal"&gt;docker logout &amp;lt;acr_registry_domain&amp;gt;&lt;/tt&gt; 退出要测试的 ACR registry 域名，清理对应已保存的 docker 凭证。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;通过 &lt;tt class="docutils literal"&gt;docker pull &amp;lt;acr_image&amp;gt;&lt;/tt&gt; 确认当前已无权限访问对应的 ACR 私有镜像。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;修改 docker 配置文件 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;~/.docker/config.json&lt;/span&gt;&lt;/tt&gt; 中 &lt;tt class="docutils literal"&gt;credHelpers&lt;/tt&gt; 配置项，
指定访问某个 ACR registry 域名时，使用 docker-credential-acr-helper 获取访问凭证
（关于这个配置的更多说明详见 &lt;a class="reference external" href="https://docs.docker.com/engine/reference/commandline/login/#configure-credential-helpers"&gt;Docker 官方文档&lt;/a&gt; 或者本项目 README）。
配置示例:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{
  &amp;quot;credHelpers&amp;quot; : {
    &amp;quot;registry.cn-beijing.aliyuncs.com&amp;quot; : &amp;quot;acr-helper&amp;quot;
  }
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;通过 &lt;tt class="docutils literal"&gt;docker pull &amp;lt;acr_image&amp;gt;&lt;/tt&gt; 验证配置完成后又可以访问对应的 ACR 私有镜像了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class="section" id="golang-package"&gt;
&lt;h2 id="hidgolang-package"&gt;作为 golang package 被集成到第三方项目中&lt;a class="headerlink" href="#hidgolang-package" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;同时，也可以把这个项目当成一个 golang package 来使用，将这个项目的能力集成到第三方项目中。&lt;/p&gt;
&lt;p&gt;比如，在使用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;github.com/google/go-containerregistry/pkg/crane&lt;/span&gt;&lt;/tt&gt; 操作
docker registry 时，可以使用下面的方法在项目中集成 docker-credential-acr-helper
提供的辅助认证能力:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;github.com/google/go-containerregistry/pkg/authn&amp;quot;&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;github.com/google/go-containerregistry/pkg/crane&amp;quot;&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;github.com/mozillazg/docker-credential-acr-helper/pkg/credhelper&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;kc&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;authn&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewMultiKeychain&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="nx"&gt;authn&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DefaultKeychain&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="nx"&gt;authn&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewKeychainFromHelper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;credhelper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;NewACRHelper&lt;/span&gt;&lt;span class="p"&gt;()),&lt;/span&gt;  &lt;span class="c1"&gt;// &amp;lt;- here&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;ref&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Getenv&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;REPO_URL&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;digest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;crane&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Digest&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ref&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;crane&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;WithAuthFromKeychain&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;kc&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nb"&gt;panic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;got digest for %q:\n%s\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;ref&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;digest&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整示例代码详见： &lt;a class="reference external" href="https://github.com/mozillazg/docker-credential-acr-helper/blob/master/examples/go-containerregistry-auth/main.go"&gt;examples/go-containerregistry-auth&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="faq"&gt;
&lt;h2 id="hidfaq"&gt;FAQ&lt;a class="headerlink" href="#hidfaq" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="acr"&gt;
&lt;h3 id="hidacr"&gt;是否支持 ACR 企业版？&lt;a class="headerlink" href="#hidacr" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;支持。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h3 id="hidid4"&gt;如何实现不同 ACR 域名使用不同的阿里云访问凭证？&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过为不同的访问凭证编写独立的 shell 脚本的方式实现。&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ cat /usr/local/bin/docker-credential-acr-helper-user-1
#!/usr/bin/env bash

# export ALIBABA_CLOUD_ACCESS_KEY_ID=foo
# export ALIBABA_CLOUD_ACCESS_KEY_SECRET=bar
export ALIBABA_CLOUD_CREDENTIALS_FILE=/path/to/user-1-credentials

exec /usr/local/bin/docker-credential-acr-helper &amp;quot;$&amp;#64;&amp;quot;

$ chmod +x /usr/local/bin/docker-credential-acr-helper-user-1
&lt;/pre&gt;
&lt;p&gt;然后配置 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;~/.docker/config.json&lt;/span&gt;&lt;/tt&gt; 实现不同的 ACR 域名使用配置了不同访问凭证的 shell 脚本即可:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{
  &amp;quot;credHelpers&amp;quot; : {
    &amp;quot;registry.cn-beijing.aliyuncs.com&amp;quot; : &amp;quot;acr-helper&amp;quot;,
    &amp;quot;registry.cn-hangzhou.aliyuncs.com&amp;quot; : &amp;quot;acr-helper-user-1&amp;quot;,
    &amp;quot;registry.cn-shenzhen.aliyuncs.com&amp;quot; : &amp;quot;acr-helper-user-2&amp;quot;
  }
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2 id="hidid5"&gt;参考资料&lt;a class="headerlink" href="#hidid5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.docker.com/engine/reference/commandline/login/"&gt;docker login | Docker Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/docker/docker-credential-helpers"&gt;docker/docker-credential-helpers: Programs to keep Docker login credentials safe by storing in platform keystores&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/docker-credential-acr-helper"&gt;mozillazg/docker-credential-acr-helper: A credential helper for the Docker daemon that makes it easier to use Alibaba Cloud Container Registry(ACR).&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://help.aliyun.com/document_detail/72334.html"&gt;GetAuthorizationToken - ACR Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sun, 19 Jun 2022 00:00:00 +0000</pubDate><guid>tag:mozillazg.com,2022-06-19:2022/06/use-docker-credential-acr-helper-help-auth-alibaba-cloud-container-registry-with-temporary-password-without-docker-login.html</guid><category>ACR</category></item><item><title>ebpf/libbpf 程序使用 btf raw tracepoint 的常见问题</title><link>https://mozillazg.com/2022/06/ebpf-libbpf-btf-powered-enabled-raw-tracepoint-common-questions.html</link><description>&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;前言&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文记录一些编写 ebpf/libbpf 程序时涉及到的 btf raw tracepoint 相关的常见问题。&lt;/p&gt;
&lt;!-- （编写 ``BPF_PROG_TYPE_TRACING`` 程序） --&gt;
&lt;/div&gt;
&lt;div class="section" id="btf-raw-tracepoint-raw-tracepoint"&gt;
&lt;h2 id="hidbtf-raw-tracepoint-raw-tracepoint"&gt;btf raw tracepoint 跟常规 raw tracepoint 的区别&lt;a class="headerlink" href="#hidbtf-raw-tracepoint-raw-tracepoint" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;所谓的 btf raw tracepoint 指的是 &lt;a class="reference external" href="https://lore.kernel.org/netdev/20201203204634.1325171-1-andrii&amp;#64;kernel.org/t/"&gt;BTF-powered raw tracepoint (tp_btf) 或者说是 BTF-enabled raw tracepoint&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;btf raw tracepoint 跟常规 raw tracepoint 有一个 &lt;a class="reference external" href="https://nakryiko.com/posts/bpf-core-reference-guide/#btf-enabled-bpf-program-types-with-direct-memory-reads"&gt;最主要的区别&lt;/a&gt; 是：
btf 版本可以直接在 ebpf 程序中访问内核内存，
不需要像常规 raw tracepoint 一样需要借助类似 &lt;tt class="docutils literal"&gt;bpf_core_read&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel&lt;/tt&gt; 这样 的辅助函数才能访问内核内存:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;task_struct&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;task_struct&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;bpf_get_current_task&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="n"&gt;ppid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BPF_CORE_READ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;real_parent&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tgid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// btf enabled&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;task_struct&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;task_struct&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;bpf_get_current_task_btf&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="n"&gt;ppid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;real_parent&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;tgid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="btf-raw-tracepoint"&gt;
&lt;h2 id="hidbtf-raw-tracepoint"&gt;btf raw tracepoint 可以监控哪些事件&lt;a class="headerlink" href="#hidbtf-raw-tracepoint" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;btf raw tracepoint 跟 &lt;a class="reference external" href="https://mozillazg.com/2022/05/ebpf-libbpf-raw-tracepoint-common-questions.html"&gt;raw tracepoint&lt;/a&gt; 所能监控的事件是一样的，这里不再赘述。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sec"&gt;
&lt;h2 id="hidsec"&gt;SEC 内容的格式&lt;a class="headerlink" href="#hidsec" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;btf raw tracepoint 事件对应的 SEC 格式为:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
SEC(&amp;quot;tp_btf/&amp;lt;name&amp;gt;&amp;quot;)

// 比如:
// SEC(&amp;quot;tp_btf/sched_switch&amp;quot;)
// SEC(&amp;quot;tp_btf/sys_enter&amp;quot;)
// SEC(&amp;quot;tp_btf/sys_exit&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&amp;lt;name&amp;gt;&lt;/tt&gt; 的值跟 &lt;a class="reference external" href="https://mozillazg.com/2022/05/ebpf-libbpf-raw-tracepoint-common-questions.html"&gt;raw tracepoint&lt;/a&gt; SEC 中使用的 &lt;tt class="docutils literal"&gt;&amp;lt;name&amp;gt;&lt;/tt&gt; 是一样的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;如何确定 btf raw tracepoint 事件处理函数的参数类型，获取对应的内核调用参数&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;所有事件都是在 vmlinux.h 中存在一个名为 &lt;tt class="docutils literal"&gt;btf_trace_&amp;lt;name&amp;gt;&lt;/tt&gt; 的定义。&lt;/p&gt;
&lt;p&gt;比如 &lt;tt class="docutils literal"&gt;sys_enter&lt;/tt&gt; 这个事件对应的定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;btf_trace_sys_enter&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;pt_regs&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应的 ebpf 函数可以定义成下面这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tp_btf/sys_enter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;btf_raw_tracepoint__sys_enter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u64&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;tt class="docutils literal"&gt;ctx[0]&lt;/tt&gt; 对应上面 &lt;tt class="docutils literal"&gt;btf_trace_sys_enter&lt;/tt&gt; 中 &lt;tt class="docutils literal"&gt;void *&lt;/tt&gt; 后面的第一个参数 &lt;tt class="docutils literal"&gt;struct pt_regs *&lt;/tt&gt;,
&lt;tt class="docutils literal"&gt;ctx[1]&lt;/tt&gt; 是第二个参数 &lt;tt class="docutils literal"&gt;long int&lt;/tt&gt; 。这两个参数的含义跟前面 &lt;a class="reference external" href="https://mozillazg.com/2022/05/ebpf-libbpf-raw-tracepoint-common-questions.html"&gt;raw tracepoint&lt;/a&gt; 中所说的 &lt;tt class="docutils literal"&gt;TP_PROTO(struct pt_regs *regs, long id)&lt;/tt&gt; 中的含义是一样的。&lt;/p&gt;
&lt;p&gt;对应的，使用 btf raw tracepoint 获取 &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; 系统调用事件的示例程序如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tp_btf/sys_enter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;btf_raw_tracepoint__sys_enter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u64&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;syscall_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syscall_id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;268&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c1"&gt;// fchmodat&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;pt_regs&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;regs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;pt_regs&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="c1"&gt;// 后面的逻辑跟前面 raw tracepoint 示例程序中是一样的&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BTW, 在 btf raw tracepoint 程序中可以通过 &lt;tt class="docutils literal"&gt;bpf_get_current_task_btf()&lt;/tt&gt; 获取 btf 版本的 task 信息。&lt;/p&gt;
&lt;p&gt;完整的示例程序如下：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/16-btf-raw-tracepoint-args"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/16-btf-raw-tracepoint-args&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/17-btf-raw-tracepoint-args-sched_switch"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/17-btf-raw-tracepoint-args-sched_switch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;参考资料&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lore.kernel.org/netdev/20201203204634.1325171-1-andrii&amp;#64;kernel.org/t/"&gt;[PATCH v6 bpf-next 00/14] Support BTF-powered BPF tracing programs for kernel modules&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://nakryiko.com/posts/bpf-core-reference-guide/#btf-enabled-bpf-program-types-with-direct-memory-reads"&gt;BPF CO-RE reference guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/libbpf/libbpf/blob/12e932ac0e18546dd7247e66ea1b4aa236d2ef38/src/libbpf.c#L9002-L9081"&gt;libbpf/libbpf.c at 12e932ac0e18546dd7247e66ea1b4aa236d2ef38 · libbpf/libbpf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- * https://github.com/aya-rs/aya/pull/85 --&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Tue, 14 Jun 2022 00:00:00 +0000</pubDate><guid>tag:mozillazg.com,2022-06-14:2022/06/ebpf-libbpf-btf-powered-enabled-raw-tracepoint-common-questions.html</guid><category>btf</category><category>raw-tracepoint</category><category>libbpf</category><category>libbpfgo</category></item><item><title>ebpf/libbpf 程序使用 raw tracepoint 的常见问题</title><link>https://mozillazg.com/2022/05/ebpf-libbpf-raw-tracepoint-common-questions.html</link><description>&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;前言&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;记录一些编写 ebpf/libbpf 程序（比如编写类型为 &lt;tt class="docutils literal"&gt;BPF_PROG_TYPE_RAW_TRACEPOINT&lt;/tt&gt; 的 ebpf 程序）时
涉及到的 raw tracepoint 相关的常见问题。&lt;/p&gt;
&lt;!-- （编写 ``BPF_PROG_TYPE_RAW_TRACEPOINT`` 程序） --&gt;
&lt;!-- raw tracepoint 和 tracepoint 的区别 --&gt;
&lt;!-- ===================================== --&gt;
&lt;/div&gt;
&lt;div class="section" id="raw-tracepoint"&gt;
&lt;h2 id="hidraw-tracepoint"&gt;raw tracepoint 可以监控哪些事件&lt;a class="headerlink" href="#hidraw-tracepoint" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;可以通过查看 &lt;tt class="docutils literal"&gt;/sys/kernel/debug/tracing/available_events&lt;/tt&gt; 文件的内容找到 tracepoint 可监控的事件。
文件中每行内容的格式是:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;lt;category&amp;gt;:&amp;lt;name&amp;gt;
&lt;/pre&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sched:sched_switch
&lt;/pre&gt;
&lt;p&gt;不过，raw tracepoint 用到的是 &lt;tt class="docutils literal"&gt;&amp;lt;name&amp;gt;&lt;/tt&gt; 的值，而不是整个 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;&amp;lt;category&amp;gt;:&amp;lt;name&amp;gt;&lt;/span&gt;&lt;/tt&gt; ， 详见下方介绍。&lt;/p&gt;
&lt;!-- 内核源码中使用 ``TRACE_EVENT`` 这个宏所定义的事件都可以通过 raw tracepoint 进行监控。 --&gt;
&lt;!-- 这些事件主要集中在 `include/trace/events/ &lt;https://elixir.bootlin.com/linux/v5.13/source/include/trace/events&gt;`__   目录下。 --&gt;
&lt;!--  --&gt;
&lt;!-- 定义 raw tracepoint 可用事件的内容的格式是:: --&gt;
&lt;!--  --&gt;
&lt;!-- TRACE_EVENT(&lt;event_name&gt;, --&gt;
&lt;!-- TP_PROTO(...), --&gt;
&lt;!-- TP_ARGS(...), ...) --&gt;
&lt;!--  --&gt;
&lt;!-- .. 比如:: --&gt;
&lt;!--  --&gt;
&lt;!-- TRACE_EVENT_FN(sys_enter, --&gt;
&lt;!-- TP_PROTO(struct pt_regs *regs, long id), --&gt;
&lt;!-- TP_ARGS(regs, id), ...) --&gt;
&lt;!--  --&gt;
&lt;!-- 上面这个示例表示可以使用 ``sys_enter`` 作为 raw tracepoint 事件名称。 --&gt;
&lt;!-- 可以使用的 `include/trace/events/syscalls.h &lt;https://elixir.bootlin.com/linux/v5.13/source/include/trace/events/syscalls.h&gt;`__ 文件中定义的 ``sys_enter`` 和 ``sys_exit`` 事件来监控所有系统调用事件 --&gt;
&lt;/div&gt;
&lt;div class="section" id="sec"&gt;
&lt;h2 id="hidsec"&gt;SEC 内容的格式&lt;a class="headerlink" href="#hidsec" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;raw tracepoint 事件对应的 SEC 格式为:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
SEC(&amp;quot;raw_tracepoint/&amp;lt;name&amp;gt;&amp;quot;)

// 比如:
// SEC(&amp;quot;raw_tracepoint/sched_switch&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;或:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
SEC(&amp;quot;raw_tp/&amp;lt;name&amp;gt;&amp;quot;)

// 比如:
// SEC(&amp;quot;raw_tp/sched_switch&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&amp;lt;name&amp;gt;&lt;/tt&gt; 值为前面面 &lt;tt class="docutils literal"&gt;available_events&lt;/tt&gt; 文件中列出的那些 &lt;tt class="docutils literal"&gt;&amp;lt;name&amp;gt;&lt;/tt&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;SEC(&amp;quot;raw_tp/xx&amp;quot;)&lt;/span&gt;&lt;/tt&gt; 跟 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;SEC(&amp;quot;raw_tracepoint/xx&amp;quot;)&lt;/span&gt;&lt;/tt&gt; 其实是等效的，看个人喜好随便用哪种都行。&lt;/p&gt;
&lt;p&gt;有两个特殊情况，那就是:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;统一用 &lt;tt class="docutils literal"&gt;sys_enter&lt;/tt&gt; 表示 &lt;tt class="docutils literal"&gt;syscalls&lt;/tt&gt; 分类下的 &lt;tt class="docutils literal"&gt;sys_enter_xxx&lt;/tt&gt; 事件: &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;SEC(&amp;quot;raw_tracepoint/sys_enter&amp;quot;)&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;统一用 &lt;tt class="docutils literal"&gt;sys_exit&lt;/tt&gt; 表示 &lt;tt class="docutils literal"&gt;syscalls&lt;/tt&gt; 分类下的 &lt;tt class="docutils literal"&gt;sys_exit_xxx&lt;/tt&gt; 事件: &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;SEC(&amp;quot;raw_tracepoint/sys_exit&amp;quot;)&lt;/span&gt;&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即，可以用 &lt;tt class="docutils literal"&gt;sys_enter&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;sys_exit&lt;/tt&gt; 事件来监控所有系统调用事件。&lt;/p&gt;
&lt;!-- 可以使用的 `include/trace/events/syscalls.h &lt;https://elixir.bootlin.com/linux/v5.13/source/include/trace/events/syscalls.h&gt;`__ 文件中定义的 ``sys_enter`` 和 ``sys_exit`` 事件来监控所有系统调用事件 --&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;如何确定 raw tracepoint 事件处理函数的参数类型，获取对应的内核调用参数&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;假设，我们想通过 raw tracepoint 监控 &lt;tt class="docutils literal"&gt;chmod&lt;/tt&gt; 这个命令涉及的 &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; 系统调用，
那么，如何确定ebpf 中事件处理函数的参数类型，以及如何获取到对应的 &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; 这个系统调用涉及的参数的内容，
比如拿到操作文件名称以及操作的权限 mode 的值。&lt;/p&gt;
&lt;p&gt;第一步，先确定 &lt;tt class="docutils literal"&gt;chmod&lt;/tt&gt; 所使用的系统调用，这个比较简单，有很多种方法可以做到，比如通过 &lt;tt class="docutils literal"&gt;strace&lt;/tt&gt; 命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ strace chmod 600 a.txt
...
fchmodat(AT_FDCWD, &amp;quot;a.txt&amp;quot;, 0600)       = 0
...
&lt;/pre&gt;
&lt;!-- 第二步，找到针对这个系统调用可以使用的 raw tracepoint 事件。raw tracepoint 可以使用 `include/trace/events/syscalls.h &lt;https://elixir.bootlin.com/linux/v5.13/source/include/trace/events/syscalls.h&gt;`__ 文件中定义的 ``sys_enter`` 和 ``sys_exit`` 事件来监控所有系统调用事件。 --&gt;
&lt;p&gt;第二步，找到针对这个系统调用可以使用的 raw tracepoint 事件。前面说了，可以用 &lt;tt class="docutils literal"&gt;sys_enter&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;sys_exit&lt;/tt&gt; 事件来监控所有系统调用事件。&lt;/p&gt;
&lt;p&gt;第三步，确定函数的参数类型。raw tracepoint 统一使用 &lt;tt class="docutils literal"&gt;bpf_raw_tracepoint_args&lt;/tt&gt; 这个结构体&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;bpf_raw_tracepoint_args&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;__u64&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; 中就存储了事件相关的我们可以获取的信息，至于里面包含了哪些信息就是第四步需要确定的信息。&lt;/p&gt;
&lt;!-- 第四步，确定事件本身可以获取到哪些信息。前面说了，可以使用的 `include/trace/events/syscalls.h &lt;https://elixir.bootlin.com/linux/v5.13/source/include/trace/events/syscalls.h&gt;`__ 文件中定义的 ``sys_enter`` 和 ``sys_exit`` 事件来监控所有系统调用事件。这里以 ``sys_enter`` 为例： --&gt;
&lt;p&gt;第四步，确定事件本身可以获取到哪些信息。这里以 &lt;tt class="docutils literal"&gt;sys_enter&lt;/tt&gt; 为例（内容取自 &lt;a class="reference external" href="https://elixir.bootlin.com/linux/v5.13/source/include/trace/events/syscalls.h"&gt;include/trace/events/syscalls.h&lt;/a&gt; ， 大部分事件主要集中在 &lt;a class="reference external" href="https://elixir.bootlin.com/linux/v5.13/source/include/trace/events"&gt;include/trace/events/&lt;/a&gt;   目录下） 。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TRACE_EVENT_FN&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys_enter&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="n"&gt;TP_PROTO&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;pt_regs&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;regs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="n"&gt;TP_ARGS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;regs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="n"&gt;TP_STRUCT__entry&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;__field&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;    &lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;           &lt;span class="n"&gt;id&lt;/span&gt;              &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;__array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;   &lt;span class="mi"&gt;6&lt;/span&gt;       &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="n"&gt;TP_fast_assign&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;syscall_get_arguments&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;regs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="n"&gt;TP_printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;NR %ld (%lx, %lx, %lx, %lx, %lx, %lx)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
          &lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
          &lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
          &lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;__entry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt;
    &lt;span class="n"&gt;syscall_regfunc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;syscall_unregfunc&lt;/span&gt;
&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;TP_PROTO(struct pt_regs *regs, long id)&lt;/tt&gt; 定义了可以通过 &lt;tt class="docutils literal"&gt;bpf_raw_tracepoint_args&lt;/tt&gt; 的 &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; 拿到的信息。
&lt;tt class="docutils literal"&gt;id&lt;/tt&gt; 是系统调用的 id， &lt;tt class="docutils literal"&gt;regs&lt;/tt&gt; 中包含了对应的系统调用的参数。 可以通过 id 过滤只处理 &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; 的系统调用事件（通过命令 &lt;tt class="docutils literal"&gt;ausyscall fchmodat&lt;/tt&gt; 找到对应的系统调用 id），&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后在继续获取对应的系统调用参数。&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; 这个系统调用的函数定义如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;fchmodat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;dirfd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;mode_t&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为 &lt;tt class="docutils literal"&gt;regs&lt;/tt&gt; 是 &lt;tt class="docutils literal"&gt;pt_regs&lt;/tt&gt; 类型，所以我们可以通过 &lt;tt class="docutils literal"&gt;PT_REGS_PARM1_CORE(regs)&lt;/tt&gt; 获取第一个参数的值，
&lt;tt class="docutils literal"&gt;PT_REGS_PARM2_CORE(regs)&lt;/tt&gt; 获取第二个参数的值， &lt;tt class="docutils literal"&gt;PT_REGS_PARM3_CORE(regs)&lt;/tt&gt; 获取第三个参数的值，以此类推，
可以通过 &lt;tt class="docutils literal"&gt;PT_REGS_PARM4_CORE&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;PT_REGS_PARM5_CORE&lt;/tt&gt; 分别获取 regs 中第四个和第五个参数的值。&lt;/p&gt;
&lt;p&gt;信息都确定好了，就可以写程序了。比如上面通过 &lt;tt class="docutils literal"&gt;sys_enter&lt;/tt&gt; 事件处理 &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; 系统调用的示例 ebpf 程序如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;raw_tracepoint/sys_enter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;raw_tracepoint__sys_enter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;bpf_raw_tracepoint_args&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;syscall_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;syscall_id&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;268&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="c1"&gt;// 过滤系统调用 id，只处理 fchmodat 系统调用&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;pt_regs&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;regs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;regs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;pt_regs&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;u32&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// 读取第二个参数的值&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pathname_ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;PT_REGS_PARM2_CORE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;regs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;bpf_core_read_user_str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;pathname_ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// 读取第三个参数的值&lt;/span&gt;
    &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;PT_REGS_PARM3_CORE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;regs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;fchmodat %s %d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;bpf_trace_printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的示例程序详见：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/12-raw-tracepoint-args"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/12-raw-tracepoint-args&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/13-raw-tracepoint-args-sched_switch"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/13-raw-tracepoint-args-sched_switch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;参考资料&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/379903/"&gt;Using the TRACE_EVENT() macro (Part 1) [LWN.net]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/381064/"&gt;Using the TRACE_EVENT() macro (Part 2) [LWN.net]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/383362/"&gt;Using the TRACE_EVENT() macro (Part 3) [LWN.net]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/750569/"&gt;bpf, tracing: introduce bpf raw tracepoints [LWN.net]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://nakryiko.com/posts/bpf-core-reference-guide/"&gt;BPF CO-RE reference guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md#7-raw-tracepoints"&gt;bcc/reference_guide.md at master · iovisor/bcc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/libbpf/libbpf/blob/12e932ac0e18546dd7247e66ea1b4aa236d2ef38/src/libbpf.c#L9002-L9081"&gt;libbpf/libbpf.c at 12e932ac0e18546dd7247e66ea1b4aa236d2ef38 · libbpf/libbpf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/"&gt;BCC to libbpf conversion guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://sysdig.com/blog/the-art-of-writing-ebpf-programs-a-primer/"&gt;The art of writing eBPF programs: a primer. –Sysdig&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://unix.stackexchange.com/questions/421750/where-do-you-find-the-syscall-table-for-linux"&gt;Where do you find the syscall table for Linux? - Unix &amp;amp; Linux Stack Exchange&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://linux.die.net/man/8/ausyscall"&gt;ausyscall(8) - Linux man page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- * `linux/syscall_32.tbl at v5.13 · torvalds/linux &lt;https://github.com/torvalds/linux/blob/v5.13/arch/x86/entry/syscalls/syscall_32.tbl&gt;`__ --&gt;
&lt;!-- * `linux/syscall_64.tbl at v5.13 · torvalds/linux &lt;https://github.com/torvalds/linux/blob/v5.13/arch/x86/entry/syscalls/syscall_64.tbl&gt;`__ --&gt;
&lt;!-- * `linux/syscall.tbl at v5.13 · torvalds/linux &lt;https://github.com/torvalds/linux/blob/v5.13/arch/arm/tools/syscall.tbl&gt;`__ --&gt;
&lt;!-- * `linux/unistd.h at v5.13 · torvalds/linux &lt;https://github.com/torvalds/linux/blob/v5.13/include/uapi/asm-generic/unistd.h&gt;`__ --&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate><guid>tag:mozillazg.com,2022-05-29:2022/05/ebpf-libbpf-raw-tracepoint-common-questions.html</guid><category>raw-tracepoint</category><category>libbpf</category><category>libbpfgo</category></item><item><title>libbpfgo 使用示例：在内核态和用户态使用 ebpf map</title><link>https://mozillazg.com/2022/05/ebpf-libbpfgo-use-map-example.html</link><description>&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;前言&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;记录一下如何在 libbpfgo 程序中使用 ebpf map（ebpf map 本身的资料可以参考参考资料）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ebpf-ebpf-map"&gt;
&lt;h2 id="hidebpf-ebpf-map"&gt;ebpf 程序中使用 ebpf map&lt;a class="headerlink" href="#hidebpf-ebpf-map" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="map"&gt;
&lt;h3 id="hidmap"&gt;定义 map&lt;a class="headerlink" href="#hidmap" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;先看一下定义一个 ebpf map 的方法，比如类型为 &lt;tt class="docutils literal"&gt;BPF_MAP_TYPE_HASH&lt;/tt&gt; 的 map:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BPF_MAP_TYPE_HASH&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;event_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_entries&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;event_map&lt;/span&gt; &lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.maps&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到主要需要指定 &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;key&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;value&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;max_entries&lt;/tt&gt; 这几个字段。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h3 id="hidid2"&gt;对 map 进行操作&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在 ebpf 程序中可以通过下面几个常用的辅助函数对 map 对象进行操作：&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;void bpf_map_lookup_elem(map, void *key. &lt;span class="pre"&gt;...)&lt;/span&gt;&lt;/tt&gt; 通过 key 查找对应的 value&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bpf_map_lookup_elem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event_map&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;// key 不存在&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;void bpf_map_update_elem(map, void *key, &lt;span class="pre"&gt;...,&lt;/span&gt; __u64 flags)&lt;/tt&gt; 更新指定 key 的值， &lt;tt class="docutils literal"&gt;flags&lt;/tt&gt; 参数用于控制更新行为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* File: include/uapi/linux/bpf.h */&lt;/span&gt;
&lt;span class="cm"&gt;/* flags for BPF_MAP_UPDATE_ELEM command */&lt;/span&gt;
&lt;span class="cp"&gt;#define BPF_ANY       0 &lt;/span&gt;&lt;span class="cm"&gt;/* create new element or update existing */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define BPF_NOEXIST   1 &lt;/span&gt;&lt;span class="cm"&gt;/* create new element only if it didn&amp;#39;t exist */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define BPF_EXIST     2 &lt;/span&gt;&lt;span class="cm"&gt;/* only update existing element */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="n"&gt;bpf_map_update_elem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event_map&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BPF_ANY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;void bpf_map_delete_elem(map, void *key)&lt;/tt&gt; 删除指定 key&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;bpf_map_delete_elem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event_map&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整示例程序详见: &lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/08-map-map-type-hash-kernel"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/08-map-map-type-hash-kernel&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pin-map"&gt;
&lt;h3 id="hidpin-map"&gt;pin map&lt;a class="headerlink" href="#hidpin-map" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;pin map 用于将 map 保存到本地文件系统中进行持久化，
libbpf 中是会自动保存到 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;/sys/fs/bpf/&amp;lt;map_name&amp;gt;&lt;/span&gt;&lt;/tt&gt; 路径下。&lt;/p&gt;
&lt;p&gt;定义 pin map 的方法只是在普通 map 的基础上加一个 &lt;tt class="docutils literal"&gt;pinning&lt;/tt&gt; 字段:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BPF_MAP_TYPE_HASH&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;event_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_entries&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pinning&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LIBBPF_PIN_BY_NAME&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// &amp;lt;- pin&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;event_map&lt;/span&gt; &lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.maps&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整示例程序详见： &lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/11-map-pin"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/11-map-pin&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="go-ebpf-map"&gt;
&lt;h2 id="hidgo-ebpf-map"&gt;go 程序中使用 ebpf map&lt;a class="headerlink" href="#hidgo-ebpf-map" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;可以使用 libbpfgo 在 go 程序中操作 ebpf 程序中定义的 ebpf map。&lt;/p&gt;
&lt;div class="section" id="id3"&gt;
&lt;h3 id="hidid3"&gt;对 map 进行操作&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;先通过 &lt;tt class="docutils literal"&gt;bpfmap, err := &lt;span class="pre"&gt;bpfModule.GetMap(&amp;quot;bpf_map&amp;quot;)&lt;/span&gt;&lt;/tt&gt; 拿到定义的 map 对象，然后就可以
做一些常见的操作了：&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Update(key, value unsafe.Pointer) error&lt;/tt&gt; 更新指定 key 的值，使用的 flags 是 &lt;tt class="docutils literal"&gt;BPF_ANY&lt;/tt&gt; 即
创建新元素或者更新已有的 key:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nx"&gt;value&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;233&lt;/span&gt;
&lt;span class="nx"&gt;keyPtr&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Pointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;valuePtr&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Pointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;bpfmap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;keyPtr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;valuePtr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;GetValue(key unsafe.Pointer) &lt;span class="pre"&gt;([]byte,&lt;/span&gt; error)&lt;/tt&gt; 获取指定 key 的值，当 key 不存在时会返回 error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nx"&gt;keyPtr&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Pointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;bpfmap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;GetValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;keyPtr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;DeleteKey(key unsafe.Pointer) error&lt;/tt&gt; 删除指定 key，当 key 不存在时会返回 error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nx"&gt;keyPtr&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Pointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;bpfmap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DeleteKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;keyPtr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整示例程序详见: &lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/09-map-map-type-hash-userspace"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/09-map-map-type-hash-userspace&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;参考资料&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://arthurchiao.art/blog/bpf-advanced-notes-2-zh/"&gt;BPF 进阶笔记（二）：BPF Map 类型详解：使用场景、程序示例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/"&gt;BCC to libbpf conversion guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/aquasecurity/libbpfgo"&gt;aquasecurity/libbpfgo: eBPF library for Go, wrapping libbpf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://prototype-kernel.readthedocs.io/en/latest/bpf/ebpf_maps.html"&gt;eBPF maps — Prototype Kernel 0.0.1 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://man7.org/linux/man-pages/man2/bpf.2.html"&gt;bpf(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate><guid>tag:mozillazg.com,2022-05-22:2022/05/ebpf-libbpfgo-use-map-example.html</guid><category>libbpf</category><category>libbpfgo</category></item><item><title>libbpfgo example: using ebpf map in kernel and userspace</title><link>https://mozillazg.com/2022/05/ebpf-libbpfgo-use-map-example-en.html</link><description>&lt;div class="section" id="preface"&gt;
&lt;h2 id="hidpreface"&gt;Preface&lt;a class="headerlink" href="#hidpreface" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Document how to use the ebpf map in the libbpfgo program (see the references for the ebpf map itself).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="using-ebpf-map-in-ebpf-programs"&gt;
&lt;h2 id="hidusing-ebpf-map-in-ebpf-programs"&gt;Using ebpf map in ebpf programs&lt;a class="headerlink" href="#hidusing-ebpf-map-in-ebpf-programs" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="define-map"&gt;
&lt;h3 id="hiddefine-map"&gt;Define map&lt;a class="headerlink" href="#hiddefine-map" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let's look at defining an ebpf map, such as a map of type &lt;tt class="docutils literal"&gt;BPF_MAP_TYPE_HASH&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BPF_MAP_TYPE_HASH&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;event_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_entries&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;event_map&lt;/span&gt; &lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.maps&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can see that you mainly need to specify the fields &lt;tt class="docutils literal"&gt;type&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;key&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;value&lt;/tt&gt;, and &lt;tt class="docutils literal"&gt;max_entries&lt;/tt&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="operate-on-map"&gt;
&lt;h3 id="hidoperate-on-map"&gt;Operate on map&lt;a class="headerlink" href="#hidoperate-on-map" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The map object can be manipulated in the ebpf program by using the following common helper functions:&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;void bpf_map_lookup_elem(map, void *key. &lt;span class="pre"&gt;...)&lt;/span&gt;&lt;/tt&gt; Perform a lookup in map for an entry associated to key.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bpf_map_lookup_elem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event_map&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;// key not exist&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;void bpf_map_update_elem(map, void *key, &lt;span class="pre"&gt;...,&lt;/span&gt; __u64 flags)&lt;/tt&gt; Add or update the value of the entry associated to key in map with value.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* File: include/uapi/linux/bpf.h */&lt;/span&gt;
&lt;span class="cm"&gt;/* flags for BPF_MAP_UPDATE_ELEM command */&lt;/span&gt;
&lt;span class="cp"&gt;#define BPF_ANY       0 &lt;/span&gt;&lt;span class="cm"&gt;/* create new element or update existing */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define BPF_NOEXIST   1 &lt;/span&gt;&lt;span class="cm"&gt;/* create new element only if it didn&amp;#39;t exist */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define BPF_EXIST     2 &lt;/span&gt;&lt;span class="cm"&gt;/* only update existing element */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="n"&gt;bpf_map_update_elem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event_map&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BPF_ANY&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;void bpf_map_delete_elem(map, void *key)&lt;/tt&gt; Delete entry with key from map.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;bpf_map_delete_elem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event_map&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can check out full sample codes on Github: &lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/08-map-map-type-hash-kernel"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/08-map-map-type-hash-kernel&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pin-map"&gt;
&lt;h3 id="hidpin-map"&gt;pin map&lt;a class="headerlink" href="#hidpin-map" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The pin map is used to save the map to the local filesystem for persistence. In libbpf, it is automatically saved to the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;/sys/fs/bpf/&amp;lt;map_name&amp;gt;&lt;/span&gt;&lt;/tt&gt; path.&lt;/p&gt;
&lt;p&gt;The method for defining a pin map is simply to add a &lt;tt class="docutils literal"&gt;pinning&lt;/tt&gt; field to the normal map:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BPF_MAP_TYPE_HASH&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;u32&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;__type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;event_t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_entries&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;__uint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pinning&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LIBBPF_PIN_BY_NAME&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// &amp;lt;- pin&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;event_map&lt;/span&gt; &lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.maps&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can check out full sample codes on Github:  &lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/11-map-pin"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/11-map-pin&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="using-ebpf-map-in-go-program"&gt;
&lt;h2 id="hidusing-ebpf-map-in-go-program"&gt;Using ebpf map in go program&lt;a class="headerlink" href="#hidusing-ebpf-map-in-go-program" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The ebpf map defined in the ebpf program can be manipulated in the go program using libbpfgo.&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h3 id="hidid1"&gt;Operate on map&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Get the map object defined by &lt;tt class="docutils literal"&gt;bpfmap, err := &lt;span class="pre"&gt;bpfModule.GetMap(&amp;quot;bpf_map&amp;quot;)&lt;/span&gt;&lt;/tt&gt;, and then you can
do some common operations:&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;Update(key, value unsafe.Pointer) error&lt;/tt&gt; Add or update the value of the entry associated to key in map with value and use &lt;tt class="docutils literal"&gt;BPF_ANY&lt;/tt&gt; as flag.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nx"&gt;value&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;233&lt;/span&gt;
&lt;span class="nx"&gt;keyPtr&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Pointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;valuePtr&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Pointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;bpfmap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;keyPtr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;valuePtr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;GetValue(key unsafe.Pointer) &lt;span class="pre"&gt;([]byte,&lt;/span&gt; error)&lt;/tt&gt; Perform a lookup in map for an entry associated to key. Return an error when the key is not exist.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nx"&gt;keyPtr&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Pointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;bpfmap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;GetValue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;keyPtr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;DeleteKey(key unsafe.Pointer) error&lt;/tt&gt; Delete entry with key from map. Return an error when the key is not exist.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="nx"&gt;keyPtr&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;unsafe&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Pointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;err&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;bpfmap&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;DeleteKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;keyPtr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can check out full codes on Github: &lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/09-map-map-type-hash-userspace"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/09-map-map-type-hash-userspace&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="references"&gt;
&lt;h2 id="hidreferences"&gt;References&lt;a class="headerlink" href="#hidreferences" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/"&gt;BCC to libbpf conversion guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/aquasecurity/libbpfgo"&gt;aquasecurity/libbpfgo: eBPF library for Go, wrapping libbpf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://prototype-kernel.readthedocs.io/en/latest/bpf/ebpf_maps.html"&gt;eBPF maps — Prototype Kernel 0.0.1 documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://man7.org/linux/man-pages/man2/bpf.2.html"&gt;bpf(2) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sun, 22 May 2022 00:00:00 +0000</pubDate><guid>tag:mozillazg.com,2022-05-22:2022/05/ebpf-libbpfgo-use-map-example-en.html</guid><category>libbpf</category><category>libbpfgo</category><category>go</category><category>golang</category><category>en-version</category></item><item><title>ebpf/libbpf 程序使用 tracepoint 的常见问题</title><link>https://mozillazg.com/2022/05/ebpf-libbpf-tracepoint-common-questions.html</link><description>&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;前言&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;记录一些编写 ebpf/libbpf 程序（比如编写类型为 &lt;tt class="docutils literal"&gt;BPF_PROG_TYPE_TRACEPOINT&lt;/tt&gt; 的 ebpf 程序）时
涉及到的 tracepoint 相关的常见问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tracepoint"&gt;
&lt;h2 id="hidtracepoint"&gt;tracepoint 可以监控哪些事件&lt;a class="headerlink" href="#hidtracepoint" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;可以通过查看 &lt;tt class="docutils literal"&gt;/sys/kernel/debug/tracing/available_events&lt;/tt&gt; 文件的内容找到 tracepoint 可监控的事件。
文件中每行内容的格式是:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;lt;category&amp;gt;:&amp;lt;name&amp;gt;
&lt;/pre&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
syscalls:sys_enter_execve
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="sec"&gt;
&lt;h2 id="hidsec"&gt;SEC 内容的格式&lt;a class="headerlink" href="#hidsec" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;tracepoint 事件对应的 SEC 格式为:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
SEC(&amp;quot;tracepoint/&amp;lt;category&amp;gt;/&amp;lt;name&amp;gt;&amp;quot;)

// 比如:
// SEC(&amp;quot;tracepoint/syscalls/sys_enter_openat&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;或:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
SEC(&amp;quot;tp/&amp;lt;category&amp;gt;/&amp;lt;name&amp;gt;&amp;quot;)

// 比如:
// SEC(&amp;quot;tp/syscalls/sys_enter_openat&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&amp;lt;category&amp;gt;&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;&amp;lt;name&amp;gt;&lt;/tt&gt; 的值均取值前面 available_events 文件中列出的内容。&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;SEC(&amp;quot;tp/xx/yy&amp;quot;)&lt;/span&gt;&lt;/tt&gt; 跟 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;SEC(&amp;quot;tracepoint/xx/yy&amp;quot;)&lt;/span&gt;&lt;/tt&gt; 其实是等效的，看个人喜好随便用哪种都行。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;如何确定 tracepoint 事件处理函数的参数类型，获取对应的内核调用参数&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;假设，我们想通过 tracepoint 监控 &lt;tt class="docutils literal"&gt;chmod&lt;/tt&gt; 这个命令涉及的 &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; 系统调用，
那么，如何确定ebpf 中事件处理函数的参数类型，以及如何获取到对应的 &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; 这个系统调用涉及的参数的内容，
比如拿到操作文件名称以及操作的权限 mode 的值。&lt;/p&gt;
&lt;p&gt;第一步，先确定 &lt;tt class="docutils literal"&gt;chmod&lt;/tt&gt; 所使用的系统调用，这个比较简单，有很多种方法可以做到，比如通过 &lt;tt class="docutils literal"&gt;strace&lt;/tt&gt; 命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ strace chmod 600 a.txt
...
fchmodat(AT_FDCWD, &amp;quot;a.txt&amp;quot;, 0600)       = 0
...
&lt;/pre&gt;
&lt;p&gt;第二步，找到针对这个系统调用可以使用的 tracepoint 事件:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo cat /sys/kernel/debug/tracing/available_events |grep fchmodat
syscalls:sys_exit_fchmodat
syscalls:sys_enter_fchmodat
&lt;/pre&gt;
&lt;p&gt;可以看到，有 &lt;tt class="docutils literal"&gt;sys_enter_fchmodat&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;sys_exit_fchmodat&lt;/tt&gt; 这两个事件。这里选择
&lt;tt class="docutils literal"&gt;sys_enter_fchmodat&lt;/tt&gt; 这个事件进行后续的说明。&lt;/p&gt;
&lt;p&gt;第三步，确定函数的参数类型。这个需要到 &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; 文件中进行查找，
一般 &lt;tt class="docutils literal"&gt;sys_enter_xx&lt;/tt&gt; 对应 &lt;tt class="docutils literal"&gt;trace_event_raw_sys_enter&lt;/tt&gt; ，
&lt;tt class="docutils literal"&gt;sys_exit_xx&lt;/tt&gt; 对应 &lt;tt class="docutils literal"&gt;trace_event_raw_sys_exit&lt;/tt&gt; ，
其他的一般对应 &lt;tt class="docutils literal"&gt;trace_event_raw_&amp;lt;name&amp;gt;&lt;/tt&gt; ，如果没找到的话，可以参考 &lt;tt class="docutils literal"&gt;trace_event_raw_sys_enter&lt;/tt&gt;
的例子找它相近的 struct。 对于 &lt;tt class="docutils literal"&gt;sys_enter_fchmodat&lt;/tt&gt; ，我们使用 &lt;tt class="docutils literal"&gt;trace_event_raw_sys_enter&lt;/tt&gt; 这个 struct:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;trace_event_raw_sys_enter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;trace_entry&lt;/span&gt; &lt;span class="n"&gt;ent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;__data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; 中就存储了事件相关的我们可以获取的信息，至于里面包含了哪些信息就是第四步需要确定的信息。&lt;/p&gt;
&lt;p&gt;第四步，确定事件本身可以获取到哪些信息，虽然我们知道 &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; 系统调用需要提供文件名称和 mode 信息，
但是，我们不确定是否可以在 ebpf 程序中获取到这些信息。可以通过查看
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;/sys/kernel/debug/tracing/events/&amp;lt;category&amp;gt;/&amp;lt;name&amp;gt;/format&lt;/span&gt;&lt;/tt&gt; 文件获取到我们可以获取哪些信息。
比如 &lt;tt class="docutils literal"&gt;sys_enter_fchmodat&lt;/tt&gt; 这个事件的 &lt;tt class="docutils literal"&gt;/sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format&lt;/tt&gt;
的内容如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format
name: sys_enter_fchmodat
ID: 647
format:
        field:unsigned short common_type;       offset:0;       size:2; signed:0;
        field:unsigned char common_flags;       offset:2;       size:1; signed:0;
        field:unsigned char common_preempt_count;       offset:3;       size:1; signed:0;
        field:int common_pid;   offset:4;       size:4; signed:1;

        field:int __syscall_nr; offset:8;       size:4; signed:1;
        field:int dfd;  offset:16;      size:8; signed:0;
        field:const char * filename;    offset:24;      size:8; signed:0;
        field:umode_t mode;     offset:32;      size:8; signed:0;

print fmt: &amp;quot;dfd: 0x%08lx, filename: 0x%08lx, mode: 0x%08lx&amp;quot;, ((unsigned long)(REC-&amp;gt;dfd)), ((unsigned long)(REC-&amp;gt;filename)), ((unsigned long)(REC-&amp;gt;mode))
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;print fmt&lt;/tt&gt; 中引用的字段都是我们可以在 ebpf 程序中获取的信息。
从上面可以看到，我们可以获取 &lt;tt class="docutils literal"&gt;sys_enter_fchmodat&lt;/tt&gt; 事件的 &lt;tt class="docutils literal"&gt;dfd&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;filename&lt;/tt&gt; 以及 &lt;tt class="docutils literal"&gt;mode&lt;/tt&gt; 信息，
这里就包含了前面所说的文件名称以及权限 mode 信息。
这些字段的值可以通过 &lt;tt class="docutils literal"&gt;trace_event_raw_sys_enter&lt;/tt&gt; 的 &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; 数组获取，即通过 &lt;tt class="docutils literal"&gt;args[0]&lt;/tt&gt; 获取 &lt;tt class="docutils literal"&gt;dfd&lt;/tt&gt; , &lt;tt class="docutils literal"&gt;args[1]&lt;/tt&gt; 获取 &lt;tt class="docutils literal"&gt;filename&lt;/tt&gt; 以此类推。&lt;/p&gt;
&lt;p&gt;信息都确定好了，就可以写程序了。比如上面 &lt;tt class="docutils literal"&gt;sys_enter_fchmodat&lt;/tt&gt; 事件的示例 ebpf 程序如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tracepoint/syscalls/sys_enter_fchmodat&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;tracepoint__syscalls__sys_enter_fchmodat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;trace_event_raw_sys_enter&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;

        &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;filename_ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;BPF_CORE_READ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;bpf_core_read_user_str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;filename_ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BPF_CORE_READ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

        &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的示例程序详见：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/07-tracepoint-args"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/07-tracepoint-args&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/14-tracepoint-args-sched_switch"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/14-tracepoint-args-sched_switch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;参考资料&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://nakryiko.com/posts/bpf-core-reference-guide/"&gt;BPF CO-RE reference guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/libbpf/libbpf/blob/12e932ac0e18546dd7247e66ea1b4aa236d2ef38/src/libbpf.c#L9002-L9081"&gt;libbpf/libbpf.c at 12e932ac0e18546dd7247e66ea1b4aa236d2ef38 · libbpf/libbpf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/"&gt;BCC to libbpf conversion guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate><guid>tag:mozillazg.com,2022-05-15:2022/05/ebpf-libbpf-tracepoint-common-questions.html</guid><category>tracepoint</category><category>libbpf</category><category>libbpfgo</category></item><item><title>Frequently asked questions about using tracepoint with ebpf/libbpf programs</title><link>https://mozillazg.com/2022/05/ebpf-libbpf-tracepoint-common-questions-en.html</link><description>&lt;div class="section" id="preface"&gt;
&lt;h2 id="hidpreface"&gt;Preface&lt;a class="headerlink" href="#hidpreface" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Note some common problems related to tracepoint when writing ebpf/libbpf programs (such as &lt;tt class="docutils literal"&gt;BPF_PROG_TYPE_TRACEPOINT&lt;/tt&gt; program).&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-events-can-be-monitored-by-tracepoint"&gt;
&lt;h2 id="hidwhat-events-can-be-monitored-by-tracepoint"&gt;What events can be monitored by tracepoint&lt;a class="headerlink" href="#hidwhat-events-can-be-monitored-by-tracepoint" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The events that tracepoint can monitor can be found by looking at the contents of the &lt;tt class="docutils literal"&gt;/sys/kernel/debug/tracing/available_events&lt;/tt&gt; file.&lt;/p&gt;
&lt;p&gt;The format of each line in the file is:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;lt;category&amp;gt;:&amp;lt;name&amp;gt;
&lt;/pre&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
syscalls:sys_enter_execve
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="format-of-sec-content"&gt;
&lt;h2 id="hidformat-of-sec-content"&gt;Format of SEC content&lt;a class="headerlink" href="#hidformat-of-sec-content" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The SEC format for the tracepoint event is:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
SEC(&amp;quot;tracepoint/&amp;lt;category&amp;gt;/&amp;lt;name&amp;gt;&amp;quot;)

// for example:
// SEC(&amp;quot;tracepoint/syscalls/sys_enter_openat&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;or:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
SEC(&amp;quot;tp/&amp;lt;category&amp;gt;/&amp;lt;name&amp;gt;&amp;quot;)

// for example:
// SEC(&amp;quot;tp/syscalls/sys_enter_openat&amp;quot;)
&lt;/pre&gt;
&lt;p&gt;he values of &lt;tt class="docutils literal"&gt;&amp;lt;category&amp;gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&amp;lt;name&amp;gt;&lt;/tt&gt; both take the values listed in the available_events file earlier.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;SEC(&amp;quot;tp/xx/yy&amp;quot;)&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;SEC(&amp;quot;tracepoint/xx/yy&amp;quot;)&lt;/span&gt;&lt;/tt&gt; are actually equivalent, depending on personal preference, which one can be used at will.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-to-determine-the-parameter-type-of-the-tracepoint-event-handler-and-get-the-corresponding-kernel-call-parameters"&gt;
&lt;h2 id="hidhow-to-determine-the-parameter-type-of-the-tracepoint-event-handler-and-get-the-corresponding-kernel-call-parameters"&gt;How to determine the parameter type of the tracepoint event handler and get the corresponding kernel call parameters&lt;a class="headerlink" href="#hidhow-to-determine-the-parameter-type-of-the-tracepoint-event-handler-and-get-the-corresponding-kernel-call-parameters" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Suppose that we want to monitor the &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; system call involved in the &lt;tt class="docutils literal"&gt;chmod&lt;/tt&gt; command via tracepoint. Then, how do we determine the types of parameters of the event handler functions in ebpf and how do we get the contents of the corresponding &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; system call parameters? For example, get the name of the file to be operated on and the value of the permission mode to be operated on.&lt;/p&gt;
&lt;p&gt;The first step is to determine the system call used by &lt;tt class="docutils literal"&gt;chmod&lt;/tt&gt;, which is relatively simple and can be done in a variety of ways, such as through the &lt;tt class="docutils literal"&gt;strace&lt;/tt&gt; command:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ strace chmod 600 a.txt
...
fchmodat(AT_FDCWD, &amp;quot;a.txt&amp;quot;, 0600)       = 0
...
&lt;/pre&gt;
&lt;p&gt;The second step is to find the tracepoint event that can be used for this system call:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo cat /sys/kernel/debug/tracing/available_events |grep fchmodat
syscalls:sys_exit_fchmodat
syscalls:sys_enter_fchmodat
&lt;/pre&gt;
&lt;p&gt;As you can see, there are &lt;tt class="docutils literal"&gt;sys_enter_fchmodat&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;sys_exit_fchmodat&lt;/tt&gt; events. Here choose
&lt;tt class="docutils literal"&gt;sys_enter_fchmodat&lt;/tt&gt; event for subsequent explanation.&lt;/p&gt;
&lt;p&gt;The third step is to determine the argument type of the function. This needs to be found in the &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; file, generally &lt;tt class="docutils literal"&gt;sys_enter_xx&lt;/tt&gt; corresponds to &lt;tt class="docutils literal"&gt;trace_event_raw_sys_enter&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;sys_exit_xx&lt;/tt&gt; corresponds to &lt;tt class="docutils literal"&gt;trace_event_raw_sys_exit&lt;/tt&gt;, and the others generally correspond to &lt;tt class="docutils literal"&gt;trace_event_raw_sys_enter&lt;/tt&gt;. &lt;tt class="docutils literal"&gt;trace_event_raw_&amp;lt;name&amp;gt;&lt;/tt&gt;, if you don't find it, you can refer to the &lt;tt class="docutils literal"&gt;trace_event_raw_sys_enter&lt;/tt&gt; example to find its similar struct.&lt;/p&gt;
&lt;p&gt;For &lt;tt class="docutils literal"&gt;sys_enter_fchmodat&lt;/tt&gt;, we use the struct &lt;tt class="docutils literal"&gt;trace_event_raw_sys_enter&lt;/tt&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;trace_event_raw_sys_enter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;trace_entry&lt;/span&gt; &lt;span class="n"&gt;ent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;__data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; stores the information we can get about the event, and what information is contained in them is what we need to determine in step 4.&lt;/p&gt;
&lt;p&gt;The fourth step is to determine what information is available in the event itself, although we know that the &lt;tt class="docutils literal"&gt;fchmodat&lt;/tt&gt; system call requires the file name and mode information.
However, we are not sure if this information is available in the ebpf program. This can be done by looking at
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;/sys/kernel/debug/tracing/events/&amp;lt;category&amp;gt;/&amp;lt;name&amp;gt;/format&lt;/span&gt;&lt;/tt&gt; file to see what information we can get.
For example, the &lt;tt class="docutils literal"&gt;sys_enter_fchmodat&lt;/tt&gt; event &lt;tt class="docutils literal"&gt;/sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format&lt;/tt&gt; is as follows:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo cat /sys/kernel/debug/tracing/events/syscalls/sys_enter_fchmodat/format
name: sys_enter_fchmodat
ID: 647
format:
        field:unsigned short common_type;       offset:0;       size:2; signed:0;
        field:unsigned char common_flags;       offset:2;       size:1; signed:0;
        field:unsigned char common_preempt_count;       offset:3;       size:1; signed:0;
        field:int common_pid;   offset:4;       size:4; signed:1;

        field:int __syscall_nr; offset:8;       size:4; signed:1;
        field:int dfd;  offset:16;      size:8; signed:0;
        field:const char * filename;    offset:24;      size:8; signed:0;
        field:umode_t mode;     offset:32;      size:8; signed:0;

print fmt: &amp;quot;dfd: 0x%08lx, filename: 0x%08lx, mode: 0x%08lx&amp;quot;, ((unsigned long)(REC-&amp;gt;dfd)), ((unsigned long)(REC-&amp;gt;filename)), ((unsigned long)(REC-&amp;gt;mode))
&lt;/pre&gt;
&lt;p&gt;The fields referenced in &lt;tt class="docutils literal"&gt;print fmt&lt;/tt&gt; are all information that we can get in the ebpf program.
From the above, we can see that we can get the &lt;tt class="docutils literal"&gt;sys_enter_fchmodat&lt;/tt&gt; event &lt;tt class="docutils literal"&gt;dfd&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;filename&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;mode&lt;/tt&gt; information.  Here contains the previously mentioned file name and permission mode information.
The values of these fields can be obtained from the &lt;tt class="docutils literal"&gt;args&lt;/tt&gt; array of &lt;tt class="docutils literal"&gt;trace_event_raw_sys_enter&lt;/tt&gt;, i.e. &lt;tt class="docutils literal"&gt;args[0]&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;dfd&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;args[1]&lt;/tt&gt; for &lt;tt class="docutils literal"&gt;filename&lt;/tt&gt; and so on.&lt;/p&gt;
&lt;p&gt;Once the information has been determined, you can write the program. For example, the example ebpf program for the &lt;tt class="docutils literal"&gt;sys_enter_fchmodat&lt;/tt&gt; event above is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;SEC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;tracepoint/syscalls/sys_enter_fchmodat&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;tracepoint__syscalls__sys_enter_fchmodat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;trace_event_raw_sys_enter&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// ...&lt;/span&gt;

        &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;filename_ptr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;BPF_CORE_READ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;bpf_core_read_user_str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;filename_ptr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;BPF_CORE_READ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ctx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

        &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can check out full example codes on Github:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/07-tracepoint-args"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/07-tracepoint-args&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/hello-libbpfgo/tree/master/14-tracepoint-args-sched_switch"&gt;https://github.com/mozillazg/hello-libbpfgo/tree/master/14-tracepoint-args-sched_switch&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="references"&gt;
&lt;h2 id="hidreferences"&gt;References&lt;a class="headerlink" href="#hidreferences" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://nakryiko.com/posts/bpf-core-reference-guide/"&gt;BPF CO-RE reference guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/libbpf/libbpf/blob/12e932ac0e18546dd7247e66ea1b4aa236d2ef38/src/libbpf.c#L9002-L9081"&gt;libbpf/libbpf.c at 12e932ac0e18546dd7247e66ea1b4aa236d2ef38 · libbpf/libbpf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/"&gt;BCC to libbpf conversion guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sun, 15 May 2022 00:00:00 +0000</pubDate><guid>tag:mozillazg.com,2022-05-15:2022/05/ebpf-libbpf-tracepoint-common-questions-en.html</guid><category>tracepoint</category><category>libbpf</category><category>libbpfgo</category><category>go</category><category>golang</category><category>en-version</category></item></channel></rss>