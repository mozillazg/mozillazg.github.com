<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>mozillazg's Blog</title><link>https://mozillazg.com/</link><description></description><lastBuildDate>Sun, 05 Jan 2025 00:00:00 +0000</lastBuildDate><item><title>Workload Identity Federation for GKE 特性探索</title><link>https://mozillazg.com/2025/01/security-deep-dive-into-gcp-workload-identity-federation-for-gke-feature.html</link><description>&lt;p&gt;本文将简单探索一下前段时间 GKE 官宣的名为 &lt;a class="reference external" href="https://cloud.google.com/blog/products/identity-security/make-iam-for-gke-easier-to-use-with-workload-identity-federation"&gt;Workload Identity Federation for GKE&lt;/a&gt; 的特性。&lt;/p&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2 id="hidsection-1"&gt;功能介绍&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Workload Identity Federation for GKE 是原有的 GKE Workload Identity 特性的改进版本,
核心的改进是减少了需要配置的信息，提升了用户体验。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2 id="hidsection-2"&gt;使用方法&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;可以通过下面几个步骤体验该特性：&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;创建一个启用 Workload Identity Federation for GKE 特性的 GKE 集群。具体启用位置是：创建集群 - 安全 - 启用 Workload Identity。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;为测试应用使用的 service account 关联 iam 角色，一个 service account 可以关联多个角色。比如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ kubectl create ns demo-ns
$ kubectl -n demo-ns create serviceaccount demo-sa

$ gcloud projects add-iam-policy-binding projects/test-gke-XXX \
    --role=roles/container.clusterViewer \
    --member=principal://iam.googleapis.com/projects/23182XXXXXXX/locations/global/workloadIdentityPools/test-gke-XXXXXX.svc.id.goog/subject/ns/&amp;lt;namespace-name&amp;gt;/sa/&amp;lt;service-account-name&amp;gt; \
    --condition=None

$ gcloud storage buckets add-iam-policy-binding gs://&amp;lt;bucket-name&amp;gt; \
--role=roles/storage.objectViewer \
--member=principal://iam.googleapis.com/projects/23182XXXXXXX/locations/global/workloadIdentityPools/test-gke-XXXXXX.svc.id.goog/subject/ns/&amp;lt;namespace-name&amp;gt;/sa/&amp;lt;service-account-name&amp;gt; \
--condition=None
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;部署测试应用，测试应用的 pod 需要使用第 2 步对应的 namespace 和 service account 以及增加 nodeSelector 确保调度到启用了 Workload Identity Federation for GKE 特性的节点上:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
apiVersion: v1
kind: Pod
metadata:
  name: test-pod
  namespace: demo-ns
spec:
  nodeSelector:
    iam.gke.io/gke-metadata-server-enabled: &amp;quot;true&amp;quot;
  serviceAccountName: demo-sa
  containers:
  - name: test-pod
    image: google/cloud-sdk:slim
    command: [&amp;quot;sleep&amp;quot;,&amp;quot;infinity&amp;quot;]
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;待 pod running 后, 进入 test-pod 容器内，访问实例元数据服务获取 sts token，实际的业务应用使用的官方 SDK 也将使用类似的方式访问实例元数据服务获取用于请求云产品 API 的 sts token。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$&lt;span class="w"&gt; &lt;/span&gt;gcloud&lt;span class="w"&gt; &lt;/span&gt;auth&lt;span class="w"&gt; &lt;/span&gt;print-access-token
&lt;span class="w"&gt; &lt;/span&gt;ya29.d.XXX
$&lt;span class="w"&gt; &lt;/span&gt;curl&lt;span class="w"&gt; &lt;/span&gt;-H&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Metadata-Flavor: Google&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;access_token&amp;quot;&lt;/span&gt;:&lt;span class="s2"&gt;&amp;quot;ya29.d.XXX&amp;quot;&lt;/span&gt;,&lt;span class="s2"&gt;&amp;quot;expires_in&amp;quot;&lt;/span&gt;:3423,&lt;span class="s2"&gt;&amp;quot;token_type&amp;quot;&lt;/span&gt;:&lt;span class="s2"&gt;&amp;quot;Bearer&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol class="arabic simple" start="5"&gt;
&lt;li&gt;获取的 sts token 将具有前面第 2 步所关联的所有角色的权限.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$&lt;span class="w"&gt; &lt;/span&gt;gcloud&lt;span class="w"&gt; &lt;/span&gt;container&lt;span class="w"&gt; &lt;/span&gt;node-pools&lt;span class="w"&gt; &lt;/span&gt;list&lt;span class="w"&gt; &lt;/span&gt;--zone&lt;span class="w"&gt; &lt;/span&gt;us-central1&lt;span class="w"&gt; &lt;/span&gt;--cluster&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;test&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;NAME&lt;span class="w"&gt;          &lt;/span&gt;MACHINE_TYPE&lt;span class="w"&gt;  &lt;/span&gt;DISK_SIZE_GB&lt;span class="w"&gt;  &lt;/span&gt;NODE_VERSION
&lt;span class="w"&gt; &lt;/span&gt;default-pool&lt;span class="w"&gt;  &lt;/span&gt;e2-medium&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="m"&gt;100&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.30.6-gke.1125000

$&lt;span class="w"&gt; &lt;/span&gt;curl&lt;span class="w"&gt; &lt;/span&gt;-X&lt;span class="w"&gt; &lt;/span&gt;GET&lt;span class="w"&gt; &lt;/span&gt;-H&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Authorization: Bearer &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;gcloud&lt;span class="w"&gt; &lt;/span&gt;auth&lt;span class="w"&gt; &lt;/span&gt;print-access-token&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;https://storage.googleapis.com/storage/v1/b/demo-gke-workload-identity-federation/o&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kind&amp;quot;&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;storage#objects&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h2 id="hidsection-3"&gt;工作流程&lt;a class="headerlink" href="#hidsection-3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Workload Identity Federation for GKE 特性的工作流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/static/images/security/gke-workload-identity-federation-for-gke.png" /&gt;&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;当应用 Pod 容器内的程序请求实例元数据服务（访问 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;http://metadata.google.internal&lt;/span&gt;&lt;/tt&gt; ，实际是访问 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;http://169.254.169.254:80&lt;/span&gt;&lt;/tt&gt; ）
获取 sts token 时, 该请求将被重定向到 169.254.169.252:988。
169.254.169.252:988 是节点上部署的 gke-metadata-server 服务所监听的端口。&lt;/li&gt;
&lt;li&gt;gke-metadata-server 服务在收到请求后，将根据请求的 client ip 确定请求来自哪个 Pod，
然后再请求 apiserver 生成一个该 Pod 所使用的 service account 对应的 token。&lt;/li&gt;
&lt;li&gt;gke-metadata-server 将使用获取的 service account token 访问 GCP 的
&lt;a class="reference external" href="https://cloud.google.com/iam/docs/reference/sts/rest/v1/TopLevel/token"&gt;STS API&lt;/a&gt; 获取一个 sts token，
最后 gke-metadata-server 将获取到的 sts token 返回给客户端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个流程中有几个关键的组件和信息需要重点关注，下面将逐个说明。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="gke-metadata-server"&gt;
&lt;h2 id="hidgke-metadata-server"&gt;gke-metadata-server&lt;a class="headerlink" href="#hidgke-metadata-server" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;当在集群维度或节点池维度启用 Workload Identity Federation for GKE 特性时，集群内将自动部署一个名为 gke-metadata-server 的组件。
该组件的工作负载 YAML 如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
apiVersion: apps/v1
kind: DaemonSet
metadata:
  annotations:
    deprecated.daemonset.template.generation: &amp;quot;1&amp;quot;
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    k8s-app: gke-metadata-server
  name: gke-metadata-server
  namespace: kube-system
spec:
  minReadySeconds: 90
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      k8s-app: gke-metadata-server
  template:
    metadata:
      annotations:
        components.gke.io/component-name: gke-metadata-server
        components.gke.io/component-version: 0.4.301
        monitoring.gke.io/path: /metricz
      creationTimestamp: null
      labels:
        addonmanager.kubernetes.io/mode: Reconcile
        k8s-app: gke-metadata-server
    spec:
      containers:
      - command:
        - /gke-metadata-server
        - --logtostderr
        - --token-exchange-endpoint=https://securetoken.googleapis.com/v1/identitybindingtoken
        - --workload-pool=test-gke-XXXXXX.svc.id.goog
        - --alts-service-suffixes-using-node-identity=storage.googleapis.com,bigtable.googleapis.com,bigtable2.googleapis.com,bigtablerls.googleapis.com,spanner.googleapis.com,spanner2.googleapis.com,spanner-rls.googleapis.com,grpclb.directpath.google.internal,grpclb-dualstack.directpath.google.internal,staging-wrenchworks.sandbox.googleapis.com,preprod-spanner.sandbox.googleapis.com,wrenchworks-loadtest.googleapis.com,wrenchworks-nonprod.googleapis.com
        - --identity-provider=https://container.googleapis.com/v1/projects/test-gke-XXXXXX/locations/us-central1/clusters/test
        - --passthrough-ksa-list=anthos-identity-service:gke-oidc-envoy-sa,anthos-identity-service:gke-oidc-service-sa,gke-managed-dpv2-observability:hubble-relay,kube-system:antrea-controller,kube-system:container-watcher-pod-reader,kube-system:coredns,kube-system:egress-nat-controller,kube-system:event-exporter-sa,kube-system:fluentd-gcp-scaler,kube-system:gke-metrics-agent,kube-system:gke-spiffe-node-agent,kube-system:heapster,kube-system:konnectivity-agent,kube-system:kube-dns,kube-system:maintenance-handler,kube-system:metadata-agent,kube-system:network-metering-agent,kube-system:node-local-dns,kube-system:pkgextract-service,kube-system:pkgextract-cleanup-service,kube-system:securityprofile-controller,istio-system:istio-ingressgateway-service-account,istio-system:cluster-local-gateway-service-account,csm:csm-sync-agent,knative-serving:controller,kube-system:pdcsi-node-sa,kube-system:gcsfusecsi-node-sa,gmp-system:collector,gke-gmp-system:collector,gke-managed-cim:kube-state-metrics
        - --attributes=cluster-name=test,cluster-uid=392f63049deXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX,cluster-location=us-central1
        - --cluster-uid=392f63049ded410XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        - --sts-endpoint=https://sts.googleapis.com
        - --token-exchange-mode=sts
        - --cloud-monitoring-endpoint=monitoring.googleapis.com:443
        - --iam-cred-service-endpoint=https://iamcredentials.googleapis.com
        - --cluster-project-number=2318XXXXXXXX
        - --cluster-location=us-central1
        - --cluster-name=test
        - --component-version=0.4.301
        - --ksa-cache-mode=watchchecker
        - --kcp-allow-watch-checker=true
        - --enable-mds-csi-driver=true
        - --csi-socket=/csi/csi.sock
        - --volumes-db=/var/run/gkemds.gke.io/csi/volumes.boltdb
        env:
        - name: GOMEMLIMIT
          value: &amp;quot;94371840&amp;quot;
        image: us-central1-artifactregistry.gcr.io/gke-release/gke-release/gke-metadata-server:gke_metadata_server_20240702.00_p0&amp;#64;sha256:aea9cc887c91b9a05e5bb4bb604180772594a01f0828bbfacf30c77562ac7205
        imagePullPolicy: IfNotPresent
        livenessProbe:
          failureThreshold: 3
          httpGet:
            host: 127.0.0.1
            path: /healthz
            port: 989
            scheme: HTTP
          initialDelaySeconds: 30
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 3
        name: gke-metadata-server
        ports:
        - containerPort: 987
          name: alts
          protocol: TCP
        - containerPort: 988
          name: metadata-server
          protocol: TCP
        - containerPort: 989
          name: debug-port
          protocol: TCP
        readinessProbe:
          failureThreshold: 3
          httpGet:
            host: 127.0.0.1
            path: /healthz
            port: 989
            scheme: HTTP
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        resources:
          limits:
            memory: 100Mi
          requests:
            cpu: 100m
            memory: 100Mi
        securityContext:
          privileged: true
          readOnlyRootFilesystem: true
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        volumeMounts:
        - mountPath: /var/lib/kubelet/kubeconfig
          name: kubelet-credentials
          readOnly: true
        - mountPath: /var/lib/kubelet/pki/
          name: kubelet-certs
          readOnly: true
        - mountPath: /var/run/
          name: container-runtime-interface
        - mountPath: /etc/srv/kubernetes/pki
          name: kubelet-pki
          readOnly: true
        - mountPath: /etc/ssl/certs/
          name: ca-certificates
          readOnly: true
        - mountPath: /home/kubernetes/bin/gke-exec-auth-plugin
          name: gke-exec-auth-plugin
          readOnly: true
        - mountPath: /sys/firmware/efi/efivars/
          name: efivars
          readOnly: true
        - mountPath: /dev/tpm0
          name: vtpm
          readOnly: true
        - mountPath: /csi
          name: csi-socket-dir
        - mountPath: /var/run/gkemds.gke.io/csi
          name: state-dir
        - mountPath: /var/lib/kubelet/pods
          mountPropagation: Bidirectional
          name: pods-dir
        - mountPath: /registration
          name: kubelet-registration-dir
      dnsPolicy: Default
      hostNetwork: true
      nodeSelector:
        iam.gke.io/gke-metadata-server-enabled: &amp;quot;true&amp;quot;
        kubernetes.io/os: linux
      priorityClassName: system-node-critical
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      serviceAccount: gke-metadata-server
      serviceAccountName: gke-metadata-server
      terminationGracePeriodSeconds: 30
      tolerations:
      - effect: NoExecute
        operator: Exists
      - effect: NoSchedule
        operator: Exists
      - key: components.gke.io/gke-managed-components
        operator: Exists
      volumes:
      - hostPath:
          path: /var/lib/kubelet/pki/
          type: Directory
        name: kubelet-certs
      - hostPath:
          path: /var/lib/kubelet/kubeconfig
          type: File
        name: kubelet-credentials
      - hostPath:
          path: /var/run/
          type: Directory
        name: container-runtime-interface
      - hostPath:
          path: /etc/srv/kubernetes/pki/
          type: Directory
        name: kubelet-pki
      - hostPath:
          path: /etc/ssl/certs/
          type: Directory
        name: ca-certificates
      - hostPath:
          path: /home/kubernetes/bin/gke-exec-auth-plugin
          type: File
        name: gke-exec-auth-plugin
      - hostPath:
          path: /sys/firmware/efi/efivars/
          type: Directory
        name: efivars
      - hostPath:
          path: /dev/tpm0
          type: CharDevice
        name: vtpm
      - hostPath:
          path: /var/lib/kubelet/plugins/gkemds.gke.io
          type: DirectoryOrCreate
        name: csi-socket-dir
      - hostPath:
          path: /var/lib/kubelet/pods
          type: Directory
        name: pods-dir
      - hostPath:
          path: /var/lib/kubelet/plugins_registry
          type: Directory
        name: kubelet-registration-dir
      - hostPath:
          path: /var/lib/kubelet/plugins
          type: Directory
        name: kubelet-plugins-dir
      - hostPath:
          path: /var/run/gkemds.gke.io/csi
          type: DirectoryOrCreate
        name: state-dir
&lt;/pre&gt;
&lt;p&gt;gke-metadata-server 组件具有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;组件的工作负载是一个 DaemonSet。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;组件 Pod 使用 &lt;tt class="docutils literal"&gt;hostNetwork: true&lt;/tt&gt; 以及 &lt;tt class="docutils literal"&gt;privileged: true&lt;/tt&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;组件内的服务将监听 987, 988 以及 989 端口, 其中 988 端口将用于接收重定向过来的访问实例元数据服务的请求:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ss -atnlp |grep gke
LISTEN 0      1024               *:987              *:*    users:((&amp;quot;gke-metadata-se&amp;quot;,pid=183706,fd=10))
LISTEN 0      1024               *:989              *:*    users:((&amp;quot;gke-metadata-se&amp;quot;,pid=183706,fd=12))
LISTEN 0      1024               *:988              *:*    users:((&amp;quot;gke-metadata-se&amp;quot;,pid=183706,fd=15))
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;前面所说的 169.254.169.252 这个 IP 是本机 lo 的 IP 地址，所以 gke-metadata-server 监听的 988 端口
就包含了前面所说的 &lt;tt class="docutils literal"&gt;169.254.169.252:988&lt;/tt&gt; 端口:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet 169.254.169.252/32 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;所有启用了 Workload Identity Federation for GKE 特性的节点在初始化的时候都会配置如下 nftables 规则，
确保从业务容器内发起的请求元数据服务 (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;http://metadata.google.internal&lt;/span&gt;&lt;/tt&gt; , 169.254.169.254:80)
的流量都会被重定向到组件所监听的 &lt;tt class="docutils literal"&gt;169.254.169.252:988&lt;/tt&gt; 端口:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
table ip nat {
        chain PREROUTING {
                type nat hook prerouting priority dstnat; policy accept;
                 counter packets 2143 bytes 169432 jump KUBE-SERVICES
                iifname != &amp;quot;eth0&amp;quot; meta l4proto tcp ip daddr 169.254.169.254 tcp dport 8080  counter packets 0 bytes 0 dnat to 169.254.169.252:987
                iifname != &amp;quot;eth0&amp;quot; meta l4proto tcp ip daddr 169.254.169.254 tcp dport 80  counter packets 181 bytes 10860 dnat to 169.254.169.252:988
        }
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;前面说到组件将通过 client ip 确定请求的来源 pod 以及会请求 apiserver 获取 service account，这里就涉及到组件是使用的什么凭证来访问 apiserver。
组件使用的是节点上 kubelet 的凭证来访问的 apiserver（前面的组件 YAML 中包含了挂载 kubelet kubeconfig 的配置）。
同时在部署组件时，将额外为 kubelet 的凭证授予 pods 和 serviceaccounts 的 get/list/watch RBAC 权限，
用于获取当前节点的 pod 以及 service account 信息:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    components.gke.io/component-name: gke-metadata-server
    components.gke.io/component-version: 0.4.301
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
  name: gce:gke-metadata-server-reader
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: gce:gke-metadata-server-reader
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:nodes
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    components.gke.io/component-name: gke-metadata-server
    components.gke.io/component-version: 0.4.301
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
  name: gce:gke-metadata-server-reader
rules:
- apiGroups:
  - &amp;quot;&amp;quot;
  resources:
  - pods
  - serviceaccounts
  verbs:
  - get
  - watch
  - list
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;如果 pod 使用的 service account 没有绑定 IAM 角色，pod 内应用访问元数据服务获取的 sts token 将会是节点默认的 google serivce account 的 sts token。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="service-account-token"&gt;
&lt;h2 id="hidservice-account-token"&gt;service account token&lt;a class="headerlink" href="#hidservice-account-token" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;对于每个 pod 内程序发起的请求，gke-metadata-server 组件不是直接使用 pod 容器所挂载 service account token，
而是请求 apiserver 生成了一份新的 service account token。&lt;/p&gt;
&lt;p&gt;容器所挂载的 service account token 的 payload 示例如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{
  &amp;quot;aud&amp;quot;: [
    &amp;quot;https://container.googleapis.com/v1/projects/test-gke-XXXXXX/locations/us-central1/clusters/test&amp;quot;
  ],
  &amp;quot;exp&amp;quot;: ...,
  &amp;quot;iat&amp;quot;: ...,
  &amp;quot;iss&amp;quot;: &amp;quot;https://container.googleapis.com/v1/projects/test-gke-XXXXXX/locations/us-central1/clusters/test&amp;quot;,
  &amp;quot;jti&amp;quot;: &amp;quot;...&amp;quot;,
  &amp;quot;kubernetes.io&amp;quot;: {...},
  &amp;quot;nbf&amp;quot;: ...,
  &amp;quot;sub&amp;quot;: &amp;quot;system:serviceaccount:demo-ns:demo-sa&amp;quot;
}
&lt;/pre&gt;
&lt;p&gt;组件请求 apiserver 所生成的 service account token 的 payload 示例如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{
  &amp;quot;aud&amp;quot;: [
    &amp;quot;test-gke-XXXXXX.svc.id.goog&amp;quot;
  ],
  &amp;quot;exp&amp;quot;: ...,
  &amp;quot;iat&amp;quot;: ...,
  &amp;quot;iss&amp;quot;: &amp;quot;https://container.googleapis.com/v1/projects/test-gke-XXXXXX/locations/us-central1/clusters/test&amp;quot;,
  &amp;quot;jti&amp;quot;: &amp;quot;...&amp;quot;,
  &amp;quot;kubernetes.io&amp;quot;: {...},
  &amp;quot;nbf&amp;quot;: ...,
  &amp;quot;sub&amp;quot;: &amp;quot;system:serviceaccount:demo-ns:demo-sa&amp;quot;
}
&lt;/pre&gt;
&lt;p&gt;可以看到，主要的区别是 aud 的内容不一样。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sts-token"&gt;
&lt;h2 id="hidsts-token"&gt;sts token&lt;a class="headerlink" href="#hidsts-token" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;gke-metadata-server 组件将使用获取到的 service account token 访问 STS 的
&lt;a class="reference external" href="https://cloud.google.com/iam/docs/reference/sts/rest/v1/TopLevel/token"&gt;token API&lt;/a&gt; 获取一份 sts token。&lt;/p&gt;
&lt;p&gt;对应的请求示例如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:authority: sts.googleapis.com
:method: POST
:path: /v1/token?alt=json&amp;amp;prettyPrint=false
:scheme: https
x-goog-api-client: gl-go/1.23.0--20240626-RC01 cl/646990413 +5a18e79687 X:fieldtrack,boringcrypto gdcl/0.177.0
user-agent: google-api-go-client/0.5 gke-metadata-server
content-type: application/json
content-length: 1673
accept-encoding: gzip

{&amp;quot;audience&amp;quot;:&amp;quot;identitynamespace:test-gke-XXXXXX.svc.id.goog:https://container.googleapis.com/v1/projects/test-gke-XXXXXX/locations/us-central1/clusters/test&amp;quot;,&amp;quot;grantType&amp;quot;:&amp;quot;urn:ietf:params:oauth:grant-type:token-exchange&amp;quot;,&amp;quot;requestedTokenType&amp;quot;:&amp;quot;urn:ietf:params:oauth:token-type:access_token&amp;quot;,&amp;quot;scope&amp;quot;:&amp;quot;https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/userinfo.email&amp;quot;,&amp;quot;subjectToken&amp;quot;:&amp;quot;XXX.XXX.XXX&amp;quot;,&amp;quot;subjectTokenType&amp;quot;:&amp;quot;urn:ietf:params:oauth:token-type:jwt&amp;quot;}

:status: 200
content-type: application/json; charset=UTF-8
vary: Origin
vary: X-Origin
vary: Referer
content-encoding: gzip
date: ...
server: scaffolding on HTTPServer2
content-length: 1061
x-xss-protection: 0
x-frame-options: SAMEORIGIN
x-content-type-options: nosniff

{&amp;quot;access_token&amp;quot;:&amp;quot;ya29.d.XXX&amp;quot;,&amp;quot;issued_token_type&amp;quot;:&amp;quot;urn:ietf:params:oauth:token-type:access_token&amp;quot;,&amp;quot;token_type&amp;quot;:&amp;quot;Bearer&amp;quot;,&amp;quot;expires_in&amp;quot;:3599}
&lt;/pre&gt;
&lt;p&gt;其中请求 body 格式化后的内容如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{
  &amp;quot;audience&amp;quot;: &amp;quot;identitynamespace:test-gke-XXXXXX.svc.id.goog:https://container.googleapis.com/v1/projects/test-gke-XXXXXX/locations/us-central1/clusters/test&amp;quot;,
  &amp;quot;grantType&amp;quot;: &amp;quot;urn:ietf:params:oauth:grant-type:token-exchange&amp;quot;,
  &amp;quot;requestedTokenType&amp;quot;: &amp;quot;urn:ietf:params:oauth:token-type:access_token&amp;quot;,
  &amp;quot;scope&amp;quot;: &amp;quot;https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/userinfo.email&amp;quot;,
  &amp;quot;subjectToken&amp;quot;: &amp;quot;XXX.XXX.XXX&amp;quot;,
  &amp;quot;subjectTokenType&amp;quot;: &amp;quot;urn:ietf:params:oauth:token-type:jwt&amp;quot;
}
&lt;/pre&gt;
&lt;p&gt;响应 body 格式化后的内容如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{
  &amp;quot;access_token&amp;quot;: &amp;quot;ya29.d.XXX&amp;quot;,
  &amp;quot;issued_token_type&amp;quot;: &amp;quot;urn:ietf:params:oauth:token-type:access_token&amp;quot;,
  &amp;quot;token_type&amp;quot;: &amp;quot;Bearer&amp;quot;,
  &amp;quot;expires_in&amp;quot;: 3599
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="gke-workload-identity"&gt;
&lt;h2 id="hidgke-workload-identity"&gt;与 GKE Workload Identity 的区别&lt;a class="headerlink" href="#hidgke-workload-identity" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Workload Identity Federation for GKE 与 GKE Workload Identity 特性（又叫 link Kubernetes ServiceAccounts to IAM）的区别如下：&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="29%" /&gt;
&lt;col width="26%" /&gt;
&lt;col width="45%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;比较项&lt;/th&gt;
&lt;th class="head"&gt;GKE Workload Identity&lt;/th&gt;
&lt;th class="head"&gt;Workload Identity Federation for GKE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;需要创建 Google service account (GSA)&lt;/td&gt;
&lt;td&gt;需要&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不需要&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;需要配置 GSA 绑定的 IAM 角色&lt;/td&gt;
&lt;td&gt;需要&lt;/td&gt;
&lt;td&gt;需要配置 k8s service account (KSA) 绑定的角色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;需要配置允许使用 KSA 扮演 GSA&lt;/td&gt;
&lt;td&gt;需要&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不需要&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;需要在集群内配置 KSA 的 GSA 信息&lt;/td&gt;
&lt;td&gt;需要&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不需要&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;绑定角色时支持指定多个 KSA/GSA&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;支持&lt;/strong&gt; 指定多个，比如某个命名空间下的所有SA, 某个集群内的所有SA&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;支持 project + namespace + KSA 维度授权&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;支持 cluster + namespace + KSA 维度授权&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;不支持使用 hostNetwork 的应用&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;依赖部署 gke-metadata-server 组件&lt;/td&gt;
&lt;td&gt;依赖&lt;/td&gt;
&lt;td&gt;依赖&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;云产品API对获取的 sts token 的支持情况&lt;/td&gt;
&lt;td&gt;几乎所有云产品 API 都支持&lt;/td&gt;
&lt;td&gt;大部分云产品API都支持，部分云产品有限支持，少量云产品不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;BTW, 虽然 Workload Identity Federation for GKE 方案的官方教程和文档中都是说的需要依赖 gke-metadata-server 这个组件，
但是从前面的内容中我们也可以看到：我们其实也可以在不安装 gke-metadata-server 组件的情况下，使用该方案。
具体来说就是，我们可以通过为应用 Pod 挂载所需的 service account token 然后在应用程序内直接访问
STS 提供的 Token API 的方式来解除对该组件的依赖。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h2 id="hidsection-4"&gt;参考资料&lt;a class="headerlink" href="#hidsection-4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cloud.google.com/blog/products/identity-security/make-iam-for-gke-easier-to-use-with-workload-identity-federation"&gt;Make IAM for GKE easier to use with Workload Identity Federation | Google Cloud Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity"&gt;Authenticate to Google Cloud APIs from GKE workloads &amp;nbsp;|&amp;nbsp; Google Kubernetes Engine (GKE)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cloud.google.com/kubernetes-engine/docs/concepts/workload-identity"&gt;About Workload Identity Federation for GKE &amp;nbsp;|&amp;nbsp; Google Kubernetes Engine (GKE) &amp;nbsp;|&amp;nbsp; Google Cloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cloud.google.com/iam/docs/federated-identity-supported-services"&gt;Identity federation: products and limitations &amp;nbsp;|&amp;nbsp; IAM Documentation &amp;nbsp;|&amp;nbsp; Google Cloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cloud.google.com/iam/docs/reference/sts/rest/v1/TopLevel/token"&gt;Method: token &amp;nbsp;|&amp;nbsp; IAM Documentation &amp;nbsp;|&amp;nbsp; Google Cloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cloud.google.com/compute/docs/metadata/overview"&gt;About VM metadata &amp;nbsp;|&amp;nbsp; Compute Engine Documentation &amp;nbsp;|&amp;nbsp; Google Cloud&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sun, 05 Jan 2025 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2025-01-05:2025/01/security-deep-dive-into-gcp-workload-identity-federation-for-gke-feature.html</guid><category>kubernetes</category><category>k8s</category><category>gcp</category><category>gke</category><category>Workload Identity Federation for GKE</category><category>cloud-security</category></item><item><title>Exploring Workload Identity Federation for GKE</title><link>https://mozillazg.com/2025/01/security-deep-dive-into-gcp-workload-identity-federation-for-gke-feature-en.html</link><description>&lt;p&gt;In this article, we will briefly explore a feature called &amp;quot;&lt;a class="reference external" href="https://cloud.google.com/blog/products/identity-security/make-iam-for-gke-easier-to-use-with-workload-identity-federation"&gt;Workload Identity Federation for GKE&lt;/a&gt;&amp;quot;
that was recently announced by GKE in their official blog.&lt;/p&gt;
&lt;div class="section" id="features-overview"&gt;
&lt;h2 id="hidfeatures-overview"&gt;Features Overview&lt;a class="headerlink" href="#hidfeatures-overview" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Workload Identity Federation for GKE is an improved version of the original GKE Workload Identity feature.
The main improvement is that it needs less configuration and offers better user experience.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-to-use"&gt;
&lt;h2 id="hidhow-to-use"&gt;How to Use&lt;a class="headerlink" href="#hidhow-to-use" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Follow these steps to try this feature:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;Create a GKE cluster with Workload Identity Federation for GKE enabled. You can find this option at:
Create Cluster - Security - Enable Workload Identity.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Link IAM roles to the service account used by your test application. One service account can have multiple roles.
For example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ kubectl create ns demo-ns
$ kubectl -n demo-ns create serviceaccount demo-sa

$ gcloud projects add-iam-policy-binding projects/test-gke-XXX \
    --role=roles/container.clusterViewer \
    --member=principal://iam.googleapis.com/projects/23182XXXXXXX/locations/global/workloadIdentityPools/test-gke-XXXXXX.svc.id.goog/subject/ns/&amp;lt;namespace-name&amp;gt;/sa/&amp;lt;service-account-name&amp;gt; \
    --condition=None

$ gcloud storage buckets add-iam-policy-binding gs://&amp;lt;bucket-name&amp;gt; \
--role=roles/storage.objectViewer \
--member=principal://iam.googleapis.com/projects/23182XXXXXXX/locations/global/workloadIdentityPools/test-gke-XXXXXX.svc.id.goog/subject/ns/&amp;lt;namespace-name&amp;gt;/sa/&amp;lt;service-account-name&amp;gt; \
--condition=None
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Deploy the test application. The application pod needs to use the namespace and service account from step 2,
and add nodeSelector to ensure scheduling on nodes with the Workload Identity Federation for GKE feature enabled&lt;/p&gt;
&lt;pre class="literal-block"&gt;
apiVersion: v1
kind: Pod
metadata:
  name: test-pod
  namespace: demo-ns
spec:
  nodeSelector:
    iam.gke.io/gke-metadata-server-enabled: &amp;quot;true&amp;quot;
  serviceAccountName: demo-sa
  containers:
  - name: test-pod
    image: google/cloud-sdk:slim
    command: [&amp;quot;sleep&amp;quot;,&amp;quot;infinity&amp;quot;]
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;After the pod is running, enter the test-pod container and access the instance metadata service to obtain the STS token.
The official SDK used by actual business applications will use a similar method to access the instance metadata service to
obtain STS tokens for requesting cloud product APIs.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$&lt;span class="w"&gt; &lt;/span&gt;gcloud&lt;span class="w"&gt; &lt;/span&gt;auth&lt;span class="w"&gt; &lt;/span&gt;print-access-token
&lt;span class="w"&gt; &lt;/span&gt;ya29.d.XXX
$&lt;span class="w"&gt; &lt;/span&gt;curl&lt;span class="w"&gt; &lt;/span&gt;-H&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Metadata-Flavor: Google&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;access_token&amp;quot;&lt;/span&gt;:&lt;span class="s2"&gt;&amp;quot;ya29.d.XXX&amp;quot;&lt;/span&gt;,&lt;span class="s2"&gt;&amp;quot;expires_in&amp;quot;&lt;/span&gt;:3423,&lt;span class="s2"&gt;&amp;quot;token_type&amp;quot;&lt;/span&gt;:&lt;span class="s2"&gt;&amp;quot;Bearer&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol class="arabic simple" start="5"&gt;
&lt;li&gt;The obtained STS token will have all the permissions of the roles associated in step 2.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$&lt;span class="w"&gt; &lt;/span&gt;gcloud&lt;span class="w"&gt; &lt;/span&gt;container&lt;span class="w"&gt; &lt;/span&gt;node-pools&lt;span class="w"&gt; &lt;/span&gt;list&lt;span class="w"&gt; &lt;/span&gt;--zone&lt;span class="w"&gt; &lt;/span&gt;us-central1&lt;span class="w"&gt; &lt;/span&gt;--cluster&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nb"&gt;test&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;NAME&lt;span class="w"&gt;          &lt;/span&gt;MACHINE_TYPE&lt;span class="w"&gt;  &lt;/span&gt;DISK_SIZE_GB&lt;span class="w"&gt;  &lt;/span&gt;NODE_VERSION
&lt;span class="w"&gt; &lt;/span&gt;default-pool&lt;span class="w"&gt;  &lt;/span&gt;e2-medium&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="m"&gt;100&lt;/span&gt;&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.30.6-gke.1125000

$&lt;span class="w"&gt; &lt;/span&gt;curl&lt;span class="w"&gt; &lt;/span&gt;-X&lt;span class="w"&gt; &lt;/span&gt;GET&lt;span class="w"&gt; &lt;/span&gt;-H&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Authorization: Bearer &lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;gcloud&lt;span class="w"&gt; &lt;/span&gt;auth&lt;span class="w"&gt; &lt;/span&gt;print-access-token&lt;span class="k"&gt;)&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;https://storage.googleapis.com/storage/v1/b/demo-gke-workload-identity-federation/o&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;kind&amp;quot;&lt;/span&gt;:&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;storage#objects&amp;quot;&lt;/span&gt;
&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="workflow-explained"&gt;
&lt;h2 id="hidworkflow-explained"&gt;Workflow Explained&lt;a class="headerlink" href="#hidworkflow-explained" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The workflow of Workload Identity Federation for GKE feature is as follows:&lt;/p&gt;
&lt;p&gt;&lt;img alt="image" src="/static/images/security/gke-workload-identity-federation-for-gke-en.png" /&gt;&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;When a program in the application Pod container requests the instance metadata service
(accessing &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;http://metadata.google.internal&lt;/span&gt;&lt;/tt&gt;, which actually accesses &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;http://169.254.169.254:80&lt;/span&gt;&lt;/tt&gt;)
to get an STS token, the request will be redirected to 169.254.169.252:988.
169.254.169.252:988 is the port listened to by the gke-metadata-server service deployed on the node.&lt;/li&gt;
&lt;li&gt;When the gke-metadata-server service receives the request, it will determine which Pod the request came from based on the client IP,
then request the apiserver to generate a token corresponding to the service account used by that Pod.&lt;/li&gt;
&lt;li&gt;gke-metadata-server will use the obtained service account token to access GCP's
&lt;a class="reference external" href="https://cloud.google.com/iam/docs/reference/sts/rest/v1/TopLevel/token"&gt;STS API&lt;/a&gt; to get an STS token,
finally gke-metadata-server returns the obtained STS token to the client.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There are several key components and information that need special attention in this workflow, which will be explained one by one below.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="gke-metadata-server"&gt;
&lt;h2 id="hidgke-metadata-server"&gt;gke-metadata-server&lt;a class="headerlink" href="#hidgke-metadata-server" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When enabling the Workload Identity Federation for GKE feature at the cluster or node pool level,
a component named gke-metadata-server will be automatically deployed in the cluster.
The workload YAML for this component is as follows:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
apiVersion: apps/v1
kind: DaemonSet
metadata:
  annotations:
    deprecated.daemonset.template.generation: &amp;quot;1&amp;quot;
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
    k8s-app: gke-metadata-server
  name: gke-metadata-server
  namespace: kube-system
spec:
  minReadySeconds: 90
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      k8s-app: gke-metadata-server
  template:
    metadata:
      annotations:
        components.gke.io/component-name: gke-metadata-server
        components.gke.io/component-version: 0.4.301
        monitoring.gke.io/path: /metricz
      creationTimestamp: null
      labels:
        addonmanager.kubernetes.io/mode: Reconcile
        k8s-app: gke-metadata-server
    spec:
      containers:
      - command:
        - /gke-metadata-server
        - --logtostderr
        - --token-exchange-endpoint=https://securetoken.googleapis.com/v1/identitybindingtoken
        - --workload-pool=test-gke-XXXXXX.svc.id.goog
        - --alts-service-suffixes-using-node-identity=storage.googleapis.com,bigtable.googleapis.com,bigtable2.googleapis.com,bigtablerls.googleapis.com,spanner.googleapis.com,spanner2.googleapis.com,spanner-rls.googleapis.com,grpclb.directpath.google.internal,grpclb-dualstack.directpath.google.internal,staging-wrenchworks.sandbox.googleapis.com,preprod-spanner.sandbox.googleapis.com,wrenchworks-loadtest.googleapis.com,wrenchworks-nonprod.googleapis.com
        - --identity-provider=https://container.googleapis.com/v1/projects/test-gke-XXXXXX/locations/us-central1/clusters/test
        - --passthrough-ksa-list=anthos-identity-service:gke-oidc-envoy-sa,anthos-identity-service:gke-oidc-service-sa,gke-managed-dpv2-observability:hubble-relay,kube-system:antrea-controller,kube-system:container-watcher-pod-reader,kube-system:coredns,kube-system:egress-nat-controller,kube-system:event-exporter-sa,kube-system:fluentd-gcp-scaler,kube-system:gke-metrics-agent,kube-system:gke-spiffe-node-agent,kube-system:heapster,kube-system:konnectivity-agent,kube-system:kube-dns,kube-system:maintenance-handler,kube-system:metadata-agent,kube-system:network-metering-agent,kube-system:node-local-dns,kube-system:pkgextract-service,kube-system:pkgextract-cleanup-service,kube-system:securityprofile-controller,istio-system:istio-ingressgateway-service-account,istio-system:cluster-local-gateway-service-account,csm:csm-sync-agent,knative-serving:controller,kube-system:pdcsi-node-sa,kube-system:gcsfusecsi-node-sa,gmp-system:collector,gke-gmp-system:collector,gke-managed-cim:kube-state-metrics
        - --attributes=cluster-name=test,cluster-uid=392f63049deXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX,cluster-location=us-central1
        - --cluster-uid=392f63049ded410XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        - --sts-endpoint=https://sts.googleapis.com
        - --token-exchange-mode=sts
        - --cloud-monitoring-endpoint=monitoring.googleapis.com:443
        - --iam-cred-service-endpoint=https://iamcredentials.googleapis.com
        - --cluster-project-number=2318XXXXXXXX
        - --cluster-location=us-central1
        - --cluster-name=test
        - --component-version=0.4.301
        - --ksa-cache-mode=watchchecker
        - --kcp-allow-watch-checker=true
        - --enable-mds-csi-driver=true
        - --csi-socket=/csi/csi.sock
        - --volumes-db=/var/run/gkemds.gke.io/csi/volumes.boltdb
        env:
        - name: GOMEMLIMIT
          value: &amp;quot;94371840&amp;quot;
        image: us-central1-artifactregistry.gcr.io/gke-release/gke-release/gke-metadata-server:gke_metadata_server_20240702.00_p0&amp;#64;sha256:aea9cc887c91b9a05e5bb4bb604180772594a01f0828bbfacf30c77562ac7205
        imagePullPolicy: IfNotPresent
        livenessProbe:
          failureThreshold: 3
          httpGet:
            host: 127.0.0.1
            path: /healthz
            port: 989
            scheme: HTTP
          initialDelaySeconds: 30
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 3
        name: gke-metadata-server
        ports:
        - containerPort: 987
          name: alts
          protocol: TCP
        - containerPort: 988
          name: metadata-server
          protocol: TCP
        - containerPort: 989
          name: debug-port
          protocol: TCP
        readinessProbe:
          failureThreshold: 3
          httpGet:
            host: 127.0.0.1
            path: /healthz
            port: 989
            scheme: HTTP
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        resources:
          limits:
            memory: 100Mi
          requests:
            cpu: 100m
            memory: 100Mi
        securityContext:
          privileged: true
          readOnlyRootFilesystem: true
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
        volumeMounts:
        - mountPath: /var/lib/kubelet/kubeconfig
          name: kubelet-credentials
          readOnly: true
        - mountPath: /var/lib/kubelet/pki/
          name: kubelet-certs
          readOnly: true
        - mountPath: /var/run/
          name: container-runtime-interface
        - mountPath: /etc/srv/kubernetes/pki
          name: kubelet-pki
          readOnly: true
        - mountPath: /etc/ssl/certs/
          name: ca-certificates
          readOnly: true
        - mountPath: /home/kubernetes/bin/gke-exec-auth-plugin
          name: gke-exec-auth-plugin
          readOnly: true
        - mountPath: /sys/firmware/efi/efivars/
          name: efivars
          readOnly: true
        - mountPath: /dev/tpm0
          name: vtpm
          readOnly: true
        - mountPath: /csi
          name: csi-socket-dir
        - mountPath: /var/run/gkemds.gke.io/csi
          name: state-dir
        - mountPath: /var/lib/kubelet/pods
          mountPropagation: Bidirectional
          name: pods-dir
        - mountPath: /registration
          name: kubelet-registration-dir
      dnsPolicy: Default
      hostNetwork: true
      nodeSelector:
        iam.gke.io/gke-metadata-server-enabled: &amp;quot;true&amp;quot;
        kubernetes.io/os: linux
      priorityClassName: system-node-critical
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      serviceAccount: gke-metadata-server
      serviceAccountName: gke-metadata-server
      terminationGracePeriodSeconds: 30
      tolerations:
      - effect: NoExecute
        operator: Exists
      - effect: NoSchedule
        operator: Exists
      - key: components.gke.io/gke-managed-components
        operator: Exists
      volumes:
      - hostPath:
          path: /var/lib/kubelet/pki/
          type: Directory
        name: kubelet-certs
      - hostPath:
          path: /var/lib/kubelet/kubeconfig
          type: File
        name: kubelet-credentials
      - hostPath:
          path: /var/run/
          type: Directory
        name: container-runtime-interface
      - hostPath:
          path: /etc/srv/kubernetes/pki/
          type: Directory
        name: kubelet-pki
      - hostPath:
          path: /etc/ssl/certs/
          type: Directory
        name: ca-certificates
      - hostPath:
          path: /home/kubernetes/bin/gke-exec-auth-plugin
          type: File
        name: gke-exec-auth-plugin
      - hostPath:
          path: /sys/firmware/efi/efivars/
          type: Directory
        name: efivars
      - hostPath:
          path: /dev/tpm0
          type: CharDevice
        name: vtpm
      - hostPath:
          path: /var/lib/kubelet/plugins/gkemds.gke.io
          type: DirectoryOrCreate
        name: csi-socket-dir
      - hostPath:
          path: /var/lib/kubelet/pods
          type: Directory
        name: pods-dir
      - hostPath:
          path: /var/lib/kubelet/plugins_registry
          type: Directory
        name: kubelet-registration-dir
      - hostPath:
          path: /var/lib/kubelet/plugins
          type: Directory
        name: kubelet-plugins-dir
      - hostPath:
          path: /var/run/gkemds.gke.io/csi
          type: DirectoryOrCreate
        name: state-dir
&lt;/pre&gt;
&lt;p&gt;The gke-metadata-server component has the following characteristics:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;The component's workload is a DaemonSet.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;The component Pod uses &lt;tt class="docutils literal"&gt;hostNetwork: true&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;privileged: true&lt;/tt&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;The service inside the component will listen on ports 987, 988, and 989, where port 988 will be used to
receive redirected requests for accessing the instance metadata service:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ss -atnlp |grep gke
LISTEN 0      1024               *:987              *:*    users:((&amp;quot;gke-metadata-se&amp;quot;,pid=183706,fd=10))
LISTEN 0      1024               *:989              *:*    users:((&amp;quot;gke-metadata-se&amp;quot;,pid=183706,fd=12))
LISTEN 0      1024               *:988              *:*    users:((&amp;quot;gke-metadata-se&amp;quot;,pid=183706,fd=15))
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;The previously mentioned IP 169.254.169.252 is the local loopback (lo) IP address,
so the port 988 listened to by gke-metadata-server
includes the previously mentioned &lt;tt class="docutils literal"&gt;169.254.169.252:988&lt;/tt&gt; port:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet 169.254.169.252/32 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;All nodes with the Workload Identity Federation for GKE feature enabled will be configured with the following
nftables rules during initialization, ensuring that traffic from business containers requesting
the metadata service (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;http://metadata.google.internal&lt;/span&gt;&lt;/tt&gt;, 169.254.169.254:80)
will be redirected to the &lt;tt class="docutils literal"&gt;169.254.169.252:988&lt;/tt&gt; port listened to by the component:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
table ip nat {
        chain PREROUTING {
                type nat hook prerouting priority dstnat; policy accept;
                 counter packets 2143 bytes 169432 jump KUBE-SERVICES
                iifname != &amp;quot;eth0&amp;quot; meta l4proto tcp ip daddr 169.254.169.254 tcp dport 8080  counter packets 0 bytes 0 dnat to 169.254.169.252:987
                iifname != &amp;quot;eth0&amp;quot; meta l4proto tcp ip daddr 169.254.169.254 tcp dport 80  counter packets 181 bytes 10860 dnat to 169.254.169.252:988
        }
}
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;As mentioned earlier, the component will determine the source pod through the client IP
and request the apiserver to get the service account. This involves what credentials the component uses to access the apiserver.
The component uses the kubelet's credentials on the node to access the apiserver
(the component YAML shown earlier includes the configuration for mounting kubelet kubeconfig).
Additionally, when deploying the component, extra RBAC permissions for get/list/watch on pods
and serviceaccounts will be granted to the kubelet's credentials,
used for obtaining information about pods and service accounts on the current node:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  annotations:
    components.gke.io/component-name: gke-metadata-server
    components.gke.io/component-version: 0.4.301
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
  name: gce:gke-metadata-server-reader
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: gce:gke-metadata-server-reader
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:nodes
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  annotations:
    components.gke.io/component-name: gke-metadata-server
    components.gke.io/component-version: 0.4.301
  labels:
    addonmanager.kubernetes.io/mode: Reconcile
  name: gce:gke-metadata-server-reader
rules:
- apiGroups:
  - &amp;quot;&amp;quot;
  resources:
  - pods
  - serviceaccounts
  verbs:
  - get
  - watch
  - list
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;If the service account used by the pod is not bound to any IAM role,
the STS token obtained by the application in the pod when accessing the metadata service will
be the STS token of the node's default Google service account.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="service-account-token"&gt;
&lt;h2 id="hidservice-account-token"&gt;service account token&lt;a class="headerlink" href="#hidservice-account-token" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For requests initiated by programs within each pod, the gke-metadata-server component
doesn't directly use the service account token mounted in the pod container,
but instead requests the apiserver to generate a new service account token.&lt;/p&gt;
&lt;p&gt;Here's an example of the payload for a service account token mounted in the container:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{
  &amp;quot;aud&amp;quot;: [
    &amp;quot;https://container.googleapis.com/v1/projects/test-gke-XXXXXX/locations/us-central1/clusters/test&amp;quot;
  ],
  &amp;quot;exp&amp;quot;: ...,
  &amp;quot;iat&amp;quot;: ...,
  &amp;quot;iss&amp;quot;: &amp;quot;https://container.googleapis.com/v1/projects/test-gke-XXXXXX/locations/us-central1/clusters/test&amp;quot;,
  &amp;quot;jti&amp;quot;: &amp;quot;...&amp;quot;,
  &amp;quot;kubernetes.io&amp;quot;: {...},
  &amp;quot;nbf&amp;quot;: ...,
  &amp;quot;sub&amp;quot;: &amp;quot;system:serviceaccount:demo-ns:demo-sa&amp;quot;
}
&lt;/pre&gt;
&lt;p&gt;Here's an example of the payload for a service account token generated by the apiserver when requested by the component:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{
  &amp;quot;aud&amp;quot;: [
    &amp;quot;test-gke-XXXXXX.svc.id.goog&amp;quot;
  ],
  &amp;quot;exp&amp;quot;: ...,
  &amp;quot;iat&amp;quot;: ...,
  &amp;quot;iss&amp;quot;: &amp;quot;https://container.googleapis.com/v1/projects/test-gke-XXXXXX/locations/us-central1/clusters/test&amp;quot;,
  &amp;quot;jti&amp;quot;: &amp;quot;...&amp;quot;,
  &amp;quot;kubernetes.io&amp;quot;: {...},
  &amp;quot;nbf&amp;quot;: ...,
  &amp;quot;sub&amp;quot;: &amp;quot;system:serviceaccount:demo-ns:demo-sa&amp;quot;
}
&lt;/pre&gt;
&lt;p&gt;As we can see, the main difference is in the content of the &lt;tt class="docutils literal"&gt;aud&lt;/tt&gt; field.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sts-token"&gt;
&lt;h2 id="hidsts-token"&gt;sts token&lt;a class="headerlink" href="#hidsts-token" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The gke-metadata-server component will use the obtained service account token to access the STS
&lt;a class="reference external" href="https://cloud.google.com/iam/docs/reference/sts/rest/v1/TopLevel/token"&gt;token API&lt;/a&gt; to get an STS token.&lt;/p&gt;
&lt;p&gt;Here's an example of the corresponding request:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
:authority: sts.googleapis.com
:method: POST
:path: /v1/token?alt=json&amp;amp;prettyPrint=false
:scheme: https
x-goog-api-client: gl-go/1.23.0--20240626-RC01 cl/646990413 +5a18e79687 X:fieldtrack,boringcrypto gdcl/0.177.0
user-agent: google-api-go-client/0.5 gke-metadata-server
content-type: application/json
content-length: 1673
accept-encoding: gzip

{&amp;quot;audience&amp;quot;:&amp;quot;identitynamespace:test-gke-XXXXXX.svc.id.goog:https://container.googleapis.com/v1/projects/test-gke-XXXXXX/locations/us-central1/clusters/test&amp;quot;,&amp;quot;grantType&amp;quot;:&amp;quot;urn:ietf:params:oauth:grant-type:token-exchange&amp;quot;,&amp;quot;requestedTokenType&amp;quot;:&amp;quot;urn:ietf:params:oauth:token-type:access_token&amp;quot;,&amp;quot;scope&amp;quot;:&amp;quot;https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/userinfo.email&amp;quot;,&amp;quot;subjectToken&amp;quot;:&amp;quot;XXX.XXX.XXX&amp;quot;,&amp;quot;subjectTokenType&amp;quot;:&amp;quot;urn:ietf:params:oauth:token-type:jwt&amp;quot;}

:status: 200
content-type: application/json; charset=UTF-8
vary: Origin
vary: X-Origin
vary: Referer
content-encoding: gzip
date: ...
server: scaffolding on HTTPServer2
content-length: 1061
x-xss-protection: 0
x-frame-options: SAMEORIGIN
x-content-type-options: nosniff

{&amp;quot;access_token&amp;quot;:&amp;quot;ya29.d.XXX&amp;quot;,&amp;quot;issued_token_type&amp;quot;:&amp;quot;urn:ietf:params:oauth:token-type:access_token&amp;quot;,&amp;quot;token_type&amp;quot;:&amp;quot;Bearer&amp;quot;,&amp;quot;expires_in&amp;quot;:3599}
&lt;/pre&gt;
&lt;p&gt;The formatted content of the request body is as follows:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{
  &amp;quot;audience&amp;quot;: &amp;quot;identitynamespace:test-gke-XXXXXX.svc.id.goog:https://container.googleapis.com/v1/projects/test-gke-XXXXXX/locations/us-central1/clusters/test&amp;quot;,
  &amp;quot;grantType&amp;quot;: &amp;quot;urn:ietf:params:oauth:grant-type:token-exchange&amp;quot;,
  &amp;quot;requestedTokenType&amp;quot;: &amp;quot;urn:ietf:params:oauth:token-type:access_token&amp;quot;,
  &amp;quot;scope&amp;quot;: &amp;quot;https://www.googleapis.com/auth/cloud-platform https://www.googleapis.com/auth/userinfo.email&amp;quot;,
  &amp;quot;subjectToken&amp;quot;: &amp;quot;XXX.XXX.XXX&amp;quot;,
  &amp;quot;subjectTokenType&amp;quot;: &amp;quot;urn:ietf:params:oauth:token-type:jwt&amp;quot;
}
&lt;/pre&gt;
&lt;p&gt;The formatted content of the response body is as follows:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
{
  &amp;quot;access_token&amp;quot;: &amp;quot;ya29.d.XXX&amp;quot;,
  &amp;quot;issued_token_type&amp;quot;: &amp;quot;urn:ietf:params:oauth:token-type:access_token&amp;quot;,
  &amp;quot;token_type&amp;quot;: &amp;quot;Bearer&amp;quot;,
  &amp;quot;expires_in&amp;quot;: 3599
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="differences-from-gke-workload-identity"&gt;
&lt;h2 id="hiddifferences-from-gke-workload-identity"&gt;Differences from GKE Workload Identity&lt;a class="headerlink" href="#hiddifferences-from-gke-workload-identity" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Here are the differences between Workload Identity Federation for GKE and GKE Workload Identity feature
(also known as linking Kubernetes ServiceAccounts to IAM):&lt;/p&gt;
&lt;table border="1" class="docutils"&gt;
&lt;colgroup&gt;
&lt;col width="29%" /&gt;
&lt;col width="26%" /&gt;
&lt;col width="45%" /&gt;
&lt;/colgroup&gt;
&lt;thead valign="bottom"&gt;
&lt;tr&gt;&lt;th class="head"&gt;Comparison Item&lt;/th&gt;
&lt;th class="head"&gt;GKE Workload Identity&lt;/th&gt;
&lt;th class="head"&gt;Workload Identity Federation for GKE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td&gt;Requires Google service account (GSA)&lt;/td&gt;
&lt;td&gt;Required&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Not Required&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;IAM role binding configuration&lt;/td&gt;
&lt;td&gt;Requires GSA role binding&lt;/td&gt;
&lt;td&gt;Requires k8s service account (KSA) role binding&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;KSA impersonating GSA configuration&lt;/td&gt;
&lt;td&gt;Required&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Not Required&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;GSA info configuration for KSA in cluster&lt;/td&gt;
&lt;td&gt;Required&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Not Required&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Multiple KSA/GSA binding support&lt;/td&gt;
&lt;td&gt;Not supported&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Supported&lt;/strong&gt; (e.g., all SAs in namespace, all SAs in cluster)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Authorization at project + namespace + KSA&lt;/td&gt;
&lt;td&gt;Supported&lt;/td&gt;
&lt;td&gt;Supported&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Authorization at cluster + namespace + KSA&lt;/td&gt;
&lt;td&gt;Not supported&lt;/td&gt;
&lt;td&gt;Not supported&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Support for hostNetwork applications&lt;/td&gt;
&lt;td&gt;Not supported&lt;/td&gt;
&lt;td&gt;Not supported&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Depends on gke-metadata-server component&lt;/td&gt;
&lt;td&gt;Required&lt;/td&gt;
&lt;td&gt;Required&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Cloud API support for obtained STS token&lt;/td&gt;
&lt;td&gt;Almost all cloud product APIs&lt;/td&gt;
&lt;td&gt;Most cloud APIs supported, some limited support, few unsupported&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;By the way, although the official tutorials and documentation for Workload Identity Federation for GKE mention that it requires the gke-metadata-server component,
from what we discussed earlier, we can see that: we can actually use this solution without installing the gke-metadata-server component.
Specifically, we can remove the dependency on this component by mounting the required service account token to the application Pod and then directly accessing
the Token API provided by STS within our applications.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="references"&gt;
&lt;h2 id="hidreferences"&gt;References&lt;a class="headerlink" href="#hidreferences" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cloud.google.com/blog/products/identity-security/make-iam-for-gke-easier-to-use-with-workload-identity-federation"&gt;Make IAM for GKE easier to use with Workload Identity Federation | Google Cloud Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity"&gt;Authenticate to Google Cloud APIs from GKE workloads &amp;nbsp;|&amp;nbsp; Google Kubernetes Engine (GKE)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cloud.google.com/kubernetes-engine/docs/concepts/workload-identity"&gt;About Workload Identity Federation for GKE &amp;nbsp;|&amp;nbsp; Google Kubernetes Engine (GKE) &amp;nbsp;|&amp;nbsp; Google Cloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cloud.google.com/iam/docs/federated-identity-supported-services"&gt;Identity federation: products and limitations &amp;nbsp;|&amp;nbsp; IAM Documentation &amp;nbsp;|&amp;nbsp; Google Cloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cloud.google.com/iam/docs/reference/sts/rest/v1/TopLevel/token"&gt;Method: token &amp;nbsp;|&amp;nbsp; IAM Documentation &amp;nbsp;|&amp;nbsp; Google Cloud&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://cloud.google.com/compute/docs/metadata/overview"&gt;About VM metadata &amp;nbsp;|&amp;nbsp; Compute Engine Documentation &amp;nbsp;|&amp;nbsp; Google Cloud&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sun, 05 Jan 2025 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2025-01-05:2025/01/security-deep-dive-into-gcp-workload-identity-federation-for-gke-feature-en.html</guid><category>kubernetes</category><category>k8s</category><category>gcp</category><category>gke</category><category>Workload Identity Federation for GKE</category><category>cloud-security</category><category>en-version</category></item><item><title>ptcpdump v0.16 ~ v0.26 的主要变更内容</title><link>https://mozillazg.com/2024/11/whats-new-ptcpdump-v1.16-v1.26.html</link><description>&lt;div class="section" id="section-1"&gt;
&lt;h2 id="hidsection-1"&gt;前言&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;距离 &lt;a class="reference external" href="https://mozillazg.com/2024/07/ebpf-ptcpdump-capturing-the-network-traffic-of-a-process-or-container-or-pod.html"&gt;上次首次介绍&lt;/a&gt;
&lt;a class="reference external" href="https://github.com/mozillazg/ptcpdump"&gt;ptcpdump&lt;/a&gt; 项目已经过去好几个月了，
最近这几个月我一直在持续开发这个项目，
本文将按变更顺序介绍一下从上次的 v0.16 版本到最新的 v0.26 版本期间所发布的主要变更内容。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2 id="hidsection-2"&gt;主要变更内容&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="tencentos-opencloudos"&gt;
&lt;h3 id="hidtencentos-opencloudos"&gt;兼容老版本的 TencentOS/OpenCloudOS 系统&lt;a class="headerlink" href="#hidtencentos-opencloudos" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;根据用户 &lt;a class="reference external" href="https://github.com/mozillazg/ptcpdump/issues/89"&gt;反馈&lt;/a&gt; ，
之前的版本无法在老版本的 TencentOS/OpenCloudOS 上运行，
当前最新版本已经支持了如下 TencentOS/OpenCloudOS 系统版本：
OpenCloudOS 7/8/9 and TencentOS Server 2.4/2.6/3.1/3.2 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h3 id="hidsection-3"&gt;在输出中增加父进程信息&lt;a class="headerlink" href="#hidsection-3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;老版本:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
13:44:41.529003 eth0 In IP (tos 0x4, ttl 45, id 45428, offset 0, flags [DF], proto TCP (6), length 52)
    139.178.84.217.443 &amp;gt; 172.19.0.2.42606: Flags [.], cksum 0x5284, seq 3173118145, ack 1385712707, win 118, options [nop,nop,TS val 134560683 ecr 1627716996], length 0
    Process (pid 553587, cmd /usr/bin/wget, args wget kernel.org)
    Container (...)
    Pod (...)
&lt;/pre&gt;
&lt;p&gt;新版本:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
13:44:41.529003 eth0 In IP (tos 0x4, ttl 45, id 45428, offset 0, flags [DF], proto TCP (6), length 52)
    139.178.84.217.443 &amp;gt; 172.19.0.2.42606: Flags [.], cksum 0x5284, seq 3173118145, ack 1385712707, win 118, options [nop,nop,TS val 134560683 ecr 1627716996], length 0
    Process (pid 553587, cmd /usr/bin/wget, args wget kernel.org)
    ParentProc (pid 553296, cmd /bin/sh, args sh)
    Container (...)
    Pod (...)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="dockershim-kubernetes"&gt;
&lt;h3 id="hiddockershim-kubernetes"&gt;支持使用 Dockershim 的老版本 Kubernetes 环境&lt;a class="headerlink" href="#hiddockershim-kubernetes" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;之前的版本无法在使用 Dockershim （准确的说是基于 CRI v1alpha2）的老版本 Kubernetes 环境中获取 Pod 信息，新版本已兼容这种环境。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pod"&gt;
&lt;h3 id="hidpod"&gt;修复按 Pod 名称过滤时，无法支持包含点号的名称&lt;a class="headerlink" href="#hidpod" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;之前的版本中按 Pod 名称过滤时，过滤的名称不能包含英文点号，新版本已兼容包含点号的名称:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
--pod-name foo.bar.default
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="pod-pod"&gt;
&lt;h3 id="hidpod-pod"&gt;修复按 Pod 过滤时，无法支持包含多个容器的 Pod 的场景&lt;a class="headerlink" href="#hidpod-pod" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;之前的版本中按 Pod 过滤时，无法支持 Pod 中存在多个容器的场景，新版本已修复该问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ptcpdump"&gt;
&lt;h3 id="hidptcpdump"&gt;支持同时运行多个 ptcpdump 实例&lt;a class="headerlink" href="#hidptcpdump" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;之前的版本同时只能运行一个 ptcpdump 进程，当运行多个 ptcpdump 进程时，老的进程将不能正常工作（抓不到任何流量），
新版本已修复该问题，在新版本中可以同时运行多个 ptcpdump 进程，多个 ptcpdump 进程不会出现互相干扰或导致其他进程无法抓包的问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pid"&gt;
&lt;h3 id="hidpid"&gt;支持同时过滤多个进程 PID&lt;a class="headerlink" href="#hidpid" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;现在 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--pid&lt;/span&gt;&lt;/tt&gt; 参数支持过滤多个 pid 了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
--pid pid1 --pid pid2
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="micro-nano-time-stamp-precision"&gt;
&lt;h3 id="hidmicro-nano-time-stamp-precision"&gt;新增参数 --micro, --nano, --time-stamp-precision 用于控制输出中的时间格式&lt;a class="headerlink" href="#hidmicro-nano-time-stamp-precision" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;新增参数 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--micro&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--nano&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--time-stamp-precision&lt;/span&gt;&lt;/tt&gt; ，作用和用法对标 tcpdump。&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--micro&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--time-stamp-precision=micro&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
13:36:05.701978 IP 10.0.2.15.22 &amp;gt; 10.0.2.2.59874: Flags [P.], seq 1370707216:1370707292, ack 4569736, win 62780, length 76
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--nano&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--time-stamp-precision=nano&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
13:36:05.701978488 IP 10.0.2.15.22 &amp;gt; 10.0.2.2.59874: Flags [P.], seq 1370707216:1370707292, ack 4569736, win 62780, length 76
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="a-x-xx-x-xx"&gt;
&lt;h3 id="hida-x-xx-x-xx"&gt;新增参数 -A, -x, -xx, -X, -XX 用于控制数据输出格式&lt;a class="headerlink" href="#hida-x-xx-x-xx" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;新增作用和用法对标 tcpdump 的参数 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-A&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-x&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-xx&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-X&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-XX&lt;/span&gt;&lt;/tt&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-A&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:36:38.159559 ens33 curl.244103 Out IP 10.0.2.15.53478 &amp;gt; 203.205.254.157.80: Flags [P.], seq 3293023896:3293023966, ack 1986159173, win 64240, length 70, ParentProc [ptcpdump.244094]
E..nHL&amp;#64;.&amp;#64;...
..........P.G..vbbEP.......GET / HTTP/1.1
Host: qq.com
User-Agent: curl/7.81.0
Accept: */*
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-x&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:36:38.159559 ens33 curl.244103 Out IP 10.0.2.15.53478 &amp;gt; 203.205.254.157.80: Flags [P.], seq 3293023896:3293023966, ack 1986159173, win 64240, length 70, ParentProc [ptcpdump.244094]
        0x0000:  4500 006e 484c 4000 4006 1bc4 0a00 020f
        0x0010:  cbcd fe9d d0e6 0050 c447 8e98 7662 6245
        0x0020:  5018 faf0 d6da 0000 4745 5420 2f20 4854
        0x0030:  5450 2f31 2e31 0d0a 486f 7374 3a20 7171
        0x0040:  2e63 6f6d 0d0a 5573 6572 2d41 6765 6e74
        0x0050:  3a20 6375 726c 2f37 2e38 312e 300d 0a41
        0x0060:  6363 6570 743a 202a 2f2a 0d0a 0d0a
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-xx&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:36:38.159559 ens33 curl.244103 Out IP 10.0.2.15.53478 &amp;gt; 203.205.254.157.80: Flags [P.], seq 3293023896:3293023966, ack 1986159173, win 64240, length 70, ParentProc [ptcpdump.244094]
        0x0000:  0050 56eb bc4e 000c 298e 31f3 0800 4500
        0x0010:  006e 484c 4000 4006 1bc4 0a00 020f cbcd
        0x0020:  fe9d d0e6 0050 c447 8e98 7662 6245 5018
        0x0030:  faf0 d6da 0000 4745 5420 2f20 4854 5450
        0x0040:  2f31 2e31 0d0a 486f 7374 3a20 7171 2e63
        0x0050:  6f6d 0d0a 5573 6572 2d41 6765 6e74 3a20
        0x0060:  6375 726c 2f37 2e38 312e 300d 0a41 6363
        0x0070:  6570 743a 202a 2f2a 0d0a 0d0a
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-X&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:36:38.159559 ens33 curl.244103 Out IP 10.0.2.15.53478 &amp;gt; 203.205.254.157.80: Flags [P.], seq 3293023896:3293023966, ack 1986159173, win 64240, length 70, ParentProc [ptcpdump.244094]
        0x0000:  4500 006e 484c 4000 4006 1bc4 0a00 020f  E..nHL&amp;#64;.&amp;#64;.......
        0x0010:  cbcd fe9d d0e6 0050 c447 8e98 7662 6245  .......P.G..vbbE
        0x0020:  5018 faf0 d6da 0000 4745 5420 2f20 4854  P.......GET / HT
        0x0030:  5450 2f31 2e31 0d0a 486f 7374 3a20 7171  TP/1.1..Host: qq
        0x0040:  2e63 6f6d 0d0a 5573 6572 2d41 6765 6e74  .com..User-Agent
        0x0050:  3a20 6375 726c 2f37 2e38 312e 300d 0a41  : curl/7.81.0..A
        0x0060:  6363 6570 743a 202a 2f2a 0d0a 0d0a       ccept: */*....
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-XX&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:36:38.159559 ens33 curl.244103 Out IP 10.0.2.15.53478 &amp;gt; 203.205.254.157.80: Flags [P.], seq 3293023896:3293023966, ack 1986159173, win 64240, length 70, ParentProc [ptcpdump.244094]
        0x0000:  0050 56eb bc4e 000c 298e 31f3 0800 4500  .PV..N..).1...E.
        0x0010:  006e 484c 4000 4006 1bc4 0a00 020f cbcd  .nHL&amp;#64;.&amp;#64;.........
        0x0020:  fe9d d0e6 0050 c447 8e98 7662 6245 5018  .....P.G..vbbEP.
        0x0030:  faf0 d6da 0000 4745 5420 2f20 4854 5450  ......GET / HTTP
        0x0040:  2f31 2e31 0d0a 486f 7374 3a20 7171 2e63  /1.1..Host: qq.c
        0x0050:  6f6d 0d0a 5573 6572 2d41 6765 6e74 3a20  om..User-Agent:
        0x0060:  6375 726c 2f37 2e38 312e 300d 0a41 6363  curl/7.81.0..Acc
        0x0070:  6570 743a 202a 2f2a 0d0a 0d0a            ept: */*....
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="ptcpdump-docker"&gt;
&lt;h3 id="hidptcpdump-docker"&gt;新增用于编译和运行 ptcpdump 的 Docker 镜像&lt;a class="headerlink" href="#hidptcpdump-docker" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;新增用于编译程序的 Docker 镜像： &lt;tt class="docutils literal"&gt;quay.io/ptcpdump/develop:latest&lt;/tt&gt;
以及用于通过 Docker 运行 ptcpdump 的镜像： &lt;tt class="docutils literal"&gt;quay.io/ptcpdump/ptcpdump:latest&lt;/tt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;可以通过 &lt;tt class="docutils literal"&gt;make &lt;span class="pre"&gt;build-bpf-via-docker&lt;/span&gt;&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;make &lt;span class="pre"&gt;build-via-docker&lt;/span&gt;&lt;/tt&gt; 按需编译 eBPF 程序和 ptcpdump 程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;可以使用类似下面的命令，通过 docker 运行 ptcpdump:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
docker run --privileged --rm -t --net=host --pid=host \
  -v /sys/fs/cgroup:/sys/fs/cgroup:ro \
  quay.io/ptcpdump/ptcpdump:latest ptcpdump -i any -c 2 tcp
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="go-tls-key-log"&gt;
&lt;h3 id="hidgo-tls-key-log"&gt;实验性新功能：在对 Go 程序进行抓包时生成相应的 TLS Key Log 文件&lt;a class="headerlink" href="#hidgo-tls-key-log" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在新版本中还尝试了一个实验性的功能：在对 Go 程序进行抓包时生成相应的 TLS Key Log 文件。&lt;/p&gt;
&lt;p&gt;TLS Key Log 文件又叫 &lt;a class="reference external" href="https://tlswg.org/sslkeylogfile/draft-ietf-tls-keylogfile.html"&gt;SSLKEYLOGFILE&lt;/a&gt; ，
在 Wireshark 中对应的是 pre-master secret 配置，
第三方程序可以通过这个文件中记录的信息解密抓取的 TLS 流量。&lt;/p&gt;
&lt;p&gt;注意：该功能是一个实验性的功能，只支持 1.18+ 版本的 Go 编译的程序（支持 stripped 的二进制），
并且只支持通过 ptcpdump 运行目标 Go 程序。&lt;/p&gt;
&lt;p&gt;可以通过下面两种方法试用这个功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--write-keylog-file&lt;/span&gt;&lt;/tt&gt; 参数或者环境变量 &lt;tt class="docutils literal"&gt;SSLKEYLOGFILE&lt;/tt&gt; 指定 SSLKEYLOGFILE 文件的保存路径:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo ptcpdump -i any --write-keylog-file /tmp/keylogfile.txt -w /tmp/go.pcapng -- ./gohttpapp
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;通过指定 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--embed-keylog-to-pcapng&lt;/span&gt;&lt;/tt&gt; 参数在保存数据到 pcapng 格式文件时内嵌 SSLKEYLOGFILE 文件内容:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo ptcpdump -i any --embed-keylog-to-pcapng -w /tmp/gotls.pcapng -- ./gohttpapp
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以通过 Wireshark 或 tshark 使用记录的 SSLKEYLOGFILE 内容对保存的 TLS 数据进行解密:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo tshark -r /tmp/go.pcapng -o tls.keylog_file:/tmp/keylogfile.txt | grep HTTP -B 2
Running as user &amp;quot;root&amp;quot; and group &amp;quot;root&amp;quot;. This could be dangerous.
   18 0.518380586    10.0.2.15 → 13.35.238.63 TLSv1.3 118 Change Cipher Spec, Finished
   19 0.519208290 13.35.238.63 → 10.0.2.15    TCP 60 443 → 47606 [ACK] Seq=5508 Ack=340 Win=64240 Len=0
   20 0.519914720    10.0.2.15 → 13.35.238.63 HTTP 179 GET /foo/bar HTTP/1.1


$ tshark -r /tmp/gotls.pcapng | grep HTTP -B 2
   20 0.525662563    10.0.2.15 → 13.35.238.114 TLSv1.3 118 Change Cipher Spec, Finished
   21 0.526138582 13.35.238.114 → 10.0.2.15    TCP 60 443 → 37618 [ACK] Seq=5987 Ack=340 Win=64240 Len=0
   22 0.526977836    10.0.2.15 → 13.35.238.114 HTTP 179 GET /foo/bar HTTP/1.1
&lt;/pre&gt;
&lt;p&gt;ptcpdump 计划未来内置支持使用 SSLKEYLOGFILE 对 TLS 数据进行解密的能力，
以及在抓包时实时获取 SSLKEYLOGFILE 并自动解密的能力，
目前暂时只能使用第三方工具实现 TLS 数据解密。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tcp-options"&gt;
&lt;h3 id="hidtcp-options"&gt;默认输出 TCP Options&lt;a class="headerlink" href="#hidtcp-options" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;新版本将默认输出 TCP Options 信息：&lt;/p&gt;
&lt;p&gt;老版本:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:09:54.324433 ens33 curl.26570 Out IP (..).43772 &amp;gt; (..).443: Flags [S], seq 1674193846, win 64240, length 0, ParentProc [ptcpdump.26560]
&lt;/pre&gt;
&lt;p&gt;新版本:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:09:54.324433 ens33 curl.26570 Out IP (..).43772 &amp;gt; (..).443: Flags [S], seq 1674193846, win 64240, options [mss 1460,sackOK,TS val 2107137325 ecr 0,nop,wscale 7], length 0, ParentProc [ptcpdump.26560]
&lt;/pre&gt;
&lt;p&gt;同时新版本还新增对 TCP SACK (Selective Acknowledgment) 和 TFO (TCP Fast Open) 的支持:&lt;/p&gt;
&lt;p&gt;SACK:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
19:03:36.220872 IP6 dead:beef:2::2.35288 &amp;gt; dead:beef:2::1.10029: Flags [.], seq 731670714, ack 2274465610, win 201, options [nop,nop,TS val 1253137130 ecr 837820024,nop,nop,sack 1 {2274467010:2274483378},mptcp 12 dss ack 16301812255838552430], length 0
&lt;/pre&gt;
&lt;p&gt;TFO:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
19:22:26.586851 IP6 dead:beef:1::2.54040 &amp;gt; dead:beef:1::1.10056: Flags [S], seq 271661201, win 64800, options [mss 1440,sackOK,TS val 2947503028 ecr 0,nop,wscale 7,tfo  cookiereq,nop,nop,mptcp 4 capable v1 flags [H]], length 0
19:22:26.591736 IP6 dead:beef:1::1.10056 &amp;gt; dead:beef:1::2.54040: Flags [S.], seq 1229575956, ack 271661202, win 64260, options [mss 1440,nop,nop,sackOK,nop,wscale 7,tfo  cookie 29b3cc66639d427d,nop,nop,mptcp 12 capable v1 flags [H] {0xc87438912bc26cb7}], length 0
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="tcp-options-mptcp"&gt;
&lt;h3 id="hidtcp-options-mptcp"&gt;输出 TCP Options 中的 MPTCP 信息&lt;a class="headerlink" href="#hidtcp-options-mptcp" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;应 MPTCP (MultiPath TCP) 社区的 &lt;a class="reference external" href="https://github.com/mozillazg/ptcpdump/issues/148"&gt;需求&lt;/a&gt;  ，
新增对 MPTCP 的支持:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
15:31:51.696224 IP 10.0.1.2.60958 &amp;gt; 10.0.1.1.10004: Flags [S], seq 3019570341, win 64240, options [mss 1460,sackOK,TS val 1007819908 ecr 0,nop,wscale 7,mptcp 4 capable v1 flags [H]], length 0
15:31:51.696346 IP 10.0.1.1.10004 &amp;gt; 10.0.1.2.60958: Flags [S.], seq 2367868313, ack 3019570342, win 65160, options [mss 1460,sackOK,TS val 162498895 ecr 1007819908,nop,wscale 7,mptcp 12 capable v1 flags [H] {0x8ea1df6e0d588003}], length 0
15:31:51.696587 IP 10.0.1.2.60958 &amp;gt; 10.0.1.1.10004: Flags [.], seq 3019570342, ack 2367868314, win 502, options [nop,nop,TS val 1007819909 ecr 162498895,mptcp 20 capable v1 flags [H] {0x465bcd01b5d78120,0x8ea1df6e0d588003}], length 0
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="netns"&gt;
&lt;h3 id="hidnetns"&gt;新增参数 --netns 支持对在其他网络命名空间中的网络接口进行抓包&lt;a class="headerlink" href="#hidnetns" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;之前的版本只支持对当前网络命名空间中的网络接口进行抓包，新版本通过新增 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--netns&lt;/span&gt;&lt;/tt&gt;
参数支持对其他网络命名空间中的网络接口进行抓包:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo ptcpdump -i lo --netns /run/netns/foobar
sudo ptcpdump -i any --netns /run/netns/foobar
sudo ptcpdump -i any --netns /proc/26/ns/net
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="pcapng-inbound-outbound"&gt;
&lt;h3 id="hidpcapng-inbound-outbound"&gt;PcapNg 格式增强：读取/写入网络接口名称和 Inbound/Outbound 信息&lt;a class="headerlink" href="#hidpcapng-inbound-outbound" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在之前的版本中使用 &lt;tt class="docutils literal"&gt;ptcpdump &lt;span class="pre"&gt;-r&lt;/span&gt; &amp;lt;file.pcapng&amp;gt;&lt;/tt&gt; 读取 pcapng 文件不会读取其中记录的网络接口名称以及 Inbound/Outbound 信息，
在新版本中已经解决了这个问题:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ptcpdump -r demo.pcapng
14:36:35.880947 ens33 curl.244103 Out IP 10.0.2.15.37668 &amp;gt; 114.114.114.114.53: 44427+ A? qq.com. (24), ParentProc [ptcpdump.244094]
14:36:35.882099 ens33 curl.244103 Out IP 10.0.2.15.37668 &amp;gt; 114.114.114.114.53: 31415+ AAAA? qq.com. (24), ParentProc [ptcpdump.244094]
14:36:35.954613 ens33 curl.244103 In IP 114.114.114.114.53 &amp;gt; 10.0.2.15.37668: 44427 3/0/0 A 203.205.254.157, A 113.108.81.189, A 123.150.76.218 (72), ParentProc [ptcpdump.244094]
&lt;/pre&gt;
&lt;p&gt;同时新版在将捕获的流量信息保存为 PcapNg 格式的文件时，会自动写入 Inbound/Outbound 信息（之前的版本已写入网络接口信息），
即支持 PcapNg 格式的
epb_flags （&lt;a class="reference external" href="https://www.ietf.org/archive/id/draft-tuexen-opsawg-pcapng-05.html#name-enhanced-packet-block-flags"&gt;Enhanced Packet Block Flags Word&lt;/a&gt; ）
标记。&lt;/p&gt;
&lt;p&gt;如果你对 ptcpdump 有额外的改进或新功能建议，欢迎在评论区或项目 issues 中留言。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sat, 02 Nov 2024 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2024-11-02:2024/11/whats-new-ptcpdump-v1.16-v1.26.html</guid><category>ptcpdump</category></item><item><title>Major Changes in ptcpdump versions 0.16 to 0.26</title><link>https://mozillazg.com/2024/11/whats-new-ptcpdump-v1.16-v1.26-en.html</link><description>&lt;div class="section" id="preface"&gt;
&lt;h2 id="hidpreface"&gt;Preface&lt;a class="headerlink" href="#hidpreface" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It has been several months since the
&lt;a class="reference external" href="https://mozillazg.com/2024/07/ebpf-ptcpdump-capturing-the-network-traffic-of-a-process-or-container-or-pod.html"&gt;last introduction&lt;/a&gt;
of the &lt;a class="reference external" href="https://github.com/mozillazg/ptcpdump"&gt;ptcpdump&lt;/a&gt; project.
Over these past months, I have been continuously developing this project.
This article will introduce the major changes released from the previous v0.16
version to the latest v0.26 version in chronological order.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="main-changes"&gt;
&lt;h2 id="hidmain-changes"&gt;Main changes&lt;a class="headerlink" href="#hidmain-changes" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="compatible-with-older-versions-of-tencentos-opencloudos-system"&gt;
&lt;h3 id="hidcompatible-with-older-versions-of-tencentos-opencloudos-system"&gt;Compatible with older versions of TencentOS/OpenCloudOS system&lt;a class="headerlink" href="#hidcompatible-with-older-versions-of-tencentos-opencloudos-system" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Base on user &lt;a class="reference external" href="https://github.com/mozillazg/ptcpdump/issues/89"&gt;feedback&lt;/a&gt;
the older versions were not compatible with previous editions of TencentOS/OpenCloudOS.
However, the current update now includes support for the following TencentOS/OpenCloudOS
releases: OpenCloudOS 7/8/9 and TencentOS Server 2.4/2.6/3.1/3.2.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="add-parent-process-information-to-the-output"&gt;
&lt;h3 id="hidadd-parent-process-information-to-the-output"&gt;Add parent process information to the output&lt;a class="headerlink" href="#hidadd-parent-process-information-to-the-output" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Old version:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
13:44:41.529003 eth0 In IP (tos 0x4, ttl 45, id 45428, offset 0, flags [DF], proto TCP (6), length 52)
    139.178.84.217.443 &amp;gt; 172.19.0.2.42606: Flags [.], cksum 0x5284, seq 3173118145, ack 1385712707, win 118, options [nop,nop,TS val 134560683 ecr 1627716996], length 0
    Process (pid 553587, cmd /usr/bin/wget, args wget kernel.org)
    Container (...)
    Pod (...)
&lt;/pre&gt;
&lt;p&gt;Latest update:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
13:44:41.529003 eth0 In IP (tos 0x4, ttl 45, id 45428, offset 0, flags [DF], proto TCP (6), length 52)
    139.178.84.217.443 &amp;gt; 172.19.0.2.42606: Flags [.], cksum 0x5284, seq 3173118145, ack 1385712707, win 118, options [nop,nop,TS val 134560683 ecr 1627716996], length 0
    Process (pid 553587, cmd /usr/bin/wget, args wget kernel.org)
    ParentProc (pid 553296, cmd /bin/sh, args sh)
    Container (...)
    Pod (...)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="support-using-an-older-version-of-kubernetes-environment-with-dockershim"&gt;
&lt;h3 id="hidsupport-using-an-older-version-of-kubernetes-environment-with-dockershim"&gt;Support using an older version of Kubernetes environment with Dockershim&lt;a class="headerlink" href="#hidsupport-using-an-older-version-of-kubernetes-environment-with-dockershim" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The earlier release couldn't gather Pod data in legacy Kubernetes setups running
Dockershim (specifically CRI v1alpha2). The latest update is now compatible with such environments.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-for-filtering-by-pod-name-containing-periods"&gt;
&lt;h3 id="hidfix-for-filtering-by-pod-name-containing-periods"&gt;Fix for filtering by Pod name containing periods&lt;a class="headerlink" href="#hidfix-for-filtering-by-pod-name-containing-periods" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In the past, when filtering by Pod name, names with periods were not supported.
The latest version now allows names with periods to be filtered:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
--pod-name foo.bar.default
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="fix-the-scenario-where-filtering-by-pod-does-not-support-pods-with-multiple-containers"&gt;
&lt;h3 id="hidfix-the-scenario-where-filtering-by-pod-does-not-support-pods-with-multiple-containers"&gt;Fix the scenario where filtering by Pod does not support Pods with multiple containers&lt;a class="headerlink" href="#hidfix-the-scenario-where-filtering-by-pod-does-not-support-pods-with-multiple-containers" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In previous versions, filtering by Pod did not support scenarios where Pods contain multiple containers.
This issue has been resolved in the new version.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="supporting-the-concurrent-execution-of-multiple-ptcpdump-instances"&gt;
&lt;h3 id="hidsupporting-the-concurrent-execution-of-multiple-ptcpdump-instances"&gt;Supporting the Concurrent Execution of Multiple ptcpdump Instances&lt;a class="headerlink" href="#hidsupporting-the-concurrent-execution-of-multiple-ptcpdump-instances" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Previously, only one ptcpdump process could run at a time. Running multiple ptcpdump processes simultaneously
would cause the old process to malfunction (capture no traffic). The latest version has resolved this issue.
In the new version, multiple ptcpdump processes can run concurrently without interfering
with each other or causing problems with packet capture for other processes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="support-filtering-multiple-process-pid-simultaneously"&gt;
&lt;h3 id="hidsupport-filtering-multiple-process-pid-simultaneously"&gt;Support Filtering Multiple Process PID Simultaneously&lt;a class="headerlink" href="#hidsupport-filtering-multiple-process-pid-simultaneously" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Now the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--pid&lt;/span&gt;&lt;/tt&gt; parameter supports filtering multiple PIDs simultaneously:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
--pid pid1 --pid pid2
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="new-parameters-micro-nano-time-stamp-precision-added-to-control-the-time-format-in-the-output"&gt;
&lt;h3 id="hidnew-parameters-micro-nano-time-stamp-precision-added-to-control-the-time-format-in-the-output"&gt;New parameters --micro, --nano, --time-stamp-precision added to control the time format in the output&lt;a class="headerlink" href="#hidnew-parameters-micro-nano-time-stamp-precision-added-to-control-the-time-format-in-the-output" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;New parameters &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--micro&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--nano&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--time-stamp-precision&lt;/span&gt;&lt;/tt&gt; have been added to control the
time format in the output, mirroring the functionality and usage of tcpdump.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--micro&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--time-stamp-precision=micro&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
13:36:05.701978 IP 10.0.2.15.22 &amp;gt; 10.0.2.2.59874: Flags [P.], seq 1370707216:1370707292, ack 4569736, win 62780, length 76
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--nano&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--time-stamp-precision=nano&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
13:36:05.701978488 IP 10.0.2.15.22 &amp;gt; 10.0.2.2.59874: Flags [P.], seq 1370707216:1370707292, ack 4569736, win 62780, length 76
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="add-parameters-a-x-xx-x-xx-to-control-the-output-format-of-the-data"&gt;
&lt;h3 id="hidadd-parameters-a-x-xx-x-xx-to-control-the-output-format-of-the-data"&gt;Add parameters -A, -x, -xx, -X, -XX to control the output format of the data&lt;a class="headerlink" href="#hidadd-parameters-a-x-xx-x-xx-to-control-the-output-format-of-the-data" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Add functionality and usage comparison of tcpdump flags &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-A&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-x&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-xx&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-X&lt;/span&gt;&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-XX&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-A&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:36:38.159559 ens33 curl.244103 Out IP 10.0.2.15.53478 &amp;gt; 203.205.254.157.80: Flags [P.], seq 3293023896:3293023966, ack 1986159173, win 64240, length 70, ParentProc [ptcpdump.244094]
E..nHL&amp;#64;.&amp;#64;...
..........P.G..vbbEP.......GET / HTTP/1.1
Host: qq.com
User-Agent: curl/7.81.0
Accept: */*
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-x&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:36:38.159559 ens33 curl.244103 Out IP 10.0.2.15.53478 &amp;gt; 203.205.254.157.80: Flags [P.], seq 3293023896:3293023966, ack 1986159173, win 64240, length 70, ParentProc [ptcpdump.244094]
        0x0000:  4500 006e 484c 4000 4006 1bc4 0a00 020f
        0x0010:  cbcd fe9d d0e6 0050 c447 8e98 7662 6245
        0x0020:  5018 faf0 d6da 0000 4745 5420 2f20 4854
        0x0030:  5450 2f31 2e31 0d0a 486f 7374 3a20 7171
        0x0040:  2e63 6f6d 0d0a 5573 6572 2d41 6765 6e74
        0x0050:  3a20 6375 726c 2f37 2e38 312e 300d 0a41
        0x0060:  6363 6570 743a 202a 2f2a 0d0a 0d0a
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-xx&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:36:38.159559 ens33 curl.244103 Out IP 10.0.2.15.53478 &amp;gt; 203.205.254.157.80: Flags [P.], seq 3293023896:3293023966, ack 1986159173, win 64240, length 70, ParentProc [ptcpdump.244094]
        0x0000:  0050 56eb bc4e 000c 298e 31f3 0800 4500
        0x0010:  006e 484c 4000 4006 1bc4 0a00 020f cbcd
        0x0020:  fe9d d0e6 0050 c447 8e98 7662 6245 5018
        0x0030:  faf0 d6da 0000 4745 5420 2f20 4854 5450
        0x0040:  2f31 2e31 0d0a 486f 7374 3a20 7171 2e63
        0x0050:  6f6d 0d0a 5573 6572 2d41 6765 6e74 3a20
        0x0060:  6375 726c 2f37 2e38 312e 300d 0a41 6363
        0x0070:  6570 743a 202a 2f2a 0d0a 0d0a
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-X&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:36:38.159559 ens33 curl.244103 Out IP 10.0.2.15.53478 &amp;gt; 203.205.254.157.80: Flags [P.], seq 3293023896:3293023966, ack 1986159173, win 64240, length 70, ParentProc [ptcpdump.244094]
        0x0000:  4500 006e 484c 4000 4006 1bc4 0a00 020f  E..nHL&amp;#64;.&amp;#64;.......
        0x0010:  cbcd fe9d d0e6 0050 c447 8e98 7662 6245  .......P.G..vbbE
        0x0020:  5018 faf0 d6da 0000 4745 5420 2f20 4854  P.......GET / HT
        0x0030:  5450 2f31 2e31 0d0a 486f 7374 3a20 7171  TP/1.1..Host: qq
        0x0040:  2e63 6f6d 0d0a 5573 6572 2d41 6765 6e74  .com..User-Agent
        0x0050:  3a20 6375 726c 2f37 2e38 312e 300d 0a41  : curl/7.81.0..A
        0x0060:  6363 6570 743a 202a 2f2a 0d0a 0d0a       ccept: */*....
&lt;/pre&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-XX&lt;/span&gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:36:38.159559 ens33 curl.244103 Out IP 10.0.2.15.53478 &amp;gt; 203.205.254.157.80: Flags [P.], seq 3293023896:3293023966, ack 1986159173, win 64240, length 70, ParentProc [ptcpdump.244094]
        0x0000:  0050 56eb bc4e 000c 298e 31f3 0800 4500  .PV..N..).1...E.
        0x0010:  006e 484c 4000 4006 1bc4 0a00 020f cbcd  .nHL&amp;#64;.&amp;#64;.........
        0x0020:  fe9d d0e6 0050 c447 8e98 7662 6245 5018  .....P.G..vbbEP.
        0x0030:  faf0 d6da 0000 4745 5420 2f20 4854 5450  ......GET / HTTP
        0x0040:  2f31 2e31 0d0a 486f 7374 3a20 7171 2e63  /1.1..Host: qq.c
        0x0050:  6f6d 0d0a 5573 6572 2d41 6765 6e74 3a20  om..User-Agent:
        0x0060:  6375 726c 2f37 2e38 312e 300d 0a41 6363  curl/7.81.0..Acc
        0x0070:  6570 743a 202a 2f2a 0d0a 0d0a            ept: */*....
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="create-docker-images-for-compiling-and-running-ptcpdump"&gt;
&lt;h3 id="hidcreate-docker-images-for-compiling-and-running-ptcpdump"&gt;Create Docker Images for Compiling and Running ptcpdump&lt;a class="headerlink" href="#hidcreate-docker-images-for-compiling-and-running-ptcpdump" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Create a Docker image for compiling programs: &lt;tt class="docutils literal"&gt;quay.io/ptcpdump/develop:latest&lt;/tt&gt; and
a Docker image for running ptcpdump through Docker: &lt;tt class="docutils literal"&gt;quay.io/ptcpdump/ptcpdump:latest&lt;/tt&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Compile eBPF programs and ptcpdump programs as needed using &lt;tt class="docutils literal"&gt;make &lt;span class="pre"&gt;build-bpf-via-docker&lt;/span&gt;&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;make &lt;span class="pre"&gt;build-via-docker&lt;/span&gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;You can run ptcpdump through Docker using a command similar to the following:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
docker run --privileged --rm -t --net=host --pid=host \
  -v /sys/fs/cgroup:/sys/fs/cgroup:ro \
  quay.io/ptcpdump/ptcpdump:latest ptcpdump -i any -c 2 tcp
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="experimental-new-feature-generating-corresponding-tls-key-log-file-when-capturing-go-program-s-network-traffic"&gt;
&lt;h3 id="hidexperimental-new-feature-generating-corresponding-tls-key-log-file-when-capturing-go-program-s-network-traffic"&gt;Experimental New Feature: Generating Corresponding TLS Key Log File When Capturing Go Program's Network Traffic&lt;a class="headerlink" href="#hidexperimental-new-feature-generating-corresponding-tls-key-log-file-when-capturing-go-program-s-network-traffic" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A new experimental feature has been implemented in the latest version:
generating the corresponding TLS Key Log file when capturing Go program's network traffic.&lt;/p&gt;
&lt;p&gt;The TLS Key Log file, also known as &lt;a class="reference external" href="https://tlswg.org/sslkeylogfile/draft-ietf-tls-keylogfile.html"&gt;SSLKEYLOGFILE&lt;/a&gt; ,
corresponds to the pre-master secret configuration in Wireshark.
Third-party programs can decrypt captured TLS traffic using the information recorded in this file.&lt;/p&gt;
&lt;p&gt;Please note: This feature is experimental and is only supported by Go programs compiled with version 1.18 or above (supports stripped binary).
It also requires running the target Go program via ptcpdump.&lt;/p&gt;
&lt;p&gt;You can try out this feature using the following two methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Use the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--write-keylog-file&lt;/span&gt;&lt;/tt&gt; argument or the &lt;tt class="docutils literal"&gt;SSLKEYLOGFILE&lt;/tt&gt; environment variable to specify the location
where the SSLKEYLOGFILE file will be saved:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo ptcpdump -i any --write-keylog-file /tmp/keylogfile.txt -w /tmp/go.pcapng -- ./gohttpapp
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;By specifying the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--embed-keylog-to-pcapng&lt;/span&gt;&lt;/tt&gt; parameter, embed the contents of the SSLKEYLOGFILE into
the saved data in the pcapng format file:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo ptcpdump -i any --embed-keylog-to-pcapng -w /tmp/gotls.pcapng -- ./gohttpapp
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Later, you can decrypt the saved TLS data using the recorded SSLKEYLOGFILE content with Wireshark or tshark:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo tshark -r /tmp/go.pcapng -o tls.keylog_file:/tmp/keylogfile.txt | grep HTTP -B 2
Running as user &amp;quot;root&amp;quot; and group &amp;quot;root&amp;quot;. This could be dangerous.
   18 0.518380586    10.0.2.15 → 13.35.238.63 TLSv1.3 118 Change Cipher Spec, Finished
   19 0.519208290 13.35.238.63 → 10.0.2.15    TCP 60 443 → 47606 [ACK] Seq=5508 Ack=340 Win=64240 Len=0
   20 0.519914720    10.0.2.15 → 13.35.238.63 HTTP 179 GET /foo/bar HTTP/1.1


$ tshark -r /tmp/gotls.pcapng | grep HTTP -B 2
   20 0.525662563    10.0.2.15 → 13.35.238.114 TLSv1.3 118 Change Cipher Spec, Finished
   21 0.526138582 13.35.238.114 → 10.0.2.15    TCP 60 443 → 37618 [ACK] Seq=5987 Ack=340 Win=64240 Len=0
   22 0.526977836    10.0.2.15 → 13.35.238.114 HTTP 179 GET /foo/bar HTTP/1.1
&lt;/pre&gt;
&lt;p&gt;ptcpdump plans to eventually have built-in support for decrypting TLS data using SSLKEYLOGFILE
and to automatically decrypt TLS data in real-time while capturing packets.
Currently, this can only be achieved using third-party tools for decrypting TLS data.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="output-tcp-options-by-default"&gt;
&lt;h3 id="hidoutput-tcp-options-by-default"&gt;Output TCP options by default&lt;a class="headerlink" href="#hidoutput-tcp-options-by-default" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The new version will by default output TCP Options information:&lt;/p&gt;
&lt;p&gt;Old version:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:09:54.324433 ens33 curl.26570 Out IP (..).43772 &amp;gt; (..).443: Flags [S], seq 1674193846, win 64240, length 0, ParentProc [ptcpdump.26560]
&lt;/pre&gt;
&lt;p&gt;Latest version:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:09:54.324433 ens33 curl.26570 Out IP (..).43772 &amp;gt; (..).443: Flags [S], seq 1674193846, win 64240, options [mss 1460,sackOK,TS val 2107137325 ecr 0,nop,wscale 7], length 0, ParentProc [ptcpdump.26560]
&lt;/pre&gt;
&lt;p&gt;Moreover, the latest update includes support for TCP SACK (Selective Acknowledgment) and TFO (TCP Fast Open).&lt;/p&gt;
&lt;p&gt;SACK:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
19:03:36.220872 IP6 dead:beef:2::2.35288 &amp;gt; dead:beef:2::1.10029: Flags [.], seq 731670714, ack 2274465610, win 201, options [nop,nop,TS val 1253137130 ecr 837820024,nop,nop,sack 1 {2274467010:2274483378},mptcp 12 dss ack 16301812255838552430], length 0
&lt;/pre&gt;
&lt;p&gt;TFO:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
19:22:26.586851 IP6 dead:beef:1::2.54040 &amp;gt; dead:beef:1::1.10056: Flags [S], seq 271661201, win 64800, options [mss 1440,sackOK,TS val 2947503028 ecr 0,nop,wscale 7,tfo  cookiereq,nop,nop,mptcp 4 capable v1 flags [H]], length 0
19:22:26.591736 IP6 dead:beef:1::1.10056 &amp;gt; dead:beef:1::2.54040: Flags [S.], seq 1229575956, ack 271661202, win 64260, options [mss 1440,nop,nop,sackOK,nop,wscale 7,tfo  cookie 29b3cc66639d427d,nop,nop,mptcp 12 capable v1 flags [H] {0xc87438912bc26cb7}], length 0
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="output-the-mptcp-information-in-the-tcp-options"&gt;
&lt;h3 id="hidoutput-the-mptcp-information-in-the-tcp-options"&gt;Output the MPTCP information in the TCP Options&lt;a class="headerlink" href="#hidoutput-the-mptcp-information-in-the-tcp-options" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;According to the &lt;a class="reference external" href="https://github.com/mozillazg/ptcpdump/issues/148"&gt;requirement&lt;/a&gt; from
the MPTCP (MultiPath TCP) community, support for MPTCP should be added:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
15:31:51.696224 IP 10.0.1.2.60958 &amp;gt; 10.0.1.1.10004: Flags [S], seq 3019570341, win 64240, options [mss 1460,sackOK,TS val 1007819908 ecr 0,nop,wscale 7,mptcp 4 capable v1 flags [H]], length 0
15:31:51.696346 IP 10.0.1.1.10004 &amp;gt; 10.0.1.2.60958: Flags [S.], seq 2367868313, ack 3019570342, win 65160, options [mss 1460,sackOK,TS val 162498895 ecr 1007819908,nop,wscale 7,mptcp 12 capable v1 flags [H] {0x8ea1df6e0d588003}], length 0
15:31:51.696587 IP 10.0.1.2.60958 &amp;gt; 10.0.1.1.10004: Flags [.], seq 3019570342, ack 2367868314, win 502, options [nop,nop,TS val 1007819909 ecr 162498895,mptcp 20 capable v1 flags [H] {0x465bcd01b5d78120,0x8ea1df6e0d588003}], length 0
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="add-a-new-parameter-netns-to-support-capturing-network-interfaces-in-other-network-namespaces"&gt;
&lt;h3 id="hidadd-a-new-parameter-netns-to-support-capturing-network-interfaces-in-other-network-namespaces"&gt;Add a new parameter --netns to support capturing network interfaces in other network namespaces&lt;a class="headerlink" href="#hidadd-a-new-parameter-netns-to-support-capturing-network-interfaces-in-other-network-namespaces" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The previous version only supported capturing network interfaces in the current network namespace.
The new version now supports capturing network interfaces in other network namespaces
by adding the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--netns&lt;/span&gt;&lt;/tt&gt; parameter:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo ptcpdump -i lo --netns /run/netns/foobar
sudo ptcpdump -i any --netns /run/netns/foobar
sudo ptcpdump -i any --netns /proc/26/ns/net
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="pcapng-format-enhancement-reading-writing-network-interface-names-and-inbound-outbound-information"&gt;
&lt;h3 id="hidpcapng-format-enhancement-reading-writing-network-interface-names-and-inbound-outbound-information"&gt;PcapNg format enhancement: reading/writing network interface names and Inbound/Outbound information&lt;a class="headerlink" href="#hidpcapng-format-enhancement-reading-writing-network-interface-names-and-inbound-outbound-information" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In previous versions, using &lt;tt class="docutils literal"&gt;ptcpdump &lt;span class="pre"&gt;-r&lt;/span&gt; &amp;lt;file.pcapng&amp;gt;&lt;/tt&gt; to read a pcapng file did not display
the recorded network interface names and Inbound/Outbound information.
This issue has been resolved in the new version:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ptcpdump -r demo.pcapng
14:36:35.880947 ens33 curl.244103 Out IP 10.0.2.15.37668 &amp;gt; 114.114.114.114.53: 44427+ A? qq.com. (24), ParentProc [ptcpdump.244094]
14:36:35.882099 ens33 curl.244103 Out IP 10.0.2.15.37668 &amp;gt; 114.114.114.114.53: 31415+ AAAA? qq.com. (24), ParentProc [ptcpdump.244094]
14:36:35.954613 ens33 curl.244103 In IP 114.114.114.114.53 &amp;gt; 10.0.2.15.37668: 44427 3/0/0 A 203.205.254.157, A 113.108.81.189, A 123.150.76.218 (72), ParentProc [ptcpdump.244094]
&lt;/pre&gt;
&lt;p&gt;When saving the captured traffic information as a PcapNg format file, the new version will automatically
write Inbound/Outbound information (previous versions already wrote network interface information),
thus supporting the epb_flags (&lt;a class="reference external" href="https://www.ietf.org/archive/id/draft-tuexen-opsawg-pcapng-05.html#name-enhanced-packet-block-flags"&gt;Enhanced Packet Block Flags Word&lt;/a&gt; )
flag for the PcapNg format.&lt;/p&gt;
&lt;p&gt;If you have any additional improvements or new feature suggestions for ptcpdump,
feel free to leave a comment in the comments section or project issues.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sat, 02 Nov 2024 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2024-11-02:2024/11/whats-new-ptcpdump-v1.16-v1.26-en.html</guid><category>ptcpdump</category></item><item><title>我参与写作的新书《eBPF 云原生安全：原理与实践》目前正在新鲜发售中</title><link>https://mozillazg.com/2024/09/new-book-cloud-native-security-with-ebpf.html</link><description>&lt;p&gt;我跟同事合著的新书《eBPF 云原生安全：原理与实践》在 8 月底的时候已经正式对外发售了。
好像还没在博客中宣传过这个消息，今天特意发篇文章来打个广告。&lt;/p&gt;
&lt;div class="section" id="section-1"&gt;
&lt;h2 id="hidsection-1"&gt;广告时间&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我跟同事合著的由机械工业出版社出版的新书《eBPF 云原生安全：原理与实践》现已正式出版发售，各大电商平台上均有现货！
推荐对 eBPF 或安全感兴趣的朋友们关注一下。下面是一些链接资源，供大家参考：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;出版社旗下公众号的介绍页面：&lt;a class="reference external" href="https://mp.weixin.qq.com/s/EWsKxgRFNiqF1HEqVNEQ5w"&gt;https://mp.weixin.qq.com/s/EWsKxgRFNiqF1HEqVNEQ5w&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;豆瓣介绍页面：&lt;a class="reference external" href="https://book.douban.com/subject/37022239/"&gt;https://book.douban.com/subject/37022239/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;京东购买链接：&lt;a class="reference external" href="https://item.jd.com/10111206687256.html"&gt;https://item.jd.com/10111206687256.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;天猫购买链接：&lt;a class="reference external" href="https://detail.tmall.com/item.htm?id=82"&gt;https://detail.tmall.com/item.htm?id=82&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;书中所有示例程序的完整源代码：&lt;a class="reference external" href="https://github.com/mozillazg/cloud-native-security-with-ebpf"&gt;https://github.com/mozillazg/cloud-native-security-with-ebpf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h2 id="hidsection-2"&gt;关于这本书&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;我从 2022 年开始参与本书的写作，耗时 2 年多，期间经历了新冠疫情封控、疫情结束、各种拖延症发作，
最后终于在 2024 年 8 月底正式对外出版发售了！&lt;/p&gt;
&lt;p&gt;在这里我想感谢家人和朋友们的支持和帮助、感谢机械工业出版社的各位主编、编辑、设计、文案、市场、营销、策划、印刷等
老师的支持和帮助、感谢同事和领导的支持和帮助。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;尤其要感谢出版社的杨福川老师给予我们写作本书的机会以及老师对我们写作和出版的帮助和督促；&lt;/li&gt;
&lt;li&gt;感谢出版社的陈洁老师专业的编辑水平和素养以及专业和细致认真的审稿和出版支持；&lt;/li&gt;
&lt;li&gt;感谢匡大虎老师愿意合作参与本书的写作，感谢匡老师带我飞；&lt;/li&gt;
&lt;li&gt;感谢易立、李鹏两位老板的大力支持，感谢两位老板在百忙中抽空为本书撰写推荐语；&lt;/li&gt;
&lt;li&gt;感谢姜坦、杜岚两位老师百忙中抽空为本书撰写推荐语；&lt;/li&gt;
&lt;li&gt;感谢 &lt;a class="reference external" href="https://github.com/Zheaoli"&gt;&amp;#64;Zheaoli&lt;/a&gt; 、 &lt;a class="reference external" href="https://github.com/jschwinger233"&gt;&amp;#64;jschwinger233&lt;/a&gt; 两位老师在百忙中抽空阅读本书并撰写推荐语；&lt;/li&gt;
&lt;li&gt;感谢我的妻子的支持，感谢她对我写作的支持和包容；&lt;/li&gt;
&lt;li&gt;感谢 &lt;a class="reference external" href="https://github.com/Zheaoli"&gt;&amp;#64;Zheaoli&lt;/a&gt; 老师在网上向网友们推荐本书；&lt;/li&gt;
&lt;li&gt;感谢 &lt;a class="reference external" href="https://x.com/yihong0618"&gt;&amp;#64;yihong0618&lt;/a&gt; 老师在网上向网友们推荐本书；&lt;/li&gt;
&lt;li&gt;感谢已经购买和即将购买这本书的读者朋友们的支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，关于这本书的质量：我只能保证这本书不是一本烂书、书中所有的代码都能跑通并且结果可以复现（
可以在上面的源码仓库中查看所有示例代码的编译和运行说明），至于是否是好书就见仁见智了。
因为是第一次写书以及本人水平有限，难免会存在各种各样的问题，大家如果有任何建议或发现任何问题可以在前面的源码仓库中通过 issue 的形式反馈
或者加我微信反馈（下方有我的微信二维码链接，相信细心的你一定能找到），也可以在下方评论区反馈。&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2024-09-28:2024/09/new-book-cloud-native-security-with-ebpf.html</guid></item><item><title>[译] BPF CO-RE 参考指南 (2021)</title><link>https://mozillazg.com/2024/07/bpf-core-reference-guide-zh.html</link><description>&lt;p&gt;本文译自 &lt;a class="reference external" href="https://nakryiko.com/posts/bpf-core-reference-guide/"&gt;BPF CO-RE reference guide - Andrii Nakryiko's Blog&lt;/a&gt; 。&lt;/p&gt;
&lt;div class="section" id="section-1"&gt;
&lt;span id="the-missing-manual"&gt;&lt;/span&gt;&lt;h2 id="hidsection-1"&gt;缺失的手册&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;BPF CO-RE (Compile Once – Run Everywhere)（一次编译，到处运行）是一种现代的用于编写可移植 BPF 应用程序的方法。
通过这个方法编写的 BPF 程序无需修改就能在多个内核版本和配置上运行，
并且还不需要在目标机器上编译源代码。
这与更传统的 &lt;a class="reference external" href="https://github.com/iovisor/bcc"&gt;BCC&lt;/a&gt; 框架提供的方法形成鲜明对比，
后者将 BPF 应用程序源代码编译推迟到目标主机的运行时，这需要携带庞大的编译器工具链才能实现。
请查看 &lt;a class="reference external" href="https://nakryiko.com/posts/bpf-portability-and-co-re/"&gt;这篇博文&lt;/a&gt; ，
它介绍了 BPF CO-RE 的概念，并解释了为什么这对许多真实世界的 BPF 应用程序至关重要和必要，
以及在没有 &lt;a class="reference external" href="https://nakryiko.com/posts/btf-dedup/"&gt;内核 BTF&lt;/a&gt; 的情况下，这会变得多么困难。&lt;/p&gt;
&lt;p&gt;随着 BPF CO-RE 成为一种成熟的方法，关于其所有功能以及如何在实践中使用它的一些建议非常缺失。
在这篇博客文章中，我将尝试填补这一空白，并将介绍 BPF CO-RE
（以及作为其官方实现的 &lt;a class="reference external" href="https://github.com/libbpf/libbpf"&gt;libbpf&lt;/a&gt; ）提供的所有不同功能。
如果您之前编写过 BPF CO-RE 应用程序，您很可能已经使用了本文描述的一些功能。
但遗憾的是，其中一些功能仍然鲜为人知。然而，正是这些鲜为人知的 BPF CO-RE 秘密有时
使真实世界的 BPF 应用程序变得可行，简单且易于实现和支持，避免了在主机上编译或预编译同一 BPF 应用程序的
多个变体（flavors），每个变体针对不同的内核。&lt;/p&gt;
&lt;p&gt;这篇文章很长，但因为它的目标是作为一个参考指南，因此将其保持为一个整体而不是将其分成几个部分分几周发布会更好。
它分为三个部分，从最常用的功能开始，逐渐向更高级和不太常用的功能发展，
希望能够自然地引导刚开始使用 BPF CO-RE 范式编写 BPF 应用程序的人。&lt;/p&gt;
&lt;p&gt;在本文中，我将假设您正在使用 &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; ，它为内核提供了 CO-RE 可重定位类型定义（CO-RE-relocatable type definitions），
这个文件可以通过 &lt;tt class="docutils literal"&gt;bpftool&lt;/tt&gt; 工具生成。如果您对 &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; 不熟悉，请参阅
&lt;a class="reference external" href="https://nakryiko.com/posts/libbpf-bootstrap/#includes-vmlinux-h-libbpf-and-app-headers"&gt;libbpf-bootstrap 博文&lt;/a&gt;
。在接近文章末尾的更高级用法部分，我还将详细介绍如何在没有 &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; 的情况下使用 BPF CO-RE。&lt;/p&gt;
&lt;p&gt;在讨论过程中，我会尽量保持高层次的描述，除非绝对必要我将避免深入到细节的实现部分。
如果您想进一步了解，建议查看 &lt;a class="reference external" href="https://github.com/libbpf/libbpf/tree/master/src/bpf_core_read.h"&gt;bpf_core_read.h&lt;/a&gt;
头文件，以及在 &lt;a class="reference external" href="http://vger.kernel.org/vger-lists.html#bpf"&gt;BPF 邮件列表&lt;/a&gt; 中提问。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;span id="reading-kernel-data"&gt;&lt;/span&gt;&lt;h2 id="hidsection-2"&gt;读取内核数据&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;目前，BPF CO-RE 操作中最常见的操作是从内核结构中读取字段的值。
libbpf 提供了一整套辅助函数，使得读取字段变得简单且 CO-RE 可重定位（CO-RE-relocatable）。
&lt;strong&gt;CO-RE 可重定位&lt;/strong&gt; 意味着无论结构体的实际内存布局如何（这取决于实际使用的 &lt;em&gt;内核版本&lt;/em&gt; 和 &lt;em&gt;内核配置&lt;/em&gt; ），
BPF 程序将被调整以在结构体的开始处相对正确的偏移处读取字段。&lt;/p&gt;
&lt;div class="section" id="bpf-core-read-1"&gt;
&lt;span id="bpf-core-read"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-read-1"&gt;bpf_core_read()&lt;a class="headerlink" href="#hidbpf-core-read-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;最基本的以 CO-RE 可重定位方式读取字段的辅助函数是 &lt;tt class="docutils literal"&gt;bpf_core_read(dst, sz, src)&lt;/tt&gt; ，
它将从 &lt;tt class="docutils literal"&gt;src&lt;/tt&gt; 引用的字段中读取 &lt;tt class="docutils literal"&gt;sz&lt;/tt&gt; 字节，然后将其读入 &lt;tt class="docutils literal"&gt;dst&lt;/tt&gt; 指向的内存中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;bpf_get_current_task&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent_task&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bpf_core_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;parent_task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* handle error */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/* parent_task contains the value of task-&amp;gt;parent pointer */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;bpf_core_read()&lt;/tt&gt; 与 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel()&lt;/tt&gt; BPF 辅助函数类似，
不同之处在于它记录的是应该在目标内核上重新定位的字段的信息。
比如，如果由于在 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 前面添加了新字段而导致其中的 &lt;tt class="docutils literal"&gt;parent&lt;/tt&gt; 字段被移动到了不同的偏移量，
libbpf 将自动调整实际偏移量到正确的值。&lt;/p&gt;
&lt;p&gt;有一个重要的一点需要记住，字段的 &lt;strong&gt;大小&lt;/strong&gt; &lt;em&gt;并不会自动重定位&lt;/em&gt; ，
只有其偏移量会自动重定位。所以，如果你正在读取的字段是一个 &lt;tt class="docutils literal"&gt;struct&lt;/tt&gt; ， 并且其大小发生了变化，你可能会遇到问题。
请参阅 &lt;a class="reference external" href="#sizing-kernel-types-and-fields"&gt;&amp;quot;计算内核类型和字段的大小&amp;quot;&lt;/a&gt;
部分以了解处理这种情况的方法。一般的建议是尽可能不要将整个结构体字段一次性读取，最好只读取你最感兴趣的基本字段。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bpf-core-read-str-1"&gt;
&lt;span id="bpf-core-read-str"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-read-str-1"&gt;bpf_core_read_str()&lt;a class="headerlink" href="#hidbpf-core-read-str-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;就像有 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel()&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel_str()&lt;/tt&gt; 这一对 BPF 助手函数一样，
前者读取指定数量的字节，而后者读取一个变长的以零结尾的 C 字符串，
&lt;tt class="docutils literal"&gt;bpf_core_read()&lt;/tt&gt; 也有个对应的函数 &lt;tt class="docutils literal"&gt;bpf_core_read_str()&lt;/tt&gt; 。
它的工作方式类似于 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel_str()&lt;/tt&gt; ，不同之处在于它记录了包含以零结尾的 C 字符串的源字符数组字段
的 CO-RE 重定位信息。因此，&lt;tt class="docutils literal"&gt;bpf_core_read_str()&lt;/tt&gt; 是 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel_str()&lt;/tt&gt; 的可 CO-RE 重定位版本。&lt;/p&gt;
&lt;p&gt;注意 &lt;strong&gt;字符数组&lt;/strong&gt; 字段和 &lt;strong&gt;字符指针&lt;/strong&gt; 字段之间的重要但微妙区别。在 C 语言中，当读取字符串值时，它们可以互换使用，
因为编译器会自动将数组视为指针。然而，在 CO-RE 的上下文中，这种区别 &lt;em&gt;非常重要&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;让我们来看看我们希望读取的假想内核类型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;my_kernel_type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;name&lt;/tt&gt; 字段指向存储字符串的位置，但 &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; 字段实际上 &lt;strong&gt;就是&lt;/strong&gt; 包含字符串的内存。
如果您需要使用 CO-RE 读取 &lt;tt class="docutils literal"&gt;name&lt;/tt&gt; 指向的字符串，正确的处理方式是首先以 CO-RE 可重定位的方式读取指针的值，
然后进行普通的（非 CO-RE） &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel_str()&lt;/tt&gt;  读取（为简洁起见，下面的示例忽略了错误处理）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;my_kernel_type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="cm"&gt;/* get string pointer, CO-RE-relocatable */&lt;/span&gt;
&lt;span class="n"&gt;bpf_core_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cm"&gt;/* read the string, non-CO-RE-relocatable, pointer is valid regardless */&lt;/span&gt;
&lt;span class="n"&gt;bpf_probe_read_kernel_str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们需要读取 &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; 字符串，相应的示例将是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;my_kernel_type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="cm"&gt;/* read string as CO-RE-relocatable */&lt;/span&gt;
&lt;span class="n"&gt;bpf_core_read_str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请花点时间思考为什么第一个示例不能使用 &lt;tt class="docutils literal"&gt;bpf_core_read_str()&lt;/tt&gt;
（_提示_ ：您可能会将 &lt;strong&gt;指针值&lt;/strong&gt; 解释为 C 字符串本身），
以及为什么第二个示例不能作为指针读取然后在进行字符串读取
（_提示_ ：字符串本身是结构体的一部分，所以没有专用指针，它位于相对于 &lt;tt class="docutils literal"&gt;t&lt;/tt&gt; 指针指向位置的
&lt;strong&gt;偏移量&lt;/strong&gt; ）。这种情况很微妙，幸运的是很少遇到，但如果您不清楚这种差异，在实践中可能会感到非常困惑。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bpf-core-read-2"&gt;
&lt;span id="bpf-core-read-1-1"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-read-2"&gt;BPF_CORE_READ()&lt;a class="headerlink" href="#hidbpf-core-read-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;bpf_core_read()&lt;/tt&gt; 函数虽然允许进行大量的控制和精细的错误处理，但直接使用起来确实有些繁琐，
特别是在读取需要通过较长指针解引用链访问的字段时。&lt;/p&gt;
&lt;p&gt;让我们来看一个读取运行中进程的可执行文件名称的例子。
如果你正在用 C 语言编写简单的内核代码，并想要实现这个功能，你需要像下面这样做：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fpath&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/* now read string contents with bpf_probe_read_kernel_str() */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意指针解引用的顺序，其中夹杂了一些子结构的访问（即 &lt;tt class="docutils literal"&gt;fpath.dentry&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;d_name.name&lt;/tt&gt; ）。
使用 &lt;tt class="docutils literal"&gt;bpf_core_read()&lt;/tt&gt; 做这样的事情很快就会变得一团糟：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;mm_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;file&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;dentry&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;bpf_core_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;bpf_core_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;bpf_core_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;bpf_core_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* now read string contents with bpf_probe_read_kernel_str() */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;诚然，这是一个相当极端的例子，通常指针解引用链不会那么长，但观点依然存在：
使用这种方法是很痛苦的。尽管上面的例子完全忽略了错误处理，但这一切仍然存在。&lt;/p&gt;
&lt;p&gt;为了更容易编写这样的多步读取操作，libbpf 提供了 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 宏。
让我们看看如何通过使用 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 简化上述代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_CORE_READ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fpath&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* now read string contents with bpf_probe_read_kernel_str() */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对比一下 &amp;quot;原生 C&amp;quot; 示例和使用 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 的示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* direct pointer dereference */&lt;/span&gt;
&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fpath&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/* using BPF_CORE_READ() helper */&lt;/span&gt;
&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_CORE_READ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;exe_file&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fpath&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基本上，每个指针解引用在宏调用中都会被转换成逗号，而每个子结构访问则保持原样。非常简单明了。&lt;/p&gt;
&lt;p&gt;你可能已经注意到 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 直接返回读取的值，不会传播错误。
如果任何指针为 NULL 或指向无效内存，你将会得到 &lt;tt class="docutils literal"&gt;0&lt;/tt&gt; （或 &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt; ）作为返回值。
但如果你需要错误传播和处理，你就必须使用低级的 &lt;tt class="docutils literal"&gt;bpf_core_read()&lt;/tt&gt; 原语并显式地处理错误。
在实践中，这通常不是问题或必要的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bpf-core-read-into-1"&gt;
&lt;span id="bpf-core-read-into"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-read-into-1"&gt;BPF_CORE_READ_INTO()&lt;a class="headerlink" href="#hidbpf-core-read-into-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在某些情况下，将结果读入目标内存而不是直接返回结果可能必要的或更方便的，
比如当你从 C 数组中读取值时（比如，从套接字结构中读取 IPv4 地址），因为 C 语言不允许直接从表达式中返回数组。
对于这种情况，libbpf 提供了 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_INTO()&lt;/tt&gt; 宏，它的行为类似于 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; ，
除了会将最终字段的值读入目标内存。将上述示例转换为 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_INTO()&lt;/tt&gt; ，我们将得到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_CORE_READ_INTO&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;binfmt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;executable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;fpath&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* handle errors */&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cm"&gt;/* now `name` contains the pointer to the string */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意在 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_INTO()&lt;/tt&gt; 中添加了额外的 &lt;tt class="docutils literal"&gt;&amp;amp;name&lt;/tt&gt; ，以及可以获取上次操作的错误代码
（比如，读取 &lt;tt class="docutils literal"&gt;d_name.name&lt;/tt&gt; ）。总的来说， &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 在实践中更加方便，更易于阅读。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bpf-core-read-str-into-1"&gt;
&lt;span id="bpf-core-read-str-into"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-read-str-into-1"&gt;BPF_CORE_READ_STR_INTO()&lt;a class="headerlink" href="#hidbpf-core-read-str-into-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;对于最后一个字段是字符数组字段的情况（就像上面的假设示例中的 &lt;tt class="docutils literal"&gt;name&lt;/tt&gt; vs &lt;tt class="docutils literal"&gt;type&lt;/tt&gt; 一样），
有一个对应的 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_STR_INTO()&lt;/tt&gt; 宏，你现在应该对它的工作原理有一个很好的猜测了。
如果没有，请重新查看 &lt;a class="reference external" href="#bpf-core-read-str"&gt;bpf_core_read_str()&lt;/a&gt; 部分。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="btf-enabled-bpf"&gt;
&lt;span id="btf-enabled-bpf-program-types-with-direct-memory-reads"&gt;&lt;/span&gt;&lt;h3 id="hidbtf-enabled-bpf"&gt;可以直接读取内存的 BTF-enabled 的 BPF 程序类型&lt;a class="headerlink" href="#hidbtf-enabled-bpf" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在上面讨论了 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 系列宏之后，有个非常重要一点需要注意，
那就是您并不总是需要使用它们来进行 CO-RE 可重定位读取。
或者说，并不总是需要通过 &lt;em&gt;&amp;quot;probe read&amp;quot;&lt;/em&gt; 的方式（比如，使用 BPF 辅助函数来读取）来读取内存。
有时候你可以 &lt;em&gt;直接访问&lt;/em&gt; 内核内存。&lt;/p&gt;
&lt;p&gt;一些 BPF 程序类型是 &amp;quot;BTF-enabled&amp;quot;，这意味着内核中的 BPF 验证器知道与传递给 BPF 程序的输入参数相关联的类型信息。
这使得 BPF 验证器能够知道哪些内存可以在不调用 &lt;tt class="docutils literal"&gt;bpf_core_read()&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel()&lt;/tt&gt; 的情况下直接
从内核中安全读取。其中一些 BTF-enabled BPF 程序类型包括：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;BTF-enabled raw tracepoint (libbpf 术语中的 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;SEC(&amp;quot;tp_btf/...&amp;quot;)&lt;/span&gt;&lt;/tt&gt; );&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;fentry&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;fexit&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;fmod_ret&lt;/tt&gt; BPF 程序;&lt;/li&gt;
&lt;li&gt;BPF LSM 程序;&lt;/li&gt;
&lt;li&gt;可能还有一些，但是我懒得去确认了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这些程序中，如果它们获取到某种内核类型的指针（例如， &lt;tt class="docutils literal"&gt;struct task_struct *&lt;/tt&gt; ），
BPF 程序代码可以直接访问内存进行解引用，甚至可以跟踪指针。
因此，在我们上面用来演示 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 使用的详细示例中，
当使用 &lt;tt class="docutils literal"&gt;fentry&lt;/tt&gt; BPF 程序时，你所需要做的只是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;binfmt&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;executable&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fpath&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dentry&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;d_name&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是的，这与 “原生 C” 的假设示例完全相同。但请记住，要获取字符串的内容本身，
您仍然需要使用 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel_str()&lt;/tt&gt; 。&lt;/p&gt;
&lt;p&gt;这种直接访问内存的方法快速、方便且简单，您应当在可能的情况下尽量使用这种方法。
不幸的是，在许多真实世界的场景下，您仍然必须明确依赖于 “probe reading”，
因此 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 将在可预见的未来成为您的朋友，因此一定要熟悉它。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;span id="reading-bitfields-and-integers-of-varying-sizes"&gt;&lt;/span&gt;&lt;h3 id="hidsection-3"&gt;读取不同大小的位域和整数&lt;a class="headerlink" href="#hidsection-3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;从 BPF 中读取位域（bitfields）一直是一个挑战。BPF 应用程序开发人员必须费尽心思地编写非常难维护和极其痛苦的的代码，
才能从内核类型中提取位域值。以 &lt;tt class="docutils literal"&gt;struct tcp_sock&lt;/tt&gt; 为例。
它包含了很多编码为位字域的有用信息。即便使用 BCC 及其源代码编译方法，
提取这些位域仍然是一个主要的麻烦和维护负担。&lt;/p&gt;
&lt;p&gt;幸运的是，libbpf 提供了两个易于使用的宏，用于以 CO-RE 可重定位的方式读取位域：
&lt;tt class="docutils literal"&gt;BPF_CORE_READ_BITFIELD()&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_BITFIELD_PROBED()&lt;/tt&gt; 。
当要读取的数据需要进行 &amp;quot;probe read&amp;quot; 时，必须使用 &lt;tt class="docutils literal"&gt;_PROBED&lt;/tt&gt; 变体，
就像使用 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 一样。只有在可以直接访问内存时
（例如，来自 &lt;tt class="docutils literal"&gt;fentry/&lt;/tt&gt; BPF 程序，参见上文
&lt;a class="reference external" href="#btf-enabled-bpf-program-types-with-direct-memory-reads"&gt;&amp;quot;可以直接读取内存的 BTF-enabled 的 BPF 程序类型&amp;quot;&lt;/a&gt; 部分），
才应该使用 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_BITFIELD()&lt;/tt&gt; 。
这两个宏都以 &lt;tt class="docutils literal"&gt;u64&lt;/tt&gt; 整数的形式返回位域的值。
下面是从 &lt;tt class="docutils literal"&gt;struct tcp_sock&lt;/tt&gt; 中读取位字段的示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;u64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;sk_get_syn_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;tcp_sock&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* extract tp-&amp;gt;syn_data bitfield value */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_CORE_READ_BITFIELD_PROBED&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;syn_data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是这么简单。使用 BCC，实现相同效果可能会导致如下结果
（作为练习，读者可以自行思考为什么这样可以工作以及何时会出现问题）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;u64&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;sk_get_syn_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;tcp_sock&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;u8&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* get byte before tlp_high_seq */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;bpf_probe_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;tlp_high_seq&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* syn_data is the third bit of that byte in little-endian */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mh"&gt;0x1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;随着内核版本的变化，编写、阅读和维护 &lt;tt class="docutils literal"&gt;struct tcp_sock&lt;/tt&gt; 变得越来越困难，令人感到头痛。
但有了 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_BITFIELD_PROBED()&lt;/tt&gt; 后，这些问题就都迎刃而解了，变得轻而易举。&lt;/p&gt;
&lt;p&gt;值得注意的是 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_BITFIELD()&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;BPF_CORE_READ_BITFIELD_PROBED()&lt;/tt&gt; 还有一个重要特性。
它们不仅可以读取位域，还可以读取 &lt;strong&gt;任意整数&lt;/strong&gt; 字段。无论字段的实际类型是什么（位域或最多 8 字节大小的整数），
这些宏都会正确地返回符号扩展的 8 字节整数。即使字段从整数变为位域，或者反之，它们仍然能正常工作。
即使字段从 &lt;tt class="docutils literal"&gt;int&lt;/tt&gt; 变为 &lt;tt class="docutils literal"&gt;u8&lt;/tt&gt; ，它们也可以继续工作。
因此， &lt;tt class="docutils literal"&gt;BPF_CORE_READ_BITFIELD()&lt;/tt&gt; 宏是 &lt;strong&gt;一种通用的读取任何整数字段&lt;/strong&gt; 的方法，不受字段性质或大小的限制。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;span id="sizing-kernel-types-and-fields"&gt;&lt;/span&gt;&lt;h3 id="hidsection-4"&gt;计算内核类型和字段的大小&lt;a class="headerlink" href="#hidsection-4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;正如在前面某个小节中提到的， &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 并不会自动让读取大小不固定的字段（例如整个结构体或数组）的操作变得
CO-RE 可重定位，因为在内核中预先分配足够的目标内存以适应任何的大小变化通常相当的困难。&lt;/p&gt;
&lt;p&gt;然而，在某些情况下，了解字段或类型的大小是很重要的。为了满足这种需求，
BPF CO-RE 提供了两个辅助函数： &lt;tt class="docutils literal"&gt;bpf_core_type_size()&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;bpf_core_field_size()&lt;/tt&gt; 。
它们的使用方式类似于 &lt;tt class="docutils literal"&gt;bpf_core_type_exists()&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;bpf_core_field_exists()&lt;/tt&gt; （将在下一节中介绍），
不同的是，它们不返回 0 或 1，而是以字节为单位返回字段或类型的大小。&lt;/p&gt;
&lt;p&gt;您可以根据需要自行处理这个值：您可以将其作为第二个参数传递给 &lt;tt class="docutils literal"&gt;bpf_core_read()&lt;/tt&gt; ，
让读取变得完全 CO-RE 可重定位。如果您处理的是结构体数组，并且需要跳过前几个实例，
您可以使用 &lt;tt class="docutils literal"&gt;bpf_core_type_size()&lt;/tt&gt; 来计算正确的字节偏移量，以便找到第 N 个元素的起始位置。
或者您可以仅将其用于调试和报告用途，这完全取决于您，BPF CO-RE 并没有限制您如何使用它的特性。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;span id="dealing-with-kernel-changes-and-feature-detection"&gt;&lt;/span&gt;&lt;h2 id="hidsection-5"&gt;处理内核变更和特性检测&lt;a class="headerlink" href="#hidsection-5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 系列宏是 BPF CO-RE 的主力军，然而使用 BPF CO-RE 构建实用的 BPF 应用程序还需要更多的技巧。&lt;/p&gt;
&lt;p&gt;BPF 应用程序经常需要处理的一个常见问题是进行特性检测。也就是说，检测特定主机内核是否支持某种新的可选特性，
BPF 应用程序可以利用这些特性来获取更多信息或提高效率。如果不支持，
BPF 应用程序会选择回退到支持旧版内核的代码，而不是简单地直接失败。&lt;/p&gt;
&lt;p&gt;BPF CO-RE 提供了多种不同的机制来满足这类需求。当然，除了特性检测外，您也可以在其他场景下使用下面介绍的机制，
但是，我将以特性检测为主要场景来介绍所有的内容。&lt;/p&gt;
&lt;div class="section" id="bpf-core-field-exists-1"&gt;
&lt;span id="bpf-core-field-exists"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-field-exists-1"&gt;bpf_core_field_exists()&lt;a class="headerlink" href="#hidbpf-core-field-exists-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;bpf_core_field_exists()&lt;/tt&gt; 函数允许检查给定的内核类型是否包含特定的字段。
在内核特性检测的场景下中，如果某个期望的内核特性在被引入的时候，还引入了一些特定字段到其中一个内核类型，
那么就可以简单的通过直接使用 &lt;tt class="docutils literal"&gt;bpf_core_field_exists()&lt;/tt&gt; 函数来检测这类特性。&lt;/p&gt;
&lt;p&gt;举个具体的例子，一种检测内核是否支持 BPF cookie for perf-based BPF program types（tracepoints、kprobes、uprobes）
（由 &lt;a class="reference external" href="https://github.com/torvalds/linux/commit/82e6b1eee6a8875ef4eacfd60711cce6965c6b04"&gt;这个提交&lt;/a&gt; 引入）
特性的方法是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;bpf_attr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* could be NULL */&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_core_field_exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;link_create&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;perf_event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bpf_cookie&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* bpf_cookie is supported */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* bpf_cookie is NOT supported */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的示例假设 BPF 程序中有一个 &lt;tt class="docutils literal"&gt;union bpf_attr *&lt;/tt&gt; 类型的变量。
这个变量可以是 &lt;tt class="docutils literal"&gt;NULL&lt;/tt&gt; ，这实际上并不重要，因为指针本身从未被读取，
它只是为了向编译器传递类型信息而存在。
对于没有所需类型的现成变量可用的场景，您可以编写如下等效的检查代码（利用 C 语言的类型系统特性）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_core_field_exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;union&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;bpf_attr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;link_create&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;perf_event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bpf_cookie&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* bpf_cookie is supported */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* bpf_cookie is NOT supported */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这段代码中，如果主机内核的 &lt;tt class="docutils literal"&gt;union bpf_attr&lt;/tt&gt; 中没有 &lt;tt class="docutils literal"&gt;link_create.perf_event.bpf_cookie&lt;/tt&gt; ，
那么 &lt;tt class="docutils literal"&gt;if&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;else&lt;/tt&gt; 结构中的第一个分支中的代码将 &lt;em&gt;永远不会被执行&lt;/em&gt; （也 &lt;em&gt;不会被验证&lt;/em&gt; ）。&lt;/p&gt;
&lt;p&gt;值得重申的是 BPF 验证器会正确地将这样的代码识别为 &lt;strong&gt;死代码（dead code）&lt;/strong&gt; ，
因此这些代码 &lt;strong&gt;不会被验证&lt;/strong&gt; 。这意味着这样的代码可以使用主机内核上不存在的
内核和 BPF 功能（比如，新的 BPF 辅助函数），并且不需要担心 BPF 验证失败的问题。
比如，如果上述第一个分支要使用 &lt;tt class="docutils literal"&gt;bpf_get_attach_cookie()&lt;/tt&gt; 辅助函数来使用 BPF cookie 特性，
那么该程序将能够在尚未具有该辅助函数的旧内核上被正确的验证。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bpf-core-type-exists-1"&gt;
&lt;span id="bpf-core-type-exists"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-type-exists-1"&gt;bpf_core_type_exists()&lt;a class="headerlink" href="#hidbpf-core-type-exists-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在一些场景下，类型的存在本身就很重要，BPF CO-RE 提供了一种检查类型存在性的方式，
即 &lt;tt class="docutils literal"&gt;bpf_core_type_exists()&lt;/tt&gt; 辅助函数。
以下是一个检测内核是否支持 BPF 环形缓冲区（ring buffer）的示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_core_type_exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;bpf_ringbuf&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* BPF ringbuf helpers (e.g., bpf_ringbuf_reserve()) exist */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请务必确保你在某处定义了 &lt;tt class="docutils literal"&gt;struct bpf_ringbuf&lt;/tt&gt; （即使是空的），
否则你将会检查 &lt;tt class="docutils literal"&gt;bpf_ringbuf&lt;/tt&gt; 的 &lt;strong&gt;前向声明（forward declaration）&lt;/strong&gt; 是否存在，
这几乎肯定不是你想要的结果。在足够新的 &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; 中，这应该不会成为问题，但是仍然需要注意这一点。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bpf-core-enum-value-exists-1"&gt;
&lt;span id="bpf-core-enum-value-exists"&gt;&lt;/span&gt;&lt;h3 id="hidbpf-core-enum-value-exists-1"&gt;bpf_core_enum_value_exists()&lt;a class="headerlink" href="#hidbpf-core-enum-value-exists-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;能够检测特定枚举值是否存在是非常有用的。这种检查的一个重要的实际应用是 &lt;strong&gt;检测是否支持某个 BPF 辅助函数&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;每个 BPF 辅助函数都对应着 &lt;tt class="docutils literal"&gt;enum bpf_func_id&lt;/tt&gt; 中的一个枚举值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bpf_func_id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;BPF_FUNC_ringbuf_output&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;130&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;BPF_FUNC_ringbuf_reserve&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;131&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此，检查 BPF 助手函数 &lt;tt class="docutils literal"&gt;bpf_xxx()&lt;/tt&gt; 是否存在的最简单方法是检查 &lt;tt class="docutils literal"&gt;enum bpf_func_id&lt;/tt&gt; 中是否存在 &lt;tt class="docutils literal"&gt;BPF_FUNC_xxx&lt;/tt&gt; 。
因此，与在之前的示例中使用 &lt;tt class="docutils literal"&gt;bpf_core_type_exists(struct bpf_ringbuf)&lt;/tt&gt; 进行类型检查不同，我们可以更明确地表达我们的意图：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_core_enum_value_exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bpf_func_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_FUNC_ringbuf_reserve&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* use bpf_ringbuf_reserve() safely */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* fall back to using bpf_perf_event_output() */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;许多其他 BPF 功能也可以类似地被检测到。BPF 程序类型和 BPF map 类型的支持只是另一个例子。&lt;/p&gt;
&lt;p&gt;当然，这种功能并不仅限于与 BPF 相关的功能。任何可以通过字段、类型或枚举值的存在
来检测的内核特性都可以轻松地通过 BPF CO-RE 进行处理。&lt;/p&gt;
&lt;p&gt;特性检测也不仅仅局限于基于类型系统的检查。在接下来的几节中，我们将看一些其他可以用于执行内核特性检测的 BPF CO-RE 机制。而且不仅仅是特性检测，它们还允许在运行时提取内核特定信息（如 Kconfig 值），这通常无法被事先知道。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="linux-kernel-version-1"&gt;
&lt;span id="linux-kernel-version"&gt;&lt;/span&gt;&lt;h3 id="hidlinux-kernel-version-1"&gt;LINUX_KERNEL_VERSION&lt;a class="headerlink" href="#hidlinux-kernel-version-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有时候检测必要功能存在的唯一方法是通过检查 Linux 内核版本。
Libbpf 允许在 BPF 程序代码中使用特殊的 &lt;tt class="docutils literal"&gt;extern&lt;/tt&gt; 变量来实现这一点。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LINUX_KERNEL_VERSION&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦声明了 &lt;tt class="docutils literal"&gt;LINUX_KERNEL_VERSION&lt;/tt&gt; ，它会以与内核本身相同的方式编码当前运行的内核版本。
这样的变量可以像任何其他变量一样使用：可以与之进行比较，打印它，记录并发送到用户态（user-space）等。
在所有的这些情况下，BPF 验证器都知道它的确切值，因此它可以检测死代码，就像上面描述的基于类型系统的检查一样。&lt;/p&gt;
&lt;p&gt;Libbpf 还提供了一个方便的 &lt;tt class="docutils literal"&gt;KERNEL_VERSION(major, minor, patch)&lt;/tt&gt; 宏，用于与 &lt;tt class="docutils literal"&gt;LINUX_KERNEL_VERSION&lt;/tt&gt; 进行比较：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cpf"&gt;&amp;lt;bpf/bpf_helpers.h&amp;gt;&lt;/span&gt;

&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LINUX_KERNEL_VERSION&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LINUX_KERNEL_VERSION&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;KERNEL_VERSION&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* we are on v5.15+ */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="kconfig-extern"&gt;
&lt;span id="kconfig-extern-variables"&gt;&lt;/span&gt;&lt;h3 id="hidkconfig-extern"&gt;Kconfig extern 变量&lt;a class="headerlink" href="#hidkconfig-extern" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;事实上，libbpf 允许为任何内核配置（Kconfig）值声明特殊的 &lt;tt class="docutils literal"&gt;extern&lt;/tt&gt; 变量。
请记住，这 &lt;em&gt;仅在内核通过 /proc/config.gz 公开其内核配置时&lt;/em&gt; 才被支持，
幸运的是，这在现代 Linux 发行版中是非常普遍的情况。
libbpf 支持几种不同类型的变量。它们的使用取决于实际的 Kconfig 值类型：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;对于 &lt;tt class="docutils literal"&gt;y&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;n&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;m&lt;/tt&gt; 三态（tri-state） Kconfig 值，您可以使用 &lt;tt class="docutils literal"&gt;extern enum libbpf_tristate&lt;/tt&gt; 变量，
它定义了三个可能的值： &lt;tt class="docutils literal"&gt;TRI_YES&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;TRI_NO&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;TRI_MODULE&lt;/tt&gt; 。
或者，声明一个 &lt;tt class="docutils literal"&gt;extern char&lt;/tt&gt; 变量，它将直接捕获字符值
（比如，您将确实拥有一个具有 &lt;tt class="docutils literal"&gt;'y'&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;'n'&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;'m'&lt;/tt&gt; 字符值之一的变量）。&lt;/li&gt;
&lt;li&gt;对于 &lt;tt class="docutils literal"&gt;y&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;n&lt;/tt&gt; 两状态（two-state）（布尔值）的 Kconfig 值，您还可以使用 &lt;tt class="docutils literal"&gt;bool&lt;/tt&gt; 类型
（除了已经介绍过的 &lt;tt class="docutils literal"&gt;char&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;enum libbpf_tristate&lt;/tt&gt; 类型）。
在这种情况下， &lt;tt class="docutils literal"&gt;y&lt;/tt&gt; 对应 &lt;tt class="docutils literal"&gt;true&lt;/tt&gt; ，而 &lt;tt class="docutils literal"&gt;n&lt;/tt&gt; 则被转换为 &lt;tt class="docutils literal"&gt;false&lt;/tt&gt; 。&lt;/li&gt;
&lt;li&gt;对于整数 Kconfig 值，请使用 C 语言中的整型数据类型：支持所有 1、2、4 和 8 字节的有符号和无符号整数。
如果实际的 Kconfig 值超出了已声明的整数类型范围，libbpf 将会报错而不是截断数值。&lt;/li&gt;
&lt;li&gt;对于字符串 Kconfig 值，使用 &lt;tt class="docutils literal"&gt;const char[N]&lt;/tt&gt; 数组变量。如果实际值太长了，它将被截断并在末尾添加零终止符，
但是 libbpf 将会发出一个警告而不是报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请记住，如果从 &lt;tt class="docutils literal"&gt;/proc/config.gz&lt;/tt&gt; 中请求的 Kconfig 值缺失，libbpf 将会因为错误而中止程序加载。
为了更好地处理这种情况，可以将这样的 Kconfig extern 变量声明为弱（weak）变量，并加上 &lt;tt class="docutils literal"&gt;__weak&lt;/tt&gt; 属性。
在这种情况下，如果值缺失，将会被假定为 &lt;tt class="docutils literal"&gt;false&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;TRI_NO&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;'\0'&lt;/tt&gt; （零字符）、
&lt;tt class="docutils literal"&gt;0&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;&amp;quot;&amp;quot;&lt;/tt&gt; （空字符串），具体取决于所使用的类型。&lt;/p&gt;
&lt;p&gt;以下是一个快速示例，展示如何声明和使用不同类型的 Kconfig extern 变量:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;LINUX_KERNEL_VERSION&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;libbpf_tristate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_BPF_PRELOAD&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__weak&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_BPF_JIT_ALWAYS_ON&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__weak&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_BPF_JIT_DEFAULT_ON&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__weak&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_HZ&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_MODPROBE_PATH&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__kconfig&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__weak&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LINUX_KERNEL_VERSION&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;KERNEL_VERSION&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;switch&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CONFIG_BPF_PRELOAD&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;TRI_NO&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;TRI_YES&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;case&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="no"&gt;TRI_MODULE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;...;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;CONFIG_BPF_JIT_ALWAYS_ON&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;bpf_printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;BPF_JIT_DEFAULT_ON: %c&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_BPF_JIT_DEFAULT_ON&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;?:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;n&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;bpf_printk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;HZ is %d, MODPROBE_PATH: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_HZ&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CONFIG_MODPROBE_PATH&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-6"&gt;
&lt;span id="relocatable-enums"&gt;&lt;/span&gt;&lt;h3 id="hidsection-6"&gt;可重定位枚举&lt;a class="headerlink" href="#hidsection-6" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一个有趣的挑战是，一些 BPF 应用程序需要处理“不稳定”的内核枚举。也就是说，这些枚举没有固定的常量集或整数值分配给它们。
一个很好的例子是 &lt;tt class="docutils literal"&gt;enum cgroup_subsys_id&lt;/tt&gt; ，
在 &lt;a class="reference external" href="https://github.com/torvalds/linux/blob/87066fdd2e30fe9dd531125d95257c118a74617e/include/linux/cgroup-defs.h#L43-L47"&gt;include/linux/cgroup-defs.h&lt;/a&gt; 中被定义，
其定义可能会根据内核编译时启用的 cgroup 特性而异（详情请参阅 &lt;a class="reference external" href="https://github.com/torvalds/linux/blob/87066fdd2e30fe9dd531125d95257c118a74617e/include/linux/cgroup_subsys.h"&gt;include/linux/cgroup_subsys.h&lt;/a&gt; ）。
因此，如果您需要知道，比如 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;cgroup_subsys_id::cpu_cgrp_id&lt;/span&gt;&lt;/tt&gt; 的实际整数值，
这可能是一个大问题，因为这个枚举是内核内部的，并且是动态生成的。&lt;/p&gt;
&lt;p&gt;再次，BPF CO-RE 发挥了作用。它允许使用 &lt;tt class="docutils literal"&gt;bpf_core_enum_value()&lt;/tt&gt; 宏来捕获实际的值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bpf_core_enum_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cgroup_subsys_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cpu_cgrp_id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/* id will contain the actual integer value in the host kernel */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-7"&gt;
&lt;span id="guarding-potentially-failing-relocations"&gt;&lt;/span&gt;&lt;h3 id="hidsection-7"&gt;防护可能会失败的重定位操作&lt;a class="headerlink" href="#hidsection-7" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在某些内核上缺少某些字段并不罕见。如果一个 BPF 程序尝试使用 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 读取一个缺失的字段，
这将在 BPF 验证过程中导致错误。同样，当获取在主机内核中不存在的枚举值（或类型大小）时，CO-RE 重定位将失败。&lt;/p&gt;
&lt;p&gt;不幸的是，目前这个错误相当晦涩（但将由 libbpf &lt;a class="reference external" href="https://github.com/libbpf/libbpf/issues/371"&gt;很快&lt;/a&gt; 改进。译注：最新版的 libbpf 已改进这个错误），
所以最好意识到这一点，以防您意外遇到它。如果您遇到类似下面的错误，
要知道这是因为 CO-RE 重定位未能找到相应的字段/类型/枚举：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;85&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unknown&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;195896080&lt;/span&gt;
&lt;span class="n"&gt;invalid&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;unknown&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="mi"&gt;195896080&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;195896080&lt;/tt&gt; 的十六进制表示是 &lt;tt class="docutils literal"&gt;0xbad2310&lt;/tt&gt; （代表&amp;quot;bad relo&amp;quot;），它是 libbpf 使用的一个常量，
用于标记失败的 CO-RE 重定位指令。libbpf 不立即报告此类错误的原因是，如果需要，
BPF 应用程序可以优雅地处理缺少的字段/类型/枚举以及相应的 CO-RE 重定位失败。
这使得仅通过一个 BPF 应用程序就能适应内核类型的极端变化成为可能（这是 &amp;quot;Compile Once – Run Everywhere&amp;quot; 哲学的关键目标）。&lt;/p&gt;
&lt;p&gt;当某个字段/类型/枚举可能缺失时，您可以使用在处理内核变更部分中描述的检查之一来保护这样的代码路径。
如果被正确保护，BPF 验证器将知道在该特定内核中不可能触发该代码路径，因此会将其排除为死代码。&lt;/p&gt;
&lt;p&gt;这种方法允许在必要时灵活地捕获内核信息的片段，如果实际运行的内核确实包含这些片段的话。
否则，BPF 应用程序可以优雅地退回到另一种替代逻辑，并妥善处理缺失的功能或数据。
只要适当保护潜在失败的 CO-RE 重定位，一切都能正常运作。这里所说的 CO-RE 重定位指的是任何使用
&lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 系列宏、类型/字段大小重定位或枚举值捕获的操作。
如果目标字段/类型/枚举不存在或定义不兼容的话，这些操作就毫无意义。&lt;/p&gt;
&lt;p&gt;继续前面关于 &lt;tt class="docutils literal"&gt;cpu_cgrp_id&lt;/tt&gt; 枚举值的例子，为了处理那些可能没有定义这种枚举值的内核
（例如，由于未设置 &lt;tt class="docutils literal"&gt;CONFIG_CGROUP_PIDS&lt;/tt&gt; Kconfig 开关），
可以使用 &lt;tt class="docutils literal"&gt;bpf_core_enum_value_exists()&lt;/tt&gt; 进行检查（ &lt;strong&gt;存在性检查永远不会失败！&lt;/strong&gt; ），
该检查返回 &lt;tt class="docutils literal"&gt;true&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;false&lt;/tt&gt; （严格来说，在 C 中是 &lt;tt class="docutils literal"&gt;0&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;1&lt;/tt&gt; ）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_core_enum_value_exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cgroup_subsys_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cpu_cgrp_id&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bpf_core_enum_value&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cgroup_subsys_id&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;cpu_cgrp_id&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;-1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="cm"&gt;/* fallback value */&lt;/span&gt;

&lt;span class="cm"&gt;/* use id even if cpu_cgrp_id isn&amp;#39;t defined */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的示例在任何内核上都能正常运行，无论是否存在 &lt;tt class="docutils literal"&gt;cpu_cgrp_id&lt;/tt&gt; 枚举，
即使 &lt;tt class="docutils literal"&gt;bpf_core_enum_value()&lt;/tt&gt; 操作在没有 &lt;tt class="docutils literal"&gt;cpu_cgrp_id&lt;/tt&gt; 枚举的内核上失败也不会由影响。
这一切都是因为代码路径得到了适当的保护。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-8"&gt;
&lt;span id="advanced-topics"&gt;&lt;/span&gt;&lt;h2 id="hidsection-8"&gt;高级话题&lt;a class="headerlink" href="#hidsection-8" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;前面的部分介绍了大多数常见的 CO-RE 功能。本节将涵盖一些您可能会需要面对的更高级的话题，
这取决于您的 BPF 应用程序需要处理多复杂的内核状态以及在不同内核版本中的变化。&lt;/p&gt;
&lt;div class="section" id="co-re"&gt;
&lt;span id="defining-own-co-re-relocatable-type-definitions"&gt;&lt;/span&gt;&lt;h3 id="hidco-re"&gt;定义自己的 CO-RE 可重定位类型定义&lt;a class="headerlink" href="#hidco-re" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;直到现在，我们一直假设上述示例中使用的内核类型来自于 &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; 头文件，这个头文件是基于最近且足够完整的内核
BTF 生成的。但是，在 BPF CO-RE 中使用 &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; 并不是必需的。它主要是为了方便 BPF 应用程序开发者。&lt;/p&gt;
&lt;p&gt;此外，有时候 &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; 可能不足以解决更高级的情况。这可能是因为所需的类型尚未包含在内核 BTF 中，
或者因为内核中的某些内容以不兼容的方式发生了变化（例如，字段被重命名），
现在您需要处理两个不兼容的相同内核类型的定义（我们将在下文讨论如何处理这种令人沮丧的情况）。&lt;/p&gt;
&lt;p&gt;无论是什么原因，您都很容易定义自己对内核类型的期望，并使其 CO-RE 可重定位。
让我们以 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 作为一个典型的例子。
这是一个庞大而复杂的结构体，但通常你只需要从其完整定义中提取几个简单的字段。
利用 BPF CO-RE 只需要声明你将需要的字段，跳过所有其余部分，保持类型定义简单而简洁。&lt;/p&gt;
&lt;p&gt;假设你只关心 &lt;tt class="docutils literal"&gt;pid&lt;/tt&gt; 、 &lt;tt class="docutils literal"&gt;group_leader&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;comm&lt;/tt&gt;  字段。
按照以下方式声明 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 就足以让一切正常运作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;comm&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;group_leader&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__attribute__&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;preserve_access_index&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先，&lt;em&gt;字段的顺序不重要&lt;/em&gt; 。完全不重要。&lt;/p&gt;
&lt;p&gt;其次，对于允许直接内存读取的 BPF 程序， &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;__attribute__((preserve_access_index))&lt;/span&gt;&lt;/tt&gt; 是必需的。
例如，BTF-enabled raw tracepoints（ &lt;tt class="docutils literal"&gt;SEC(tp_btf)&lt;/tt&gt; ）和
&lt;tt class="docutils literal"&gt;fentry&lt;/tt&gt;/&lt;tt class="docutils literal"&gt;fexit&lt;/tt&gt; BPF 程序。
有了这个属性，任何 &lt;em&gt;使用此结构体定义进行直接内存读取的操作都将自动变得 CO-RE 可重定位&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;当使用显式的 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 宏系列时，不需要使用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;__attribute__((preserve_access_index))&lt;/span&gt;&lt;/tt&gt; ，
因为这些宏会自动强制执行。但如果直接使用旧的 &lt;tt class="docutils literal"&gt;bpf_probe_read_kernel()&lt;/tt&gt; 辅助函数，
如果结构体具有 &lt;tt class="docutils literal"&gt;preserve_access_index&lt;/tt&gt; 属性，这种 probe read 操作也会变得 CO-RE 可重定位。
因此，简单来说， &lt;em&gt;指定这个属性总是一个好主意&lt;/em&gt; 。&lt;/p&gt;
&lt;p&gt;基本就是这样。您可以将此类型用于任何 CO-RE 读取或检查操作。正如您所看到的，它并不需要完全匹配真正的 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 定义。
只需要存在并且兼容的必要字段子集即可。您的 BPF 程序不需要的 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 中定义的其他所有内容对
于 BPF CO-RE 来说都是无关紧要的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-9"&gt;
&lt;span id="handling-incompatible-field-and-type-changes"&gt;&lt;/span&gt;&lt;h3 id="hidsection-9"&gt;处理不兼容的字段和类型变更&lt;a class="headerlink" href="#hidsection-9" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;正如前面所提到的，有些情况下，内核类型和字段的变更会导致两个不同内核中的类型定义不兼容。
比如，考虑在一个结构体中对字段进行重命名。
作为一个非常真实和具体的例子，让我们看一个最近将 &lt;tt class="docutils literal"&gt;task_struct&lt;/tt&gt; 的 &lt;tt class="docutils literal"&gt;state&lt;/tt&gt; 字段重命名为
&lt;tt class="docutils literal"&gt;__state&lt;/tt&gt; 的 &lt;a class="reference external" href="https://github.com/torvalds/linux/commit/2f064a59a11ff9bc22e52e9678bc601404c7cb34"&gt;提交&lt;/a&gt; 。
如果您要编写一个需要读取任务状态的 BPF 应用程序，那么根据内核版本的不同，
您可能需要通过 &lt;strong&gt;两个不同的名称&lt;/strong&gt; 来获取 &lt;strong&gt;相同的字段&lt;/strong&gt; 。让我们看看 BPF CO-RE 如何处理这种情况。&lt;/p&gt;
&lt;p&gt;BPF CO-RE 有一个重要的命名约定（我将其称为 &lt;strong&gt;&amp;quot;忽略后缀规则&amp;quot;&lt;/strong&gt; ）。
这是一个相对不太知名的特性，但它是处理上述情况的关键机制。
对于任何类型、字段、枚举或枚举器，如果实体的名称包含形式为 &lt;tt class="docutils literal"&gt;___something&lt;/tt&gt; （三个下划线加上一些文本）的后缀，
那么这类名称后缀在 CO-RE 重定位的过程中会被忽略，就好像它们从未存在过一样。&lt;/p&gt;
&lt;p&gt;这意味着，如果您在 BPF 应用程序中定义并使用了一个名为 &lt;tt class="docutils literal"&gt;struct task_struct___my_own_copy&lt;/tt&gt; 的结构体，
对于 BPF CO-RE 来说，该结构体就等同于内核中的 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; ，将被匹配和重定位。
字段名称也适用相同的规则（因此 &lt;tt class="docutils literal"&gt;state&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;state___custom&lt;/tt&gt; 实际上是相同的），
枚举类型也是如此（包括枚举类型名称本身以及其中的枚举值名称）。实际上，这种匹配是双向的，
所以如果内核中有 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;struct task_struct___2&lt;/tt&gt; 这样的结构体
（有时由于 C 类型系统和内核源代码中的头文件包含相互作用），
那么这两个结构体都将成为与在 BPF 程序源代码中定义的 &lt;tt class="docutils literal"&gt;struct task_struct___my&lt;/tt&gt; 匹配的候选对象。&lt;/p&gt;
&lt;p&gt;这在实践中意味着，您现在可以拥有多个独立且相互冲突的相同内核类型/字段/枚举的定义，
并且可以将代码编译为有效的 C 代码，同时您可以根据您使用的任何
&lt;a class="reference external" href="#dealing-with-kernel-changes-and-feature-detection"&gt;特性检测&lt;/a&gt;
方法在运行时选择正确的定义。&lt;/p&gt;
&lt;p&gt;让我们来看一个例子，说明如何处理前面提到的将 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;task_struct-&amp;gt;state&lt;/span&gt;&lt;/tt&gt; 重命名为 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;task_struct-&amp;gt;__state&lt;/span&gt;&lt;/tt&gt; 的场景：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/* latest kernel task_struct definition, which can also come from vmlinux.h */&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__attribute__&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;preserve_access_index&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct___old&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__attribute__&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;preserve_access_index&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;bpf_get_current_task&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bpf_core_field_exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;__state&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_CORE_READ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;__state&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* recast pointer to capture task_struct___old type for compiler */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nc"&gt;task_struct___old&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t_old&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* now use old &amp;quot;state&amp;quot; name of the field */&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;BPF_CORE_READ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t_old&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的例子中，有两个最关键的部分。&lt;/p&gt;
&lt;p&gt;首先，基于最新的 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 定义进行字段存在性检查。如果运行的内核版本较旧，尚未具有 &lt;tt class="docutils literal"&gt;__state&lt;/tt&gt; 字段，
&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;bpf_core_field_exists(t-&amp;gt;__state)&lt;/span&gt;&lt;/tt&gt; 将返回 0，对于 &lt;tt class="docutils literal"&gt;if&lt;/tt&gt; 语句的第一个分支, BPF 验证器将
&lt;a class="reference external" href="#guarding-potentially-failing-relocations"&gt;跳过并消除这段死代码&lt;/a&gt; ，
因此 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;t-&amp;gt;__state&lt;/span&gt;&lt;/tt&gt; 将永远不会被尝试读取。&lt;/p&gt;
&lt;p&gt;其次，将 &lt;tt class="docutils literal"&gt;struct task_struct *&lt;/tt&gt; 指针重新转换为 &lt;tt class="docutils literal"&gt;struct task_struct___old *&lt;/tt&gt; 指针。
这是为了让 C 编译器能够跟踪 &lt;tt class="docutils literal"&gt;struct task_struct&lt;/tt&gt; 的“替代定义”
（即本例中的 &lt;tt class="docutils literal"&gt;struct task_struct___old&lt;/tt&gt; ）的类型信息。
编译器将按有效的 C 表达式识别并编译 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;t_old-&amp;gt;state&lt;/span&gt;&lt;/tt&gt; 字段引用（隐藏在 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 实现内部），
同时还会记录相应的 CO-RE 重定位信息，以便让 libbpf 知道 BPF 程序预期读取的类型和字段信息。&lt;/p&gt;
&lt;p&gt;通过 &lt;tt class="docutils literal"&gt;___suffix&lt;/tt&gt; 规则，所有操作都会正确工作。当由 libbpf 预处理一个 BPF 程序以供发送到内核进行验证时，
libbpf 会执行 CO-RE 重定位并正确调整偏移量。其中一个 CO-RE 重定位将无法被解析
（因为 &lt;tt class="docutils literal"&gt;__state&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;state&lt;/tt&gt; 在内核中不能同时存在），这将导致相应的 BPF 指令被“污染（poisoning）”
（回想一下之前介绍过的 &lt;tt class="docutils literal"&gt;0xbad2310&lt;/tt&gt; ），但该指令将受到字段存在逻辑的保护，并在程序加载期间被验证器所消除。&lt;/p&gt;
&lt;p&gt;随着 BPF CO-RE 应用程序数量和复杂性的增长，以及 Linux 内核的演进和不可避免的内部变更和重构，
处理不兼容的内核变更的能力将变得越来越重要，因此请注意这项技术。
上述介绍忽略了一堆实现细节，但仍希望能有助于理解如何在实践中使用这个特性。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="section-10"&gt;
&lt;span id="reading-kernel-data-structures-from-user-space-memory"&gt;&lt;/span&gt;&lt;h3 id="hidsection-10"&gt;从用户态内存中读取内核数据结构&lt;a class="headerlink" href="#hidsection-10" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在一些情况下可能会出现的一个（尽管不太常见的）需求是需要从用户态内存中读取内核类型。
这个类型很可能是内核 UAPI 类型之一，或者是作为系统调用的输入参数传递。
为了满足这类需求（以及为了完整性），libbpf 提供了其 &lt;tt class="docutils literal"&gt;BPF_CORE_READ()&lt;/tt&gt; 宏系列的用户态等效版本：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;bpf_core_read_user()&lt;/tt&gt;;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;bpf_core_read_user_str()&lt;/tt&gt;;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;BPF_CORE_READ_USER_STR_INTO()&lt;/tt&gt;;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;BPF_CORE_READ_USER_INTO()&lt;/tt&gt;;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;BPF_CORE_READ_USER()&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它们的功能和行为与它们的非“user”变体完全相同，唯一的区别在于所有的内存读取都是通过
&lt;tt class="docutils literal"&gt;bpf_probe_read_user()&lt;/tt&gt; 和 &lt;tt class="docutils literal"&gt;bpf_probe_read_user_str()&lt;/tt&gt; BPF 辅助函数完成的，
因此需要传递用户态指针。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="btf-id"&gt;
&lt;span id="capturing-btf-type-ids"&gt;&lt;/span&gt;&lt;h3 id="hidbtf-id"&gt;捕获 BTF 类型 ID&lt;a class="headerlink" href="#hidbtf-id" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;如果你熟悉 &lt;a class="reference external" href="https://nakryiko.com/posts/btf-dedup"&gt;BTF&lt;/a&gt; ，你就会知道 BTF 中的任何类型定义都有对应的
BTF 类型 ID。无论是用于调试和日志记录，还是作为某些 BPF API 的一部分，
了解 BPF 程序正在处理的类型/字段/枚举的 BTF 类型 ID 可能是重要的。
BPF CO-RE 提供了一种从 BPF 程序代码内部捕获这些 BTF 类型 ID 作的整数值的方法。
实际上，它提供了一个捕获两种不同 BTF 类型 ID 的方法。
一种是目标内核 BTF（ &lt;em&gt;内核类型 ID&lt;/em&gt; ），另一种是 BPF 程序自身的 BTF（ &lt;em&gt;本地类型 ID&lt;/em&gt; ）：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;bpf_core_type_id_kernel()&lt;/tt&gt; 函数从运行内核的 BTF 中返回已解析的类型 ID；&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;bpf_core_type_id_local()&lt;/tt&gt; 函数捕获在 BPF 程序编译期间由编译器捕获的类型 ID。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，使用 BPF CO-RE 重定位时，总是涉及到两种 BTF 类型。其中一种是 BPF 程序对 &lt;strong&gt;类型定义的本地期望&lt;/strong&gt;
（比如， &lt;tt class="docutils literal"&gt;vmlinux.h&lt;/tt&gt; 中的类型或使用 &lt;tt class="docutils literal"&gt;preserve_access_index&lt;/tt&gt; 属性
&lt;a class="reference external" href="#defining-own-co-re-relocatable-type-definitions"&gt;手动定义&lt;/a&gt;
的类型）。这种本地 BTF 类型为 libbpf 提供了在内核 BTF 中搜索什么的指导。
因此，它可以是类型/字段/枚举的最小定义，可以只包含必要的字段和枚举值。&lt;/p&gt;
&lt;p&gt;然后 Libbpf 可以使用本地 BTF 类型定义来找到匹配的实际完整的内核 BTF 类型。
上述辅助函数允许捕获参与 CO-RE 重定位的两种类型的 BTF 类型 ID。
它们可能用于在运行时区分不同的内核或本地类型，用于调试和日志记录，
或者潜在地用于未来的 BPF API，这些 API 将接受 BTF 类型 ID 作为输入参数。
目前还没有这样的 API，但它们肯定会在不久的将来出现。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-11"&gt;
&lt;span id="conclusion"&gt;&lt;/span&gt;&lt;h2 id="hidsection-11"&gt;结语&lt;a class="headerlink" href="#hidsection-11" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;希望这篇文章在高效地使用 BPF CO-RE 技术方面提供了足够的信息和实用指导。
欢迎在您的 BPF 需求中创造性地使用它们。
如果有任何不对或无法正常工作的地方，请通过 &lt;a class="reference external" href="http://vger.kernel.org/vger-lists.html#bpf"&gt;BPF 邮件列表&lt;/a&gt; 报告问题。&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sat, 13 Jul 2024 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2024-07-13:2024/07/bpf-core-reference-guide-zh.html</guid><category>ebpf</category><category>bpf</category><category>CO-RE</category><category>libbpf</category></item><item><title>ptcpdump: 抓包时显示进程信息以及对任意进程、容器或 Pod 进行抓包</title><link>https://mozillazg.com/2024/07/ebpf-ptcpdump-capturing-the-network-traffic-of-a-process-or-container-or-pod.html</link><description>&lt;div class="section" id="section-1"&gt;
&lt;h2 id="hidsection-1"&gt;前言&lt;a class="headerlink" href="#hidsection-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;tcpdump 是我们常用的一个网络抓包工具，它的功能非常的强大。但是它还缺少一个大家反馈很久却一直没实现的一个特性，
那就是：在结果中包含/显示发送网络请求/流量的进程信息，以及支持抓取指定进程的网络流量。&lt;/p&gt;
&lt;p&gt;当前针对 tcpdump 抓取的流量信息，如果要获取对应的进程信息的话，常见的方法是：
基于请求的连接信息，通过 &lt;tt class="docutils literal"&gt;ss&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;netstat&lt;/tt&gt; 之内的工具反查进程信息。
这个方法的缺点是：操作起来比较繁琐以及无法查找匹配短生命周期的进程所发送的网络流量。&lt;/p&gt;
&lt;p&gt;至于基于 tcpdump 实现抓取指定进程的网络流量，常见的方法是：在知晓进程要访问的目标服务地址信息的前提下，
在使用 tcpdump 时按目的地址信息过滤流量；
或者是在特定的网络命名空间中运行目标进程，然后再在该网络命名空间下使用 tcpdump 抓包。
这两个方法的缺点是：需要提前知晓目标进程访问的目的地址或者需要改变目标进程的执行方式，适用场景有限。&lt;/p&gt;
&lt;p&gt;本文将介绍一个新的工具 ptcpdump，基于这个工具，我们既可以在抓包时直接感知发送流量的进程信息，
也可以直接对运行中或待运行的任意进程进行网络抓包。如果流量是从容器内的进程发出的话，
它还支持显示流量的容器或 Pod 信息以及对特定容器或 Pod 进行抓包。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ptcpdump"&gt;
&lt;h2 id="hidptcpdump"&gt;ptcpdump 介绍&lt;a class="headerlink" href="#hidptcpdump" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ptcpdump 是一个使用 eBPF 技术开发的、类 tcpdump 的网络抓包工具。
它除了兼容 tcpdump 的常用命令行参数以及包过滤语法外，
还额外提供了如下核心特性：&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;在输出中记录和显示发送网络流量的进程、容器、Pod 信息。&lt;/li&gt;
&lt;li&gt;支持对指定进程、容器以及 Pod 进行抓包。&lt;/li&gt;
&lt;li&gt;支持将抓取的数据包保存为 pcapng 格式，可以使用 tcpdump 或者 Wireshark 做进一步分析。&lt;/li&gt;
&lt;li&gt;当在 Wireshark 中打开保存的 pcapng 文件时，将能够看到每个数据包对应的进程、容器、Pod 信息。&lt;/li&gt;
&lt;li&gt;使用静态链接的方式编译该工具，系统中不需要安装额外的系统链接库。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多信息请参考项目的源代码仓库： &lt;a class="reference external" href="https://github.com/mozillazg/ptcpdump"&gt;https://github.com/mozillazg/ptcpdump&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面将以示例的形式介绍 ptcpdump 的核心功能。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="tcpdump"&gt;
&lt;h2 id="hidtcpdump"&gt;兼容 tcpdump 的常用命令行参数和包过滤语法&lt;a class="headerlink" href="#hidtcpdump" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ptcpdump 兼容 tcpdump 的包过滤语法和常用的命令行参数，比如：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo tcpdump -i eth0 tcp
sudo tcpdump -i eth0 -A -v tcp and port 80 and host 10.10.1.1
sudo tcpdump -i eth0 'tcp[tcpflags] &amp;amp; (tcp-syn|tcp-fin) != 0'
sudo tcpdump -i any
sudo tcpdump -i any -s 0 -n -c 100 -w demo.pcapng port 80
&lt;/pre&gt;
&lt;p&gt;上面这些常见的 tcpdump 命令可以直接无缝替换为对应的 ptcpdump 命令，只需要将 tcpdump 改为 ptcpdump 即可:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo ptcpdump -i eth0 tcp
sudo ptcpdump -i eth0 -A -v tcp and port 80 and host 10.10.1.1
sudo ptcpdump -i eth0 'tcp[tcpflags] &amp;amp; (tcp-syn|tcp-fin) != 0'
sudo ptcpdump -i any
sudo ptcpdump -i any -s 0 -n -c 100 -w demo.pcapng port 80
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="pod"&gt;
&lt;h2 id="hidpod"&gt;在输出中记录和显示发送网络流量的进程、容器和 Pod 信息&lt;a class="headerlink" href="#hidpod" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;默认情况下，ptcpdump 将在输出中显示简单的进程、容器以及 Pod 信息:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 4 port 80 or port 443
2024-07-07 12:56:56 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 12:56:56 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
12:56:59.517657 veth18618a4a wget.13626 In IP 10.244.0.4.46834 &amp;gt; 13.251.96.10.443: Flags [S], seq 2743105662, win 64240, length 0, Container [test], Pod [test.default]
12:56:59.517836 eth0 wget.13626 Out IP 172.19.0.2.46834 &amp;gt; 13.251.96.10.443: Flags [S], seq 2743105662, win 64240, length 0, Container [test], Pod [test.default]
12:56:59.692593 eth0 wget.13626 In IP 13.251.96.10.443 &amp;gt; 172.19.0.2.46834: Flags [S.], seq 1966397178, ack 2743105663, win 65084, length 0, Container [test], Pod [test.default]
12:56:59.692754 veth18618a4a wget.13626 Out IP 13.251.96.10.443 &amp;gt; 10.244.0.4.46834: Flags [S.], seq 1966397178, ack 2743105663, win 65084, length 0, Container [test], Pod [test.default]
4 packets captured
6 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;可以通过指定 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-v&lt;/span&gt;&lt;/tt&gt; 参数，查看更详细的进程、容器以及 Pod 信息:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ptcpdump -i any -c 4 -v port 80 or port 443
2024-07-07 12:58:59 WARN ptcpdump: capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
12:59:02.265356 veth18618a4a In IP (tos 0x0, ttl 64, id 35996, offset 0, flags [DF], proto TCP (6), length 60)
    10.244.0.4.41666 &amp;gt; 13.215.144.61.443: Flags [S], cksum 0xa93a, seq 40651020, win 64240, options [mss 1460,sackOK,TS val 2665081987 ecr 0,nop,wscale 7], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
12:59:02.265606 eth0 Out IP (tos 0x0, ttl 63, id 35996, offset 0, flags [DF], proto TCP (6), length 60)
    172.19.0.2.41666 &amp;gt; 13.215.144.61.443: Flags [S], cksum 0x4a58, seq 40651020, win 64240, options [mss 1460,sackOK,TS val 2665081987 ecr 0,nop,wscale 7], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
12:59:02.462586 eth0 In IP (tos 0x4, ttl 47, id 0, offset 0, flags [DF], proto TCP (6), length 60)
    13.215.144.61.443 &amp;gt; 172.19.0.2.41666: Flags [S.], cksum 0x9772, seq 3160052321, ack 40651021, win 65084, options [mss 1240,sackOK,TS val 3710435767 ecr 2665081987,nop,wscale 9], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
12:59:02.462782 veth18618a4a Out IP (tos 0x4, ttl 46, id 0, offset 0, flags [DF], proto TCP (6), length 60)
    13.215.144.61.443 &amp;gt; 10.244.0.4.41666: Flags [S.], cksum 0x3890, seq 3160052321, ack 40651021, win 65084, options [mss 1240,sackOK,TS val 3710435767 ecr 2665081987,nop,wscale 9], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
4 packets captured
6 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-A&lt;/span&gt;&lt;/tt&gt; 参数以 ASCII 格式输出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:44:34.457504 ens33 curl.205562 Out IP 10.0.2.15.39984 &amp;gt; 139.178.84.217.80: Flags [P.], seq 2722472188:2722472262, ack 892036871, win 64240, length 74, ParentProc [bash.180205]
E..r.,&amp;#64;.&amp;#64;.o.
.....T..0.P.E..5+g.P.......GET / HTTP/1.1
Host: kernel.org
User-Agent: curl/7.81.0
Accept: */*
&lt;/pre&gt;
&lt;p&gt;通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-x&lt;/span&gt;&lt;/tt&gt; 参数以 16 进制格式输出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:44:34.457504 ens33 curl.205562 IP 10.0.2.15.39984 &amp;gt; 139.178.84.217.80: Flags [P.], seq 2722472188:2722472262, ack 892036871, win 64240, length 74, ParentProc [bash.180205]
        0x0000:  4500 0072 de2c 4000 4006 6fbf 0a00 020f
        0x0010:  8bb2 54d9 9c30 0050 a245 a0fc 352b 6707
        0x0020:  5018 faf0 ecfe 0000 4745 5420 2f20 4854
        0x0030:  5450 2f31 2e31 0d0a 486f 7374 3a20 6b65
        0x0040:  726e 656c 2e6f 7267 0d0a 5573 6572 2d41
        0x0050:  6765 6e74 3a20 6375 726c 2f37 2e38 312e
        0x0060:  300d 0a41 6363 6570 743a 202a 2f2a 0d0a
        0x0070:  0d0a
&lt;/pre&gt;
&lt;p&gt;通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-X&lt;/span&gt;&lt;/tt&gt; 参数以 16 进制和 ASCII 格式输出:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:44:34.457504 ens33 curl.205562 IP 10.0.2.15.39984 &amp;gt; 139.178.84.217.80: Flags [P.], seq 2722472188:2722472262, ack 892036871, win 64240, length 74, ParentProc [bash.180205]
        0x0000:  4500 0072 de2c 4000 4006 6fbf 0a00 020f  E..r.,&amp;#64;.&amp;#64;.o.....
        0x0010:  8bb2 54d9 9c30 0050 a245 a0fc 352b 6707  ..T..0.P.E..5+g.
        0x0020:  5018 faf0 ecfe 0000 4745 5420 2f20 4854  P.......GET / HT
        0x0030:  5450 2f31 2e31 0d0a 486f 7374 3a20 6b65  TP/1.1..Host: ke
        0x0040:  726e 656c 2e6f 7267 0d0a 5573 6572 2d41  rnel.org..User-A
        0x0050:  6765 6e74 3a20 6375 726c 2f37 2e38 312e  gent: curl/7.81.
        0x0060:  300d 0a41 6363 6570 743a 202a 2f2a 0d0a  0..Accept: */*..
        0x0070:  0d0a                                     ..
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="pod-1"&gt;
&lt;h2 id="hidpod-1"&gt;支持对指定进程、容器或 Pod 进行抓包&lt;a class="headerlink" href="#hidpod-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="pid"&gt;
&lt;h3 id="hidpid"&gt;指定进程 pid 抓包&lt;a class="headerlink" href="#hidpid" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--pid&lt;/span&gt;&lt;/tt&gt; 参数指定要抓包的进程 pid，实现对指定进程进行抓包:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 4 --pid 82106
2024-07-07 13:11:40 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:11:40 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:11:50.170538 ens33 python3.10.82106 Out IP 10.0.2.15.36648 &amp;gt; 13.251.96.10.443: Flags [S], seq 1633417447, win 64240, length 0
13:11:50.369972 ens33 python3.10.82106 In IP 13.251.96.10.443 &amp;gt; 10.0.2.15.36648: Flags [S.], seq 1793291274, ack 1633417448, win 64240, length 0
2 packets captured
3 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;同时还可以通过指定 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-f&lt;/span&gt;&lt;/tt&gt; 参数对该进程创建的子进程也进行抓包:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 4 --pid 82106 -f 'tcp[tcpflags] &amp;amp; tcp-fin != 0'
2024-07-07 13:17:31 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:17:31 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:17:37.800903 ens33 python3.10.82106 Out IP 10.0.2.15.38576 &amp;gt; 52.74.166.77.443: Flags [F.], seq 2442149577, ack 367271121, win 62780, length 0
13:17:37.977316 ens33 python3.10.82106 In IP 52.74.166.77.443 &amp;gt; 10.0.2.15.38576: Flags [FP.], seq 367271145, ack 2442149578, win 64239, length 0
13:17:44.390627 ens33 curl.95920 Out IP 10.0.2.15.38590 &amp;gt; 52.74.166.77.443: Flags [F.], seq 3726932781, ack 1510095004, win 63045, length 0
13:17:44.564990 ens33 curl.95920 In IP 52.74.166.77.443 &amp;gt; 10.0.2.15.38590: Flags [FP.], seq 1510095028, ack 3726932782, win 64239, length 0
4 packets captured
4 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="section-2"&gt;
&lt;h3 id="hidsection-2"&gt;指定进程名称抓包&lt;a class="headerlink" href="#hidsection-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--pname&lt;/span&gt;&lt;/tt&gt; 参数指定进程名称（comm），实现指定进程名称抓包:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --pname curl
2024-07-07 13:23:18 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:23:18 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:23:24.881499 lo curl.26511 Out IP 127.0.0.1.43332 &amp;gt; 127.0.0.53.53: 44133+ [1au] A? mozillazg.com. (42)
13:23:24.881663 lo curl.26511 Out IP 127.0.0.1.43332 &amp;gt; 127.0.0.53.53: 14694+ [1au] AAAA? mozillazg.com. (42)
2 packets captured
2 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="section-3"&gt;
&lt;h3 id="hidsection-3"&gt;通过运行目标程序来抓包&lt;a class="headerlink" href="#hidsection-3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有需要的话，也可以通过使用 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--&lt;/span&gt;&lt;/tt&gt; 参数运行目标程序的方式来实现对特定程序进行抓包:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -- curl -I https://mozillazg.com
2024-07-07 13:26:44 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:26:44 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:26:44.055757 lo curl.28094 Out IP 127.0.0.1.48826 &amp;gt; 127.0.0.53.53: 8942+ [1au] A? mozillazg.com. (42)
13:26:44.055914 lo curl.28094 Out IP 127.0.0.1.48826 &amp;gt; 127.0.0.53.53: 34274+ [1au] AAAA? mozillazg.com. (42)
13:26:44.775840 lo curl.28094 In IP 127.0.0.53.53 &amp;gt; 127.0.0.1.48826: 8942 3/0/1 CNAME mozillazg.netlify.com., A 13.251.96.10, A 46.137.195.11 (106)
13:26:45.135988 lo curl.28094 In IP 127.0.0.53.53 &amp;gt; 127.0.0.1.48826: 34274 3/0/1 CNAME mozillazg.netlify.com., AAAA 2406:da18:880:3802::c8, AAAA 2406:da18:b3d:e202::64 (130)
13:26:45.136819 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [S], seq 3460683104, win 64800, length 0
13:26:45.310505 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [S.], seq 630810442, ack 3460683105, win 65232, length 0
13:26:45.310821 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683105, ack 630810443, win 507, length 0
13:26:45.414551 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683105:3460683622, ack 630810443, win 507, length 517
13:26:45.595214 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630810443, ack 3460683622, win 127, length 0
13:26:45.595413 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630810443:630811651, ack 3460683622, win 127, length 1208
13:26:45.595595 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630811651, win 501, length 0
13:26:45.595702 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630811651:630812859, ack 3460683622, win 127, length 1208
13:26:45.595797 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630812859, win 492, length 0
13:26:45.595862 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630812859:630813338, ack 3460683622, win 127, length 479
13:26:45.595934 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630813338, win 489, length 0
13:26:45.600998 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683622:3460683686, ack 630813338, win 489, length 64
13:26:45.601344 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683686:3460683781, ack 630813338, win 489, length 95
13:26:45.616759 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683781:3460683882, ack 630813338, win 501, length 101
13:26:45.779516 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813338, ack 3460683781, win 127, length 0
13:26:45.779792 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813338:630813399, ack 3460683781, win 127, length 61
13:26:45.779996 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813399:630813443, ack 3460683781, win 127, length 44
13:26:45.780318 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683882:3460683913, ack 630813443, win 501, length 31
HTTP/2 200
13:26:45.788787 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813443:630813677, ack 3460683882, win 127, length 234
accept-ranges: bytes
age: 79059
cache-control: public,max-age=0,must-revalidate
cache-status: &amp;quot;Netlify Edge&amp;quot;; hit
content-type: text/html; charset=UTF-8
date: Sun, 07 Jul 2024 05:26:44 GMT
etag: &amp;quot;80cf37f5974e2232d976c6f622121dee-ssl&amp;quot;
server: Netlify
strict-transport-security: max-age=31536000
x-nf-request-id: 01J25THACQSN9364YHSR2C0X5F
content-length: 11727

13:26:45.789558 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683913:3460683937, ack 630813677, win 501, length 24
13:26:45.791514 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [F.], seq 3460683937, ack 630813677, win 501, length 0
13:26:45.963642 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813677, ack 3460683937, win 127, length 0
13:26:45.963956 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813677:630813701, ack 3460683937, win 127, length 24
13:26:45.964172 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683937, win 0, length 0
13:26:45.964415 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [F.], seq 630813701, ack 3460683937, win 127, length 0
13:26:45.964506 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683937, win 0, length 0
13:26:45.966158 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813702, ack 3460683938, win 127, length 0
13:26:45.966299 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683938, win 0, length 0
32 packets captured
32 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="section-4"&gt;
&lt;h3 id="hidsection-4"&gt;指定容器抓包&lt;a class="headerlink" href="#hidsection-4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--container-id&lt;/span&gt;&lt;/tt&gt; 参数指定容器 id 进行抓包:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --container-id 36f0310403b1
2024-07-07 13:36:19 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:36:19 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:36:24.191242 veth09dec8f curl.32636 In IP 172.19.0.2.48960 &amp;gt; 18.139.194.139.443: Flags [S], seq 3213779351, win 64240, length 0, Container [kind-control-plane]
13:36:24.191369 wlp4s0 curl.32636 Out IP 192.168.1.50.48960 &amp;gt; 18.139.194.139.443: Flags [S], seq 3213779351, win 64240, length 0, Container [kind-control-plane]
2 packets captured
2 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;也可以通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--container-name&lt;/span&gt;&lt;/tt&gt; 参数指定容器名称进行抓包:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --container-name kind-control-plane
2024-07-07 13:37:16 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:37:16 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:37:22.560764 veth09dec8f curl.33093 In IP 172.19.0.2.39084 &amp;gt; 18.139.194.139.443: Flags [S], seq 3645727033, win 64240, length 0, Container [kind-control-plane]
13:37:22.561010 wlp4s0 curl.33093 Out IP 192.168.1.50.39084 &amp;gt; 18.139.194.139.443: Flags [S], seq 3645727033, win 64240, length 0, Container [kind-control-plane]
2 packets captured
2 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="pod-2"&gt;
&lt;h3 id="hidpod-2"&gt;指定 Pod 抓包&lt;a class="headerlink" href="#hidpod-2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--pod-name&lt;/span&gt;&lt;/tt&gt; 参数指定 Pod 名称进行抓包, 参数值的格式为 &lt;tt class="docutils literal"&gt;&amp;lt;pod &lt;span class="pre"&gt;名称&amp;gt;.&amp;lt;pod&lt;/span&gt; 命名空间&amp;gt;&lt;/tt&gt;:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --pod-name test.default
2024-07-07 13:38:29 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:38:29 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:38:34.175752 eth0 wget.33660 Out IP 172.19.0.2.51564 &amp;gt; 13.215.144.61.443: Flags [S], seq 567383917, win 64240, length 0, Container [test], Pod [test.default]
13:38:34.372894 eth0 wget.33660 In IP 13.215.144.61.443 &amp;gt; 172.19.0.2.51564: Flags [S.], seq 2654865684, ack 567383918, win 65084, length 0, Container [test], Pod [test.default]
2 packets captured
3 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="pcapng-tcpdump-wireshark"&gt;
&lt;h2 id="hidpcapng-tcpdump-wireshark"&gt;将数据保存为 pcapng 格式使用 tcpdump 或 Wireshark 进行分析&lt;a class="headerlink" href="#hidpcapng-tcpdump-wireshark" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="pcapng"&gt;
&lt;h3 id="hidpcapng"&gt;保存为 pcapng 格式&lt;a class="headerlink" href="#hidpcapng" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-w&lt;/span&gt;&lt;/tt&gt; 参数将抓包数据保存为 pcapng 格式:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 5 -w demo.pcapng
2024-07-07 13:41:32 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:41:32 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
5 packets captured
22 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="tcpdump-1"&gt;
&lt;h3 id="hidtcpdump-1"&gt;使用 tcpdump 进行分析&lt;a class="headerlink" href="#hidtcpdump-1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;可以直接通过管道的方式通过 tcpdump 对抓取的数据进行分析:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 5 -w - port 80 | tcpdump -n -r -
reading from file -, link-type EN10MB (Ethernet), snapshot length 65535
2024-07-07 13:44:33 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:44:33 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:44:44.530637 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &amp;gt; 2406:da18:880:3801::c8.80: Flags [S], seq 495824072, win 64800, options [mss 1440,sackOK,TS val 2411675580 ecr 0,nop,wscale 7], length 0
13:44:44.708902 IP6 2406:da18:880:3801::c8.80 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858: Flags [S.], seq 640438481, ack 495824073, win 65232, options [mss 1220,sackOK,TS val 1591525382 ecr 2411675580,nop,wscale 9], length 0
13:44:44.709261 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &amp;gt; 2406:da18:880:3801::c8.80: Flags [.], ack 1, win 507, options [nop,nop,TS val 2411675670 ecr 1591525382], length 0
13:44:44.709475 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &amp;gt; 2406:da18:880:3801::c8.80: Flags [P.], seq 1:78, ack 1, win 507, options [nop,nop,TS val 2411675670 ecr 1591525382], length 77: HTTP: GET / HTTP/1.1
5 packets captured
6 packets received by filter
0 packets dropped by kernel
13:44:44.877110 IP6 2406:da18:880:3801::c8.80 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858: Flags [P.], seq 1:266, ack 78, win 128, options [nop,nop,TS val 1591525469 ecr 2411675670], length 265: HTTP: HTTP/1.1 301 Moved Permanently
&lt;/pre&gt;
&lt;p&gt;也可以通过读取文件的方式通过 tcpdump 对抓取的数据进行分析:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ tcpdump -n -r demo.pcapng
reading from file demo.pcapng, link-type EN10MB (Ethernet), snapshot length 65535
13:47:41.169584 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &amp;gt; 2406:da18:b3d:e201::64.80: Flags [S], seq 3876639697, win 64800, options [mss 1440,sackOK,TS val 2072195434 ecr 0,nop,wscale 7], length 0
13:47:41.571055 IP 192.168.1.50.60580 &amp;gt; 18.139.194.139.80: Flags [S], seq 481256927, win 64240, options [mss 1460,sackOK,TS val 2707199178 ecr 0,nop,wscale 7], length 0
13:47:41.956270 IP6 2406:da18:b3d:e201::64.80 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038: Flags [S.], seq 2283576526, ack 3876639698, win 65232, options [mss 1220,sackOK,TS val 4276006323 ecr 2072195434,nop,wscale 9], length 0
13:47:41.956437 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &amp;gt; 2406:da18:b3d:e201::64.80: Flags [.], ack 1, win 507, options [nop,nop,TS val 2072195828 ecr 4276006323], length 0
13:47:41.956733 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &amp;gt; 2406:da18:b3d:e201::64.80: Flags [P.], seq 1:78, ack 1, win 507, options [nop,nop,TS val 2072195828 ecr 4276006323], length 77: HTTP: GET / HTTP/1.1
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="wireshark"&gt;
&lt;h3 id="hidwireshark"&gt;使用 Wireshark 进行分析&lt;a class="headerlink" href="#hidwireshark" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;当使用 Wireshark 打开保存的 pcapng 格式的文件时，将在 Wireshark 的界面中显示相关的进程、容器以及 Pod 信息：&lt;/p&gt;
&lt;img alt="" src="/static/images/bpf/ptcpdump-wireshark.png" /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="section-5"&gt;
&lt;h2 id="hidsection-5"&gt;参考资料&lt;a class="headerlink" href="#hidsection-5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/ptcpdump"&gt;mozillazg/ptcpdump: Process-aware, eBPF-based tcpdump&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.tcpdump.org/manpages/tcpdump.1-4.99.4.html"&gt;tcpdump(1) man page | TCPDUMP &amp;amp; LIBPCAP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sat, 06 Jul 2024 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2024-07-06:2024/07/ebpf-ptcpdump-capturing-the-network-traffic-of-a-process-or-container-or-pod.html</guid><category>ebpf</category><category>ptcpdump</category><category>tcpdump</category><category>pcapng</category><category>wireshark</category><category>container</category><category>pod</category></item><item><title>ptcpdump: Capturing the Network Traffic of any Process, Container, or Pod</title><link>https://mozillazg.com/2024/07/ebpf-ptcpdump-capturing-the-network-traffic-of-a-process-or-container-or-pod-en.html</link><description>&lt;div class="section" id="preface"&gt;
&lt;h2 id="hidpreface"&gt;Preface&lt;a class="headerlink" href="#hidpreface" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;tcpdump is a widely used network packet capture tool known for its powerful functionality.
Despite its strengths, it still lacks a long-requested feature:
displaying process information associated with network requests/traffic
in the output and enabling the capture of network traffic for specific processes.&lt;/p&gt;
&lt;p&gt;To retrieve process information corresponding to the traffic captured by tcpdump,
a common approach involves associating process details with connection information using tools
such as &lt;tt class="docutils literal"&gt;ss&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;netstat&lt;/tt&gt;.
However, this method has drawbacks—it can be cumbersome to execute and may not effectively
identify network traffic from processes with short lifecycles.&lt;/p&gt;
&lt;p&gt;When capturing network traffic of a specific process using tcpdump, common methods include:
filtering traffic by destination address when knowing the target service address the
process will access; or running the target process in a specific network namespace
and then using tcpdump to capture packets within that namespace.
These methods have limitations as they require prior knowledge of the
target process's destination address or altering the target process's execution, restricting their practicality.&lt;/p&gt;
&lt;p&gt;This article will introduce a new tool called ptcpdump. With this tool, we can directly detect the
process information of the sending traffic while capturing packets.
We can also capture network packets directly for any running or pending process.
If the traffic is generated by a process inside a container, it also supports displaying
the container or Pod information of the traffic and capturing packets for specific containers or Pods.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="ptcpdump-introduction"&gt;
&lt;h2 id="hidptcpdump-introduction"&gt;ptcpdump Introduction&lt;a class="headerlink" href="#hidptcpdump-introduction" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ptcpdump is a network packet capture tool developed using eBPF technology,
designed in a tcpdump-like style.
In addition to supporting tcpdump's common command-line parameters
and packet filtering syntax, it also offers the following core features:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Capture and display information about the processes, containers, and Pods responsible for sending network traffic in the output.&lt;/li&gt;
&lt;li&gt;Support packet capture for specific processes, containers, and Pods.&lt;/li&gt;
&lt;li&gt;Save captured packets in pcapng format for further analysis using tcpdump or Wireshark.&lt;/li&gt;
&lt;li&gt;When opening the saved pcapng file in Wireshark, you can view the details of the process, container, and Pod associated with each data packet.&lt;/li&gt;
&lt;li&gt;Compile this tool using static linking to eliminate the need for additional system libraries installation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For additional information, please refer to the project's source code repository: &lt;a class="reference external" href="https://github.com/mozillazg/tcpdump"&gt;https://github.com/mozillazg/tcpdump&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The following will showcase the core functions of ptcpdump through examples.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="common-command-line-parameters-and-packet-filtering-syntax-compatible-with-tcpdump"&gt;
&lt;h2 id="hidcommon-command-line-parameters-and-packet-filtering-syntax-compatible-with-tcpdump"&gt;Common command-line parameters and packet filtering syntax compatible with tcpdump&lt;a class="headerlink" href="#hidcommon-command-line-parameters-and-packet-filtering-syntax-compatible-with-tcpdump" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;ptcpdump compatible with tcpdump include filtering syntax and most command-line parameters. for example:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo tcpdump -i eth0 tcp
sudo tcpdump -i eth0 -A -v tcp and port 80 and host 10.10.1.1
sudo tcpdump -i eth0 'tcp[tcpflags] &amp;amp; (tcp-syn|tcp-fin) != 0'
sudo tcpdump -i any
sudo tcpdump -i any -s 0 -n -c 100 -w demo.pcapng port 80
&lt;/pre&gt;
&lt;p&gt;The common tcpdump commands mentioned above can be easily replaced with the corresponding
ptcpdump commands by simply changing &lt;tt class="docutils literal"&gt;tcpdump&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;ptcpdump&lt;/tt&gt;.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
sudo ptcpdump -i eth0 tcp
sudo ptcpdump -i eth0 -A -v tcp and port 80 and host 10.10.1.1
sudo ptcpdump -i eth0 'tcp[tcpflags] &amp;amp; (tcp-syn|tcp-fin) != 0'
sudo ptcpdump -i any
sudo ptcpdump -i any -s 0 -n -c 100 -w demo.pcapng port 80
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="capture-and-showcase-the-processes-containers-and-pod-details-involved-in-transmitting-network-traffic-within-the-output"&gt;
&lt;h2 id="hidcapture-and-showcase-the-processes-containers-and-pod-details-involved-in-transmitting-network-traffic-within-the-output"&gt;Capture and showcase the processes, containers, and Pod details involved in transmitting network traffic within the output&lt;a class="headerlink" href="#hidcapture-and-showcase-the-processes-containers-and-pod-details-involved-in-transmitting-network-traffic-within-the-output" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;By default, ptcpdump will show basic information about processes, containers, and Pods in the output.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 4 port 80 or port 443
2024-07-07 12:56:56 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 12:56:56 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
12:56:59.517657 veth18618a4a wget.13626 In IP 10.244.0.4.46834 &amp;gt; 13.251.96.10.443: Flags [S], seq 2743105662, win 64240, length 0, Container [test], Pod [test.default]
12:56:59.517836 eth0 wget.13626 Out IP 172.19.0.2.46834 &amp;gt; 13.251.96.10.443: Flags [S], seq 2743105662, win 64240, length 0, Container [test], Pod [test.default]
12:56:59.692593 eth0 wget.13626 In IP 13.251.96.10.443 &amp;gt; 172.19.0.2.46834: Flags [S.], seq 1966397178, ack 2743105663, win 65084, length 0, Container [test], Pod [test.default]
12:56:59.692754 veth18618a4a wget.13626 Out IP 13.251.96.10.443 &amp;gt; 10.244.0.4.46834: Flags [S.], seq 1966397178, ack 2743105663, win 65084, length 0, Container [test], Pod [test.default]
4 packets captured
6 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;By specifying the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-v&lt;/span&gt;&lt;/tt&gt; parameter, you can access detailed information about processes, containers, and pods.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ ptcpdump -i any -c 4 -v port 80 or port 443
2024-07-07 12:58:59 WARN ptcpdump: capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
12:59:02.265356 veth18618a4a In IP (tos 0x0, ttl 64, id 35996, offset 0, flags [DF], proto TCP (6), length 60)
    10.244.0.4.41666 &amp;gt; 13.215.144.61.443: Flags [S], cksum 0xa93a, seq 40651020, win 64240, options [mss 1460,sackOK,TS val 2665081987 ecr 0,nop,wscale 7], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
12:59:02.265606 eth0 Out IP (tos 0x0, ttl 63, id 35996, offset 0, flags [DF], proto TCP (6), length 60)
    172.19.0.2.41666 &amp;gt; 13.215.144.61.443: Flags [S], cksum 0x4a58, seq 40651020, win 64240, options [mss 1460,sackOK,TS val 2665081987 ecr 0,nop,wscale 7], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
12:59:02.462586 eth0 In IP (tos 0x4, ttl 47, id 0, offset 0, flags [DF], proto TCP (6), length 60)
    13.215.144.61.443 &amp;gt; 172.19.0.2.41666: Flags [S.], cksum 0x9772, seq 3160052321, ack 40651021, win 65084, options [mss 1240,sackOK,TS val 3710435767 ecr 2665081987,nop,wscale 9], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
12:59:02.462782 veth18618a4a Out IP (tos 0x4, ttl 46, id 0, offset 0, flags [DF], proto TCP (6), length 60)
    13.215.144.61.443 &amp;gt; 10.244.0.4.41666: Flags [S.], cksum 0x3890, seq 3160052321, ack 40651021, win 65084, options [mss 1240,sackOK,TS val 3710435767 ecr 2665081987,nop,wscale 9], length 0
    Process (pid 14565, cmd /usr/bin/wget, args wget https://mozillazg.com -O /dev/null)
    Container (name test, id 78116e60ff73d3dc41c795288fbf955ed543c964e56cada0c3fa466bc939a339, image docker.io/library/alpine:3.18, labels {&amp;quot;io.cri-containerd.kind&amp;quot;:&amp;quot;container&amp;quot;,&amp;quot;io.kubernetes.container.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.name&amp;quot;:&amp;quot;test&amp;quot;,&amp;quot;io.kubernetes.pod.namespace&amp;quot;:&amp;quot;default&amp;quot;,&amp;quot;io.kubernetes.pod.uid&amp;quot;:&amp;quot;9e4bc54b-de48-4b1c-8b9e-54709f67ed0c&amp;quot;})
    Pod (name test, namespace default, UID 9e4bc54b-de48-4b1c-8b9e-54709f67ed0c, labels {&amp;quot;run&amp;quot;:&amp;quot;test&amp;quot;}, annotations {&amp;quot;kubernetes.io/config.seen&amp;quot;:&amp;quot;2024-07-07T12:43:29.121307922Z&amp;quot;,&amp;quot;kubernetes.io/config.source&amp;quot;:&amp;quot;api&amp;quot;})
4 packets captured
6 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;With &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-A&lt;/span&gt;&lt;/tt&gt; to print data in ASCII:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:44:34.457504 ens33 curl.205562 Out IP 10.0.2.15.39984 &amp;gt; 139.178.84.217.80: Flags [P.], seq 2722472188:2722472262, ack 892036871, win 64240, length 74, ParentProc [bash.180205]
E..r.,&amp;#64;.&amp;#64;.o.
.....T..0.P.E..5+g.P.......GET / HTTP/1.1
Host: kernel.org
User-Agent: curl/7.81.0
Accept: */*
&lt;/pre&gt;
&lt;p&gt;With &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-x&lt;/span&gt;&lt;/tt&gt; to print data in hex:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:44:34.457504 ens33 curl.205562 IP 10.0.2.15.39984 &amp;gt; 139.178.84.217.80: Flags [P.], seq 2722472188:2722472262, ack 892036871, win 64240, length 74, ParentProc [bash.180205]
        0x0000:  4500 0072 de2c 4000 4006 6fbf 0a00 020f
        0x0010:  8bb2 54d9 9c30 0050 a245 a0fc 352b 6707
        0x0020:  5018 faf0 ecfe 0000 4745 5420 2f20 4854
        0x0030:  5450 2f31 2e31 0d0a 486f 7374 3a20 6b65
        0x0040:  726e 656c 2e6f 7267 0d0a 5573 6572 2d41
        0x0050:  6765 6e74 3a20 6375 726c 2f37 2e38 312e
        0x0060:  300d 0a41 6363 6570 743a 202a 2f2a 0d0a
        0x0070:  0d0a
&lt;/pre&gt;
&lt;p&gt;With &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-X&lt;/span&gt;&lt;/tt&gt; to print data in hex and ASCII:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
14:44:34.457504 ens33 curl.205562 IP 10.0.2.15.39984 &amp;gt; 139.178.84.217.80: Flags [P.], seq 2722472188:2722472262, ack 892036871, win 64240, length 74, ParentProc [bash.180205]
        0x0000:  4500 0072 de2c 4000 4006 6fbf 0a00 020f  E..r.,&amp;#64;.&amp;#64;.o.....
        0x0010:  8bb2 54d9 9c30 0050 a245 a0fc 352b 6707  ..T..0.P.E..5+g.
        0x0020:  5018 faf0 ecfe 0000 4745 5420 2f20 4854  P.......GET / HT
        0x0030:  5450 2f31 2e31 0d0a 486f 7374 3a20 6b65  TP/1.1..Host: ke
        0x0040:  726e 656c 2e6f 7267 0d0a 5573 6572 2d41  rnel.org..User-A
        0x0050:  6765 6e74 3a20 6375 726c 2f37 2e38 312e  gent: curl/7.81.
        0x0060:  300d 0a41 6363 6570 743a 202a 2f2a 0d0a  0..Accept: */*..
        0x0070:  0d0a                                     ..
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="support-capturing-packets-for-specified-processes-containers-or-pods"&gt;
&lt;h2 id="hidsupport-capturing-packets-for-specified-processes-containers-or-pods"&gt;Support capturing packets for specified processes, containers, or Pods&lt;a class="headerlink" href="#hidsupport-capturing-packets-for-specified-processes-containers-or-pods" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="capture-packets-for-a-specific-process-identified-by-its-pid"&gt;
&lt;h3 id="hidcapture-packets-for-a-specific-process-identified-by-its-pid"&gt;Capture packets for a specific process identified by its PID&lt;a class="headerlink" href="#hidcapture-packets-for-a-specific-process-identified-by-its-pid" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You can use the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--pid&lt;/span&gt;&lt;/tt&gt; parameter to specify the process ID for capturing packets,
allowing you to capture packets specifically for the designated process.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 4 --pid 82106
2024-07-07 13:11:40 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:11:40 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:11:50.170538 ens33 python3.10.82106 Out IP 10.0.2.15.36648 &amp;gt; 13.251.96.10.443: Flags [S], seq 1633417447, win 64240, length 0
13:11:50.369972 ens33 python3.10.82106 In IP 13.251.96.10.443 &amp;gt; 10.0.2.15.36648: Flags [S.], seq 1793291274, ack 1633417448, win 64240, length 0
2 packets captured
3 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;You can also capture packets from the subprocesses created by this process by specifying the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-f&lt;/span&gt;&lt;/tt&gt; parameter.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 4 --pid 82106 -f 'tcp[tcpflags] &amp;amp; tcp-fin != 0'
2024-07-07 13:17:31 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:17:31 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:17:37.800903 ens33 python3.10.82106 Out IP 10.0.2.15.38576 &amp;gt; 52.74.166.77.443: Flags [F.], seq 2442149577, ack 367271121, win 62780, length 0
13:17:37.977316 ens33 python3.10.82106 In IP 52.74.166.77.443 &amp;gt; 10.0.2.15.38576: Flags [FP.], seq 367271145, ack 2442149578, win 64239, length 0
13:17:44.390627 ens33 curl.95920 Out IP 10.0.2.15.38590 &amp;gt; 52.74.166.77.443: Flags [F.], seq 3726932781, ack 1510095004, win 63045, length 0
13:17:44.564990 ens33 curl.95920 In IP 52.74.166.77.443 &amp;gt; 10.0.2.15.38590: Flags [FP.], seq 1510095028, ack 3726932782, win 64239, length 0
4 packets captured
4 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="capture-packets-based-on-a-specified-process-name"&gt;
&lt;h3 id="hidcapture-packets-based-on-a-specified-process-name"&gt;Capture packets based on a specified process name&lt;a class="headerlink" href="#hidcapture-packets-based-on-a-specified-process-name" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You can capture packets for a specified process name by using the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--pname&lt;/span&gt;&lt;/tt&gt; parameter to specify the process name (comm).&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --pname curl
2024-07-07 13:23:18 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:23:18 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:23:24.881499 lo curl.26511 Out IP 127.0.0.1.43332 &amp;gt; 127.0.0.53.53: 44133+ [1au] A? mozillazg.com. (42)
13:23:24.881663 lo curl.26511 Out IP 127.0.0.1.43332 &amp;gt; 127.0.0.53.53: 14694+ [1au] AAAA? mozillazg.com. (42)
2 packets captured
2 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="capture-packets-by-executing-the-target-program"&gt;
&lt;h3 id="hidcapture-packets-by-executing-the-target-program"&gt;Capture packets by executing the target program&lt;a class="headerlink" href="#hidcapture-packets-by-executing-the-target-program" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If needed, you can capture packets for specific programs by running the target program with the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--&lt;/span&gt;&lt;/tt&gt; parameter.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -- curl -I https://mozillazg.com
2024-07-07 13:26:44 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:26:44 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:26:44.055757 lo curl.28094 Out IP 127.0.0.1.48826 &amp;gt; 127.0.0.53.53: 8942+ [1au] A? mozillazg.com. (42)
13:26:44.055914 lo curl.28094 Out IP 127.0.0.1.48826 &amp;gt; 127.0.0.53.53: 34274+ [1au] AAAA? mozillazg.com. (42)
13:26:44.775840 lo curl.28094 In IP 127.0.0.53.53 &amp;gt; 127.0.0.1.48826: 8942 3/0/1 CNAME mozillazg.netlify.com., A 13.251.96.10, A 46.137.195.11 (106)
13:26:45.135988 lo curl.28094 In IP 127.0.0.53.53 &amp;gt; 127.0.0.1.48826: 34274 3/0/1 CNAME mozillazg.netlify.com., AAAA 2406:da18:880:3802::c8, AAAA 2406:da18:b3d:e202::64 (130)
13:26:45.136819 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [S], seq 3460683104, win 64800, length 0
13:26:45.310505 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [S.], seq 630810442, ack 3460683105, win 65232, length 0
13:26:45.310821 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683105, ack 630810443, win 507, length 0
13:26:45.414551 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683105:3460683622, ack 630810443, win 507, length 517
13:26:45.595214 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630810443, ack 3460683622, win 127, length 0
13:26:45.595413 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630810443:630811651, ack 3460683622, win 127, length 1208
13:26:45.595595 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630811651, win 501, length 0
13:26:45.595702 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630811651:630812859, ack 3460683622, win 127, length 1208
13:26:45.595797 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630812859, win 492, length 0
13:26:45.595862 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630812859:630813338, ack 3460683622, win 127, length 479
13:26:45.595934 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [.], seq 3460683622, ack 630813338, win 489, length 0
13:26:45.600998 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683622:3460683686, ack 630813338, win 489, length 64
13:26:45.601344 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683686:3460683781, ack 630813338, win 489, length 95
13:26:45.616759 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683781:3460683882, ack 630813338, win 501, length 101
13:26:45.779516 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813338, ack 3460683781, win 127, length 0
13:26:45.779792 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813338:630813399, ack 3460683781, win 127, length 61
13:26:45.779996 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813399:630813443, ack 3460683781, win 127, length 44
13:26:45.780318 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683882:3460683913, ack 630813443, win 501, length 31
HTTP/2 200
13:26:45.788787 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813443:630813677, ack 3460683882, win 127, length 234
accept-ranges: bytes
age: 79059
cache-control: public,max-age=0,must-revalidate
cache-status: &amp;quot;Netlify Edge&amp;quot;; hit
content-type: text/html; charset=UTF-8
date: Sun, 07 Jul 2024 05:26:44 GMT
etag: &amp;quot;80cf37f5974e2232d976c6f622121dee-ssl&amp;quot;
server: Netlify
strict-transport-security: max-age=31536000
x-nf-request-id: 01J25THACQSN9364YHSR2C0X5F
content-length: 11727

13:26:45.789558 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [P.], seq 3460683913:3460683937, ack 630813677, win 501, length 24
13:26:45.791514 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [F.], seq 3460683937, ack 630813677, win 501, length 0
13:26:45.963642 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813677, ack 3460683937, win 127, length 0
13:26:45.963956 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [P.], seq 630813677:630813701, ack 3460683937, win 127, length 24
13:26:45.964172 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683937, win 0, length 0
13:26:45.964415 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [F.], seq 630813701, ack 3460683937, win 127, length 0
13:26:45.964506 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683937, win 0, length 0
13:26:45.966158 wlp4s0 curl.28094 In IP6 2406:da18:880:3802::c8.443 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744: Flags [.], seq 630813702, ack 3460683938, win 127, length 0
13:26:45.966299 wlp4s0 curl.28094 Out IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.53744 &amp;gt; 2406:da18:880:3802::c8.443: Flags [R], seq 3460683938, win 0, length 0
32 packets captured
32 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="capturing-packets-for-a-specific-container"&gt;
&lt;h3 id="hidcapturing-packets-for-a-specific-container"&gt;Capturing Packets for a Specific Container&lt;a class="headerlink" href="#hidcapturing-packets-for-a-specific-container" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You can capture network packets by specifying the container ID using the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--container-id&lt;/span&gt;&lt;/tt&gt; parameter.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --container-id 36f0310403b1
2024-07-07 13:36:19 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:36:19 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:36:24.191242 veth09dec8f curl.32636 In IP 172.19.0.2.48960 &amp;gt; 18.139.194.139.443: Flags [S], seq 3213779351, win 64240, length 0, Container [kind-control-plane]
13:36:24.191369 wlp4s0 curl.32636 Out IP 192.168.1.50.48960 &amp;gt; 18.139.194.139.443: Flags [S], seq 3213779351, win 64240, length 0, Container [kind-control-plane]
2 packets captured
2 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;p&gt;You can also capture packets by specifying the container name using the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--container-name&lt;/span&gt;&lt;/tt&gt; parameter.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --container-name kind-control-plane
2024-07-07 13:37:16 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:37:16 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:37:22.560764 veth09dec8f curl.33093 In IP 172.19.0.2.39084 &amp;gt; 18.139.194.139.443: Flags [S], seq 3645727033, win 64240, length 0, Container [kind-control-plane]
13:37:22.561010 wlp4s0 curl.33093 Out IP 192.168.1.50.39084 &amp;gt; 18.139.194.139.443: Flags [S], seq 3645727033, win 64240, length 0, Container [kind-control-plane]
2 packets captured
2 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="capture-packets-for-a-specific-pod"&gt;
&lt;h3 id="hidcapture-packets-for-a-specific-pod"&gt;Capture packets for a specific Pod&lt;a class="headerlink" href="#hidcapture-packets-for-a-specific-pod" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You can capture packets by specifying the Pod name using the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--pod-name&lt;/span&gt;&lt;/tt&gt; parameter.
The format for the parameter value should be &lt;tt class="docutils literal"&gt;&amp;lt;pod &lt;span class="pre"&gt;name&amp;gt;.&amp;lt;pod&lt;/span&gt; namespace&amp;gt;&lt;/tt&gt;.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 2 --pod-name test.default
2024-07-07 13:38:29 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:38:29 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:38:34.175752 eth0 wget.33660 Out IP 172.19.0.2.51564 &amp;gt; 13.215.144.61.443: Flags [S], seq 567383917, win 64240, length 0, Container [test], Pod [test.default]
13:38:34.372894 eth0 wget.33660 In IP 13.215.144.61.443 &amp;gt; 172.19.0.2.51564: Flags [S.], seq 2654865684, ack 567383918, win 65084, length 0, Container [test], Pod [test.default]
2 packets captured
3 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="save-the-data-in-pcapng-format-and-analyze-it-using-tcpdump-or-wireshark"&gt;
&lt;h2 id="hidsave-the-data-in-pcapng-format-and-analyze-it-using-tcpdump-or-wireshark"&gt;Save the data in pcapng format and analyze it using tcpdump or Wireshark&lt;a class="headerlink" href="#hidsave-the-data-in-pcapng-format-and-analyze-it-using-tcpdump-or-wireshark" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="save-as-pcapng-format"&gt;
&lt;h3 id="hidsave-as-pcapng-format"&gt;Save as pcapng format&lt;a class="headerlink" href="#hidsave-as-pcapng-format" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You can save captured data in pcapng format by using the &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-w&lt;/span&gt;&lt;/tt&gt; parameter.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 5 -w demo.pcapng
2024-07-07 13:41:32 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:41:32 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
5 packets captured
22 packets received by filter
0 packets dropped by kernel
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="analyzing-with-tcpdump"&gt;
&lt;h3 id="hidanalyzing-with-tcpdump"&gt;Analyzing with tcpdump&lt;a class="headerlink" href="#hidanalyzing-with-tcpdump" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You can analyze the captured data using tcpdump through a pipeline method.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ sudo ptcpdump -i any -c 5 -w - port 80 | tcpdump -n -r -
reading from file -, link-type EN10MB (Ethernet), snapshot length 65535
2024-07-07 13:44:33 WARN ptcpdump: verbose output suppressed, use -v[v]... for verbose output
2024-07-07 13:44:33 WARN capturing on any, link-type EN10MB (Ethernet), snapshot length 262144 bytes
13:44:44.530637 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &amp;gt; 2406:da18:880:3801::c8.80: Flags [S], seq 495824072, win 64800, options [mss 1440,sackOK,TS val 2411675580 ecr 0,nop,wscale 7], length 0
13:44:44.708902 IP6 2406:da18:880:3801::c8.80 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858: Flags [S.], seq 640438481, ack 495824073, win 65232, options [mss 1220,sackOK,TS val 1591525382 ecr 2411675580,nop,wscale 9], length 0
13:44:44.709261 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &amp;gt; 2406:da18:880:3801::c8.80: Flags [.], ack 1, win 507, options [nop,nop,TS val 2411675670 ecr 1591525382], length 0
13:44:44.709475 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858 &amp;gt; 2406:da18:880:3801::c8.80: Flags [P.], seq 1:78, ack 1, win 507, options [nop,nop,TS val 2411675670 ecr 1591525382], length 77: HTTP: GET / HTTP/1.1
5 packets captured
6 packets received by filter
0 packets dropped by kernel
13:44:44.877110 IP6 2406:da18:880:3801::c8.80 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.50858: Flags [P.], seq 1:266, ack 78, win 128, options [nop,nop,TS val 1591525469 ecr 2411675670], length 265: HTTP: HTTP/1.1 301 Moved Permanently
&lt;/pre&gt;
&lt;p&gt;You can also analyze the captured data by reading files using tcpdump.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ tcpdump -n -r demo.pcapng
reading from file demo.pcapng, link-type EN10MB (Ethernet), snapshot length 65535
13:47:41.169584 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &amp;gt; 2406:da18:b3d:e201::64.80: Flags [S], seq 3876639697, win 64800, options [mss 1440,sackOK,TS val 2072195434 ecr 0,nop,wscale 7], length 0
13:47:41.571055 IP 192.168.1.50.60580 &amp;gt; 18.139.194.139.80: Flags [S], seq 481256927, win 64240, options [mss 1460,sackOK,TS val 2707199178 ecr 0,nop,wscale 7], length 0
13:47:41.956270 IP6 2406:da18:b3d:e201::64.80 &amp;gt; 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038: Flags [S.], seq 2283576526, ack 3876639698, win 65232, options [mss 1220,sackOK,TS val 4276006323 ecr 2072195434,nop,wscale 9], length 0
13:47:41.956437 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &amp;gt; 2406:da18:b3d:e201::64.80: Flags [.], ack 1, win 507, options [nop,nop,TS val 2072195828 ecr 4276006323], length 0
13:47:41.956733 IP6 2409:8a00:2631:22f0:acdc:55a6:9015:b8f1.43038 &amp;gt; 2406:da18:b3d:e201::64.80: Flags [P.], seq 1:78, ack 1, win 507, options [nop,nop,TS val 2072195828 ecr 4276006323], length 77: HTTP: GET / HTTP/1.1
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="analyzing-network-traffic-with-wireshark"&gt;
&lt;h3 id="hidanalyzing-network-traffic-with-wireshark"&gt;Analyzing Network Traffic with Wireshark&lt;a class="headerlink" href="#hidanalyzing-network-traffic-with-wireshark" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When using Wireshark to open a saved pcapng format file, the relevant process, container,
and Pod information will be displayed in the Wireshark interface:&lt;/p&gt;
&lt;img alt="" src="/static/images/bpf/ptcpdump-wireshark.png" /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="references"&gt;
&lt;h2 id="hidreferences"&gt;References&lt;a class="headerlink" href="#hidreferences" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/mozillazg/ptcpdump"&gt;mozillazg/ptcpdump: Process-aware, eBPF-based tcpdump&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.tcpdump.org/manpages/tcpdump.1-4.99.4.html"&gt;tcpdump(1) man page | TCPDUMP &amp;amp; LIBPCAP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">mozillazg</dc:creator><pubDate>Sat, 06 Jul 2024 00:00:00 +0000</pubDate><guid isPermaLink="false">tag:mozillazg.com,2024-07-06:2024/07/ebpf-ptcpdump-capturing-the-network-traffic-of-a-process-or-container-or-pod-en.html</guid><category>ebpf</category><category>ptcpdump</category><category>tcpdump</category><category>pcapng</category><category>wireshark</category><category>container</category><category>pod</category><category>en-version</category></item></channel></rss>