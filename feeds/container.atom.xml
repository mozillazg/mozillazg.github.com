<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>mozillazg's blog</title><link href="https://mozillazg.com/" rel="alternate"></link><link href="https://mozillazg.com/feeds/container.atom.xml" rel="self"></link><id>https://mozillazg.com/</id><updated>2021-11-21T00:00:00+00:00</updated><entry><title>容器特权模式与非特权模式的区别</title><link href="https://mozillazg.com/2021/11/docker-container-difference-between-privileged-mode-and-non-privileged-mode.html" rel="alternate"></link><updated>2021-11-21T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2021-11-21:2021/11/docker-container-difference-between-privileged-mode-and-non-privileged-mode.html</id><summary type="html">&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;前言&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本文尝试解答容器特权模式和非特权模式的区别，
以及通过它们之间的区别找出哪些场景下必需使用特权模式才能实现业务需求。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;特权模式&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/kubernetes/cri-api"&gt;CRI(Container Runtime Interface)&lt;/a&gt; 中特权模式的说明如下：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
// If set, run container in privileged mode.
// Privileged mode is incompatible with the following options. If
// privileged is set, the following features MAY have no effect:
// 1. capabilities
// 2. selinux_options
// 4. seccomp
// 5. apparmor
//
// Privileged mode implies the following specific options are applied:
// 1. All capabilities are added.
// 2. Sensitive paths, such as kernel module paths within sysfs, are not masked.
// 3. Any sysfs and procfs mounts are mounted RW.
// 4. AppArmor confinement is not applied.
// 5. Seccomp restrictions are not applied.
// 6. The device cgroup does not restrict access to any devices.
// 7. All devices from the host's /dev are available within the container.
// 8. SELinux restrictions are not applied (e.g. label=disabled).
&lt;/pre&gt;
&lt;!-- 通过上面的说明，可以得出如下信息： --&gt;
&lt;!--  --&gt;
&lt;!-- * 开启特权模式后，linux capabilities、SELinux、Seccomp、AppArmor 等限制容器内进程权限的功能可能不会再生效。 --&gt;
&lt;!-- * 开启特权模式时，将： --&gt;
&lt;!--  --&gt;
&lt;!-- * 启用所有的 `linux capabilities &lt;https://man7.org/linux/man-pages/man7/capabilities.7.html&gt;`__ --&gt;
&lt;!-- * 将不再对容器内进程屏蔽主机上的敏感目录，比如 sysfs 下的内核模块文件 --&gt;
&lt;!-- * 任何的 sysfs 和 procfs 挂载目录将以 ``RW`` 读写模式进行挂载 --&gt;
&lt;!-- * 不再应用 AppArmor 安全配置 --&gt;
&lt;!-- * 不再应用 Seccomp 安全约束 --&gt;
&lt;!-- * cgroup 设备将不再禁止访问任何的设备 --&gt;
&lt;!-- * 容器将可以操作主机上的 /dev 下的设备 --&gt;
&lt;!-- * 不再应用 SELinux 安全约束 --&gt;
&lt;p&gt;下面我们将通过示例说明一下每一项的效果。&lt;/p&gt;
&lt;div class="section" id="all-capabilities-are-added"&gt;
&lt;h3 id="hidall-capabilities-are-added"&gt;All capabilities are added&lt;a class="headerlink" href="#hidall-capabilities-are-added" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;普通模式下容器内进程只可以使用有限的一些 linux capabilities:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ docker run --rm -it  r.j3ss.co/amicontained bash

Capabilities:
    BOUNDING -&amp;gt; chown dac_override fowner fsetid kill setgid setuid setpcap net_bind_service net_raw sys_chroot mknod audit_write setfcap
&lt;/pre&gt;
&lt;p&gt;但是，特权模式下的容器内进程可以使用所有的 linux capabilities:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ docker run --privileged --rm -it  r.j3ss.co/amicontained bash

Capabilities:
    BOUNDING -&amp;gt; chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read
&lt;/pre&gt;
&lt;p&gt;也可以通过手动自定义 &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;--cap-add&lt;/span&gt;&lt;/tt&gt; 参数的方式，在普通模式下实现类似的需求:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ docker run --cap-add=ALL  --rm -it  r.j3ss.co/amicontained bash
Capabilities:
        BOUNDING -&amp;gt; chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend audit_read
&lt;/pre&gt;
&lt;p&gt;BTW，特权模式下，容器内进程拥有使用所有的 linux capabilities 的能力，但是，
不表示进程就一定有使用某些 linux capabilities 的权限。比如，如果容器是以非 root 用户启动的，
就算它是以特权模式启动的容器，也不表示它就能够做一些无权限做的事情:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ docker run --rm -it debian:buster chown 65534 /var/log/lastlog

$ docker run -u 65534 --rm -it debian:buster chown 65534 /var/log/lastlog
chown: changing ownership of '/var/log/lastlog': Operation not permitted

$ docker run --privileged -u 65534 --rm -it debian:buster chown 65534 /var/log/lastlog
chown: changing ownership of '/var/log/lastlog': Operation not permitted
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="sensitive-paths-such-as-kernel-module-paths-within-sysfs-are-not-masked"&gt;
&lt;h3 id="hidsensitive-paths-such-as-kernel-module-paths-within-sysfs-are-not-masked"&gt;Sensitive paths, such as kernel module paths within sysfs, are not masked.&lt;a class="headerlink" href="#hidsensitive-paths-such-as-kernel-module-paths-within-sysfs-are-not-masked" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;普通模式下，部分内核模块路径比如 /proc 下的一些目录需要阻止写入、有些又需要允许读写，
这些文件目录将会以 tmpfs 文件系统的方式挂载到容器中，以实现目录 mask 的需求
（TODO: 待进一步更新说明）:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ docker run --rm -it debian:buster mount |grep '/proc.*tmpfs'
tmpfs on /proc/acpi type tmpfs (ro,relatime)
tmpfs on /proc/kcore type tmpfs (rw,nosuid,size=65536k,mode=755)
tmpfs on /proc/keys type tmpfs (rw,nosuid,size=65536k,mode=755)
tmpfs on /proc/timer_list type tmpfs (rw,nosuid,size=65536k,mode=755)
tmpfs on /proc/sched_debug type tmpfs (rw,nosuid,size=65536k,mode=755)
tmpfs on /proc/scsi type tmpfs (ro,relatime)
&lt;/pre&gt;
&lt;p&gt;特权模式下，这些目录将不再以 tmpfs 文件系统的方式挂载:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ docker run --privileged --rm -it debian:buster mount |grep '/proc.*tmpfs'
$
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="any-sysfs-and-procfs-mounts-are-mounted-rw"&gt;
&lt;h3 id="hidany-sysfs-and-procfs-mounts-are-mounted-rw"&gt;Any sysfs and procfs mounts are mounted RW.&lt;a class="headerlink" href="#hidany-sysfs-and-procfs-mounts-are-mounted-rw" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;普通模式下，部分内核文件系统(sysfs、procfs)会被以只读的方式挂载到容器中，以阻止容器内进程随意修改系统内核:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ docker run --rm -it debian:buster mount |grep '(ro'
sysfs on /sys type sysfs (ro,nosuid,nodev,noexec,relatime)
cgroup on /sys/fs/cgroup/systemd type cgroup (ro,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)
cgroup on /sys/fs/cgroup/memory type cgroup (ro,nosuid,nodev,noexec,relatime,memory)
cgroup on /sys/fs/cgroup/rdma type cgroup (ro,nosuid,nodev,noexec,relatime,rdma)
cgroup on /sys/fs/cgroup/cpuset type cgroup (ro,nosuid,nodev,noexec,relatime,cpuset)
cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (ro,nosuid,nodev,noexec,relatime,net_cls,net_prio)
cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (ro,nosuid,nodev,noexec,relatime,cpu,cpuacct)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (ro,nosuid,nodev,noexec,relatime,hugetlb)
cgroup on /sys/fs/cgroup/freezer type cgroup (ro,nosuid,nodev,noexec,relatime,freezer)
cgroup on /sys/fs/cgroup/blkio type cgroup (ro,nosuid,nodev,noexec,relatime,blkio)
cgroup on /sys/fs/cgroup/perf_event type cgroup (ro,nosuid,nodev,noexec,relatime,perf_event)
cgroup on /sys/fs/cgroup/devices type cgroup (ro,nosuid,nodev,noexec,relatime,devices)
cgroup on /sys/fs/cgroup/pids type cgroup (ro,nosuid,nodev,noexec,relatime,pids)
proc on /proc/bus type proc (ro,nosuid,nodev,noexec,relatime)
proc on /proc/fs type proc (ro,nosuid,nodev,noexec,relatime)
proc on /proc/irq type proc (ro,nosuid,nodev,noexec,relatime)
proc on /proc/sys type proc (ro,nosuid,nodev,noexec,relatime)
proc on /proc/sysrq-trigger type proc (ro,nosuid,nodev,noexec,relatime)
tmpfs on /proc/acpi type tmpfs (ro,relatime)
tmpfs on /proc/scsi type tmpfs (ro,relatime)
tmpfs on /sys/firmware type tmpfs (ro,relatime)
&lt;/pre&gt;
&lt;p&gt;但是在特权模式下，内核文件系统将不再以只读的方式被挂载:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ docker run --privileged --rm -it debian:buster mount |grep '(ro'
$
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="apparmor-confinement-is-not-applied"&gt;
&lt;h3 id="hidapparmor-confinement-is-not-applied"&gt;AppArmor confinement is not applied.&lt;a class="headerlink" href="#hidapparmor-confinement-is-not-applied" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;div class="section" id="seccomp-restrictions-are-not-applied"&gt;
&lt;h3 id="hidseccomp-restrictions-are-not-applied"&gt;Seccomp restrictions are not applied.&lt;a class="headerlink" href="#hidseccomp-restrictions-are-not-applied" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;普通模式下，可以通过配置 AppArmor 或 Seccomp 相关安全选项
（如果未配置的话，容器引擎默认也会启用一些对应的默认配置）
对容器进行加固:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ docker run --rm -it  r.j3ss.co/amicontained bash
AppArmor Profile: unconfined
Seccomp: filtering
Blocked Syscalls (63):
        MSGRCV SYSLOG SETPGID SETSID USELIB USTAT SYSFS VHANGUP PIVOT_ROOT _SYSCTL ACCT SETTIMEOFDAY MOUNT UMOUNT2 SWAPON SWAPOFF REBOOT SETHOSTNAME SETDOMAINNAME IOPL IOPERM CREATE_MODULE INIT_MODULE DELETE_MODULE GET_KERNEL_SYMS QUERY_MODULE QUOTACTL NFSSERVCTL GETPMSG PUTPMSG AFS_SYSCALL TUXCALL SECURITY LOOKUP_DCOOKIE CLOCK_SETTIME VSERVER MBIND SET_MEMPOLICY GET_MEMPOLICY KEXEC_LOAD ADD_KEY REQUEST_KEY KEYCTL MIGRATE_PAGES UNSHARE MOVE_PAGES PERF_EVENT_OPEN FANOTIFY_INIT NAME_TO_HANDLE_AT OPEN_BY_HANDLE_AT SETNS PROCESS_VM_READV PROCESS_VM_WRITEV KCMP FINIT_MODULE KEXEC_FILE_LOAD BPF USERFAULTFD PREADV2 PWRITEV2 PKEY_MPROTECT PKEY_ALLOC PKEY_FREE
&lt;/pre&gt;
&lt;p&gt;特权模式下，这些 AppArmor 或 Seccomp 相关配置将不再生效:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ docker run --privileged --rm -it  r.j3ss.co/amicontained bash
AppArmor Profile: unconfined
Seccomp: disabled
&lt;/pre&gt;
&lt;p&gt;普通模式下也可以通过对应的安全选项来禁用 AppArmor 或 Seccomp 特性。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="the-device-cgroup-does-not-restrict-access-to-any-devices"&gt;
&lt;h3 id="hidthe-device-cgroup-does-not-restrict-access-to-any-devices"&gt;The device cgroup does not restrict access to any devices.&lt;a class="headerlink" href="#hidthe-device-cgroup-does-not-restrict-access-to-any-devices" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;默认模式下，只能以只读模式操作 cgroup&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ docker run --rm -it debian:buster mount | grep 'cgroup'
tmpfs on /sys/fs/cgroup type tmpfs (rw,nosuid,nodev,noexec,relatime,mode=755)
cgroup on /sys/fs/cgroup/systemd type cgroup (ro,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)
cgroup on /sys/fs/cgroup/memory type cgroup (ro,nosuid,nodev,noexec,relatime,memory)
cgroup on /sys/fs/cgroup/rdma type cgroup (ro,nosuid,nodev,noexec,relatime,rdma)
cgroup on /sys/fs/cgroup/cpuset type cgroup (ro,nosuid,nodev,noexec,relatime,cpuset)
cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (ro,nosuid,nodev,noexec,relatime,net_cls,net_prio)
cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (ro,nosuid,nodev,noexec,relatime,cpu,cpuacct)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (ro,nosuid,nodev,noexec,relatime,hugetlb)
cgroup on /sys/fs/cgroup/freezer type cgroup (ro,nosuid,nodev,noexec,relatime,freezer)
cgroup on /sys/fs/cgroup/blkio type cgroup (ro,nosuid,nodev,noexec,relatime,blkio)
cgroup on /sys/fs/cgroup/perf_event type cgroup (ro,nosuid,nodev,noexec,relatime,perf_event)
cgroup on /sys/fs/cgroup/devices type cgroup (ro,nosuid,nodev,noexec,relatime,devices)
cgroup on /sys/fs/cgroup/pids type cgroup (ro,nosuid,nodev,noexec,relatime,pids)
&lt;/pre&gt;
&lt;p&gt;特权模式下，将可以对 cgroup 进行读写操作:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ docker run --privileged --rm -it debian:buster mount | grep 'cgroup'
tmpfs on /sys/fs/cgroup type tmpfs (rw,nosuid,nodev,noexec,relatime,mode=755)
cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)
cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)
cgroup on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma)
cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)
cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)
cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)
cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)
cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)
cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)
cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)
cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)
cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="all-devices-from-the-host-s-dev-are-available-within-the-container"&gt;
&lt;h3 id="hidall-devices-from-the-host-s-dev-are-available-within-the-container"&gt;All devices from the host's /dev are available within the container.&lt;a class="headerlink" href="#hidall-devices-from-the-host-s-dev-are-available-within-the-container" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;普通模式下，容器内 /dev 目录下看不到节点 /dev 目录下特有的 devices&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# docker run --rm -it debian:buster ls /dev
console  fd    mqueue  ptmx  random  stderr  stdout  urandom
core     full  null    pts   shm     stdin   tty     zero
&lt;/pre&gt;
&lt;p&gt;特权模式下，容器内的 /dev 目录会包含这些来自节点 /dev 目录下的那些内容:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ docker run --privileged --rm -it debian:buster ls /dev
autofs           mapper              stdin   tty25  tty44  tty63    vcsa1
btrfs-control    mcelog              stdout  tty26  tty45  tty7     vcsa2
bus              mem                 tty     tty27  tty46  tty8     vcsa3
console          memory_bandwidth    tty0    tty28  tty47  tty9     vcsa4
core             mqueue              tty1    tty29  tty48  ttyS0    vcsa5
cpu              net                 tty10   tty3   tty49  ttyS1    vcsa6
cpu_dma_latency  network_latency     tty11   tty30  tty5   ttyS2    vcsu
cuse             network_throughput  tty12   tty31  tty50  ttyS3    vcsu1
dri              null                tty13   tty32  tty51  uhid     vcsu2
fb0              nvram               tty14   tty33  tty52  uinput   vcsu3
fd               port                tty15   tty34  tty53  urandom  vcsu4
full             ppp                 tty16   tty35  tty54  usbmon0  vcsu5
fuse             ptmx                tty17   tty36  tty55  usbmon1  vcsu6
hidraw0          ptp0                tty18   tty37  tty56  vcs      vda
hpet             pts                 tty19   tty38  tty57  vcs1     vda1
hwrng            random              tty2    tty39  tty58  vcs2     vfio
infiniband       raw                 tty20   tty4   tty59  vcs3     vga_arbiter
input            rtc0                tty21   tty40  tty6   vcs4     vhost-net
kmsg             shm                 tty22   tty41  tty60  vcs5     vhost-vsock
lightnvm         snapshot            tty23   tty42  tty61  vcs6     zero
loop-control     stderr              tty24   tty43  tty62  vcsa
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="selinux-restrictions-are-not-applied-e-g-label-disabled"&gt;
&lt;h3 id="hidselinux-restrictions-are-not-applied-e-g-label-disabled"&gt;SELinux restrictions are not applied (e.g. label=disabled).&lt;a class="headerlink" href="#hidselinux-restrictions-are-not-applied-e-g-label-disabled" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;特权模式下，SELinux 相关的安全加固配置将被禁用。&lt;/p&gt;
&lt;p&gt;普通模式下也可以通过对应的安全选项来禁用 SELinux 特性。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;参考资料&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/kubernetes/cri-api"&gt;kubernetes/cri-api: Container Runtime Interface (CRI) – a plugin interface which enables kubelet to use a wide variety of container runtimes.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://man7.org/linux/man-pages/man7/capabilities.7.html"&gt;capabilities(7) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities"&gt;Docker run reference | Docker Documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="privileged"></category><category term="security"></category></entry><entry><title>一个在容器外用 tcpdump 命令对容器内的网络请求抓包的方法</title><link href="https://mozillazg.com/2020/04/use-tcpdump-for-a-container-but-outside-container.html" rel="alternate"></link><updated>2020-04-04T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2020-04-04:2020/04/use-tcpdump-for-a-container-but-outside-container.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;前言&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;如题所述，记录一种在不进入容器的情况下对容器进行抓包的方法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;方法介绍&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;简单来说就是找到容器所用的网卡，然后在 host 机器上对该网卡进行抓包就可以了 :joy&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;操作示例&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;创建一个测试容器:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ docker run -d --rm --name test2 busybox sh -c 'while true; do wget baidu.com -O /tmp/test ; sleep 1; done'
1adfbbc5e3519eed16334590934c48cce778728660508a255f6fafe600c6bcd1
&lt;/pre&gt;
&lt;p&gt;找到这个容器使用的网卡:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ PID=$(docker inspect --format {{.State.Pid}} test2)

$ nsenter -n -t $PID ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
18: eth0&amp;#64;if19: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
&lt;/pre&gt;
&lt;p&gt;上面的那个 &lt;tt class="docutils literal"&gt;&amp;#64;if19&lt;/tt&gt; 是关键信息，然后在 host 机器上找到这个 &lt;tt class="docutils literal"&gt;&amp;#64;if19&lt;/tt&gt; 对应的网卡:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# ip addr
...
19: veth504d7e6&amp;#64;if18: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue master docker0 state UP group default
    link/ether 9a:e8:ea:58:9d:f1 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet6 fe80::98e8:eaff:fe58:9df1/64 scope link
       valid_lft forever preferred_lft forever
&lt;/pre&gt;
&lt;p&gt;这个 &lt;tt class="docutils literal"&gt;19:&lt;/tt&gt; 就是我们要找的 &lt;tt class="docutils literal"&gt;&amp;#64;if19&lt;/tt&gt; 网卡信息，抓包的时候指定对应的网卡 &lt;tt class="docutils literal"&gt;veth504d7e6&lt;/tt&gt; ， 现在可以抓包了:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ tcpdump -i veth504d7e6 port 80 -A
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on veth504d7e6, link-type EN10MB (Ethernet), capture size 262144 bytes
05:39:43.181244 IP 172.17.0.2.33430 &amp;gt; 39.156.69.79.http: Flags [S], seq 2619505737, win 29200, options [mss 1460,sackOK,TS val 812639981 ecr 0,nop,wscale 7], length 0
E..&amp;lt;Vj&amp;#64;.&amp;#64;..S....'.EO...P.&amp;quot;|I......r..-.........
0o..........
05:39:43.270550 IP 39.156.69.79.http &amp;gt; 172.17.0.2.33430: Flags [S.], seq 820750215, ack 2619505738, win 8192, options [mss 1452,sackOK,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,nop,wscale 5], length 0
E..&amp;lt;Vj&amp;#64;.,..O'.EO.....P..0....&amp;quot;|J.. ..:......................
05:39:43.270608 IP 172.17.0.2.33430 &amp;gt; 39.156.69.79.http: Flags [.], ack 1, win 229, length 0
E..(Vk&amp;#64;.&amp;#64;..f....'.EO...P.&amp;quot;|J0...P.......
05:39:43.270686 IP 172.17.0.2.33430 &amp;gt; 39.156.69.79.http: Flags [P.], seq 1:73, ack 1, win 229, length 72: HTTP: GET / HTTP/1.1
E..pVl&amp;#64;.&amp;#64;.......'.EO...P.&amp;quot;|J0...P....a..GET / HTTP/1.1
Host: baidu.com
User-Agent: Wget
Connection: close
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;总结&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2 id="hidid5"&gt;参考资料&lt;a class="headerlink" href="#hidid5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://man7.org/linux/man-pages/man1/nsenter.1.html"&gt;nsenter(1) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.docker.com/engine/reference/commandline/inspect/"&gt;docker inspect | Docker Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mozillazg.com/2018/01/tcpdump-common-useful-examples-cookbook.html"&gt;tcpdump 常用操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mozillazg.com/2020/04/nsenter-usage.html"&gt;nsenter 常用操作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="debug"></category><category term="tcpdump"></category><category term="nsenter"></category><category term="docker"></category></entry><entry><title>nsenter 常用操作</title><link href="https://mozillazg.com/2020/04/nsenter-usage.html" rel="alternate"></link><updated>2020-04-03T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2020-04-03:2020/04/nsenter-usage.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;前言&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;nsenter 是一个可以用来进入到目标程序说在 namespace 中运行命令的工具，一般可以用于在容器外 debug 容器中运行的程序。简单记录一下 nsenter 的常用用法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;常用参数&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;最常用的参数组合是:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;nsenter -a -t &amp;lt;pid&amp;gt; &amp;lt;command&amp;gt;
&lt;span class="c1"&gt;# 有的版本没有 -a 这个参数&lt;/span&gt;
nsenter -m -u -i -n -p -t &amp;lt;pid&amp;gt; &amp;lt;command&amp;gt;
&lt;span class="c1"&gt;# 有的版本没有 -t 这个参数&lt;/span&gt;
nsenter -m /proc/1/ns/mnt -u /proc/1/ns/uts -i /proc/1/ns/ipc -n /proc/1/ns/net &amp;lt;command&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数的含义如下:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-a,&lt;/span&gt; &lt;span class="pre"&gt;--all&lt;/span&gt;&lt;/tt&gt;             enter all namespaces of the target process by the default /proc/[pid]/ns/* namespace paths.&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-m,&lt;/span&gt; &lt;span class="pre"&gt;--mount[=&amp;lt;file&amp;gt;]&lt;/span&gt;&lt;/tt&gt;   enter mount namespace&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-u,&lt;/span&gt; &lt;span class="pre"&gt;--uts[=&amp;lt;file&amp;gt;]&lt;/span&gt;&lt;/tt&gt;     enter UTS namespace (hostname etc)&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-i,&lt;/span&gt; &lt;span class="pre"&gt;--ipc[=&amp;lt;file&amp;gt;]&lt;/span&gt;&lt;/tt&gt;     enter System V IPC namespace&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-n,&lt;/span&gt; &lt;span class="pre"&gt;--net[=&amp;lt;file&amp;gt;]&lt;/span&gt;&lt;/tt&gt;     enter network namespace&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-p,&lt;/span&gt; &lt;span class="pre"&gt;--pid[=&amp;lt;file&amp;gt;]&lt;/span&gt;&lt;/tt&gt;     enter pid namespace&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;-t,&lt;/span&gt; &lt;span class="pre"&gt;--target&lt;/span&gt; &amp;lt;pid&amp;gt;&lt;/tt&gt;     target process to get namespaces from&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结合 docker 使用用于在某个容器的 namespace 中运行指定程序的常用命令是:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;PID&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;docker inspect --format &lt;span class="o"&gt;{{&lt;/span&gt;.State.Pid&lt;span class="o"&gt;}}&lt;/span&gt; &amp;lt;container_name_or_ID&amp;gt;&lt;span class="k"&gt;)&lt;/span&gt;
nsenter -m -u -i -n -p -t &lt;span class="nv"&gt;$PID&lt;/span&gt; &amp;lt;command&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ docker run --rm --name test -d busybox  sleep 10000
8115009baccc53a2a5f6dfff642e0d8ab1dfb95dde473d14fb9a06ce4e89364c

$ docker ps |grep busybox
8115009baccc        busybox             &amp;quot;sleep 10000&amp;quot;            9 seconds ago       Up 8 seconds                            test

$ PID=$(docker inspect --format {{.State.Pid}} 8115009baccc)

$ nsenter -m -u -i -n -p -t $PID ps aux
PID   USER     TIME  COMMAND
    1 root      0:00 sleep 10000
    7 root      0:00 ps aux

$ nsenter -m -u -i -n -p -t $PID hostname
8115009baccc
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;参考资料&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://man7.org/linux/man-pages/man1/nsenter.1.html"&gt;nsenter(1) - Linux manual page&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://docs.docker.com/engine/reference/commandline/inspect/"&gt;docker inspect | Docker Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/alexei-led/nsenter"&gt;alexei-led/nsenter: Slim nsenter Docker image - enter into Docker container/host namespaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://alexei-led.github.io/post/k8s_node_shell/"&gt;Terra Nullius&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="nsenter"></category><category term="debug"></category><category term="tools"></category><category term="docker"></category></entry><entry><title>使用 Alpine 作为基础镜像时可能会遇到的常见问题的解决方法</title><link href="https://mozillazg.com/2020/03/use-alpine-image-common-issues.rst.html" rel="alternate"></link><updated>2020-03-31T00:00:00+00:00</updated><author><name>mozillazg</name></author><id>tag:mozillazg.com,2020-03-31:2020/03/use-alpine-image-common-issues.rst.html</id><summary type="html">&lt;div class="section" id="id1"&gt;
&lt;h2 id="hidid1"&gt;前言&lt;a class="headerlink" href="#hidid1" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;简单记录一下使用 Alpine 作为基础镜像时可能会遇到的常见问题的解决方法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2 id="hidid2"&gt;设置国内软件仓库镜像&lt;a class="headerlink" href="#hidid2" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;alpine 镜像默认的软件仓库在国外，有时 docker build 的时候安装软件包会很慢。&lt;/p&gt;
&lt;p&gt;解决方法：使用国内的软件包镜像，比如 &lt;a class="reference external" href="https://mirrors.ustc.edu.cn"&gt;https://mirrors.ustc.edu.cn&lt;/a&gt; 的镜像:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
RUN sed -i 's!http://dl-cdn.alpinelinux.org/!https://mirrors.ustc.edu.cn/!g' /etc/apk/repositories
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="panic-open-usr-local-go-lib-time-zoneinfo-zip-no-such-file-or-directory"&gt;
&lt;h2 id="hidpanic-open-usr-local-go-lib-time-zoneinfo-zip-no-such-file-or-directory"&gt;panic: open /usr/local/go/lib/time/zoneinfo.zip: no such file or directory&lt;a class="headerlink" href="#hidpanic-open-usr-local-go-lib-time-zoneinfo-zip-no-such-file-or-directory" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;有些使用 alpine 作为基础镜像的 go 程序镜像可能会出现类似下面这样的错误:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
panic: open /usr/local/go/lib/time/zoneinfo.zip: no such file or directory
&lt;/pre&gt;
&lt;p&gt;常见原因：alpine 基础镜像中没有包含时区信息文件，当代码中有调用类似下面这样的通过名称获取时区信息的时候，就会出现上面的错误:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
lc, err := time.LoadLocation(&amp;quot;Asia/Shanghai&amp;quot;)
if err != nil {
    panic(err)
}

panic: open /usr/local/go/lib/time/zoneinfo.zip: no such file or directory
&lt;/pre&gt;
&lt;p&gt;解决方法：安装 &lt;tt class="docutils literal"&gt;tzdata&lt;/tt&gt; 这个包:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
RUN apk --no-cache add tzdata
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2 id="hidid3"&gt;配置时区&lt;a class="headerlink" href="#hidid3" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;可以通过下面的方法配置时区，大部分程序都会认这个配置:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
RUN apk --no-cache add tzdata &amp;amp;&amp;amp; \
    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;amp;&amp;amp; \
    echo &amp;quot;Asia/Shanghai&amp;quot; &amp;gt; /etc/timezone
ENV TZ Asia/Shanghai
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="not-found-no-such-file"&gt;
&lt;h2 id="hidnot-found-no-such-file"&gt;明明镜像中有对应的二进制文件，但是执行时却提示 not found 或 no such file&lt;a class="headerlink" href="#hidnot-found-no-such-file" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;有时可能会遇到明明镜像中存在相应的二进制文件，但是执行对应的二进制文件时却提示 &lt;tt class="docutils literal"&gt;not found&lt;/tt&gt; 或 &lt;tt class="docutils literal"&gt;no such file&lt;/tt&gt; 错误，类似下面这样:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# ls /usr/bin/grep
/usr/bin/grep

# /usr/bin/grep
/bin/sh: /usr/bin/grep: not found
&lt;/pre&gt;
&lt;p&gt;常见原因：该二进制文件是使用动态链接方式编译了一个使用了 &lt;tt class="docutils literal"&gt;GLIBC&lt;/tt&gt; 库的程序生成的，但是 alpne 镜像中没有 &lt;tt class="docutils literal"&gt;GLIBC&lt;/tt&gt; 库而是用的 &lt;tt class="docutils literal"&gt;MUSL LIBC&lt;/tt&gt; 库，这样就会导致该二进制文件无法被执行。&lt;/p&gt;
&lt;p&gt;解决办法：下面两个解决方法&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;改为静态编译&lt;/li&gt;
&lt;li&gt;如果要使用动态链接函数编译的话，不要依赖 &lt;tt class="docutils literal"&gt;GLIBC&lt;/tt&gt; （比如编译 Go 程序的时候指定 &lt;tt class="docutils literal"&gt;CGO_ENABLED=0&lt;/tt&gt; ） 或者在 alpine 中编译一个依赖 &lt;tt class="docutils literal"&gt;MUSL LIBC&lt;/tt&gt; 的版本&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="go-https-x509-certificate-signed-by-unknown-authority"&gt;
&lt;h2 id="hidgo-https-x509-certificate-signed-by-unknown-authority"&gt;Go 程序访问 https 服务时提示证书问题：x509: certificate signed by unknown authority&lt;a class="headerlink" href="#hidgo-https-x509-certificate-signed-by-unknown-authority" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Go 程序使用 alpine 作为基础镜像时有时可能会遇到程序中访问 https 服务时会提示证书问题 &lt;tt class="docutils literal"&gt;x509: certificate signed by unknown authority&lt;/tt&gt;&lt;/p&gt;
&lt;p&gt;常见原因：镜像内的 CA 证书信息太老了，需要更新一下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
RUN apk add --no-cache ca-certificates &amp;amp;&amp;amp; \
    update-ca-certificates
&lt;/pre&gt;
&lt;!-- 还有另一个证书错误（待补充对应的 case 和详细错误信息）的原因是：编译的时候没有禁用 CGO，导致编译时使用了部分依赖 glic 的代码，解决方法就是通过 ``CGO_ENABLED=0`` 禁用 CGO（只在确认程序确实不依赖 CGO 也可以正常工作的情况下禁用）:: --&gt;
&lt;!--  --&gt;
&lt;!-- CGO_ENABLED=0 go build --&gt;
&lt;/div&gt;
&lt;div class="section" id="exec-user-process-caused-exec-format-error"&gt;
&lt;h2 id="hidexec-user-process-caused-exec-format-error"&gt;exec user process caused &amp;quot;exec format error&amp;quot;&lt;a class="headerlink" href="#hidexec-user-process-caused-exec-format-error" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;有时运行有些基于 alpine 的容器会提示 &lt;tt class="docutils literal"&gt;exec user process caused &amp;quot;exec format error&amp;quot;&lt;/tt&gt; 。&lt;/p&gt;
&lt;p&gt;常见原因：镜像中的程序编译的时候适配的不是当前运行该镜像的机器的 CPU 架构，比如程序和镜像编译时是为 x86 架构编译的，此时这个镜像就无法在 amd64 架构下运行，会报上面的错误。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h2 id="hidid4"&gt;总结&lt;a class="headerlink" href="#hidid4" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;简单记录了一下使用 Apline 作为基础镜像时可能会遇到的常见问题的解决方法（后面会持续更新）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2 id="hidid5"&gt;参考资料&lt;a class="headerlink" href="#hidid5" title="Permalink to this headline"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://mirrors.ustc.edu.cn/help/alpine.html"&gt;Alpine Linux 源使用帮助 — USTC Mirror Help 文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/takecy/tz-sample"&gt;takecy/tz-sample: Sample for alpine with timezone in Golang&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/aquasecurity/kube-bench/issues/501"&gt;Error Executing 'ps' Command RHEL 7.x/8x - Ubuntu 19x · Issue #501 · aquasecurity/kube-bench&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://stackoverflow.com/questions/36279253/go-compiled-binary-wont-run-in-an-alpine-docker-container-on-ubuntu-host"&gt;Go-compiled binary won't run in an alpine docker container on Ubuntu host - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.jeffsloyer.io/post/cross-compiling-docker-alpine-golang/"&gt;Cross Compiling Golang with a Docker Alpine Container -- JeffSloyer.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://golang.org/pkg/net/#hdr-Name_Resolution"&gt;net - The Go Programming Language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://wiki.alpinelinux.org/wiki/Setting_the_timezone"&gt;Setting the timezone - Alpine Linux&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="alpine"></category></entry></feed>