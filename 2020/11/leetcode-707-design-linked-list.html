<!DOCTYPE html>
<html lang="zh"  prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml" class="han-init">
<head>
    <title>LeetCode: 707. Design Linked List - mozillazg's blog</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- share.css -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">


    <link href="https://mozillazg.com/favicon.ico" rel="icon">

<link rel="canonical" href="https://mozillazg.com/2020/11/leetcode-707-design-linked-list.html">

        <meta name="author" content="mozillazg" />
        <meta name="keywords" content="leetcode,Linked-List,链表" />
    <meta name="description" content="题目 原题地址：https://leetcode.com/problems/design-linked-list/ Design your implementation of the linked list. You can choose to use a singly or doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement the MyLinkedList class: MyLinkedList() Initializes the MyLinkedList object. int get(int index) Get the value of the index-th node in the linked list. If the index is invalid, return -1. void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. void addAtTail(int val) Append a node of value val as the last element of the linked list. void addAtIndex(int index, int val) Add a node of value val before the index-th node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted. void deleteAtIndex(int index) Delete the index-th node in the linked list, if the index is valid. Example 1: Input [&#34;MyLinkedList&#34;, &#34;addAtHead&#34;, &#34;addAtTail&#34;, &#34;addAtIndex&#34;, &#34;get&#34;, &#34;deleteAtIndex&#34;, &#34;get&#34;] [[], [1], [3], [1, 2], [1], [1], [1]] Output [null, null, null, null, 2, null, 3] Explanation MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.addAtHead(1); myLinkedList.addAtTail(3); myLinkedList.addAtIndex(1, 2); // linked list becomes 1-&gt;2-&gt;3 myLinkedList.get(1); // return 2 myLinkedList.deleteAtIndex(1); // now the linked list is 1-&gt;3 myLinkedList.get(1); // return 3 Constraints: 0 &lt;= index, val &lt;= 1000 Please do not use the built-in LinkedList library. At most 2000 calls will be made to get, addAtHead, addAtTail, addAtIndex and deleteAtIndex. 解法 使用单向链表实现 实现时主要需要注意处理几个边界 case: 当链表只有一个元素时，记得确保 head 和 tail 要指向同一个节点 当链表没有元素后，记得确保 head 和 tail 都没有指向任何节点 当删除 tail 指向的节点时，记得更新 tail 指向原来节点的上一个节点 这个方法的 Python 代码类似下面这样: class Node(object): def __init__(self, val=0, next=None): self.val = val self.next = next class MyLinkedList(object): def __init__(self): self._head = None self._tail = None self._length = 0 def get(self, index): &#34;&#34;&#34; Get the value of the index-th node in the linked list. If the index is invalid, return -1. :type index: int :rtype: int &#34;&#34;&#34; if index &lt; 0 or index &gt;= self._length: return -1 node = self._get_node_by_index(index) return node.val def addAtHead(self, val): &#34;&#34;&#34; Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. :type val: int :rtype: None &#34;&#34;&#34; node = Node(val, self._head) self._head = node self._length += 1 # 只有一个元素的链表 head 和 tail 指向同一个节点 if self._length == 1: self._tail = self._head def addAtTail(self, val): &#34;&#34;&#34; Append a node of value val to the last element of the linked list. :type val: int :rtype: None &#34;&#34;&#34; node = Node(val) if self._tail is not None: self._tail.next = node self._tail = node self._length += 1 # 只有一个元素的链表 head 和 tail 指向同一个节点 if self._length == 1: self._head = self._tail def addAtIndex(self, index, val): &#34;&#34;&#34; Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. :type index: int :type val: int :rtype: None &#34;&#34;&#34; if index &gt; self._length: return if index == 0: self.addAtHead(val) return if index == self._length: self.addAtTail(val) return pre = self._get_node_by_index(index -1) curr = pre.next node = Node(val, curr) pre.next = node self._length += 1 def deleteAtIndex(self, index): &#34;&#34;&#34; Delete the index-th node in the linked list, if the index is valid. :type index: int :rtype: None &#34;&#34;&#34; if index &gt;= self._length: return if index == 0: self._head = self._head.next else: pre = self._get_node_by_index(index -1) curr = pre.next pre.next = curr.next # 删除 tail 指向的节点时更新新的 tail 指向节点 if index == self._length - 1: self._tail = pre self._length -= 1 # 当链表为空时 head 和 tail 不指向任何节点 if self._length == 0: self._tail = self._head = None def _get_node_by_index(self, index): node = self._head curr_index = 0 while node is not None: if curr_index == index: return node curr_index += 1 node = node.next return None # Your MyLinkedList object will be instantiated and called as such: # obj = MyLinkedList() # param_1 = obj.get(index) # obj.addAtHead(val) # obj.addAtTail(val) # obj.addAtIndex(index,val) # obj.deleteAtIndex(index) 参考资料 https://leetcode.com/problems/design-linked-list/" />
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4941850466486001"
     crossorigin="anonymous"></script>

    <style>
      .js-toc {
        margin-bottom: 20px;
      }
      .donate-modal {
        text-align: center;
      }
      #donate-modal-container .donate-image {
        max-height: 300px !important;
        min-height: inherit !important;
      }
    </style>

        <meta property="og:site_name" content="mozillazg's blog" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="LeetCode: 707. Design Linked List"/>
        <meta property="og:url" content="https://mozillazg.com/2020/11/leetcode-707-design-linked-list.html"/>
        <meta property="og:description" content="题目 原题地址：https://leetcode.com/problems/design-linked-list/ Design your implementation of the linked list. You can choose to use a singly or doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement the MyLinkedList class: MyLinkedList() Initializes the MyLinkedList object. int get(int index) Get the value of the index-th node in the linked list. If the index is invalid, return -1. void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. void addAtTail(int val) Append a node of value val as the last element of the linked list. void addAtIndex(int index, int val) Add a node of value val before the index-th node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted. void deleteAtIndex(int index) Delete the index-th node in the linked list, if the index is valid. Example 1: Input [&#34;MyLinkedList&#34;, &#34;addAtHead&#34;, &#34;addAtTail&#34;, &#34;addAtIndex&#34;, &#34;get&#34;, &#34;deleteAtIndex&#34;, &#34;get&#34;] [[], [1], [3], [1, 2], [1], [1], [1]] Output [null, null, null, null, 2, null, 3] Explanation MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.addAtHead(1); myLinkedList.addAtTail(3); myLinkedList.addAtIndex(1, 2); // linked list becomes 1-&gt;2-&gt;3 myLinkedList.get(1); // return 2 myLinkedList.deleteAtIndex(1); // now the linked list is 1-&gt;3 myLinkedList.get(1); // return 3 Constraints: 0 &lt;= index, val &lt;= 1000 Please do not use the built-in LinkedList library. At most 2000 calls will be made to get, addAtHead, addAtTail, addAtIndex and deleteAtIndex. 解法 使用单向链表实现 实现时主要需要注意处理几个边界 case: 当链表只有一个元素时，记得确保 head 和 tail 要指向同一个节点 当链表没有元素后，记得确保 head 和 tail 都没有指向任何节点 当删除 tail 指向的节点时，记得更新 tail 指向原来节点的上一个节点 这个方法的 Python 代码类似下面这样: class Node(object): def __init__(self, val=0, next=None): self.val = val self.next = next class MyLinkedList(object): def __init__(self): self._head = None self._tail = None self._length = 0 def get(self, index): &#34;&#34;&#34; Get the value of the index-th node in the linked list. If the index is invalid, return -1. :type index: int :rtype: int &#34;&#34;&#34; if index &lt; 0 or index &gt;= self._length: return -1 node = self._get_node_by_index(index) return node.val def addAtHead(self, val): &#34;&#34;&#34; Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. :type val: int :rtype: None &#34;&#34;&#34; node = Node(val, self._head) self._head = node self._length += 1 # 只有一个元素的链表 head 和 tail 指向同一个节点 if self._length == 1: self._tail = self._head def addAtTail(self, val): &#34;&#34;&#34; Append a node of value val to the last element of the linked list. :type val: int :rtype: None &#34;&#34;&#34; node = Node(val) if self._tail is not None: self._tail.next = node self._tail = node self._length += 1 # 只有一个元素的链表 head 和 tail 指向同一个节点 if self._length == 1: self._head = self._tail def addAtIndex(self, index, val): &#34;&#34;&#34; Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. :type index: int :type val: int :rtype: None &#34;&#34;&#34; if index &gt; self._length: return if index == 0: self.addAtHead(val) return if index == self._length: self.addAtTail(val) return pre = self._get_node_by_index(index -1) curr = pre.next node = Node(val, curr) pre.next = node self._length += 1 def deleteAtIndex(self, index): &#34;&#34;&#34; Delete the index-th node in the linked list, if the index is valid. :type index: int :rtype: None &#34;&#34;&#34; if index &gt;= self._length: return if index == 0: self._head = self._head.next else: pre = self._get_node_by_index(index -1) curr = pre.next pre.next = curr.next # 删除 tail 指向的节点时更新新的 tail 指向节点 if index == self._length - 1: self._tail = pre self._length -= 1 # 当链表为空时 head 和 tail 不指向任何节点 if self._length == 0: self._tail = self._head = None def _get_node_by_index(self, index): node = self._head curr_index = 0 while node is not None: if curr_index == index: return node curr_index += 1 node = node.next return None # Your MyLinkedList object will be instantiated and called as such: # obj = MyLinkedList() # param_1 = obj.get(index) # obj.addAtHead(val) # obj.addAtTail(val) # obj.addAtIndex(index,val) # obj.deleteAtIndex(index) 参考资料 https://leetcode.com/problems/design-linked-list/"/>
        <meta property="article:published_time" content="2020-11-07" />
            <meta property="article:section" content="leetcode" />
            <meta property="article:tag" content="leetcode" />
            <meta property="article:tag" content="Linked-List" />
            <meta property="article:tag" content="链表" />
            <meta property="article:author" content="mozillazg" />
            <meta property="og:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>


    <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@mozillazg">
        <meta name="twitter:creator" content="@mozillazg">
    <meta name="twitter:domain" content="https://mozillazg.com">
            <meta property="twitter:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/css/bootstrap.min.css" type="text/css"/>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link href="https://cdn.jsdelivr.net/npm/pygments-css@1.0.0/github.css" rel="stylesheet">
    <link rel="stylesheet" href="https://mozillazg.com/theme/css/style.css" type="text/css"/>
            <link href="https://mozillazg.com/static/custom.css" rel="stylesheet">

        <link href="https://mozillazg.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's blog ATOM Feed"/>

        <link href="https://mozillazg.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="mozillazg's blog RSS Feed"/>


        <link href="https://mozillazg.com/feeds/leetcode.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's blog leetcode ATOM Feed"/>


    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "publisher": {
            "@type": "Person",
            "name": "mozillazg",
            "logo": "https://mozillazg.com/static/avatar.jpeg"
        },
        "author": {
            "@type": "Person",
            "name": "mozillazg",
            "image": "https://mozillazg.com/static/avatar.jpeg",
            "url": "https://mozillazg.com",
            "sameAs": []
        },
        "headline": "LeetCode: 707. Design Linked List",
        "url": "https://mozillazg.com/2020/11/leetcode-707-design-linked-list.html",
        "image": [
            "https://mozillazg.com/static/avatar.jpeg"
         ],
        "keywords": "leetcode, Linked-List, 链表",
        "description": "题目 原题地址：https://leetcode.com/problems/design-linked-list/ Design your implementation of the linked list. You can choose to use a singly or doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list. Assume all nodes in the linked list are 0-indexed. Implement the MyLinkedList class: MyLinkedList() Initializes the MyLinkedList object. int get(int index) Get the value of the index-th node in the linked list. If the index is invalid, return -1. void addAtHead(int val) Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. void addAtTail(int val) Append a node of value val as the last element of the linked list. void addAtIndex(int index, int val) Add a node of value val before the index-th node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If index is greater than the length, the node will not be inserted. void deleteAtIndex(int index) Delete the index-th node in the linked list, if the index is valid. Example 1: Input [&#34;MyLinkedList&#34;, &#34;addAtHead&#34;, &#34;addAtTail&#34;, &#34;addAtIndex&#34;, &#34;get&#34;, &#34;deleteAtIndex&#34;, &#34;get&#34;] [[], [1], [3], [1, 2], [1], [1], [1]] Output [null, null, null, null, 2, null, 3] Explanation MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.addAtHead(1); myLinkedList.addAtTail(3); myLinkedList.addAtIndex(1, 2); // linked list becomes 1-&gt;2-&gt;3 myLinkedList.get(1); // return 2 myLinkedList.deleteAtIndex(1); // now the linked list is 1-&gt;3 myLinkedList.get(1); // return 3 Constraints: 0 &lt;= index, val &lt;= 1000 Please do not use the built-in LinkedList library. At most 2000 calls will be made to get, addAtHead, addAtTail, addAtIndex and deleteAtIndex. 解法 使用单向链表实现 实现时主要需要注意处理几个边界 case: 当链表只有一个元素时，记得确保 head 和 tail 要指向同一个节点 当链表没有元素后，记得确保 head 和 tail 都没有指向任何节点 当删除 tail 指向的节点时，记得更新 tail 指向原来节点的上一个节点 这个方法的 Python 代码类似下面这样: class Node(object): def __init__(self, val=0, next=None): self.val = val self.next = next class MyLinkedList(object): def __init__(self): self._head = None self._tail = None self._length = 0 def get(self, index): &#34;&#34;&#34; Get the value of the index-th node in the linked list. If the index is invalid, return -1. :type index: int :rtype: int &#34;&#34;&#34; if index &lt; 0 or index &gt;= self._length: return -1 node = self._get_node_by_index(index) return node.val def addAtHead(self, val): &#34;&#34;&#34; Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. :type val: int :rtype: None &#34;&#34;&#34; node = Node(val, self._head) self._head = node self._length += 1 # 只有一个元素的链表 head 和 tail 指向同一个节点 if self._length == 1: self._tail = self._head def addAtTail(self, val): &#34;&#34;&#34; Append a node of value val to the last element of the linked list. :type val: int :rtype: None &#34;&#34;&#34; node = Node(val) if self._tail is not None: self._tail.next = node self._tail = node self._length += 1 # 只有一个元素的链表 head 和 tail 指向同一个节点 if self._length == 1: self._head = self._tail def addAtIndex(self, index, val): &#34;&#34;&#34; Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. :type index: int :type val: int :rtype: None &#34;&#34;&#34; if index &gt; self._length: return if index == 0: self.addAtHead(val) return if index == self._length: self.addAtTail(val) return pre = self._get_node_by_index(index -1) curr = pre.next node = Node(val, curr) pre.next = node self._length += 1 def deleteAtIndex(self, index): &#34;&#34;&#34; Delete the index-th node in the linked list, if the index is valid. :type index: int :rtype: None &#34;&#34;&#34; if index &gt;= self._length: return if index == 0: self._head = self._head.next else: pre = self._get_node_by_index(index -1) curr = pre.next pre.next = curr.next # 删除 tail 指向的节点时更新新的 tail 指向节点 if index == self._length - 1: self._tail = pre self._length -= 1 # 当链表为空时 head 和 tail 不指向任何节点 if self._length == 0: self._tail = self._head = None def _get_node_by_index(self, index): node = self._head curr_index = 0 while node is not None: if curr_index == index: return node curr_index += 1 node = node.next return None # Your MyLinkedList object will be instantiated and called as such: # obj = MyLinkedList() # param_1 = obj.get(index) # obj.addAtHead(val) # obj.addAtTail(val) # obj.addAtIndex(index,val) # obj.deleteAtIndex(index) 参考资料 https://leetcode.com/problems/design-linked-list/",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "https://mozillazg.com/2020/11/leetcode-707-design-linked-list.html"
        },
        "datePublished": "2020-11-07"
    }
    </script>

</head>
<body>

<div class="navbar" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://mozillazg.com/" class="navbar-brand">
mozillazg's blog            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="https://mozillazg.com/feeds/all.atom.xml">Feed</a></li>
                    <li><a href="/2014/10/pages/about-me.html">About</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://mozillazg.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content" class="yue">
        <article>
            <header class="text-center">
                <h1>
                    <a href="https://mozillazg.com/2020/11/leetcode-707-design-linked-list.html"
                       rel="bookmark"
                       title="Permalink to LeetCode: 707. Design Linked List">
                        LeetCode: 707. Design Linked List
                    </a>
                </h1>
                <p class="published">
                    <time datetime="2020-11-07T00:00:00+00:00">
                    2020-11-07
                    </time>
                </p>
            </header>
            <div class="entry-content">
                <div class="well-sm article-info">
<footer class="post-info">
        <a href="https://mozillazg.com/category/leetcode.html">leetcode</a>


<span class="label label-default hide">Tags</span>
	<a href="https://mozillazg.com/tag/linked-list.html">Linked-List</a>
        /
	<a href="https://mozillazg.com/tag/lian-biao.html">链表</a>
    
</footer><!-- /.post-info -->                </div>
                <div class="js-toc"></div>
                <div>
                <div class="section" id="id1">
<h2 id="hidid1">题目<a class="headerlink" href="#hidid1" title="Permalink to this headline">¶</a></h2>
<p>原题地址：<a class="reference external" href="https://leetcode.com/problems/design-linked-list/">https://leetcode.com/problems/design-linked-list/</a></p>
<p>Design your implementation of the linked list. You can choose to use a singly or doubly linked list.</p>
<p>A node in a singly linked list should have two attributes: <tt class="docutils literal">val</tt> and <tt class="docutils literal">next</tt>. <tt class="docutils literal">val</tt> is the value of the current node, and <tt class="docutils literal">next</tt> is a pointer/reference to the next node.</p>
<p>If you want to use the doubly linked list, you will need one more attribute <tt class="docutils literal">prev</tt> to indicate the previous node in the linked list. Assume all nodes in the linked list are <strong>0-indexed</strong>.</p>
<p>Implement the <tt class="docutils literal">MyLinkedList</tt> class:</p>
<ul class="simple">
<li><tt class="docutils literal">MyLinkedList()</tt> Initializes the <tt class="docutils literal">MyLinkedList</tt> object.</li>
<li><tt class="docutils literal">int get(int index)</tt> Get the value of the <tt class="docutils literal">index</tt>-th node in the linked list. If the index is invalid, return <tt class="docutils literal"><span class="pre">-1</span></tt>.</li>
<li><tt class="docutils literal">void addAtHead(int val)</tt> Add a node of value <tt class="docutils literal">val</tt> before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</li>
<li><tt class="docutils literal">void addAtTail(int val)</tt> Append a node of value <tt class="docutils literal">val</tt> as the last element of the linked list.</li>
<li><tt class="docutils literal">void addAtIndex(int index, int val)</tt> Add a node of value <tt class="docutils literal">val</tt> before the <tt class="docutils literal">index</tt>-th node in the linked list. If index equals the length of the linked list, the node will be appended to the end of the linked list. If <tt class="docutils literal">index</tt> is greater than the length, the node <strong>will not be inserted</strong>.</li>
<li><tt class="docutils literal">void deleteAtIndex(int index)</tt> Delete the <tt class="docutils literal">index</tt>-th node in the linked list, if the index is valid.</li>
</ul>
<p>Example 1:</p>
<pre class="literal-block">
Input
[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]
[[], [1], [3], [1, 2], [1], [1], [1]]

Output
[null, null, null, null, 2, null, 3]

Explanation

MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // linked list becomes 1-&gt;2-&gt;3
myLinkedList.get(1);              // return 2
myLinkedList.deleteAtIndex(1);    // now the linked list is 1-&gt;3
myLinkedList.get(1);              // return 3
</pre>
<p>Constraints:</p>
<ul class="simple">
<li><tt class="docutils literal">0 &lt;= index, val &lt;= 1000</tt></li>
<li>Please do not use the built-in LinkedList library.</li>
<li>At most <tt class="docutils literal">2000</tt> calls will be made to <tt class="docutils literal">get</tt>, <tt class="docutils literal">addAtHead</tt>, <tt class="docutils literal">addAtTail</tt>,  <tt class="docutils literal">addAtIndex</tt> and <tt class="docutils literal">deleteAtIndex</tt>.</li>
</ul>
</div>
<div class="section" id="id2">
<h2 id="hidid2">解法<a class="headerlink" href="#hidid2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id3">
<h3 id="hidid3">使用单向链表实现<a class="headerlink" href="#hidid3" title="Permalink to this headline">¶</a></h3>
<p>实现时主要需要注意处理几个边界 case:</p>
<ul class="simple">
<li>当链表只有一个元素时，记得确保 head 和 tail 要指向同一个节点</li>
<li>当链表没有元素后，记得确保 head 和 tail 都没有指向任何节点</li>
<li>当删除 tail 指向的节点时，记得更新 tail 指向原来节点的上一个节点</li>
</ul>
<p>这个方法的 Python 代码类似下面这样:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Node</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">next</span>


<span class="k">class</span> <span class="nc">MyLinkedList</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_head</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tail</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">=</span> <span class="mi">0</span>


    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the value of the index-th node in the linked list. If the index is invalid, return -1.</span>
<span class="sd">        :type index: int</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_by_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">val</span>


    <span class="k">def</span> <span class="nf">addAtHead</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.</span>
<span class="sd">        :type val: int</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_head</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_head</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># 只有一个元素的链表 head 和 tail 指向同一个节点</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_head</span>

    <span class="k">def</span> <span class="nf">addAtTail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a node of value val to the last element of the linked list.</span>
<span class="sd">        :type val: int</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tail</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tail</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># 只有一个元素的链表 head 和 tail 指向同一个节点</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tail</span>


    <span class="k">def</span> <span class="nf">addAtIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.</span>
<span class="sd">        :type index: int</span>
<span class="sd">        :type val: int</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addAtHead</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addAtTail</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">pre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_by_index</span><span class="p">(</span><span class="n">index</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">next</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">curr</span><span class="p">)</span>
        <span class="n">pre</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">deleteAtIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete the index-th node in the linked list, if the index is valid.</span>
<span class="sd">        :type index: int</span>
<span class="sd">        :rtype: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_head</span><span class="o">.</span><span class="n">next</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pre</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_by_index</span><span class="p">(</span><span class="n">index</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">next</span>
            <span class="n">pre</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">next</span>
            <span class="c1"># 删除 tail 指向的节点时更新新的 tail 指向节点</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_tail</span> <span class="o">=</span> <span class="n">pre</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="c1"># 当链表为空时 head 和 tail 不指向任何节点</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_head</span> <span class="o">=</span> <span class="bp">None</span>


    <span class="k">def</span> <span class="nf">_get_node_by_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_head</span>
        <span class="n">curr_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">curr_index</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">node</span>
            <span class="n">curr_index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">next</span>

        <span class="k">return</span> <span class="bp">None</span>


<span class="c1"># Your MyLinkedList object will be instantiated and called as such:</span>
<span class="c1"># obj = MyLinkedList()</span>
<span class="c1"># param_1 = obj.get(index)</span>
<span class="c1"># obj.addAtHead(val)</span>
<span class="c1"># obj.addAtTail(val)</span>
<span class="c1"># obj.addAtIndex(index,val)</span>
<span class="c1"># obj.deleteAtIndex(index)</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2 id="hidid4">参考资料<a class="headerlink" href="#hidid4" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://leetcode.com/problems/design-linked-list/">https://leetcode.com/problems/design-linked-list/</a></li>
</ul>
</div>

                </div>
            </div>
            <!-- /.entry-content -->
<section class="text-center">
  
<div id="donate"></div>

<div class="social-share"></div>
<div class="social-comment-note">
<p>有任何建议和想法欢迎在下方评论区留言或者加我<a href="/static/wechat.png">微信</a>交流</p>
</div>

</section>
<section class="well" id="related-posts">
    <p>Related Posts:</p>
    <ul>
        <li><a href="https://mozillazg.com/2020/10/leetcode-21-merge-two-sorted-lists.html">LeetCode: 21. Merge Two Sorted Lists</a></li>
        <li><a href="https://mozillazg.com/2020/10/leetcode-147-insertion-sort-list.html">LeetCode: 147. Insertion Sort List</a></li>
        <li><a href="https://mozillazg.com/2020/09/leetcode-445-add-two-numbers-ii.html">LeetCode: 445. Add Two Numbers II</a></li>
        <li><a href="https://mozillazg.com/2020/10/leetcode-142-linked-list-cycle-ii.html">LeetCode: 142. Linked List Cycle II</a></li>
        <li><a href="https://mozillazg.com/2020/11/leetcode-148-sort-list.html">LeetCode: 148. Sort List</a></li>
    </ul>
</section>
    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'my-github-blog'; // required: replace example with your forum shortname

                    var disqus_identifier = 'leetcode-707-design-linked-list';
                var disqus_url = 'https://mozillazg.com/2020/11/leetcode-707-design-linked-list.html';

            var disqus_config = function () {
                this.language = "zh";
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2022 mozillazg
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>
            &middot; <a href="/privacy-policy.html" target="_blank">Privacy</a>              <p><small>  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/static/images/by-sa-80x15.png" /></a>
    &quot;<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">mozillazg's blog</span>&quot; by <a xmlns:cc="http://creativecommons.org/ns#" href="https://mozillazg.com" property="cc:attributionName" rel="cc:attributionURL">mozillazg</a> is
  licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="https://cdn.jsdelivr.net/npm/jquery@2.1.1/dist/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->

    <!-- Disqus -->
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'my-github-blog'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script');
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <!-- End Disqus Code -->
    <!-- Google Analytics Universal -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-77172981-1', 'auto');
        ga('send', 'pageview');
    </script>
    <!-- End Google Analytics Universal Code -->

<!-- share.js -->
<script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>



<script src="https://cdn.jsdelivr.net/npm/tocbot@3.0.2/dist/tocbot.min.js"></script>
<script>
$(document).ready(function(){
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.js-toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.entry-content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h2, h3, h4,h5',
    // Headings that match the ignoreSelector will be skipped.
    ignoreSelector: '.js-toc-ignore',
    // Main class to add to links.
    linkClass: 'toc-link',
    // Extra classes to add to links.
    extraLinkClasses: '',
    // Class to add to active links,
    // the link corresponding to the top most heading on the page.
    activeLinkClass: 'is-active-link',
    // Main class to add to lists.
    listClass: 'toc-list',
    // Extra classes to add to lists.
    extraListClasses: '',
    // Class that gets added when a list should be collapsed.
    isCollapsedClass: 'is-collapsed',
    // Class that gets added when a list should be able
    // to be collapsed but isn't necessarily collpased.
    collapsibleClass: 'is-collapsible',
    // Class to add to list items.
    listItemClass: 'toc-list-item',
    // How many heading levels should not be collpased.
    // For example, number 6 will show everything since
    // there are only 6 heading levels and number 0 will collpase them all.
    // The sections that are hidden will open
    // and close as you scroll to headings within them.
    collapseDepth: 6,
    // Smooth scrolling enabled.
    smoothScroll: true,
    // Smooth scroll duration.
    smoothScrollDuration: 420,
    // Callback for scroll end (requires: smoothScroll).
    scrollEndCallback: function (e) {},
    // Headings offset between the headings and the top of the document (this is meant for minor adjustments).
    headingsOffset: 0,
    // Timeout between events firing to make sure it's
    // not too rapid (for performance reasons).
    throttleTimeout: 50,
    // Element to add the positionFixedClass to.
    positionFixedSelector: null,
    // Fixed position class to add to make sidebar fixed after scrolling
    // down past the fixedSidebarOffset.
    positionFixedClass: 'is-position-fixed',
    // fixedSidebarOffset can be any number but by default is set
    // to auto which sets the fixedSidebarOffset to the sidebar
    // element's offsetTop from the top of the document on init.
    fixedSidebarOffset: 'auto',
    // includeHtml can be set to true to include the HTML markup from the
    // heading node instead of just including the textContent.
    includeHtml: false
  });
});
</script>
</body>
</html>