<!DOCTYPE html>
<html lang="zh"  prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml" class="han-init">
<head>
    <title>Go: 关于锁（mutex）的一些使用注意事项 - mozillazg's Blog</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- share.css -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css">


    <link href="https://mozillazg.com/favicon.ico" rel="icon">

<link rel="canonical" href="https://mozillazg.com/2019/04/notes-about-go-lock-mutex.html">

        <meta name="author" content="mozillazg" />
        <meta name="keywords" content="go,lock,mutex" />
    <meta name="description" content="前言 最近踩了一个锁的坑，所以在这里简单记录一些 Go 中关于锁（mutex）使用的一些注意事项。 尽量减少锁的持有时间 尽量减少锁的持有时间，毕竟使用锁是有代价的，通过减少锁的持有时间来减轻这个代价： 细化锁的粒度。通过细化锁的粒度来减少锁的持有时间以及避免在持有锁操作的时候做各种耗时的操作。 不要在持有锁的时候做 IO 操作。尽量只通过持有锁来保护 IO 操作需要的资源而不是 IO 操作本身： func doSomething() { m.Lock() item := ... http.Get() // 各种耗时的 IO 操作 m.Unlock() } // 改为 func doSomething() { m.Lock() item := ... m.Unlock() http.Get() } 善用 defer 来确保在函数内正确释放了锁 尤其是在那些内部有好几个通过 if err != nil 判断来提前返回的函数中，通过 defer 可以确保不会遗漏释放锁操作，避免出现死锁问题，以及避免函数内非预期的 panic 导致死锁的问题： func doSomething() { m.Lock() defer m.Unlock() err := ... if err != nil { return } err = ... if err != nil { return } ... return } 不过使用 defer 的时候也要注意别因为习惯性的 defer m.Unlock() 导致无意中在持有锁的时候做了 IO 操作，出现了非预期的持有锁时间太长的问题。 // 非预期的在持有锁期间做 IO 操作 func doSomething() { m.Lock() defer m.Unlock() item := ... http.Get() // 各种耗时的 IO 操作 } 以及 defer 其实是有点 性能 消耗 的，需要取舍下酌情使用。 在适当时候使用 RWMutex 当确定操作不会修改保护的资源时，可以使用 RWMutex 来减少锁等待时间（不同的 goroutine 可以同时持有 RLock, 但是 Lock 限制了只能有一个 goroutine 持有 Lock）： func nickName() string { rw.RLock() defer rw.RUnlock() return name } func SetName(s string) string { rw.Lock() defer rw.Unlock() name = s } copy 结构体操作可能导致非预期的死锁 copy 结构体时，如果结构体中有锁的话，记得重新初始化一个锁对象，否则会出现非预期的死锁： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( &#34;fmt&#34; &#34;sync&#34; ) type User struct { sync.Mutex name string } func main() { u1 := &amp;User{name: &#34;test&#34;} u1.Lock() defer u1.Unlock() tmp := *u1 u2 := &amp;tmp // u2.Mutex = sync.Mutex{} // 没有这一行就会死锁 fmt.Printf(&#34;%#p\n&#34;, u1) fmt.Printf(&#34;%#p\n&#34;, u2) u2.Lock() defer u2.Unlock() } $ go run main.go c00000a080 c00000a0a0 fatal error: all goroutines are asleep - deadlock! goroutine 1 [semacquire]: sync.runtime_SemacquireMutex(0xc00000a0a4, 0x0) /usr/local/Cellar/go/1.11/libexec/src/runtime/sema.go:71 +0x3d sync.(*Mutex).Lock(0xc00000a0a0) /usr/local/Cellar/go/1.11/libexec/src/sync/mutex.go:134 +0xff main.main() /Users/xxx/tmp/golang/main.go:26 +0x17f exit status 2 文档中也有类似的警告： A Mutex must not be copied after first use https://godoc.org/sync#Mutex 使用 go vet 工具检查代码中锁的使用问题 可以通过 vet 这个命令行来检查上面的锁 copy 的问题。比如上面的例子的检查结果如下：: $ go vet main.go # command-line-arguments ./main.go:19:9: assignment copies lock value to tmp: command-line-arguments.User 可以看到 vet 提示 19 行那里的 copy 操作中 copy 了一个锁。 BTW，使用 go vet 命令对整个项目进行检查时，可以通过 go vet $(go list ./... | grep -v /vendor/) 这个命令忽略掉 vendor 下的包。 build/test 时使用 -race 参数以便运行时检测数据竞争问题 可以在执行 go build 或 go test 时增加一个 -race 参数来开启数据竞争检测功能，通过这种方式来实现在本地开发环境/CI/测试环境阶段发现程序中可能存在的数据竞争问题： package main import ( &#34;fmt&#34; &#34;sync&#34; ) type Todo struct { sync.Mutex tasks []string } func (t *Todo) do() { for _, task := range t.tasks { fmt.Println(task) } } func (t *Todo) Add(task string) { t.Lock() defer t.Unlock() t.tasks = append(t.tasks, task) } func main() { t := &amp;Todo{} for i := 0; i &lt; 2; i++ { go t.Add(fmt.Sprintf(&#34;%d&#34;, i)) } for i := 0; i &lt; 2; i++ { t.do() } } -race 参数可以开启数据竞争检测（详见： Data Race Detector - The Go Programming Language ）： $ go build -race -o main . $ $ ./main ================== WARNING: DATA RACE Read at 0x00c0000a0048 by main goroutine: main.(*Todo).do() /Users/xxx/tmp/golang/race/main.go:15 +0x42 main.main() /Users/xxx/tmp/golang/race/main.go:34 +0x154 Previous write at 0x00c0000a0048 by goroutine 6: main.(*Todo).Add() /Users/xxx/tmp/golang/race/main.go:24 +0x11d Goroutine 6 (finished) created at: main.main() /Users/xxx/tmp/golang/race/main.go:31 +0x127 ================== 0 ================== WARNING: DATA RACE Read at 0x00c0000b0010 by main goroutine: main.(*Todo).do() /Users/xxx/tmp/golang/race/main.go:15 +0x85 main.main() /Users/xxx/tmp/golang/race/main.go:34 +0x154 Previous write at 0x00c0000b0010 by goroutine 7: main.(*Todo).Add() /Users/xxx/tmp/golang/race/main.go:24 +0xe3 Goroutine 7 (finished) created at: main.main() /Users/xxx/tmp/golang/race/main.go:31 +0x127 ================== 1 0 1 Found 2 data race(s) 使用 go-deadlock 检测死锁或锁等待问题 上面说的在持有锁的时候做 IO 操作或其他非预期的耗时超时的问题，一方面需要在写程序的时候注意一下，另一方面也有可能是无意中代入进去的（比如上面提到的习惯性 defer 导致的）。对于那些无意中代入进去的锁等待的问题人为的去 review 的话通常很难发现，此时就需要用工具来检测了。恰好有一个叫 go-deadlock 的工具可以实现这个功能。 package main import ( &#34;net/http&#34; &#34;time&#34; sync &#34;github.com/sasha-s/go-deadlock&#34; ) var mu sync.Mutex var url = &#34;http://baidu.com:90&#34; func do() { mu.Lock() defer mu.Unlock() u := url http.Get(u) // 非预期的在持有锁期间做 IO 操作，导致锁等待时间变长 } func main() { // 检测超过 100 ms 的锁等待 sync.Opts.DeadlockTimeout = time.Millisecond * 100 var wg sync.WaitGroup for i := 0; i &lt; 3; i++ { wg.Add(1) go func() { defer wg.Done() do() }() } wg.Wait() } 执行结果： $ go run main.go POTENTIAL DEADLOCK: Previous place where the lock was grabbed goroutine 36 lock 0x1483b90 main.go:14 main.do { mu.Lock() } &lt;&lt;&lt;&lt;&lt; main.go:30 main.main.func1 { do() } Have been trying to lock it again for more than 100ms goroutine 35 lock 0x1483b90 main.go:14 main.do { mu.Lock() } &lt;&lt;&lt;&lt;&lt; main.go:30 main.main.func1 { do() } Here is what goroutine 36 doing now goroutine 36 [select]: net/http.(*Transport).getConn(0x14616c0, 0xc00015e150, 0x0, 0x128adb3, 0x4, 0xc000014100, 0xc, 0x0, 0x0, 0xc0000559e8) /usr/local/Cellar/go/1.11/libexec/src/net/http/transport.go:1004 +0x58e net/http.(*Transport).roundTrip(0x14616c0, 0xc000160000, 0x203000, 0xc000055c90, 0x11d823a) /usr/local/Cellar/go/1.11/libexec/src/net/http/transport.go:451 +0x690 net/http.(*Transport).RoundTrip(0x14616c0, 0xc000160000, 0x14616c0, 0x0, 0x0) /usr/local/Cellar/go/1.11/libexec/src/net/http/roundtrip.go:17 +0x35 net/http.send(0xc000160000, 0x12c78a0, 0x14616c0, 0x0, 0x0, 0x0, 0xc00000e030, 0x1708000, 0xc000055d20, 0x1) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:250 +0x14b net/http.(*Client).send(0x1466200, 0xc000160000, 0x0, 0x0, 0x0, 0xc00000e030, 0x0, 0x1, 0x0) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:174 +0xfa net/http.(*Client).do(0x1466200, 0xc000160000, 0x0, 0x0, 0x0) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:641 +0x2a8 net/http.(*Client).Do(0x1466200, 0xc000160000, 0x128adb3, 0x13, 0x0) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:509 +0x35 net/http.(*Client).Get(0x1466200, 0x128adb3, 0x13, 0xc0000220c0, 0x12412c0, 0xc000055f80) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:398 +0x9d net/http.Get(0x128adb3, 0x13, 0x1483b90, 0x0, 0xc000114fb8) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:370 +0x41 main.do() /Users/xxx/tmp/golang/deadlock/main.go:18 +0x75 main.main.func1(0xc00009c3f4) /Users/xxx/tmp/golang/deadlock/main.go:30 +0x48 created by main.main /Users/xxx/tmp/golang/deadlock/main.go:28 +0x83 exit status 2 通过上面的输出可以知道 goroutine 36 持有锁的时间过长导致其他 goroutine 获取锁的等待时间超过了 100 ms ，并且 goroutine 36 在持有锁期间正在做 18 行的 http 操作。可以看到 go-deadlock 在优化锁等待时间方面有很大的帮助，可以帮助我们及时发现异常的锁使用姿势。 实现 tryLock 功能 一般 Lock() 如果拿不到锁的话，会一直阻塞在那里，在某些场景下这个功能不是我们所期望的结果，我们可能希望程序在一定时间内无法获取到锁的话就做其他操作或者直接返回失败：比如在一个 http server 中，处理请求时因为锁等待时间太长导致客户端大量超时，引发客户端重连以及服务端 goroutine 数量持续增长（虽然客户端超时了，但是处理请求的 goroutine 还在继续处理已超时的请求并且阻塞在了获取锁的地方，然后客户端重连又加重了这个问题，表现就是处理请求的 goroutine 数量直线上升）。这个时候我们就需要有一个类似 tryLock 的功能，在发现短时间内无法获取到锁的时候直接返回失败的响应，防止问题进一步加重（Fail Fast）。 关于 tryLock 这个功能的介绍可以参考 Java 中 tryLock 的介绍，至于 Go 中如何实现 tryLock 可以参考 为 Go Mutex 实现 TryLock 方法 | 鸟窝 改为使用 channel 有些时候可能使用 channel 会更符合需求，对于这些更适合 channel 的场景可以改为使用 channel 而不是 lock （可以参考 Share Memory By Communicating - The Go Blog 这篇文章），合适的场景选择合适的方法即可，既不需要畏惧 channel 也不必畏惧 lock 。 总结 目前能想到的就是这些注意事项了，欢迎纠正和补充。 参考资料 sync - GoDoc sasha-s/go-deadlock: Online deadlock detection in go (golang) Dancing with Go’s Mutexes – Hacker Noon Debugging a potential deadlock in Go with go-deadlock Data Race Detector - The Go Programming Language Share Memory By Communicating - The Go Blog Lock (Java Platform SE 8 ) 为 Go Mutex 实现 TryLock 方法 | 鸟窝 Fail-fast - Wikipedia Runtime overhead of using defer in go – i0exception – Medium runtime: defer is slow · Issue #14939 · golang/go vet - The Go Programming Language" />

    <style>
      .js-toc {
        margin-bottom: 20px;
      }
      .donate-modal {
        text-align: center;
      }
      #donate-modal-container .donate-image {
        max-height: 300px !important;
        min-height: inherit !important;
      }
    </style>

        <meta property="og:site_name" content="mozillazg's Blog" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Go: 关于锁（mutex）的一些使用注意事项"/>
        <meta property="og:url" content="https://mozillazg.com/2019/04/notes-about-go-lock-mutex.html"/>
        <meta property="og:description" content="前言 最近踩了一个锁的坑，所以在这里简单记录一些 Go 中关于锁（mutex）使用的一些注意事项。 尽量减少锁的持有时间 尽量减少锁的持有时间，毕竟使用锁是有代价的，通过减少锁的持有时间来减轻这个代价： 细化锁的粒度。通过细化锁的粒度来减少锁的持有时间以及避免在持有锁操作的时候做各种耗时的操作。 不要在持有锁的时候做 IO 操作。尽量只通过持有锁来保护 IO 操作需要的资源而不是 IO 操作本身： func doSomething() { m.Lock() item := ... http.Get() // 各种耗时的 IO 操作 m.Unlock() } // 改为 func doSomething() { m.Lock() item := ... m.Unlock() http.Get() } 善用 defer 来确保在函数内正确释放了锁 尤其是在那些内部有好几个通过 if err != nil 判断来提前返回的函数中，通过 defer 可以确保不会遗漏释放锁操作，避免出现死锁问题，以及避免函数内非预期的 panic 导致死锁的问题： func doSomething() { m.Lock() defer m.Unlock() err := ... if err != nil { return } err = ... if err != nil { return } ... return } 不过使用 defer 的时候也要注意别因为习惯性的 defer m.Unlock() 导致无意中在持有锁的时候做了 IO 操作，出现了非预期的持有锁时间太长的问题。 // 非预期的在持有锁期间做 IO 操作 func doSomething() { m.Lock() defer m.Unlock() item := ... http.Get() // 各种耗时的 IO 操作 } 以及 defer 其实是有点 性能 消耗 的，需要取舍下酌情使用。 在适当时候使用 RWMutex 当确定操作不会修改保护的资源时，可以使用 RWMutex 来减少锁等待时间（不同的 goroutine 可以同时持有 RLock, 但是 Lock 限制了只能有一个 goroutine 持有 Lock）： func nickName() string { rw.RLock() defer rw.RUnlock() return name } func SetName(s string) string { rw.Lock() defer rw.Unlock() name = s } copy 结构体操作可能导致非预期的死锁 copy 结构体时，如果结构体中有锁的话，记得重新初始化一个锁对象，否则会出现非预期的死锁： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( &#34;fmt&#34; &#34;sync&#34; ) type User struct { sync.Mutex name string } func main() { u1 := &amp;User{name: &#34;test&#34;} u1.Lock() defer u1.Unlock() tmp := *u1 u2 := &amp;tmp // u2.Mutex = sync.Mutex{} // 没有这一行就会死锁 fmt.Printf(&#34;%#p\n&#34;, u1) fmt.Printf(&#34;%#p\n&#34;, u2) u2.Lock() defer u2.Unlock() } $ go run main.go c00000a080 c00000a0a0 fatal error: all goroutines are asleep - deadlock! goroutine 1 [semacquire]: sync.runtime_SemacquireMutex(0xc00000a0a4, 0x0) /usr/local/Cellar/go/1.11/libexec/src/runtime/sema.go:71 +0x3d sync.(*Mutex).Lock(0xc00000a0a0) /usr/local/Cellar/go/1.11/libexec/src/sync/mutex.go:134 +0xff main.main() /Users/xxx/tmp/golang/main.go:26 +0x17f exit status 2 文档中也有类似的警告： A Mutex must not be copied after first use https://godoc.org/sync#Mutex 使用 go vet 工具检查代码中锁的使用问题 可以通过 vet 这个命令行来检查上面的锁 copy 的问题。比如上面的例子的检查结果如下：: $ go vet main.go # command-line-arguments ./main.go:19:9: assignment copies lock value to tmp: command-line-arguments.User 可以看到 vet 提示 19 行那里的 copy 操作中 copy 了一个锁。 BTW，使用 go vet 命令对整个项目进行检查时，可以通过 go vet $(go list ./... | grep -v /vendor/) 这个命令忽略掉 vendor 下的包。 build/test 时使用 -race 参数以便运行时检测数据竞争问题 可以在执行 go build 或 go test 时增加一个 -race 参数来开启数据竞争检测功能，通过这种方式来实现在本地开发环境/CI/测试环境阶段发现程序中可能存在的数据竞争问题： package main import ( &#34;fmt&#34; &#34;sync&#34; ) type Todo struct { sync.Mutex tasks []string } func (t *Todo) do() { for _, task := range t.tasks { fmt.Println(task) } } func (t *Todo) Add(task string) { t.Lock() defer t.Unlock() t.tasks = append(t.tasks, task) } func main() { t := &amp;Todo{} for i := 0; i &lt; 2; i++ { go t.Add(fmt.Sprintf(&#34;%d&#34;, i)) } for i := 0; i &lt; 2; i++ { t.do() } } -race 参数可以开启数据竞争检测（详见： Data Race Detector - The Go Programming Language ）： $ go build -race -o main . $ $ ./main ================== WARNING: DATA RACE Read at 0x00c0000a0048 by main goroutine: main.(*Todo).do() /Users/xxx/tmp/golang/race/main.go:15 +0x42 main.main() /Users/xxx/tmp/golang/race/main.go:34 +0x154 Previous write at 0x00c0000a0048 by goroutine 6: main.(*Todo).Add() /Users/xxx/tmp/golang/race/main.go:24 +0x11d Goroutine 6 (finished) created at: main.main() /Users/xxx/tmp/golang/race/main.go:31 +0x127 ================== 0 ================== WARNING: DATA RACE Read at 0x00c0000b0010 by main goroutine: main.(*Todo).do() /Users/xxx/tmp/golang/race/main.go:15 +0x85 main.main() /Users/xxx/tmp/golang/race/main.go:34 +0x154 Previous write at 0x00c0000b0010 by goroutine 7: main.(*Todo).Add() /Users/xxx/tmp/golang/race/main.go:24 +0xe3 Goroutine 7 (finished) created at: main.main() /Users/xxx/tmp/golang/race/main.go:31 +0x127 ================== 1 0 1 Found 2 data race(s) 使用 go-deadlock 检测死锁或锁等待问题 上面说的在持有锁的时候做 IO 操作或其他非预期的耗时超时的问题，一方面需要在写程序的时候注意一下，另一方面也有可能是无意中代入进去的（比如上面提到的习惯性 defer 导致的）。对于那些无意中代入进去的锁等待的问题人为的去 review 的话通常很难发现，此时就需要用工具来检测了。恰好有一个叫 go-deadlock 的工具可以实现这个功能。 package main import ( &#34;net/http&#34; &#34;time&#34; sync &#34;github.com/sasha-s/go-deadlock&#34; ) var mu sync.Mutex var url = &#34;http://baidu.com:90&#34; func do() { mu.Lock() defer mu.Unlock() u := url http.Get(u) // 非预期的在持有锁期间做 IO 操作，导致锁等待时间变长 } func main() { // 检测超过 100 ms 的锁等待 sync.Opts.DeadlockTimeout = time.Millisecond * 100 var wg sync.WaitGroup for i := 0; i &lt; 3; i++ { wg.Add(1) go func() { defer wg.Done() do() }() } wg.Wait() } 执行结果： $ go run main.go POTENTIAL DEADLOCK: Previous place where the lock was grabbed goroutine 36 lock 0x1483b90 main.go:14 main.do { mu.Lock() } &lt;&lt;&lt;&lt;&lt; main.go:30 main.main.func1 { do() } Have been trying to lock it again for more than 100ms goroutine 35 lock 0x1483b90 main.go:14 main.do { mu.Lock() } &lt;&lt;&lt;&lt;&lt; main.go:30 main.main.func1 { do() } Here is what goroutine 36 doing now goroutine 36 [select]: net/http.(*Transport).getConn(0x14616c0, 0xc00015e150, 0x0, 0x128adb3, 0x4, 0xc000014100, 0xc, 0x0, 0x0, 0xc0000559e8) /usr/local/Cellar/go/1.11/libexec/src/net/http/transport.go:1004 +0x58e net/http.(*Transport).roundTrip(0x14616c0, 0xc000160000, 0x203000, 0xc000055c90, 0x11d823a) /usr/local/Cellar/go/1.11/libexec/src/net/http/transport.go:451 +0x690 net/http.(*Transport).RoundTrip(0x14616c0, 0xc000160000, 0x14616c0, 0x0, 0x0) /usr/local/Cellar/go/1.11/libexec/src/net/http/roundtrip.go:17 +0x35 net/http.send(0xc000160000, 0x12c78a0, 0x14616c0, 0x0, 0x0, 0x0, 0xc00000e030, 0x1708000, 0xc000055d20, 0x1) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:250 +0x14b net/http.(*Client).send(0x1466200, 0xc000160000, 0x0, 0x0, 0x0, 0xc00000e030, 0x0, 0x1, 0x0) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:174 +0xfa net/http.(*Client).do(0x1466200, 0xc000160000, 0x0, 0x0, 0x0) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:641 +0x2a8 net/http.(*Client).Do(0x1466200, 0xc000160000, 0x128adb3, 0x13, 0x0) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:509 +0x35 net/http.(*Client).Get(0x1466200, 0x128adb3, 0x13, 0xc0000220c0, 0x12412c0, 0xc000055f80) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:398 +0x9d net/http.Get(0x128adb3, 0x13, 0x1483b90, 0x0, 0xc000114fb8) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:370 +0x41 main.do() /Users/xxx/tmp/golang/deadlock/main.go:18 +0x75 main.main.func1(0xc00009c3f4) /Users/xxx/tmp/golang/deadlock/main.go:30 +0x48 created by main.main /Users/xxx/tmp/golang/deadlock/main.go:28 +0x83 exit status 2 通过上面的输出可以知道 goroutine 36 持有锁的时间过长导致其他 goroutine 获取锁的等待时间超过了 100 ms ，并且 goroutine 36 在持有锁期间正在做 18 行的 http 操作。可以看到 go-deadlock 在优化锁等待时间方面有很大的帮助，可以帮助我们及时发现异常的锁使用姿势。 实现 tryLock 功能 一般 Lock() 如果拿不到锁的话，会一直阻塞在那里，在某些场景下这个功能不是我们所期望的结果，我们可能希望程序在一定时间内无法获取到锁的话就做其他操作或者直接返回失败：比如在一个 http server 中，处理请求时因为锁等待时间太长导致客户端大量超时，引发客户端重连以及服务端 goroutine 数量持续增长（虽然客户端超时了，但是处理请求的 goroutine 还在继续处理已超时的请求并且阻塞在了获取锁的地方，然后客户端重连又加重了这个问题，表现就是处理请求的 goroutine 数量直线上升）。这个时候我们就需要有一个类似 tryLock 的功能，在发现短时间内无法获取到锁的时候直接返回失败的响应，防止问题进一步加重（Fail Fast）。 关于 tryLock 这个功能的介绍可以参考 Java 中 tryLock 的介绍，至于 Go 中如何实现 tryLock 可以参考 为 Go Mutex 实现 TryLock 方法 | 鸟窝 改为使用 channel 有些时候可能使用 channel 会更符合需求，对于这些更适合 channel 的场景可以改为使用 channel 而不是 lock （可以参考 Share Memory By Communicating - The Go Blog 这篇文章），合适的场景选择合适的方法即可，既不需要畏惧 channel 也不必畏惧 lock 。 总结 目前能想到的就是这些注意事项了，欢迎纠正和补充。 参考资料 sync - GoDoc sasha-s/go-deadlock: Online deadlock detection in go (golang) Dancing with Go’s Mutexes – Hacker Noon Debugging a potential deadlock in Go with go-deadlock Data Race Detector - The Go Programming Language Share Memory By Communicating - The Go Blog Lock (Java Platform SE 8 ) 为 Go Mutex 实现 TryLock 方法 | 鸟窝 Fail-fast - Wikipedia Runtime overhead of using defer in go – i0exception – Medium runtime: defer is slow · Issue #14939 · golang/go vet - The Go Programming Language"/>
        <meta property="article:published_time" content="2019-04-07" />
            <meta property="article:section" content="go" />
            <meta property="article:tag" content="go" />
            <meta property="article:tag" content="lock" />
            <meta property="article:tag" content="mutex" />
            <meta property="article:author" content="mozillazg" />
            <meta property="og:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>


    <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@mozillazg">
        <meta name="twitter:creator" content="@mozillazg">
    <meta name="twitter:domain" content="https://mozillazg.com">
            <meta property="twitter:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/css/bootstrap.min.css" type="text/css"/>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link href="https://cdn.jsdelivr.net/npm/pygments-css@1.0.0/github.css" rel="stylesheet">
    <link rel="stylesheet" href="https://mozillazg.com/theme/css/style.css" type="text/css"/>
            <link href="https://mozillazg.com/static/custom.css" rel="stylesheet">

        <link href="https://mozillazg.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog ATOM Feed"/>

        <link href="https://mozillazg.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="mozillazg's Blog RSS Feed"/>


        <link href="https://mozillazg.com/feeds/go.atom.xml" type="application/atom+xml" rel="alternate"
              title="mozillazg's Blog go ATOM Feed"/>


    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "publisher": {
            "@type": "Person",
            "name": "mozillazg",
            "logo": "https://mozillazg.com/static/avatar.jpeg"
        },
        "author": {
            "@type": "Person",
            "name": "mozillazg",
            "image": "https://mozillazg.com/static/avatar.jpeg",
            "url": "https://mozillazg.com",
            "sameAs": []
        },
        "headline": "Go: 关于锁（mutex）的一些使用注意事项",
        "url": "https://mozillazg.com/2019/04/notes-about-go-lock-mutex.html",
        "image": [
            "https://mozillazg.com/static/avatar.jpeg"
         ],
        "keywords": "go, lock, mutex",
        "description": "前言 最近踩了一个锁的坑，所以在这里简单记录一些 Go 中关于锁（mutex）使用的一些注意事项。 尽量减少锁的持有时间 尽量减少锁的持有时间，毕竟使用锁是有代价的，通过减少锁的持有时间来减轻这个代价： 细化锁的粒度。通过细化锁的粒度来减少锁的持有时间以及避免在持有锁操作的时候做各种耗时的操作。 不要在持有锁的时候做 IO 操作。尽量只通过持有锁来保护 IO 操作需要的资源而不是 IO 操作本身： func doSomething() { m.Lock() item := ... http.Get() // 各种耗时的 IO 操作 m.Unlock() } // 改为 func doSomething() { m.Lock() item := ... m.Unlock() http.Get() } 善用 defer 来确保在函数内正确释放了锁 尤其是在那些内部有好几个通过 if err != nil 判断来提前返回的函数中，通过 defer 可以确保不会遗漏释放锁操作，避免出现死锁问题，以及避免函数内非预期的 panic 导致死锁的问题： func doSomething() { m.Lock() defer m.Unlock() err := ... if err != nil { return } err = ... if err != nil { return } ... return } 不过使用 defer 的时候也要注意别因为习惯性的 defer m.Unlock() 导致无意中在持有锁的时候做了 IO 操作，出现了非预期的持有锁时间太长的问题。 // 非预期的在持有锁期间做 IO 操作 func doSomething() { m.Lock() defer m.Unlock() item := ... http.Get() // 各种耗时的 IO 操作 } 以及 defer 其实是有点 性能 消耗 的，需要取舍下酌情使用。 在适当时候使用 RWMutex 当确定操作不会修改保护的资源时，可以使用 RWMutex 来减少锁等待时间（不同的 goroutine 可以同时持有 RLock, 但是 Lock 限制了只能有一个 goroutine 持有 Lock）： func nickName() string { rw.RLock() defer rw.RUnlock() return name } func SetName(s string) string { rw.Lock() defer rw.Unlock() name = s } copy 结构体操作可能导致非预期的死锁 copy 结构体时，如果结构体中有锁的话，记得重新初始化一个锁对象，否则会出现非预期的死锁： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( &#34;fmt&#34; &#34;sync&#34; ) type User struct { sync.Mutex name string } func main() { u1 := &amp;User{name: &#34;test&#34;} u1.Lock() defer u1.Unlock() tmp := *u1 u2 := &amp;tmp // u2.Mutex = sync.Mutex{} // 没有这一行就会死锁 fmt.Printf(&#34;%#p\\n&#34;, u1) fmt.Printf(&#34;%#p\\n&#34;, u2) u2.Lock() defer u2.Unlock() } $ go run main.go c00000a080 c00000a0a0 fatal error: all goroutines are asleep - deadlock! goroutine 1 [semacquire]: sync.runtime_SemacquireMutex(0xc00000a0a4, 0x0) /usr/local/Cellar/go/1.11/libexec/src/runtime/sema.go:71 +0x3d sync.(*Mutex).Lock(0xc00000a0a0) /usr/local/Cellar/go/1.11/libexec/src/sync/mutex.go:134 +0xff main.main() /Users/xxx/tmp/golang/main.go:26 +0x17f exit status 2 文档中也有类似的警告： A Mutex must not be copied after first use https://godoc.org/sync#Mutex 使用 go vet 工具检查代码中锁的使用问题 可以通过 vet 这个命令行来检查上面的锁 copy 的问题。比如上面的例子的检查结果如下：: $ go vet main.go # command-line-arguments ./main.go:19:9: assignment copies lock value to tmp: command-line-arguments.User 可以看到 vet 提示 19 行那里的 copy 操作中 copy 了一个锁。 BTW，使用 go vet 命令对整个项目进行检查时，可以通过 go vet $(go list ./... | grep -v /vendor/) 这个命令忽略掉 vendor 下的包。 build/test 时使用 -race 参数以便运行时检测数据竞争问题 可以在执行 go build 或 go test 时增加一个 -race 参数来开启数据竞争检测功能，通过这种方式来实现在本地开发环境/CI/测试环境阶段发现程序中可能存在的数据竞争问题： package main import ( &#34;fmt&#34; &#34;sync&#34; ) type Todo struct { sync.Mutex tasks []string } func (t *Todo) do() { for _, task := range t.tasks { fmt.Println(task) } } func (t *Todo) Add(task string) { t.Lock() defer t.Unlock() t.tasks = append(t.tasks, task) } func main() { t := &amp;Todo{} for i := 0; i &lt; 2; i++ { go t.Add(fmt.Sprintf(&#34;%d&#34;, i)) } for i := 0; i &lt; 2; i++ { t.do() } } -race 参数可以开启数据竞争检测（详见： Data Race Detector - The Go Programming Language ）： $ go build -race -o main . $ $ ./main ================== WARNING: DATA RACE Read at 0x00c0000a0048 by main goroutine: main.(*Todo).do() /Users/xxx/tmp/golang/race/main.go:15 +0x42 main.main() /Users/xxx/tmp/golang/race/main.go:34 +0x154 Previous write at 0x00c0000a0048 by goroutine 6: main.(*Todo).Add() /Users/xxx/tmp/golang/race/main.go:24 +0x11d Goroutine 6 (finished) created at: main.main() /Users/xxx/tmp/golang/race/main.go:31 +0x127 ================== 0 ================== WARNING: DATA RACE Read at 0x00c0000b0010 by main goroutine: main.(*Todo).do() /Users/xxx/tmp/golang/race/main.go:15 +0x85 main.main() /Users/xxx/tmp/golang/race/main.go:34 +0x154 Previous write at 0x00c0000b0010 by goroutine 7: main.(*Todo).Add() /Users/xxx/tmp/golang/race/main.go:24 +0xe3 Goroutine 7 (finished) created at: main.main() /Users/xxx/tmp/golang/race/main.go:31 +0x127 ================== 1 0 1 Found 2 data race(s) 使用 go-deadlock 检测死锁或锁等待问题 上面说的在持有锁的时候做 IO 操作或其他非预期的耗时超时的问题，一方面需要在写程序的时候注意一下，另一方面也有可能是无意中代入进去的（比如上面提到的习惯性 defer 导致的）。对于那些无意中代入进去的锁等待的问题人为的去 review 的话通常很难发现，此时就需要用工具来检测了。恰好有一个叫 go-deadlock 的工具可以实现这个功能。 package main import ( &#34;net/http&#34; &#34;time&#34; sync &#34;github.com/sasha-s/go-deadlock&#34; ) var mu sync.Mutex var url = &#34;http://baidu.com:90&#34; func do() { mu.Lock() defer mu.Unlock() u := url http.Get(u) // 非预期的在持有锁期间做 IO 操作，导致锁等待时间变长 } func main() { // 检测超过 100 ms 的锁等待 sync.Opts.DeadlockTimeout = time.Millisecond * 100 var wg sync.WaitGroup for i := 0; i &lt; 3; i++ { wg.Add(1) go func() { defer wg.Done() do() }() } wg.Wait() } 执行结果： $ go run main.go POTENTIAL DEADLOCK: Previous place where the lock was grabbed goroutine 36 lock 0x1483b90 main.go:14 main.do { mu.Lock() } &lt;&lt;&lt;&lt;&lt; main.go:30 main.main.func1 { do() } Have been trying to lock it again for more than 100ms goroutine 35 lock 0x1483b90 main.go:14 main.do { mu.Lock() } &lt;&lt;&lt;&lt;&lt; main.go:30 main.main.func1 { do() } Here is what goroutine 36 doing now goroutine 36 [select]: net/http.(*Transport).getConn(0x14616c0, 0xc00015e150, 0x0, 0x128adb3, 0x4, 0xc000014100, 0xc, 0x0, 0x0, 0xc0000559e8) /usr/local/Cellar/go/1.11/libexec/src/net/http/transport.go:1004 +0x58e net/http.(*Transport).roundTrip(0x14616c0, 0xc000160000, 0x203000, 0xc000055c90, 0x11d823a) /usr/local/Cellar/go/1.11/libexec/src/net/http/transport.go:451 +0x690 net/http.(*Transport).RoundTrip(0x14616c0, 0xc000160000, 0x14616c0, 0x0, 0x0) /usr/local/Cellar/go/1.11/libexec/src/net/http/roundtrip.go:17 +0x35 net/http.send(0xc000160000, 0x12c78a0, 0x14616c0, 0x0, 0x0, 0x0, 0xc00000e030, 0x1708000, 0xc000055d20, 0x1) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:250 +0x14b net/http.(*Client).send(0x1466200, 0xc000160000, 0x0, 0x0, 0x0, 0xc00000e030, 0x0, 0x1, 0x0) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:174 +0xfa net/http.(*Client).do(0x1466200, 0xc000160000, 0x0, 0x0, 0x0) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:641 +0x2a8 net/http.(*Client).Do(0x1466200, 0xc000160000, 0x128adb3, 0x13, 0x0) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:509 +0x35 net/http.(*Client).Get(0x1466200, 0x128adb3, 0x13, 0xc0000220c0, 0x12412c0, 0xc000055f80) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:398 +0x9d net/http.Get(0x128adb3, 0x13, 0x1483b90, 0x0, 0xc000114fb8) /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:370 +0x41 main.do() /Users/xxx/tmp/golang/deadlock/main.go:18 +0x75 main.main.func1(0xc00009c3f4) /Users/xxx/tmp/golang/deadlock/main.go:30 +0x48 created by main.main /Users/xxx/tmp/golang/deadlock/main.go:28 +0x83 exit status 2 通过上面的输出可以知道 goroutine 36 持有锁的时间过长导致其他 goroutine 获取锁的等待时间超过了 100 ms ，并且 goroutine 36 在持有锁期间正在做 18 行的 http 操作。可以看到 go-deadlock 在优化锁等待时间方面有很大的帮助，可以帮助我们及时发现异常的锁使用姿势。 实现 tryLock 功能 一般 Lock() 如果拿不到锁的话，会一直阻塞在那里，在某些场景下这个功能不是我们所期望的结果，我们可能希望程序在一定时间内无法获取到锁的话就做其他操作或者直接返回失败：比如在一个 http server 中，处理请求时因为锁等待时间太长导致客户端大量超时，引发客户端重连以及服务端 goroutine 数量持续增长（虽然客户端超时了，但是处理请求的 goroutine 还在继续处理已超时的请求并且阻塞在了获取锁的地方，然后客户端重连又加重了这个问题，表现就是处理请求的 goroutine 数量直线上升）。这个时候我们就需要有一个类似 tryLock 的功能，在发现短时间内无法获取到锁的时候直接返回失败的响应，防止问题进一步加重（Fail Fast）。 关于 tryLock 这个功能的介绍可以参考 Java 中 tryLock 的介绍，至于 Go 中如何实现 tryLock 可以参考 为 Go Mutex 实现 TryLock 方法 | 鸟窝 改为使用 channel 有些时候可能使用 channel 会更符合需求，对于这些更适合 channel 的场景可以改为使用 channel 而不是 lock （可以参考 Share Memory By Communicating - The Go Blog 这篇文章），合适的场景选择合适的方法即可，既不需要畏惧 channel 也不必畏惧 lock 。 总结 目前能想到的就是这些注意事项了，欢迎纠正和补充。 参考资料 sync - GoDoc sasha-s/go-deadlock: Online deadlock detection in go (golang) Dancing with Go’s Mutexes – Hacker Noon Debugging a potential deadlock in Go with go-deadlock Data Race Detector - The Go Programming Language Share Memory By Communicating - The Go Blog Lock (Java Platform SE 8 ) 为 Go Mutex 实现 TryLock 方法 | 鸟窝 Fail-fast - Wikipedia Runtime overhead of using defer in go – i0exception – Medium runtime: defer is slow · Issue #14939 · golang/go vet - The Go Programming Language",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "https://mozillazg.com/2019/04/notes-about-go-lock-mutex.html"
        },
        "datePublished": "2019-04-07"
    }
    </script>

</head>
<body>

<div class="navbar" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://mozillazg.com/" class="navbar-brand">
mozillazg's Blog            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="https://mozillazg.com/feeds/all.atom.xml">Feed</a></li>
                    <li><a href="/2014/10/pages/about-me.html">About</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://mozillazg.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content" class="yue">
        <article>
            <header class="text-center">
                <h1>
                    <a href="https://mozillazg.com/2019/04/notes-about-go-lock-mutex.html"
                       rel="bookmark"
                       title="Permalink to Go: 关于锁（mutex）的一些使用注意事项">
                        Go: 关于锁（mutex）的一些使用注意事项
                    </a>
                </h1>
                <p class="published">
                    <time datetime="2019-04-07T00:00:00+00:00">
                    2019-04-07
                    </time>
                </p>
            </header>
            <div class="entry-content">
                <div class="well-sm article-info">
<footer class="post-info">
        <a href="https://mozillazg.com/category/go.html">go</a>


<span class="label label-default hide">Tags</span>
	<a href="https://mozillazg.com/tag/lock.html">lock</a>
        /
	<a href="https://mozillazg.com/tag/mutex.html">mutex</a>
    
</footer><!-- /.post-info -->                </div>
                <div class="js-toc"></div>
                <div>
                <div class="section" id="id1">
<h2 id="hidid1">前言<a class="headerlink" href="#hidid1" title="Permalink to this headline">¶</a></h2>
<p>最近踩了一个锁的坑，所以在这里简单记录一些 Go 中关于锁（mutex）使用的一些注意事项。</p>
</div>
<div class="section" id="id2">
<h2 id="hidid2">尽量减少锁的持有时间<a class="headerlink" href="#hidid2" title="Permalink to this headline">¶</a></h2>
<p>尽量减少锁的持有时间，毕竟使用锁是有代价的，通过减少锁的持有时间来减轻这个代价：</p>
<ul class="simple">
<li>细化锁的粒度。通过细化锁的粒度来减少锁的持有时间以及避免在持有锁操作的时候做各种耗时的操作。</li>
<li>不要在持有锁的时候做 IO 操作。尽量只通过持有锁来保护 IO 操作需要的资源而不是 IO 操作本身：</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">doSomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="nx">item</span> <span class="o">:=</span> <span class="o">...</span>
    <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">()</span>  <span class="c1">// 各种耗时的 IO 操作</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
<span class="p">}</span>

<span class="c1">// 改为</span>
<span class="kd">func</span> <span class="nx">doSomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="nx">item</span> <span class="o">:=</span> <span class="o">...</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>

    <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="defer">
<h2 id="hiddefer">善用 defer 来确保在函数内正确释放了锁<a class="headerlink" href="#hiddefer" title="Permalink to this headline">¶</a></h2>
<p>尤其是在那些内部有好几个通过 <tt class="docutils literal">if err != nil</tt> 判断来提前返回的函数中，通过 <tt class="docutils literal">defer</tt> 可以确保不会遗漏释放锁操作，避免出现死锁问题，以及避免函数内非预期的 panic 导致死锁的问题：</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">doSomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>

    <span class="nx">err</span> <span class="o">:=</span> <span class="o">...</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="nx">err</span> <span class="p">=</span> <span class="o">...</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="o">...</span>
    <span class="k">return</span>
<span class="p">}</span>
</pre></div>
<p>不过使用 defer 的时候也要注意别因为习惯性的 <tt class="docutils literal">defer m.Unlock()</tt> 导致无意中在持有锁的时候做了 IO 操作，出现了非预期的持有锁时间太长的问题。</p>
<div class="highlight"><pre><span></span><span class="c1">// 非预期的在持有锁期间做 IO 操作</span>
<span class="kd">func</span> <span class="nx">doSomething</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">m</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">m</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>

    <span class="nx">item</span> <span class="o">:=</span> <span class="o">...</span>
    <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">()</span>  <span class="c1">// 各种耗时的 IO 操作</span>
<span class="p">}</span>
</pre></div>
<p>以及 <tt class="docutils literal">defer</tt> 其实是有点 <a class="reference external" href="https://medium.com/i0exception/runtime-overhead-of-using-defer-in-go-7140d5c40e32">性能</a> <a class="reference external" href="https://github.com/golang/go/issues/14939">消耗</a> 的，需要取舍下酌情使用。</p>
</div>
<div class="section" id="rwmutex">
<h2 id="hidrwmutex">在适当时候使用 RWMutex<a class="headerlink" href="#hidrwmutex" title="Permalink to this headline">¶</a></h2>
<p>当确定操作不会修改保护的资源时，可以使用 RWMutex 来减少锁等待时间（不同的 goroutine 可以同时持有 RLock, 但是 Lock 限制了只能有一个 goroutine 持有 Lock）：</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">nickName</span><span class="p">()</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">rw</span><span class="p">.</span><span class="nx">RLock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">rw</span><span class="p">.</span><span class="nx">RUnlock</span><span class="p">()</span>

    <span class="k">return</span> <span class="nx">name</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">SetName</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="nx">rw</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">rw</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>

    <span class="nx">name</span> <span class="p">=</span> <span class="nx">s</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="copy">
<h2 id="hidcopy">copy 结构体操作可能导致非预期的死锁<a class="headerlink" href="#hidcopy" title="Permalink to this headline">¶</a></h2>
<p>copy 结构体时，如果结构体中有锁的话，记得重新初始化一个锁对象，否则会出现非预期的死锁：</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span></span> <span class="kn">package</span> <span class="nx">main</span>

 <span class="kn">import</span> <span class="p">(</span>
     <span class="s">&quot;fmt&quot;</span>
     <span class="s">&quot;sync&quot;</span>
 <span class="p">)</span>

 <span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
     <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>

     <span class="nx">name</span> <span class="kt">string</span>
 <span class="p">}</span>

 <span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="nx">u1</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">User</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="s">&quot;test&quot;</span><span class="p">}</span>
     <span class="nx">u1</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
     <span class="k">defer</span> <span class="nx">u1</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>

<span class="hll">     <span class="nx">tmp</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">u1</span>
</span><span class="hll">     <span class="nx">u2</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">tmp</span>
</span><span class="hll">     <span class="c1">// u2.Mutex = sync.Mutex{} // 没有这一行就会死锁</span>
</span>
     <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%#p\n&quot;</span><span class="p">,</span> <span class="nx">u1</span><span class="p">)</span>
     <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%#p\n&quot;</span><span class="p">,</span> <span class="nx">u2</span><span class="p">)</span>

     <span class="nx">u2</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
     <span class="k">defer</span> <span class="nx">u2</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>
 <span class="p">}</span>
</pre></div>
</td></tr></table><div class="highlight"><pre><span></span>$ go run main.go
c00000a080
c00000a0a0
fatal error: all goroutines are asleep - deadlock!

goroutine <span class="m">1</span> <span class="o">[</span>semacquire<span class="o">]</span>:
sync.runtime_SemacquireMutex<span class="o">(</span>0xc00000a0a4, 0x0<span class="o">)</span>
    /usr/local/Cellar/go/1.11/libexec/src/runtime/sema.go:71 +0x3d
sync.<span class="o">(</span>*Mutex<span class="o">)</span>.Lock<span class="o">(</span>0xc00000a0a0<span class="o">)</span>
    /usr/local/Cellar/go/1.11/libexec/src/sync/mutex.go:134 +0xff
main.main<span class="o">()</span>
    /Users/xxx/tmp/golang/main.go:26 +0x17f
<span class="nb">exit</span> status 2
</pre></div>
<p>文档中也有类似的警告：</p>
<blockquote>
<p>A Mutex must not be copied after first use</p>
<p><a class="reference external" href="https://godoc.org/sync#Mutex">https://godoc.org/sync#Mutex</a></p>
</blockquote>
</div>
<div class="section" id="go-vet">
<h2 id="hidgo-vet">使用 go vet 工具检查代码中锁的使用问题<a class="headerlink" href="#hidgo-vet" title="Permalink to this headline">¶</a></h2>
<p>可以通过 <a class="reference external" href="https://golang.org/cmd/vet/">vet</a> 这个命令行来检查上面的锁 copy 的问题。比如上面的例子的检查结果如下：:</p>
<pre class="literal-block">
$ go vet main.go
# command-line-arguments
./main.go:19:9: assignment copies lock value to tmp: command-line-arguments.User
</pre>
<p>可以看到 vet 提示 19 行那里的 copy 操作中 copy 了一个锁。</p>
<p>BTW，使用 go vet 命令对整个项目进行检查时，可以通过 <tt class="docutils literal">go vet $(go list <span class="pre">./...</span> | grep <span class="pre">-v</span> /vendor/)</tt> 这个命令忽略掉 vendor 下的包。</p>
</div>
<div class="section" id="build-test-race">
<h2 id="hidbuild-test-race">build/test 时使用 -race 参数以便运行时检测数据竞争问题<a class="headerlink" href="#hidbuild-test-race" title="Permalink to this headline">¶</a></h2>
<p>可以在执行 go build 或 go test 时增加一个 <tt class="docutils literal"><span class="pre">-race</span></tt> 参数来开启数据竞争检测功能，通过这种方式来实现在本地开发环境/CI/测试环境阶段发现程序中可能存在的数据竞争问题：</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;fmt&quot;</span>
    <span class="s">&quot;sync&quot;</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Todo</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>

    <span class="nx">tasks</span> <span class="p">[]</span><span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Todo</span><span class="p">)</span> <span class="nx">do</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">task</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">t</span><span class="p">.</span><span class="nx">tasks</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">task</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">Todo</span><span class="p">)</span> <span class="nx">Add</span><span class="p">(</span><span class="nx">task</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">t</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>

    <span class="nx">t</span><span class="p">.</span><span class="nx">tasks</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">tasks</span><span class="p">,</span> <span class="nx">task</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">t</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Todo</span><span class="p">{}</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nx">t</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Sprintf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="nx">i</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">.</span><span class="nx">do</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p><tt class="docutils literal"><span class="pre">-race</span></tt> 参数可以开启数据竞争检测（详见： <a class="reference external" href="https://golang.org/doc/articles/race_detector.html">Data Race Detector - The Go Programming Language</a> ）：</p>
<div class="highlight"><pre><span></span>$ go build -race -o main .
$
$ ./main
<span class="o">==================</span>
WARNING: DATA RACE
Read at 0x00c0000a0048 by main goroutine:
  main.<span class="o">(</span>*Todo<span class="o">)</span>.do<span class="o">()</span>
      /Users/xxx/tmp/golang/race/main.go:15 +0x42
  main.main<span class="o">()</span>
      /Users/xxx/tmp/golang/race/main.go:34 +0x154

Previous write at 0x00c0000a0048 by goroutine 6:
  main.<span class="o">(</span>*Todo<span class="o">)</span>.Add<span class="o">()</span>
      /Users/xxx/tmp/golang/race/main.go:24 +0x11d

Goroutine <span class="m">6</span> <span class="o">(</span>finished<span class="o">)</span> created at:
  main.main<span class="o">()</span>
      /Users/xxx/tmp/golang/race/main.go:31 +0x127
<span class="o">==================</span>
<span class="nv">0</span>
<span class="o">==================</span>
WARNING: DATA RACE
Read at 0x00c0000b0010 by main goroutine:
  main.<span class="o">(</span>*Todo<span class="o">)</span>.do<span class="o">()</span>
      /Users/xxx/tmp/golang/race/main.go:15 +0x85
  main.main<span class="o">()</span>
      /Users/xxx/tmp/golang/race/main.go:34 +0x154

Previous write at 0x00c0000b0010 by goroutine 7:
  main.<span class="o">(</span>*Todo<span class="o">)</span>.Add<span class="o">()</span>
      /Users/xxx/tmp/golang/race/main.go:24 +0xe3

Goroutine <span class="m">7</span> <span class="o">(</span>finished<span class="o">)</span> created at:
  main.main<span class="o">()</span>
      /Users/xxx/tmp/golang/race/main.go:31 +0x127
<span class="o">==================</span>
1
0
1
Found <span class="m">2</span> data race<span class="o">(</span>s<span class="o">)</span>
</pre></div>
</div>
<div class="section" id="go-deadlock">
<h2 id="hidgo-deadlock">使用 go-deadlock 检测死锁或锁等待问题<a class="headerlink" href="#hidgo-deadlock" title="Permalink to this headline">¶</a></h2>
<p>上面说的在持有锁的时候做 IO 操作或其他非预期的耗时超时的问题，一方面需要在写程序的时候注意一下，另一方面也有可能是无意中代入进去的（比如上面提到的习惯性 defer 导致的）。对于那些无意中代入进去的锁等待的问题人为的去 review 的话通常很难发现，此时就需要用工具来检测了。恰好有一个叫 <a class="reference external" href="https://github.com/sasha-s/go-deadlock">go-deadlock</a> 的工具可以实现这个功能。</p>
<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&quot;net/http&quot;</span>
    <span class="s">&quot;time&quot;</span>

    <span class="nx">sync</span> <span class="s">&quot;github.com/sasha-s/go-deadlock&quot;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">mu</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="kd">var</span> <span class="nx">url</span> <span class="p">=</span> <span class="s">&quot;http://baidu.com:90&quot;</span>

<span class="kd">func</span> <span class="nx">do</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">mu</span><span class="p">.</span><span class="nx">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">mu</span><span class="p">.</span><span class="nx">Unlock</span><span class="p">()</span>

    <span class="nx">u</span> <span class="o">:=</span> <span class="nx">url</span>
    <span class="nx">http</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">u</span><span class="p">)</span>  <span class="c1">// 非预期的在持有锁期间做 IO 操作，导致锁等待时间变长</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 检测超过 100 ms 的锁等待</span>
    <span class="nx">sync</span><span class="p">.</span><span class="nx">Opts</span><span class="p">.</span><span class="nx">DeadlockTimeout</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span> <span class="o">*</span> <span class="mi">100</span>

    <span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nx">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nx">Done</span><span class="p">()</span>
            <span class="nx">do</span><span class="p">()</span>
        <span class="p">}()</span>
    <span class="p">}</span>

    <span class="nx">wg</span><span class="p">.</span><span class="nx">Wait</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
<p>执行结果：</p>
<div class="highlight"><pre><span></span>$ go run main.go
POTENTIAL DEADLOCK:
Previous place where the lock was grabbed
goroutine <span class="m">36</span> lock 0x1483b90
main.go:14 main.do <span class="o">{</span> mu.Lock<span class="o">()</span> <span class="o">}</span> <span class="o">&lt;&lt;&lt;</span><span class="s">&lt;&lt;</span>
<span class="s">main.go:30 main</span>.main.func1 <span class="o">{</span> <span class="k">do</span><span class="o">()</span> <span class="o">}</span>

Have been trying to lock it again <span class="k">for</span> more than 100ms
goroutine <span class="m">35</span> lock 0x1483b90
main.go:14 main.do <span class="o">{</span> mu.Lock<span class="o">()</span> <span class="o">}</span> <span class="o">&lt;&lt;&lt;</span><span class="s">&lt;&lt;</span>
<span class="s">main.go:30 main</span>.main.func1 <span class="o">{</span> <span class="k">do</span><span class="o">()</span> <span class="o">}</span>

Here is what goroutine <span class="m">36</span> doing now
goroutine <span class="m">36</span> <span class="o">[</span><span class="k">select</span><span class="o">]</span>:
net/http.<span class="o">(</span>*Transport<span class="o">)</span>.getConn<span class="o">(</span>0x14616c0, 0xc00015e150, 0x0, 0x128adb3, 0x4, 0xc000014100, 0xc, 0x0, 0x0, 0xc0000559e8<span class="o">)</span>
    /usr/local/Cellar/go/1.11/libexec/src/net/http/transport.go:1004 +0x58e
net/http.<span class="o">(</span>*Transport<span class="o">)</span>.roundTrip<span class="o">(</span>0x14616c0, 0xc000160000, 0x203000, 0xc000055c90, 0x11d823a<span class="o">)</span>
    /usr/local/Cellar/go/1.11/libexec/src/net/http/transport.go:451 +0x690
net/http.<span class="o">(</span>*Transport<span class="o">)</span>.RoundTrip<span class="o">(</span>0x14616c0, 0xc000160000, 0x14616c0, 0x0, 0x0<span class="o">)</span>
    /usr/local/Cellar/go/1.11/libexec/src/net/http/roundtrip.go:17 +0x35
net/http.send<span class="o">(</span>0xc000160000, 0x12c78a0, 0x14616c0, 0x0, 0x0, 0x0, 0xc00000e030, 0x1708000, 0xc000055d20, 0x1<span class="o">)</span>
    /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:250 +0x14b
net/http.<span class="o">(</span>*Client<span class="o">)</span>.send<span class="o">(</span>0x1466200, 0xc000160000, 0x0, 0x0, 0x0, 0xc00000e030, 0x0, 0x1, 0x0<span class="o">)</span>
    /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:174 +0xfa
net/http.<span class="o">(</span>*Client<span class="o">)</span>.do<span class="o">(</span>0x1466200, 0xc000160000, 0x0, 0x0, 0x0<span class="o">)</span>
    /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:641 +0x2a8
net/http.<span class="o">(</span>*Client<span class="o">)</span>.Do<span class="o">(</span>0x1466200, 0xc000160000, 0x128adb3, 0x13, 0x0<span class="o">)</span>
    /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:509 +0x35
net/http.<span class="o">(</span>*Client<span class="o">)</span>.Get<span class="o">(</span>0x1466200, 0x128adb3, 0x13, 0xc0000220c0, 0x12412c0, 0xc000055f80<span class="o">)</span>
    /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:398 +0x9d
net/http.Get<span class="o">(</span>0x128adb3, 0x13, 0x1483b90, 0x0, 0xc000114fb8<span class="o">)</span>
    /usr/local/Cellar/go/1.11/libexec/src/net/http/client.go:370 +0x41
main.do<span class="o">()</span>
    /Users/xxx/tmp/golang/deadlock/main.go:18 +0x75
main.main.func1<span class="o">(</span>0xc00009c3f4<span class="o">)</span>
    /Users/xxx/tmp/golang/deadlock/main.go:30 +0x48
created by main.main
    /Users/xxx/tmp/golang/deadlock/main.go:28 +0x83

<span class="nb">exit</span> status 2
</pre></div>
<p>通过上面的输出可以知道 goroutine 36 持有锁的时间过长导致其他 goroutine 获取锁的等待时间超过了 100 ms ，并且 goroutine 36 在持有锁期间正在做 18 行的 http 操作。可以看到 go-deadlock 在优化锁等待时间方面有很大的帮助，可以帮助我们及时发现异常的锁使用姿势。</p>
</div>
<div class="section" id="trylock">
<h2 id="hidtrylock">实现 tryLock 功能<a class="headerlink" href="#hidtrylock" title="Permalink to this headline">¶</a></h2>
<p>一般 <tt class="docutils literal">Lock()</tt> 如果拿不到锁的话，会一直阻塞在那里，在某些场景下这个功能不是我们所期望的结果，我们可能希望程序在一定时间内无法获取到锁的话就做其他操作或者直接返回失败：比如在一个 http server 中，处理请求时因为锁等待时间太长导致客户端大量超时，引发客户端重连以及服务端 goroutine 数量持续增长（虽然客户端超时了，但是处理请求的 goroutine 还在继续处理已超时的请求并且阻塞在了获取锁的地方，然后客户端重连又加重了这个问题，表现就是处理请求的 goroutine 数量直线上升）。这个时候我们就需要有一个类似 tryLock 的功能，在发现短时间内无法获取到锁的时候直接返回失败的响应，防止问题进一步加重（Fail Fast）。</p>
<p>关于 tryLock 这个功能的介绍可以参考 Java 中 <a class="reference external" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html#tryLock-long-java.util.concurrent.TimeUnit-">tryLock</a> 的介绍，至于 Go 中如何实现 tryLock 可以参考 <a class="reference external" href="https://colobu.com/2017/03/09/implement-TryLock-in-Go/">为 Go Mutex 实现 TryLock 方法 | 鸟窝</a></p>
</div>
<div class="section" id="channel">
<h2 id="hidchannel">改为使用 channel<a class="headerlink" href="#hidchannel" title="Permalink to this headline">¶</a></h2>
<p>有些时候可能使用 channel 会更符合需求，对于这些更适合 channel 的场景可以改为使用 channel 而不是 lock （可以参考 <a class="reference external" href="https://blog.golang.org/share-memory-by-communicating">Share Memory By Communicating - The Go Blog</a> 这篇文章），合适的场景选择合适的方法即可，既不需要畏惧 channel 也不必畏惧 lock 。</p>
</div>
<div class="section" id="id3">
<h2 id="hidid3">总结<a class="headerlink" href="#hidid3" title="Permalink to this headline">¶</a></h2>
<p>目前能想到的就是这些注意事项了，欢迎纠正和补充。</p>
</div>
<div class="section" id="id4">
<h2 id="hidid4">参考资料<a class="headerlink" href="#hidid4" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://godoc.org/sync">sync - GoDoc</a></li>
<li><a class="reference external" href="https://github.com/sasha-s/go-deadlock">sasha-s/go-deadlock: Online deadlock detection in go (golang)</a></li>
<li><a class="reference external" href="https://hackernoon.com/dancing-with-go-s-mutexes-92407ae927bf">Dancing with Go’s Mutexes – Hacker Noon</a></li>
<li><a class="reference external" href="https://wavded.com/post/golang-deadlockish/">Debugging a potential deadlock in Go with go-deadlock</a></li>
<li><a class="reference external" href="https://golang.org/doc/articles/race_detector.html">Data Race Detector - The Go Programming Language</a></li>
<li><a class="reference external" href="https://blog.golang.org/share-memory-by-communicating">Share Memory By Communicating - The Go Blog</a></li>
<li><a class="reference external" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html#tryLock-long-java.util.concurrent.TimeUnit-">Lock (Java Platform SE 8 )</a></li>
<li><a class="reference external" href="https://colobu.com/2017/03/09/implement-TryLock-in-Go/">为 Go Mutex 实现 TryLock 方法 | 鸟窝</a></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Fail-fast">Fail-fast - Wikipedia</a></li>
<li><a class="reference external" href="https://medium.com/i0exception/runtime-overhead-of-using-defer-in-go-7140d5c40e32">Runtime overhead of using defer in go – i0exception – Medium</a></li>
<li><a class="reference external" href="https://github.com/golang/go/issues/14939">runtime: defer is slow · Issue #14939 · golang/go</a></li>
<li><a class="reference external" href="https://golang.org/cmd/vet/">vet - The Go Programming Language</a></li>
</ul>
</div>

                </div>
            </div>
            <!-- /.entry-content -->
<section class="text-center">
  
<div id="donate"></div>

<div class="social-share"></div>
<div class="social-comment-note">
<p>有任何建议和想法欢迎在下方评论区留言或者加我<a href="/static/wechat.png">微信</a>交流</p>
</div>

</section>
    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'my-github-blog'; // required: replace example with your forum shortname

                    var disqus_identifier = 'notes-about-go-lock-mutex';
                var disqus_url = 'https://mozillazg.com/2019/04/notes-about-go-lock-mutex.html';

            var disqus_config = function () {
                this.language = "zh";
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2022 mozillazg
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>
            &middot; <a href="/privacy-policy.html" target="_blank">Privacy</a>              <p><small>  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/static/images/by-sa-80x15.png" /></a>
    &quot;<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">mozillazg's Blog</span>&quot; by <a xmlns:cc="http://creativecommons.org/ns#" href="https://mozillazg.com" property="cc:attributionName" rel="cc:attributionURL">mozillazg</a> is
  licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="https://cdn.jsdelivr.net/npm/jquery@2.1.1/dist/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->

    <!-- Disqus -->
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'my-github-blog'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script');
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <!-- End Disqus Code -->
    <!-- Google Analytics Universal -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-77172981-1', 'auto');
        ga('send', 'pageview');
    </script>
    <!-- End Google Analytics Universal Code -->

<!-- share.js -->
<script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script>



<script src="https://cdn.jsdelivr.net/npm/tocbot@3.0.2/dist/tocbot.min.js"></script>
<script>
$(document).ready(function(){
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.js-toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.entry-content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h2, h3, h4,h5',
    // Headings that match the ignoreSelector will be skipped.
    ignoreSelector: '.js-toc-ignore',
    // Main class to add to links.
    linkClass: 'toc-link',
    // Extra classes to add to links.
    extraLinkClasses: '',
    // Class to add to active links,
    // the link corresponding to the top most heading on the page.
    activeLinkClass: 'is-active-link',
    // Main class to add to lists.
    listClass: 'toc-list',
    // Extra classes to add to lists.
    extraListClasses: '',
    // Class that gets added when a list should be collapsed.
    isCollapsedClass: 'is-collapsed',
    // Class that gets added when a list should be able
    // to be collapsed but isn't necessarily collpased.
    collapsibleClass: 'is-collapsible',
    // Class to add to list items.
    listItemClass: 'toc-list-item',
    // How many heading levels should not be collpased.
    // For example, number 6 will show everything since
    // there are only 6 heading levels and number 0 will collpase them all.
    // The sections that are hidden will open
    // and close as you scroll to headings within them.
    collapseDepth: 6,
    // Smooth scrolling enabled.
    smoothScroll: true,
    // Smooth scroll duration.
    smoothScrollDuration: 420,
    // Callback for scroll end (requires: smoothScroll).
    scrollEndCallback: function (e) {},
    // Headings offset between the headings and the top of the document (this is meant for minor adjustments).
    headingsOffset: 0,
    // Timeout between events firing to make sure it's
    // not too rapid (for performance reasons).
    throttleTimeout: 50,
    // Element to add the positionFixedClass to.
    positionFixedSelector: null,
    // Fixed position class to add to make sidebar fixed after scrolling
    // down past the fixedSidebarOffset.
    positionFixedClass: 'is-position-fixed',
    // fixedSidebarOffset can be any number but by default is set
    // to auto which sets the fixedSidebarOffset to the sidebar
    // element's offsetTop from the top of the document on init.
    fixedSidebarOffset: 'auto',
    // includeHtml can be set to true to include the HTML markup from the
    // heading node instead of just including the textContent.
    includeHtml: false
  });
});
</script>
</body>
</html>