<!DOCTYPE html>
<html lang="zh-hans" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml" class="han-init">
<head>
    <title>Python: multiprocessing.Queue 在特定场景下会出现内部锁异常 - Huang Huang 的博客</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- share.css -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">
    <!-- share.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


    <link href="https://mozillazg.com/favicon.ico" rel="icon">

<link rel="canonical" href="https://mozillazg.com/2019/10/python-multiprocessing-queue-both-full-and-empty-are-true-internal-deadlock.html">

        <meta name="author" content="mozillazg" />
        <meta name="keywords" content="multiprocessing,Queue" />
    <meta name="description" content="前言¶ 如题所述，multiprocessing.Queue 在特定场景下会出现内部锁异常， 导致 Queue 实例出现既无法写入数据也无法读取数据的情况。 读取方意外退出导致内部异常¶ 一个场景是当读取方意外退出后，即便后来又有了新的读取方， 还是会出现内部异常最终导致写入方无法写入的问题。 复现问题¶ 可以通过下面的代码复现这个问题： import multiprocessing import time def reader(q): while True: try: q.get(timeout=5) print(&#39;read&#39;) except Exception as e: print(&#39;reader error: {!r}&#39;.format(e)) time.sleep(1) def writer(q): while True: try: q.put_nowait(time.time()) print(&#39;write&#39;) except Exception as e: print(&#39;writer error: {!r}&#39;.format(e)) time.sleep(1) q = multiprocessing.Queue(2) w = multiprocessing.Process(target=writer, args=(q,)) w.start() r = multiprocessing.Process(target=reader, args=(q,)) r.start() print(&#39;reader pid: {}&#39;.format(r.pid)) while True: if not r.is_alive(): print(&#39;reader dead, start new reader&#39;) r = multiprocessing.Process(target=reader, args=(q,)) r.start() print(&#39;reader pid: {}&#39;.format(r.pid)) time.sleep(1) 运行这段代码，在代码运行过程中 kill 掉 reader 进程模拟读取方意外退出的情况: $ python3.8 reader_deadlock.py reader pid: 53 write write writer error: Full() read read write write writer error: Full() read read ... read read reader dead, start new reader # &lt;-- kill 53 reader pid: 55 write write writer error: Full() writer error: Full() writer error: Full() writer error: Full() writer error: Full() writer error: Full() reader error: Empty() writer error: Full() writer error: Full() writer error: Full() writer error: Full() writer error: Full() writer error: Full() reader error: Empty() 可以看到，在杀掉 reader 进程后，即便后来再重新启动了一个 reader 进程， 还是出现了 writer 写不进去、reader 读不出来的问题。 原因¶ 为什么会出现这个问题呢？看一下 Queue 内部 get 和 put 方法的 关键代码 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Queue(object): def __init__(self, maxsize=0, *, ctx): # ... self._rlock = ctx.Lock() # ctx.Lock: class Lock(SemLock) # ... self._sem = ctx.BoundedSemaphore(maxsize) # ... def get(self, block=True, timeout=None): # ... if block and timeout is None: with self._rlock: res = self._recv_bytes() self._sem.release() # &lt;- 释放 semaphore else: if block: deadline = time.monotonic() + timeout if not self._rlock.acquire(block, timeout): # &lt;- 获取锁 raise Empty try: if block: timeout = deadline - time.monotonic() if not self._poll(timeout): # &lt;- 阻塞直到有数据或超时 raise Empty elif not self._poll(): raise Empty res = self._recv_bytes() self._sem.release() # &lt;- 释放 semaphore finally: self._rlock.release() # &lt;- 释放获取的锁 # unserialize the data after having released the lock return _ForkingPickler.loads(res) def put_nowait(self, obj): return self.put(obj, False) 为什么 kill 掉 reader 进程后就会出现前面的问题呢， 因为当 reader 进程阻塞在 get(timeout=5) 调用时，实际是阻塞在上面的 24 行代码那里， 此时 reader 进程已经通过 19 行的代码获取到了 self._rlock 这个锁， 当 kill reader 进程时，reader 进程退出并且退出的时候不会执行 31 行的释放锁操作。 当重新启动一个 reader 进程后，新 reader 进程执行 get(timeout=5) 调用时 会因为 19 行获取不到 self._rlock 这个锁导致总是抛出 Empty 异常，因为这个锁在前面那个 reader 进程里被 acquire 了，但是没有被 release 也永远都不会被 release 了，导致内部的 self._rlock 这个锁异常。 新的 reader 进程因为内部的 self._rlock 锁异常导致一直无法读取数据，进而导致 writer 进程无法写入数据，因为队列一直是满的。 验证¶ 修改一下前面的代码来验证一下上面所说的原因： def reader(q): while True: try: q.get(timeout=5) print(&#39;read&#39;) except Exception as e: print(&#39;reader error: {!r}, {}&#39;.format(e, q._rlock)) # 增加显式 _rlock 信息 time.sleep(1) 验证: $ python reader_deadlock_rlock.py reader pid: 464 write write writer error: Full() ... read read reader dead, start new reader reader pid: 466 write write writer error: Full() ... reader error: Empty(), &lt;Lock(owner=SomeOtherProcess)&gt; # _rlock 一直被其他进程所占用 writer error: Full() ... reader error: Empty(), &lt;Lock(owner=SomeOtherProcess)&gt; # _rlock 一直被其他进程所占用 writer error: Full() 写入方意外退出导致内部异常¶ 另一个场景是当写入方意外退出后，极端情况下会出现内部异常导致读取方无法读取数据、 同时新加入的写入方也无法写入数据的问题。 复现问题¶ 因为是极端情况下会出现的问题，暂时没找到 100% 复现问题的方法，只能从代码实现层面分析。 原因¶ 先来看一下 Queue 的 内部实现逻辑 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class Queue(object): def __init__(self, maxsize=0, *, ctx): # ... self._maxsize = maxsize self._reader, self._writer = connection.Pipe(duplex=False) self._rlock = ctx.Lock() self._opid = os.getpid() if sys.platform == &#39;win32&#39;: self._wlock = None else: self._wlock = ctx.Lock() # 使用 BoundedSemaphore 控制队列大小 self._sem = ctx.BoundedSemaphore(maxsize) self._after_fork() if sys.platform != &#39;win32&#39;: register_after_fork(self, Queue._after_fork) def _after_fork(self): debug(&#39;Queue._after_fork()&#39;) self._notempty = threading.Condition(threading.Lock()) self._buffer = collections.deque() self._thread = None self._jointhread = None self._joincancelled = False self._closed = False self._close = None self._send_bytes = self._writer.send_bytes self._recv_bytes = self._reader.recv_bytes self._poll = self._reader.poll def put(self, obj, block=True, timeout=None): if self._closed: raise ValueError(f&#34;Queue {self!r} is closed&#34;) if not self._sem.acquire(block, timeout): raise Full # acquire 后 _sem 中的 count - 1，表示当前 queue 可用大小减一 with self._notempty: if self._thread is None: self._start_thread() # 数据放到 buffer 里，通知后台线程去读取 buffer 里的数据 self._buffer.append(obj) self._notempty.notify() def get(self, block=True, timeout=None): if self._closed: raise ValueError(f&#34;Queue {self!r} is closed&#34;) if block and timeout is None: with self._rlock: # 从 Pipe 中读取数据 res = self._recv_bytes() # release 后 _sem 中的 count + 1，当前 queue 可用大小加一 self._sem.release() else: if block: deadline = time.monotonic() + timeout if not self._rlock.acquire(block, timeout): raise Empty try: if block: timeout = deadline - time.monotonic() if not self._poll(timeout): raise Empty elif not self._poll(): raise Empty # 从 Pipe 中读取数据 res = self._recv_bytes() # release 后 _sem 中的 count + 1，当前 queue 可用大小加一 self._sem.release() finally: self._rlock.release() # unserialize the data after having released the lock return _ForkingPickler.loads(res) def empty(self): return not self._poll() def full(self): return self._sem._semlock._is_zero() def get_nowait(self): return self.get(False) def put_nowait(self, obj): return self.put(obj, False) def _start_thread(self): debug(&#39;Queue._start_thread()&#39;) # Start thread which transfers data from buffer to pipe self._buffer.clear() self._thread = threading.Thread( target=Queue._feed, args=(self._buffer, self._notempty, self._send_bytes, self._wlock, self._writer.close, self._ignore_epipe, self._on_queue_feeder_error, self._sem), name=&#39;QueueFeederThread&#39; ) self._thread.daemon = True debug(&#39;doing self._thread.start()&#39;) self._thread.start() debug(&#39;... done self._thread.start()&#39;) # ... @staticmethod def _feed(buffer, notempty, send_bytes, writelock, close, ignore_epipe, onerror, queue_sem): debug(&#39;starting thread to feed data to pipe&#39;) nacquire = notempty.acquire nrelease = notempty.release nwait = notempty.wait bpopleft = buffer.popleft sentinel = _sentinel if sys.platform != &#39;win32&#39;: wacquire = writelock.acquire wrelease = writelock.release else: wacquire = None # 在这个后台线程中把 buffer 里的数据写入到 Pipe while 1: try: nacquire() try: if not buffer: nwait() finally: nrelease() try: while 1: obj = bpopleft() if obj is sentinel: debug(&#39;feeder thread got sentinel -- exiting&#39;) close() return # serialize the data before acquiring the lock obj = _ForkingPickler.dumps(obj) if wacquire is None: send_bytes(obj) else: wacquire() try: send_bytes(obj) finally: wrelease() except IndexError: pass except Exception as e: if ignore_epipe and getattr(e, &#39;errno&#39;, 0) == errno.EPIPE: return # Since this runs in a daemon thread the resources it uses # may be become unusable while the process is cleaning up. # We ignore errors which happen after the process has # started to cleanup. if is_exiting(): info(&#39;error in queue thread: %s&#39;, e) return else: # Since the object has not been sent in the queue, we need # to decrease the size of the queue. The error acts as # if the object had been silently removed from the queue # and this step is necessary to have a properly working # queue. queue_sem.release() onerror(e, obj) 从上面的代码可以得知，put 和 get 方法的与这个问题有关的关键流程如下: 队列大小是通过 _sem 这个 BoundedSemaphore(maxsize) 实例控制的。 get 和 put 之间的数据是通过 pipe 传递的。 put(obj) 操作: 执行 _sem.acquire() ，如果获取不到 semaphore 的话，表示当前队列已满。 获取到 semaphore 后（内部计数器加一，此时队列可用大小减一），把数据放到 buffer 中。 后台有个线程会去从 buffer 中读取数据，然后写入到 pipe 中。 get() 操作: 从 pipe 中读取数据。 读到数据后，执行 _sem.release() ，semaphore 内部计数器减一，此时队列可用大小加一。 问题出现的场景就是，上面 put(object) 中的后台线程 从 buffer 中读取数据然后写入 pipe 的过程中进程意外退出了， 此时因为数据没有写入到 pipe 中， get() 操作不会执行第2步的 _sem.release() 操作， 导致 put(object) 中 acquire 的 semaphore 永远不会被释放，也就是说当前队列可用大小会比实际大小小1。 如果这个进程意外退出的场景多出现几次，最终的结果就是有很多个 semaphore 永远不会被释放，极端情况下出现队列可用大小为 0 的情况，但是实际上队列中并没有数据，出现既写不进去数据又读取不了数据的情况。 总结¶ 参考资料¶ Issue 20527: multiprocessing.Queue deadlocks after “reader” process death - Python tracker multiprocessing — Process-based parallelism — Python 3.8.0 documentation cpython/queues.py at v3.8.0 · python/cpython c - POSIX name semaphore does not release after process exits - Stack Overflow" />

    <style>
      .js-toc {
        margin-bottom: 20px;
      }
      .donate-modal {
        text-align: center;
      }
      #donate-modal-container .donate-image {
        max-height: 300px !important;
        min-height: inherit !important;
      }
    </style>

        <meta property="og:site_name" content="Huang Huang 的博客" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Python: multiprocessing.Queue 在特定场景下会出现内部锁异常"/>
        <meta property="og:url" content="https://mozillazg.com/2019/10/python-multiprocessing-queue-both-full-and-empty-are-true-internal-deadlock.html"/>
        <meta property="og:description" content="前言¶ 如题所述，multiprocessing.Queue 在特定场景下会出现内部锁异常， 导致 Queue 实例出现既无法写入数据也无法读取数据的情况。 读取方意外退出导致内部异常¶ 一个场景是当读取方意外退出后，即便后来又有了新的读取方， 还是会出现内部异常最终导致写入方无法写入的问题。 复现问题¶ 可以通过下面的代码复现这个问题： import multiprocessing import time def reader(q): while True: try: q.get(timeout=5) print(&#39;read&#39;) except Exception as e: print(&#39;reader error: {!r}&#39;.format(e)) time.sleep(1) def writer(q): while True: try: q.put_nowait(time.time()) print(&#39;write&#39;) except Exception as e: print(&#39;writer error: {!r}&#39;.format(e)) time.sleep(1) q = multiprocessing.Queue(2) w = multiprocessing.Process(target=writer, args=(q,)) w.start() r = multiprocessing.Process(target=reader, args=(q,)) r.start() print(&#39;reader pid: {}&#39;.format(r.pid)) while True: if not r.is_alive(): print(&#39;reader dead, start new reader&#39;) r = multiprocessing.Process(target=reader, args=(q,)) r.start() print(&#39;reader pid: {}&#39;.format(r.pid)) time.sleep(1) 运行这段代码，在代码运行过程中 kill 掉 reader 进程模拟读取方意外退出的情况: $ python3.8 reader_deadlock.py reader pid: 53 write write writer error: Full() read read write write writer error: Full() read read ... read read reader dead, start new reader # &lt;-- kill 53 reader pid: 55 write write writer error: Full() writer error: Full() writer error: Full() writer error: Full() writer error: Full() writer error: Full() reader error: Empty() writer error: Full() writer error: Full() writer error: Full() writer error: Full() writer error: Full() writer error: Full() reader error: Empty() 可以看到，在杀掉 reader 进程后，即便后来再重新启动了一个 reader 进程， 还是出现了 writer 写不进去、reader 读不出来的问题。 原因¶ 为什么会出现这个问题呢？看一下 Queue 内部 get 和 put 方法的 关键代码 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Queue(object): def __init__(self, maxsize=0, *, ctx): # ... self._rlock = ctx.Lock() # ctx.Lock: class Lock(SemLock) # ... self._sem = ctx.BoundedSemaphore(maxsize) # ... def get(self, block=True, timeout=None): # ... if block and timeout is None: with self._rlock: res = self._recv_bytes() self._sem.release() # &lt;- 释放 semaphore else: if block: deadline = time.monotonic() + timeout if not self._rlock.acquire(block, timeout): # &lt;- 获取锁 raise Empty try: if block: timeout = deadline - time.monotonic() if not self._poll(timeout): # &lt;- 阻塞直到有数据或超时 raise Empty elif not self._poll(): raise Empty res = self._recv_bytes() self._sem.release() # &lt;- 释放 semaphore finally: self._rlock.release() # &lt;- 释放获取的锁 # unserialize the data after having released the lock return _ForkingPickler.loads(res) def put_nowait(self, obj): return self.put(obj, False) 为什么 kill 掉 reader 进程后就会出现前面的问题呢， 因为当 reader 进程阻塞在 get(timeout=5) 调用时，实际是阻塞在上面的 24 行代码那里， 此时 reader 进程已经通过 19 行的代码获取到了 self._rlock 这个锁， 当 kill reader 进程时，reader 进程退出并且退出的时候不会执行 31 行的释放锁操作。 当重新启动一个 reader 进程后，新 reader 进程执行 get(timeout=5) 调用时 会因为 19 行获取不到 self._rlock 这个锁导致总是抛出 Empty 异常，因为这个锁在前面那个 reader 进程里被 acquire 了，但是没有被 release 也永远都不会被 release 了，导致内部的 self._rlock 这个锁异常。 新的 reader 进程因为内部的 self._rlock 锁异常导致一直无法读取数据，进而导致 writer 进程无法写入数据，因为队列一直是满的。 验证¶ 修改一下前面的代码来验证一下上面所说的原因： def reader(q): while True: try: q.get(timeout=5) print(&#39;read&#39;) except Exception as e: print(&#39;reader error: {!r}, {}&#39;.format(e, q._rlock)) # 增加显式 _rlock 信息 time.sleep(1) 验证: $ python reader_deadlock_rlock.py reader pid: 464 write write writer error: Full() ... read read reader dead, start new reader reader pid: 466 write write writer error: Full() ... reader error: Empty(), &lt;Lock(owner=SomeOtherProcess)&gt; # _rlock 一直被其他进程所占用 writer error: Full() ... reader error: Empty(), &lt;Lock(owner=SomeOtherProcess)&gt; # _rlock 一直被其他进程所占用 writer error: Full() 写入方意外退出导致内部异常¶ 另一个场景是当写入方意外退出后，极端情况下会出现内部异常导致读取方无法读取数据、 同时新加入的写入方也无法写入数据的问题。 复现问题¶ 因为是极端情况下会出现的问题，暂时没找到 100% 复现问题的方法，只能从代码实现层面分析。 原因¶ 先来看一下 Queue 的 内部实现逻辑 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class Queue(object): def __init__(self, maxsize=0, *, ctx): # ... self._maxsize = maxsize self._reader, self._writer = connection.Pipe(duplex=False) self._rlock = ctx.Lock() self._opid = os.getpid() if sys.platform == &#39;win32&#39;: self._wlock = None else: self._wlock = ctx.Lock() # 使用 BoundedSemaphore 控制队列大小 self._sem = ctx.BoundedSemaphore(maxsize) self._after_fork() if sys.platform != &#39;win32&#39;: register_after_fork(self, Queue._after_fork) def _after_fork(self): debug(&#39;Queue._after_fork()&#39;) self._notempty = threading.Condition(threading.Lock()) self._buffer = collections.deque() self._thread = None self._jointhread = None self._joincancelled = False self._closed = False self._close = None self._send_bytes = self._writer.send_bytes self._recv_bytes = self._reader.recv_bytes self._poll = self._reader.poll def put(self, obj, block=True, timeout=None): if self._closed: raise ValueError(f&#34;Queue {self!r} is closed&#34;) if not self._sem.acquire(block, timeout): raise Full # acquire 后 _sem 中的 count - 1，表示当前 queue 可用大小减一 with self._notempty: if self._thread is None: self._start_thread() # 数据放到 buffer 里，通知后台线程去读取 buffer 里的数据 self._buffer.append(obj) self._notempty.notify() def get(self, block=True, timeout=None): if self._closed: raise ValueError(f&#34;Queue {self!r} is closed&#34;) if block and timeout is None: with self._rlock: # 从 Pipe 中读取数据 res = self._recv_bytes() # release 后 _sem 中的 count + 1，当前 queue 可用大小加一 self._sem.release() else: if block: deadline = time.monotonic() + timeout if not self._rlock.acquire(block, timeout): raise Empty try: if block: timeout = deadline - time.monotonic() if not self._poll(timeout): raise Empty elif not self._poll(): raise Empty # 从 Pipe 中读取数据 res = self._recv_bytes() # release 后 _sem 中的 count + 1，当前 queue 可用大小加一 self._sem.release() finally: self._rlock.release() # unserialize the data after having released the lock return _ForkingPickler.loads(res) def empty(self): return not self._poll() def full(self): return self._sem._semlock._is_zero() def get_nowait(self): return self.get(False) def put_nowait(self, obj): return self.put(obj, False) def _start_thread(self): debug(&#39;Queue._start_thread()&#39;) # Start thread which transfers data from buffer to pipe self._buffer.clear() self._thread = threading.Thread( target=Queue._feed, args=(self._buffer, self._notempty, self._send_bytes, self._wlock, self._writer.close, self._ignore_epipe, self._on_queue_feeder_error, self._sem), name=&#39;QueueFeederThread&#39; ) self._thread.daemon = True debug(&#39;doing self._thread.start()&#39;) self._thread.start() debug(&#39;... done self._thread.start()&#39;) # ... @staticmethod def _feed(buffer, notempty, send_bytes, writelock, close, ignore_epipe, onerror, queue_sem): debug(&#39;starting thread to feed data to pipe&#39;) nacquire = notempty.acquire nrelease = notempty.release nwait = notempty.wait bpopleft = buffer.popleft sentinel = _sentinel if sys.platform != &#39;win32&#39;: wacquire = writelock.acquire wrelease = writelock.release else: wacquire = None # 在这个后台线程中把 buffer 里的数据写入到 Pipe while 1: try: nacquire() try: if not buffer: nwait() finally: nrelease() try: while 1: obj = bpopleft() if obj is sentinel: debug(&#39;feeder thread got sentinel -- exiting&#39;) close() return # serialize the data before acquiring the lock obj = _ForkingPickler.dumps(obj) if wacquire is None: send_bytes(obj) else: wacquire() try: send_bytes(obj) finally: wrelease() except IndexError: pass except Exception as e: if ignore_epipe and getattr(e, &#39;errno&#39;, 0) == errno.EPIPE: return # Since this runs in a daemon thread the resources it uses # may be become unusable while the process is cleaning up. # We ignore errors which happen after the process has # started to cleanup. if is_exiting(): info(&#39;error in queue thread: %s&#39;, e) return else: # Since the object has not been sent in the queue, we need # to decrease the size of the queue. The error acts as # if the object had been silently removed from the queue # and this step is necessary to have a properly working # queue. queue_sem.release() onerror(e, obj) 从上面的代码可以得知，put 和 get 方法的与这个问题有关的关键流程如下: 队列大小是通过 _sem 这个 BoundedSemaphore(maxsize) 实例控制的。 get 和 put 之间的数据是通过 pipe 传递的。 put(obj) 操作: 执行 _sem.acquire() ，如果获取不到 semaphore 的话，表示当前队列已满。 获取到 semaphore 后（内部计数器加一，此时队列可用大小减一），把数据放到 buffer 中。 后台有个线程会去从 buffer 中读取数据，然后写入到 pipe 中。 get() 操作: 从 pipe 中读取数据。 读到数据后，执行 _sem.release() ，semaphore 内部计数器减一，此时队列可用大小加一。 问题出现的场景就是，上面 put(object) 中的后台线程 从 buffer 中读取数据然后写入 pipe 的过程中进程意外退出了， 此时因为数据没有写入到 pipe 中， get() 操作不会执行第2步的 _sem.release() 操作， 导致 put(object) 中 acquire 的 semaphore 永远不会被释放，也就是说当前队列可用大小会比实际大小小1。 如果这个进程意外退出的场景多出现几次，最终的结果就是有很多个 semaphore 永远不会被释放，极端情况下出现队列可用大小为 0 的情况，但是实际上队列中并没有数据，出现既写不进去数据又读取不了数据的情况。 总结¶ 参考资料¶ Issue 20527: multiprocessing.Queue deadlocks after “reader” process death - Python tracker multiprocessing — Process-based parallelism — Python 3.8.0 documentation cpython/queues.py at v3.8.0 · python/cpython c - POSIX name semaphore does not release after process exits - Stack Overflow"/>
        <meta property="article:published_time" content="2019-10-26" />
            <meta property="article:section" content="python" />
            <meta property="article:tag" content="multiprocessing" />
            <meta property="article:tag" content="Queue" />
            <meta property="article:author" content="mozillazg" />
            <meta property="og:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>


    <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="@mozillazg">
        <meta name="twitter:creator" content="@mozillazg">
    <meta name="twitter:domain" content="https://mozillazg.com">
            <meta property="twitter:image"
                  content="https://mozillazg.com/static/avatar.jpeg"/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://mozillazg.com/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="https://mozillazg.com/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="https://mozillazg.com/theme/css/pygments/github.css" rel="stylesheet">
    <link rel="stylesheet" href="https://mozillazg.com/theme/css/style.css" type="text/css"/>
            <link href="https://mozillazg.com/static/custom.css" rel="stylesheet">

        <link href="https://mozillazg.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="Huang Huang 的博客 ATOM Feed"/>

        <link href="https://mozillazg.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="Huang Huang 的博客 RSS Feed"/>


        <link href="https://mozillazg.com/feeds/python.atom.xml" type="application/atom+xml" rel="alternate"
              title="Huang Huang 的博客 python ATOM Feed"/>


    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "Website",
        "publisher": {
            "@type": "Person",
            "name": "mozillazg",
            "logo": "https://mozillazg.com/static/avatar.jpeg"
        },
        "author": {
            "@type": "Person",
            "name": "mozillazg",
            "image": "https://mozillazg.com/static/avatar.jpeg",
            "url": "https://mozillazg.com",
            "sameAs": []
        },
        // "headline": "",
        "url": "https://mozillazg.com/2019/10/python-multiprocessing-queue-both-full-and-empty-are-true-internal-deadlock.html",
        "datePublished": "2019-10-26",
        // "dateModified": "",
        "image": "https://mozillazg.com/static/avatar.jpeg",
        "keywords": "multiprocessing, Queue",
        "description": "前言¶ 如题所述，multiprocessing.Queue 在特定场景下会出现内部锁异常， 导致 Queue 实例出现既无法写入数据也无法读取数据的情况。 读取方意外退出导致内部异常¶ 一个场景是当读取方意外退出后，即便后来又有了新的读取方， 还是会出现内部异常最终导致写入方无法写入的问题。 复现问题¶ 可以通过下面的代码复现这个问题： import multiprocessing import time def reader(q): while True: try: q.get(timeout=5) print(&#39;read&#39;) except Exception as e: print(&#39;reader error: {!r}&#39;.format(e)) time.sleep(1) def writer(q): while True: try: q.put_nowait(time.time()) print(&#39;write&#39;) except Exception as e: print(&#39;writer error: {!r}&#39;.format(e)) time.sleep(1) q = multiprocessing.Queue(2) w = multiprocessing.Process(target=writer, args=(q,)) w.start() r = multiprocessing.Process(target=reader, args=(q,)) r.start() print(&#39;reader pid: {}&#39;.format(r.pid)) while True: if not r.is_alive(): print(&#39;reader dead, start new reader&#39;) r = multiprocessing.Process(target=reader, args=(q,)) r.start() print(&#39;reader pid: {}&#39;.format(r.pid)) time.sleep(1) 运行这段代码，在代码运行过程中 kill 掉 reader 进程模拟读取方意外退出的情况: $ python3.8 reader_deadlock.py reader pid: 53 write write writer error: Full() read read write write writer error: Full() read read ... read read reader dead, start new reader # &lt;-- kill 53 reader pid: 55 write write writer error: Full() writer error: Full() writer error: Full() writer error: Full() writer error: Full() writer error: Full() reader error: Empty() writer error: Full() writer error: Full() writer error: Full() writer error: Full() writer error: Full() writer error: Full() reader error: Empty() 可以看到，在杀掉 reader 进程后，即便后来再重新启动了一个 reader 进程， 还是出现了 writer 写不进去、reader 读不出来的问题。 原因¶ 为什么会出现这个问题呢？看一下 Queue 内部 get 和 put 方法的 关键代码 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Queue(object): def __init__(self, maxsize=0, *, ctx): # ... self._rlock = ctx.Lock() # ctx.Lock: class Lock(SemLock) # ... self._sem = ctx.BoundedSemaphore(maxsize) # ... def get(self, block=True, timeout=None): # ... if block and timeout is None: with self._rlock: res = self._recv_bytes() self._sem.release() # &lt;- 释放 semaphore else: if block: deadline = time.monotonic() + timeout if not self._rlock.acquire(block, timeout): # &lt;- 获取锁 raise Empty try: if block: timeout = deadline - time.monotonic() if not self._poll(timeout): # &lt;- 阻塞直到有数据或超时 raise Empty elif not self._poll(): raise Empty res = self._recv_bytes() self._sem.release() # &lt;- 释放 semaphore finally: self._rlock.release() # &lt;- 释放获取的锁 # unserialize the data after having released the lock return _ForkingPickler.loads(res) def put_nowait(self, obj): return self.put(obj, False) 为什么 kill 掉 reader 进程后就会出现前面的问题呢， 因为当 reader 进程阻塞在 get(timeout=5) 调用时，实际是阻塞在上面的 24 行代码那里， 此时 reader 进程已经通过 19 行的代码获取到了 self._rlock 这个锁， 当 kill reader 进程时，reader 进程退出并且退出的时候不会执行 31 行的释放锁操作。 当重新启动一个 reader 进程后，新 reader 进程执行 get(timeout=5) 调用时 会因为 19 行获取不到 self._rlock 这个锁导致总是抛出 Empty 异常，因为这个锁在前面那个 reader 进程里被 acquire 了，但是没有被 release 也永远都不会被 release 了，导致内部的 self._rlock 这个锁异常。 新的 reader 进程因为内部的 self._rlock 锁异常导致一直无法读取数据，进而导致 writer 进程无法写入数据，因为队列一直是满的。 验证¶ 修改一下前面的代码来验证一下上面所说的原因： def reader(q): while True: try: q.get(timeout=5) print(&#39;read&#39;) except Exception as e: print(&#39;reader error: {!r}, {}&#39;.format(e, q._rlock)) # 增加显式 _rlock 信息 time.sleep(1) 验证: $ python reader_deadlock_rlock.py reader pid: 464 write write writer error: Full() ... read read reader dead, start new reader reader pid: 466 write write writer error: Full() ... reader error: Empty(), &lt;Lock(owner=SomeOtherProcess)&gt; # _rlock 一直被其他进程所占用 writer error: Full() ... reader error: Empty(), &lt;Lock(owner=SomeOtherProcess)&gt; # _rlock 一直被其他进程所占用 writer error: Full() 写入方意外退出导致内部异常¶ 另一个场景是当写入方意外退出后，极端情况下会出现内部异常导致读取方无法读取数据、 同时新加入的写入方也无法写入数据的问题。 复现问题¶ 因为是极端情况下会出现的问题，暂时没找到 100% 复现问题的方法，只能从代码实现层面分析。 原因¶ 先来看一下 Queue 的 内部实现逻辑 : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class Queue(object): def __init__(self, maxsize=0, *, ctx): # ... self._maxsize = maxsize self._reader, self._writer = connection.Pipe(duplex=False) self._rlock = ctx.Lock() self._opid = os.getpid() if sys.platform == &#39;win32&#39;: self._wlock = None else: self._wlock = ctx.Lock() # 使用 BoundedSemaphore 控制队列大小 self._sem = ctx.BoundedSemaphore(maxsize) self._after_fork() if sys.platform != &#39;win32&#39;: register_after_fork(self, Queue._after_fork) def _after_fork(self): debug(&#39;Queue._after_fork()&#39;) self._notempty = threading.Condition(threading.Lock()) self._buffer = collections.deque() self._thread = None self._jointhread = None self._joincancelled = False self._closed = False self._close = None self._send_bytes = self._writer.send_bytes self._recv_bytes = self._reader.recv_bytes self._poll = self._reader.poll def put(self, obj, block=True, timeout=None): if self._closed: raise ValueError(f&#34;Queue {self!r} is closed&#34;) if not self._sem.acquire(block, timeout): raise Full # acquire 后 _sem 中的 count - 1，表示当前 queue 可用大小减一 with self._notempty: if self._thread is None: self._start_thread() # 数据放到 buffer 里，通知后台线程去读取 buffer 里的数据 self._buffer.append(obj) self._notempty.notify() def get(self, block=True, timeout=None): if self._closed: raise ValueError(f&#34;Queue {self!r} is closed&#34;) if block and timeout is None: with self._rlock: # 从 Pipe 中读取数据 res = self._recv_bytes() # release 后 _sem 中的 count + 1，当前 queue 可用大小加一 self._sem.release() else: if block: deadline = time.monotonic() + timeout if not self._rlock.acquire(block, timeout): raise Empty try: if block: timeout = deadline - time.monotonic() if not self._poll(timeout): raise Empty elif not self._poll(): raise Empty # 从 Pipe 中读取数据 res = self._recv_bytes() # release 后 _sem 中的 count + 1，当前 queue 可用大小加一 self._sem.release() finally: self._rlock.release() # unserialize the data after having released the lock return _ForkingPickler.loads(res) def empty(self): return not self._poll() def full(self): return self._sem._semlock._is_zero() def get_nowait(self): return self.get(False) def put_nowait(self, obj): return self.put(obj, False) def _start_thread(self): debug(&#39;Queue._start_thread()&#39;) # Start thread which transfers data from buffer to pipe self._buffer.clear() self._thread = threading.Thread( target=Queue._feed, args=(self._buffer, self._notempty, self._send_bytes, self._wlock, self._writer.close, self._ignore_epipe, self._on_queue_feeder_error, self._sem), name=&#39;QueueFeederThread&#39; ) self._thread.daemon = True debug(&#39;doing self._thread.start()&#39;) self._thread.start() debug(&#39;... done self._thread.start()&#39;) # ... @staticmethod def _feed(buffer, notempty, send_bytes, writelock, close, ignore_epipe, onerror, queue_sem): debug(&#39;starting thread to feed data to pipe&#39;) nacquire = notempty.acquire nrelease = notempty.release nwait = notempty.wait bpopleft = buffer.popleft sentinel = _sentinel if sys.platform != &#39;win32&#39;: wacquire = writelock.acquire wrelease = writelock.release else: wacquire = None # 在这个后台线程中把 buffer 里的数据写入到 Pipe while 1: try: nacquire() try: if not buffer: nwait() finally: nrelease() try: while 1: obj = bpopleft() if obj is sentinel: debug(&#39;feeder thread got sentinel -- exiting&#39;) close() return # serialize the data before acquiring the lock obj = _ForkingPickler.dumps(obj) if wacquire is None: send_bytes(obj) else: wacquire() try: send_bytes(obj) finally: wrelease() except IndexError: pass except Exception as e: if ignore_epipe and getattr(e, &#39;errno&#39;, 0) == errno.EPIPE: return # Since this runs in a daemon thread the resources it uses # may be become unusable while the process is cleaning up. # We ignore errors which happen after the process has # started to cleanup. if is_exiting(): info(&#39;error in queue thread: %s&#39;, e) return else: # Since the object has not been sent in the queue, we need # to decrease the size of the queue. The error acts as # if the object had been silently removed from the queue # and this step is necessary to have a properly working # queue. queue_sem.release() onerror(e, obj) 从上面的代码可以得知，put 和 get 方法的与这个问题有关的关键流程如下: 队列大小是通过 _sem 这个 BoundedSemaphore(maxsize) 实例控制的。 get 和 put 之间的数据是通过 pipe 传递的。 put(obj) 操作: 执行 _sem.acquire() ，如果获取不到 semaphore 的话，表示当前队列已满。 获取到 semaphore 后（内部计数器加一，此时队列可用大小减一），把数据放到 buffer 中。 后台有个线程会去从 buffer 中读取数据，然后写入到 pipe 中。 get() 操作: 从 pipe 中读取数据。 读到数据后，执行 _sem.release() ，semaphore 内部计数器减一，此时队列可用大小加一。 问题出现的场景就是，上面 put(object) 中的后台线程 从 buffer 中读取数据然后写入 pipe 的过程中进程意外退出了， 此时因为数据没有写入到 pipe 中， get() 操作不会执行第2步的 _sem.release() 操作， 导致 put(object) 中 acquire 的 semaphore 永远不会被释放，也就是说当前队列可用大小会比实际大小小1。 如果这个进程意外退出的场景多出现几次，最终的结果就是有很多个 semaphore 永远不会被释放，极端情况下出现队列可用大小为 0 的情况，但是实际上队列中并没有数据，出现既写不进去数据又读取不了数据的情况。 总结¶ 参考资料¶ Issue 20527: multiprocessing.Queue deadlocks after “reader” process death - Python tracker multiprocessing — Process-based parallelism — Python 3.8.0 documentation cpython/queues.py at v3.8.0 · python/cpython c - POSIX name semaphore does not release after process exits - Stack Overflow",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https://mozillazg.com"
        }
    }
    </script>

</head>
<body>

<div class="navbar" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://mozillazg.com/" class="navbar-brand">
Huang Huang 的博客            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                    <li><a href="https://mozillazg.com/feeds/all.atom.xml">Feed</a></li>
                    <li><a href="/2014/10/pages/about-me.html">About</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="https://mozillazg.com/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-lg-12">
    <section id="content" class="yue">
        <article>
            <header class="text-center">
                <h1>
                    <a href="https://mozillazg.com/2019/10/python-multiprocessing-queue-both-full-and-empty-are-true-internal-deadlock.html"
                       rel="bookmark"
                       title="Permalink to Python: multiprocessing.Queue 在特定场景下会出现内部锁异常">
                        Python: multiprocessing.Queue 在特定场景下会出现内部锁异常
                    </a>
                </h1>
                <p class="published">
                    <time datetime="2019-10-26T00:00:00+00:00">
                    2019-10-26
                    </time>
                </p>
            </header>
            <div class="entry-content">
                <div class="well-sm article-info">
<footer class="post-info">
        <a href="https://mozillazg.com/category/python.html">python</a>


<span class="label label-default hide">Tags</span>
	<a href="https://mozillazg.com/tag/multiprocessing.html">multiprocessing</a>
        /
	<a href="https://mozillazg.com/tag/queue.html">Queue</a>
    
</footer><!-- /.post-info -->                </div>
                <div class="js-toc"></div>
                <div>
                <div class="section" id="id1">
<h2 id="hidid1">前言<a class="headerlink" href="#hidid1" title="Permalink to this headline">¶</a></h2>
<p>如题所述，multiprocessing.Queue 在特定场景下会出现内部锁异常，
导致 <tt class="docutils literal">Queue</tt> 实例出现既无法写入数据也无法读取数据的情况。</p>
</div>
<div class="section" id="id2">
<h2 id="hidid2">读取方意外退出导致内部异常<a class="headerlink" href="#hidid2" title="Permalink to this headline">¶</a></h2>
<p>一个场景是当读取方意外退出后，即便后来又有了新的读取方，
还是会出现内部异常最终导致写入方无法写入的问题。</p>
<div class="section" id="id3">
<h3 id="hidid3">复现问题<a class="headerlink" href="#hidid3" title="Permalink to this headline">¶</a></h3>
<p>可以通过下面的代码复现这个问题：</p>
<div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">time</span>


<span class="k">def</span> <span class="nf">reader</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;read&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;reader error: {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">writer</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">q</span><span class="o">.</span><span class="n">put_nowait</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">())</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;write&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;writer error: {!r}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="n">q</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="n">w</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">writer</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
<span class="n">w</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">reader</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
<span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s1">&#39;reader pid: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">pid</span><span class="p">))</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">is_alive</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;reader dead, start new reader&#39;</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">reader</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
        <span class="n">r</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;reader pid: {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">pid</span><span class="p">))</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
<p>运行这段代码，在代码运行过程中 kill 掉 reader 进程模拟读取方意外退出的情况:</p>
<div class="highlight"><pre><span></span>$ python3.8 reader_deadlock.py
reader pid: 53
write
write
writer error: Full<span class="o">()</span>
<span class="nb">read</span>
<span class="nb">read</span>
write
write
writer error: Full<span class="o">()</span>
<span class="nb">read</span>
<span class="nb">read</span>
...
<span class="nb">read</span>
<span class="nb">read</span>
reader dead, start new reader   <span class="c1"># &lt;-- kill 53</span>
reader pid: 55
write
write
writer error: Full<span class="o">()</span>
writer error: Full<span class="o">()</span>
writer error: Full<span class="o">()</span>
writer error: Full<span class="o">()</span>
writer error: Full<span class="o">()</span>
writer error: Full<span class="o">()</span>
reader error: Empty<span class="o">()</span>
writer error: Full<span class="o">()</span>
writer error: Full<span class="o">()</span>
writer error: Full<span class="o">()</span>
writer error: Full<span class="o">()</span>
writer error: Full<span class="o">()</span>
writer error: Full<span class="o">()</span>
reader error: Empty<span class="o">()</span>
</pre></div>
<p>可以看到，在杀掉 reader 进程后，即便后来再重新启动了一个 reader 进程，
还是出现了 writer 写不进去、reader 读不出来的问题。</p>
</div>
<div class="section" id="id4">
<h3 id="hidid4">原因<a class="headerlink" href="#hidid4" title="Permalink to this headline">¶</a></h3>
<p>为什么会出现这个问题呢？看一下 Queue 内部 <tt class="docutils literal">get</tt> 和 <tt class="docutils literal">put</tt> 方法的
<a class="reference external" href="https://github.com/python/cpython/blob/v3.8.0/Lib/multiprocessing/queues.py#L34">关键代码</a> :</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></div></td><td class="code"><div class="highlight"><pre><span></span> <span class="k">class</span> <span class="nc">Queue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

     <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
         <span class="c1"># ...</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_rlock</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>  <span class="c1"># ctx.Lock:  class Lock(SemLock)</span>
         <span class="c1"># ...</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_sem</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">BoundedSemaphore</span><span class="p">(</span><span class="n">maxsize</span><span class="p">)</span>
         <span class="c1"># ...</span>

     <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
         <span class="c1"># ...</span>
         <span class="k">if</span> <span class="n">block</span> <span class="ow">and</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
             <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rlock</span><span class="p">:</span>
                 <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recv_bytes</span><span class="p">()</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">_sem</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>  <span class="c1"># &lt;- 释放 semaphore</span>
         <span class="k">else</span><span class="p">:</span>
             <span class="k">if</span> <span class="n">block</span><span class="p">:</span>
                 <span class="n">deadline</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span>
<span class="hll">             <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rlock</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>  <span class="c1"># &lt;- 获取锁</span>
</span>                 <span class="k">raise</span> <span class="n">Empty</span>
             <span class="k">try</span><span class="p">:</span>
                 <span class="k">if</span> <span class="n">block</span><span class="p">:</span>
                     <span class="n">timeout</span> <span class="o">=</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
<span class="hll">                     <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poll</span><span class="p">(</span><span class="n">timeout</span><span class="p">):</span>  <span class="c1"># &lt;- 阻塞直到有数据或超时</span>
</span>                         <span class="k">raise</span> <span class="n">Empty</span>
                 <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poll</span><span class="p">():</span>
                     <span class="k">raise</span> <span class="n">Empty</span>
                 <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recv_bytes</span><span class="p">()</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_sem</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>    <span class="c1"># &lt;- 释放 semaphore</span>
             <span class="k">finally</span><span class="p">:</span>
<span class="hll">                 <span class="bp">self</span><span class="o">.</span><span class="n">_rlock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>   <span class="c1"># &lt;- 释放获取的锁</span>
</span>         <span class="c1"># unserialize the data after having released the lock</span>
         <span class="k">return</span> <span class="n">_ForkingPickler</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

     <span class="k">def</span> <span class="nf">put_nowait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
</pre></div>
</td></tr></table><p>为什么 kill 掉 reader 进程后就会出现前面的问题呢，
因为当 reader 进程阻塞在 <tt class="docutils literal">get(timeout=5)</tt> 调用时，实际是阻塞在上面的 24 行代码那里，
此时 reader 进程已经通过 19 行的代码获取到了 <tt class="docutils literal">self._rlock</tt> 这个锁，
当 kill reader 进程时，reader 进程退出并且退出的时候不会执行 31 行的释放锁操作。
当重新启动一个 reader 进程后，新 reader 进程执行 <tt class="docutils literal">get(timeout=5)</tt> 调用时
会因为 19 行获取不到 <tt class="docutils literal">self._rlock</tt> 这个锁导致总是抛出 <tt class="docutils literal">Empty</tt> 异常，因为这个锁在前面那个 reader 进程里被 acquire 了，但是没有被 release 也永远都不会被 release 了，导致内部的 <tt class="docutils literal">self._rlock</tt> 这个锁异常。</p>
<p>新的 reader 进程因为内部的 <tt class="docutils literal">self._rlock</tt> 锁异常导致一直无法读取数据，进而导致 writer 进程无法写入数据，因为队列一直是满的。</p>
</div>
<div class="section" id="id5">
<h3 id="hidid5">验证<a class="headerlink" href="#hidid5" title="Permalink to this headline">¶</a></h3>
<p>修改一下前面的代码来验证一下上面所说的原因：</p>
<div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">reader</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;read&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;reader error: {!r}, {}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">_rlock</span><span class="p">))</span>  <span class="c1"># 增加显式 _rlock 信息</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
<p>验证:</p>
<div class="highlight"><pre><span></span>$ python reader_deadlock_rlock.py
reader pid: 464
write
write
writer error: Full<span class="o">()</span>
...
<span class="nb">read</span>
<span class="nb">read</span>
reader dead, start new reader
reader pid: 466
write
write
writer error: Full<span class="o">()</span>
...
reader error: Empty<span class="o">()</span>, &lt;Lock<span class="o">(</span><span class="nv">owner</span><span class="o">=</span>SomeOtherProcess<span class="o">)</span>&gt;  <span class="c1"># _rlock 一直被其他进程所占用</span>
writer error: Full<span class="o">()</span>
...
reader error: Empty<span class="o">()</span>, &lt;Lock<span class="o">(</span><span class="nv">owner</span><span class="o">=</span>SomeOtherProcess<span class="o">)</span>&gt;  <span class="c1"># _rlock 一直被其他进程所占用</span>
writer error: Full<span class="o">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h2 id="hidid6">写入方意外退出导致内部异常<a class="headerlink" href="#hidid6" title="Permalink to this headline">¶</a></h2>
<p>另一个场景是当写入方意外退出后，极端情况下会出现内部异常导致读取方无法读取数据、
同时新加入的写入方也无法写入数据的问题。</p>
<div class="section" id="id7">
<h3 id="hidid7">复现问题<a class="headerlink" href="#hidid7" title="Permalink to this headline">¶</a></h3>
<p>因为是极端情况下会出现的问题，暂时没找到 100% 复现问题的方法，只能从代码实现层面分析。</p>
</div>
<div class="section" id="id8">
<h3 id="hidid8">原因<a class="headerlink" href="#hidid8" title="Permalink to this headline">¶</a></h3>
<p>先来看一下 <tt class="docutils literal">Queue</tt> 的 <a class="reference external" href="https://github.com/python/cpython/blob/v3.8.0/Lib/multiprocessing/queues.py">内部实现逻辑</a> :</p>
<table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171</pre></div></td><td class="code"><div class="highlight"><pre><span></span> <span class="k">class</span> <span class="nc">Queue</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

     <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
         <span class="c1"># ...</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_maxsize</span> <span class="o">=</span> <span class="n">maxsize</span>
<span class="hll">         <span class="bp">self</span><span class="o">.</span><span class="n">_reader</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writer</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span><span class="n">duplex</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</span>         <span class="bp">self</span><span class="o">.</span><span class="n">_rlock</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_opid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()</span>
         <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;win32&#39;</span><span class="p">:</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">_wlock</span> <span class="o">=</span> <span class="bp">None</span>
         <span class="k">else</span><span class="p">:</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">_wlock</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>

         <span class="c1"># 使用 BoundedSemaphore 控制队列大小</span>
<span class="hll">         <span class="bp">self</span><span class="o">.</span><span class="n">_sem</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="n">BoundedSemaphore</span><span class="p">(</span><span class="n">maxsize</span><span class="p">)</span>
</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_after_fork</span><span class="p">()</span>

         <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">!=</span> <span class="s1">&#39;win32&#39;</span><span class="p">:</span>
             <span class="n">register_after_fork</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Queue</span><span class="o">.</span><span class="n">_after_fork</span><span class="p">)</span>

     <span class="k">def</span> <span class="nf">_after_fork</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Queue._after_fork()&#39;</span><span class="p">)</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_notempty</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Condition</span><span class="p">(</span><span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">())</span>
<span class="hll">         <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">()</span>
</span>         <span class="bp">self</span><span class="o">.</span><span class="n">_thread</span> <span class="o">=</span> <span class="bp">None</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_jointhread</span> <span class="o">=</span> <span class="bp">None</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_joincancelled</span> <span class="o">=</span> <span class="bp">False</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span> <span class="o">=</span> <span class="bp">False</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_close</span> <span class="o">=</span> <span class="bp">None</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_send_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writer</span><span class="o">.</span><span class="n">send_bytes</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_recv_bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reader</span><span class="o">.</span><span class="n">recv_bytes</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_poll</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reader</span><span class="o">.</span><span class="n">poll</span>

     <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
         <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span><span class="p">:</span>
             <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Queue {self!r} is closed&quot;</span><span class="p">)</span>
<span class="hll">         <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sem</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
</span>             <span class="k">raise</span> <span class="n">Full</span>
         <span class="c1"># acquire 后 _sem 中的 count - 1，表示当前 queue 可用大小减一</span>

         <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_notempty</span><span class="p">:</span>
             <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thread</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_start_thread</span><span class="p">()</span>
             <span class="c1"># 数据放到 buffer 里，通知后台线程去读取 buffer 里的数据</span>
<span class="hll">             <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</span>             <span class="bp">self</span><span class="o">.</span><span class="n">_notempty</span><span class="o">.</span><span class="n">notify</span><span class="p">()</span>

     <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
         <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_closed</span><span class="p">:</span>
             <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Queue {self!r} is closed&quot;</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">block</span> <span class="ow">and</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
             <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rlock</span><span class="p">:</span>
                 <span class="c1"># 从 Pipe 中读取数据</span>
<span class="hll">                 <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recv_bytes</span><span class="p">()</span>
</span>             <span class="c1"># release 后 _sem 中的 count + 1，当前 queue 可用大小加一</span>
<span class="hll">             <span class="bp">self</span><span class="o">.</span><span class="n">_sem</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</span>         <span class="k">else</span><span class="p">:</span>
             <span class="k">if</span> <span class="n">block</span><span class="p">:</span>
                 <span class="n">deadline</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span> <span class="o">+</span> <span class="n">timeout</span>
             <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rlock</span><span class="o">.</span><span class="n">acquire</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">timeout</span><span class="p">):</span>
                 <span class="k">raise</span> <span class="n">Empty</span>
             <span class="k">try</span><span class="p">:</span>
                 <span class="k">if</span> <span class="n">block</span><span class="p">:</span>
                     <span class="n">timeout</span> <span class="o">=</span> <span class="n">deadline</span> <span class="o">-</span> <span class="n">time</span><span class="o">.</span><span class="n">monotonic</span><span class="p">()</span>
                     <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poll</span><span class="p">(</span><span class="n">timeout</span><span class="p">):</span>
                         <span class="k">raise</span> <span class="n">Empty</span>
                 <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poll</span><span class="p">():</span>
                     <span class="k">raise</span> <span class="n">Empty</span>
                 <span class="c1"># 从 Pipe 中读取数据</span>
<span class="hll">                 <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recv_bytes</span><span class="p">()</span>
</span>                 <span class="c1"># release 后 _sem 中的 count + 1，当前 queue 可用大小加一</span>
<span class="hll">                 <span class="bp">self</span><span class="o">.</span><span class="n">_sem</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
</span>             <span class="k">finally</span><span class="p">:</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_rlock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
         <span class="c1"># unserialize the data after having released the lock</span>
         <span class="k">return</span> <span class="n">_ForkingPickler</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

     <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poll</span><span class="p">()</span>

     <span class="k">def</span> <span class="nf">full</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sem</span><span class="o">.</span><span class="n">_semlock</span><span class="o">.</span><span class="n">_is_zero</span><span class="p">()</span>

     <span class="k">def</span> <span class="nf">get_nowait</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

     <span class="k">def</span> <span class="nf">put_nowait</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
         <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

     <span class="k">def</span> <span class="nf">_start_thread</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Queue._start_thread()&#39;</span><span class="p">)</span>

         <span class="c1"># Start thread which transfers data from buffer to pipe</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_thread</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span>
             <span class="n">target</span><span class="o">=</span><span class="n">Queue</span><span class="o">.</span><span class="n">_feed</span><span class="p">,</span>
             <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_notempty</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_send_bytes</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">_wlock</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writer</span><span class="o">.</span><span class="n">close</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ignore_epipe</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">_on_queue_feeder_error</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sem</span><span class="p">),</span>
             <span class="n">name</span><span class="o">=</span><span class="s1">&#39;QueueFeederThread&#39;</span>
         <span class="p">)</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_thread</span><span class="o">.</span><span class="n">daemon</span> <span class="o">=</span> <span class="bp">True</span>

         <span class="n">debug</span><span class="p">(</span><span class="s1">&#39;doing self._thread.start()&#39;</span><span class="p">)</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">_thread</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
         <span class="n">debug</span><span class="p">(</span><span class="s1">&#39;... done self._thread.start()&#39;</span><span class="p">)</span>
         <span class="c1"># ...</span>

     <span class="nd">@staticmethod</span>
     <span class="k">def</span> <span class="nf">_feed</span><span class="p">(</span><span class="nb">buffer</span><span class="p">,</span> <span class="n">notempty</span><span class="p">,</span> <span class="n">send_bytes</span><span class="p">,</span> <span class="n">writelock</span><span class="p">,</span> <span class="n">close</span><span class="p">,</span> <span class="n">ignore_epipe</span><span class="p">,</span>
               <span class="n">onerror</span><span class="p">,</span> <span class="n">queue_sem</span><span class="p">):</span>
         <span class="n">debug</span><span class="p">(</span><span class="s1">&#39;starting thread to feed data to pipe&#39;</span><span class="p">)</span>
         <span class="n">nacquire</span> <span class="o">=</span> <span class="n">notempty</span><span class="o">.</span><span class="n">acquire</span>
         <span class="n">nrelease</span> <span class="o">=</span> <span class="n">notempty</span><span class="o">.</span><span class="n">release</span>
         <span class="n">nwait</span> <span class="o">=</span> <span class="n">notempty</span><span class="o">.</span><span class="n">wait</span>
         <span class="n">bpopleft</span> <span class="o">=</span> <span class="nb">buffer</span><span class="o">.</span><span class="n">popleft</span>
         <span class="n">sentinel</span> <span class="o">=</span> <span class="n">_sentinel</span>
         <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">!=</span> <span class="s1">&#39;win32&#39;</span><span class="p">:</span>
             <span class="n">wacquire</span> <span class="o">=</span> <span class="n">writelock</span><span class="o">.</span><span class="n">acquire</span>
             <span class="n">wrelease</span> <span class="o">=</span> <span class="n">writelock</span><span class="o">.</span><span class="n">release</span>
         <span class="k">else</span><span class="p">:</span>
             <span class="n">wacquire</span> <span class="o">=</span> <span class="bp">None</span>

         <span class="c1"># 在这个后台线程中把 buffer 里的数据写入到 Pipe</span>
         <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
             <span class="k">try</span><span class="p">:</span>
                 <span class="n">nacquire</span><span class="p">()</span>
                 <span class="k">try</span><span class="p">:</span>
                     <span class="k">if</span> <span class="ow">not</span> <span class="nb">buffer</span><span class="p">:</span>
                         <span class="n">nwait</span><span class="p">()</span>
                 <span class="k">finally</span><span class="p">:</span>
                     <span class="n">nrelease</span><span class="p">()</span>
                 <span class="k">try</span><span class="p">:</span>
                     <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
<span class="hll">                         <span class="n">obj</span> <span class="o">=</span> <span class="n">bpopleft</span><span class="p">()</span>
</span>                         <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="n">sentinel</span><span class="p">:</span>
                             <span class="n">debug</span><span class="p">(</span><span class="s1">&#39;feeder thread got sentinel -- exiting&#39;</span><span class="p">)</span>
                             <span class="n">close</span><span class="p">()</span>
                             <span class="k">return</span>

                         <span class="c1"># serialize the data before acquiring the lock</span>
                         <span class="n">obj</span> <span class="o">=</span> <span class="n">_ForkingPickler</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                         <span class="k">if</span> <span class="n">wacquire</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
<span class="hll">                             <span class="n">send_bytes</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</span>                         <span class="k">else</span><span class="p">:</span>
                             <span class="n">wacquire</span><span class="p">()</span>
                             <span class="k">try</span><span class="p">:</span>
<span class="hll">                                 <span class="n">send_bytes</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</span>                             <span class="k">finally</span><span class="p">:</span>
                                 <span class="n">wrelease</span><span class="p">()</span>
                 <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                     <span class="k">pass</span>
             <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                 <span class="k">if</span> <span class="n">ignore_epipe</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="s1">&#39;errno&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">EPIPE</span><span class="p">:</span>
                     <span class="k">return</span>
                 <span class="c1"># Since this runs in a daemon thread the resources it uses</span>
                 <span class="c1"># may be become unusable while the process is cleaning up.</span>
                 <span class="c1"># We ignore errors which happen after the process has</span>
                 <span class="c1"># started to cleanup.</span>
                 <span class="k">if</span> <span class="n">is_exiting</span><span class="p">():</span>
                     <span class="n">info</span><span class="p">(</span><span class="s1">&#39;error in queue thread: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
                     <span class="k">return</span>
                 <span class="k">else</span><span class="p">:</span>
                     <span class="c1"># Since the object has not been sent in the queue, we need</span>
                     <span class="c1"># to decrease the size of the queue. The error acts as</span>
                     <span class="c1"># if the object had been silently removed from the queue</span>
                     <span class="c1"># and this step is necessary to have a properly working</span>
                     <span class="c1"># queue.</span>
                     <span class="n">queue_sem</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
                     <span class="n">onerror</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
</pre></div>
</td></tr></table><p>从上面的代码可以得知，put 和 get 方法的与这个问题有关的关键流程如下:</p>
<ul class="simple">
<li>队列大小是通过 <tt class="docutils literal">_sem</tt> 这个 <tt class="docutils literal">BoundedSemaphore(maxsize)</tt> 实例控制的。</li>
<li><tt class="docutils literal">get</tt> 和 <tt class="docutils literal">put</tt> 之间的数据是通过 pipe 传递的。</li>
</ul>
<p><tt class="docutils literal">put(obj)</tt> 操作:</p>
<ol class="arabic simple">
<li>执行 <tt class="docutils literal">_sem.acquire()</tt> ，如果获取不到 semaphore 的话，表示当前队列已满。</li>
<li>获取到 semaphore 后（内部计数器加一，此时队列可用大小减一），把数据放到 buffer 中。</li>
<li>后台有个线程会去从 buffer 中读取数据，然后写入到 pipe 中。</li>
</ol>
<p><tt class="docutils literal">get()</tt> 操作:</p>
<ol class="arabic simple">
<li>从 pipe 中读取数据。</li>
<li>读到数据后，执行 <tt class="docutils literal">_sem.release()</tt> ，semaphore 内部计数器减一，此时队列可用大小加一。</li>
</ol>
<p>问题出现的场景就是，上面 <tt class="docutils literal">put(object)</tt> 中的后台线程
从 buffer 中读取数据然后写入 pipe 的过程中进程意外退出了，
此时因为数据没有写入到 pipe 中， <tt class="docutils literal">get()</tt> 操作不会执行第2步的 <tt class="docutils literal">_sem.release()</tt> 操作，
导致 <tt class="docutils literal">put(object)</tt> 中 acquire 的 semaphore 永远不会被释放，也就是说当前队列可用大小会比实际大小小1。
如果这个进程意外退出的场景多出现几次，最终的结果就是有很多个 semaphore 永远不会被释放，极端情况下出现队列可用大小为 0 的情况，但是实际上队列中并没有数据，出现既写不进去数据又读取不了数据的情况。</p>
</div>
</div>
<div class="section" id="id9">
<h2 id="hidid9">总结<a class="headerlink" href="#hidid9" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="id10">
<h2 id="hidid10">参考资料<a class="headerlink" href="#hidid10" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="https://bugs.python.org/issue20527">Issue 20527: multiprocessing.Queue deadlocks after “reader” process death - Python tracker</a></li>
<li><a class="reference external" href="https://docs.python.org/3.8/library/multiprocessing.html#pipes-and-queues">multiprocessing — Process-based parallelism — Python 3.8.0 documentation</a></li>
<li><a class="reference external" href="https://github.com/python/cpython/blob/v3.8.0/Lib/multiprocessing/queues.py">cpython/queues.py at v3.8.0 · python/cpython</a></li>
<li><a class="reference external" href="https://stackoverflow.com/questions/34756406/posix-name-semaphore-does-not-release-after-process-exits">c - POSIX name semaphore does not release after process exits - Stack Overflow</a></li>
</ul>
</div>

                </div>
            </div>
            <!-- /.entry-content -->
<section class="text-center">
  
<div id="donate"></div>

<div class="social-share"></div>
<div class="social-comment-note">
<p>有任何建议和想法欢迎在下方评论区留言或者加我<a href="/static/wechat.png">微信</a>交流</p>
</div>

</section>
<section class="well" id="related-posts">
    <p>Related Posts:</p>
    <ul>
        <li><a href="https://mozillazg.com/2017/04/tinyq-a-queue-framework.html">tinyq: 一个任务队列框架</a></li>
        <li><a href="https://mozillazg.com/2014/01/python-use-multiprocessing-dummy-run-theading-task.html">[python]使用 multiprocessing.dummy 执行多线程任务</a></li>
    </ul>
</section>
    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'my-github-blog'; // required: replace example with your forum shortname

                    var disqus_identifier = 'python-multiprocessing-queue-both-full-and-empty-are-true-internal-deadlock';
                var disqus_url = 'https://mozillazg.com/2019/10/python-multiprocessing-queue-both-full-and-empty-are-true-internal-deadlock.html';

            var disqus_config = function () {
                this.language = "zh-hans";
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
        </article>
    </section>

        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2019 mozillazg
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>              <p><small>  <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="/static/images/by-sa-80x15.png" /></a>
    &quot;<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">Huang Huang 的博客</span>&quot; by <a xmlns:cc="http://creativecommons.org/ns#" href="https://mozillazg.com" property="cc:attributionName" rel="cc:attributionURL">mozillazg</a> is
  licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>, except where indicated otherwise.
</small></p>
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="https://mozillazg.com/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://mozillazg.com/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="https://mozillazg.com/theme/js/respond.min.js"></script>

    <!-- Disqus -->
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'my-github-blog'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script');
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <!-- End Disqus Code -->
    <!-- Google Analytics Universal -->
    <script type="text/javascript">
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-77172981-1', 'auto');
        ga('send', 'pageview');
    </script>
    <!-- End Google Analytics Universal Code -->



<script src="https://mozillazg.com/theme/js/tocbot.min.js"></script>
<script>
$(document).ready(function(){
  tocbot.init({
    // Where to render the table of contents.
    tocSelector: '.js-toc',
    // Where to grab the headings to build the table of contents.
    contentSelector: '.entry-content',
    // Which headings to grab inside of the contentSelector element.
    headingSelector: 'h2, h3, h4,h5',
    // Headings that match the ignoreSelector will be skipped.
    ignoreSelector: '.js-toc-ignore',
    // Main class to add to links.
    linkClass: 'toc-link',
    // Extra classes to add to links.
    extraLinkClasses: '',
    // Class to add to active links,
    // the link corresponding to the top most heading on the page.
    activeLinkClass: 'is-active-link',
    // Main class to add to lists.
    listClass: 'toc-list',
    // Extra classes to add to lists.
    extraListClasses: '',
    // Class that gets added when a list should be collapsed.
    isCollapsedClass: 'is-collapsed',
    // Class that gets added when a list should be able
    // to be collapsed but isn't necessarily collpased.
    collapsibleClass: 'is-collapsible',
    // Class to add to list items.
    listItemClass: 'toc-list-item',
    // How many heading levels should not be collpased.
    // For example, number 6 will show everything since
    // there are only 6 heading levels and number 0 will collpase them all.
    // The sections that are hidden will open
    // and close as you scroll to headings within them.
    collapseDepth: 6,
    // Smooth scrolling enabled.
    smoothScroll: true,
    // Smooth scroll duration.
    smoothScrollDuration: 420,
    // Callback for scroll end (requires: smoothScroll).
    scrollEndCallback: function (e) {},
    // Headings offset between the headings and the top of the document (this is meant for minor adjustments).
    headingsOffset: 0,
    // Timeout between events firing to make sure it's
    // not too rapid (for performance reasons).
    throttleTimeout: 50,
    // Element to add the positionFixedClass to.
    positionFixedSelector: null,
    // Fixed position class to add to make sidebar fixed after scrolling
    // down past the fixedSidebarOffset.
    positionFixedClass: 'is-position-fixed',
    // fixedSidebarOffset can be any number but by default is set
    // to auto which sets the fixedSidebarOffset to the sidebar
    // element's offsetTop from the top of the document on init.
    fixedSidebarOffset: 'auto',
    // includeHtml can be set to true to include the HTML markup from the
    // heading node instead of just including the textContent.
    includeHtml: false
  });
});
</script>
</body>
</html>